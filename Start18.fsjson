[{"name":"READ ME! ","content":"/* NO! DON'T READ ME! GO ON DIRECTLY TO THE TUTORIALS BELOW!!!!! */\n\n\n\n- Organize your code in snippets, group them by theme, keep everything in one place, all your projects big and small\n- Develop and refine over time your personal library of functions, create your own project scaffolding\n- Use snippet predecessors to assemble your solution\n- Create one big code infrastructure that can be reused and refined over and over.\n- Code, try, test, compile, run your code\n- Intellisense (for now):\n    - Tooltips (double-click or F2)\n    - Error highlighting\n    - Auto completion (ctrl-space)\n    - Find Definition\n- Run it immediately with almost zero scaffolding\n- Produce JavaScript using Websharper and run it in your browser immediately\n- Dependencies are equivalent to `#load \"<file.fsx>\"` or include directives\n\n- Run FSI and Run Fable show in the Output pane what is printed out with printfn\n- Run WebSharper printfn's output can be seen in the console. The Output pane shows the compilation messages.\n- Run WebSharper shows in Ws Result pane or in a new browser the html produced by calling the RunNode class.\n\n- Parse F# is necessary when changing the predecessors\n\n- F# Station is intended to be used locally not through the Internet\n- Evaluate F# is disabled when not used locally","predecessors":[],"id":{"$":0,"Item":"bc0d0abf-9c94-48bb-b46e-92e5d539b172"},"expanded":true,"level":0,"levelCode":0,"properties":{"CSS":".CodeMirror span.cm-comment {\nbackground : white;\nfont-style : normal;\nfont-weight: 600;\ncolor      : black;\nfont-size  : 20px;  \n}","Mode":"none","DisableParse":"1"}},{"name":"FSSGlobal","content":"//#nowarn \"1182\"\n//#nowarn \"40\"\n#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\bin\\FSharp.Core.dll\"\n#if INTERACTIVE\n//#I @\"../WebServer/bin\"\nmodule FSSGlobal   =\n#else\nnamespace FSSGlobal\n#endif\n","predecessors":[],"id":{"$":0,"Item":"bf864f3c-1370-42f2-ac8a-565a604892e8"},"expanded":true,"level":0,"levelCode":0,"properties":{"Theme":"rubyblue"}},{"name":"F# Code","content":"// Code to be evaluated using FSI: `Evaluate F#`","parent":{"$":0,"Item":"bf864f3c-1370-42f2-ac8a-565a604892e8"},"predecessors":[],"id":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableWebSharper":"1","NoIndent":"1","DisableFable":"1"}},{"name":"open WebSharper","content":"#if WEBSHARPER\n#I @\"..\\packages\\WebSharper\\lib\\net461\"\n#I @\"..\\packages\\WebSharper.UI\\lib\\net461\"\n\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n//#r @\"..\\packages\\WebSharper.UI.Next\\lib\\net40\\WebSharper.UI.Next.dll\"\n#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI\nopen WebSharper.UI.Client\ntype on   = WebSharper.UI.Html.on\ntype attr = WebSharper.UI.Html.attr\n#endif","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Useful","content":"#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule Useful =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"extract, now, Async, String","content":"let extract n (s:string) = s.Substring(0, min n s.Length)\n\n#if WEBSHARPER\n[< Inline \"(function (n) { return n.getFullYear() + '-' +(n.getMonth() + 1) + '-' +  n.getDate() + ' '+n.getHours()+ ':'+n.getMinutes()+ ':'+n.getSeconds()+ ':'+n.getMilliseconds() })(new Date(Date.now()))\" >]\n#endif\nlet nowStamp() = \n    let t = System.DateTime.UtcNow // in two steps to avoid Warning: The value has been copied to ensure the original is not mutated\n    t.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n\nmodule Async =\n    let map f va = \n        async { \n            let! a = va\n            return f a \n        } \n    let iter f va = \n        async { \n            let! a = va\n            do f a \n        } \n\n    let retn x = async.Return x\n\n    let apply fAsync xAsync = async {\n        let! fChild = Async.StartChild fAsync\n        let! xChild = Async.StartChild xAsync\n        let! f = fChild\n        let! x = xChild \n        return f x \n        }\n\n    let bind f va = async.Bind(va, f)\n    let sleepThen f milliseconds =\n        async {\n            do! Async.Sleep milliseconds\n            do  f()\n        }\n\nmodule KeyVal =\n    //let inline getEnumerator dict = (^a : (member get_Enumerator : _) (dict, ()))\n    let inline tryGetValue key (dict) =\n        dict \n        :> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<_, _>> \n        |> Seq.tryPick (fun kp -> if kp.Key = key then Some kp.Value else None)\n\n\nmodule String =\n    let splitByChar (c: char) (s: string) = s.Split c\n    let trim                  (s: string) = s.Trim()\n    let append     (a: string)(b: string) =  a + b\n    \n    ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"7a655466-e218-4121-a7b6-f9c70a922e07"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"swap","content":"let inline swap f a b = f b a\nlet inline __   f a b = f b a\n\n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"657c8f34-c917-4659-825d-c9ead206efcf"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Result, Wrap","content":"open System\n#nowarn \"1178\"\n     \nmodule Option =\n    let defaultValue v =\n        function\n        | Some x -> x\n        | None   -> v\n\n    let defaultWith f =\n        function\n        | Some x -> x\n        | None   -> f()\n\n    let call v = \n        function\n        | None   -> None\n        | Some f -> f v |> Some\n\n    let iterF v = \n        function\n        | None   -> ()\n        | Some f -> f v\n\n    let iterFO vO fO = \n        match vO, fO with\n        | Some v, Some f -> f v\n        | _     , _      -> ()\n\n    let apply fO  vO =\n        match fO, vO with\n        | Some f, Some v -> f v |> Some\n        | _     , _      -> None\n\n    let join vOO =\n        match vOO with\n        | Some vO -> vO\n        | _       -> None\n\n    let modify modifier = Option.map (fun f -> modifier f) >> defaultValue id\n      \n\n//#nowarn \"25\"\ntype ErrMsg = \n    abstract member ErrMsg   : string\n    abstract member IsWarning: bool\n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\ntype ExceptionThrown(exn:Exception) =\n    interface ErrMsg with\n        member this.ErrMsg   : string = sprintf \"%A\" exn\n        member this.IsWarning: bool   = false\n    override this.ToString() = (this :> ErrMsg).ErrMsg\n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\ntype ErrOptionIsNone() =\n    interface ErrMsg with\n        member this.ErrMsg   : string = \"Option is None\"\n        member this.IsWarning: bool   = false\n    override this.ToString() = (this :> ErrMsg).ErrMsg\n\ntype ErrSimple(msg, warning) =\n    interface ErrMsg with\n        member this.ErrMsg   : string = msg\n        member this.IsWarning: bool   = warning\n    override this.ToString() = (this :> ErrMsg).ErrMsg\nlet errSimple msg = ErrSimple(msg, false)\n\ntype Result< 'TSuccess> = Result  of 'TSuccess option * ErrMsg    []     \ntype ResultS<'TSuccess> = ResultS of 'TSuccess option * ErrSimple []\n\nmodule Result =\n    let inline succeed             x       = Result (Some x           , [|  |]             )\n    let inline succeedWithMsg      x  m    = Result (Some x           , [|m |]             )\n    let inline succeedWithMsgs     x  ms   = Result (Some x           ,   ms               )\n    let inline fail                   m    = Result (None             , [|m |]             )\n    let inline failWithMsgs           ms   = Result (None             ,   ms               )\n    let inline failException          e    = ExceptionThrown(e) :> ErrMsg\n    /// map without try protection\n    let inline map0      f (Result(o, ms)) =       Result(o |> Option.map f, ms)\n    /// map with try protection in case of exceptions\n    let inline map       f (Result(o, ms)) = try   Result(o |> Option.map f, ms)\n                                             with  e -> failException e |> fail\n    let inline mapErr    f (Result(o, ms)) = Result (o                ,   ms |> Array.map f)\n    let inline mapMsg    f (Result(o, ms)) =        (o                ,   ms |> Array.map f)\n    let inline mapMsgs   f (Result(o, ms)) =        (o                ,   ms |>           f)\n    let inline getOption   (Result(o, _ )) =         o                   \n    let inline getMsgs     (Result(_, ms)) =                             ms\n    let inline mergeMsgs              ms r = Result (r |> mapMsgs   (Array.append ms) )\n    let inline combine     (Result(o, ms)) (rb: unit -> Result<_>) = o |> Option.map (fun _ -> rb() |> mergeMsgs ms) |> Option.defaultValue (Result(None, ms))\n    let inline join arr                    =\n        match arr with\n        | Result(None                , ms ) -> Result(None, ms                  ) \n        | Result(Some(Result(b, ms1)), ms2) -> Result(b   , Array.append ms2 ms1) \n    /// bind with no try protection\n    let inline bind0     f  ar             = map0 f ar |> join \n    /// bind with try protection in case of exceptions\n    let inline bind      f  ar             = map  f ar |> join\n    let inline applyMap mapF (Result(fO, fMs)) aR =\n        match fO with\n        | None   -> aR |> getMsgs |> Array.append fMs |> failWithMsgs\n        | Some f -> aR |> mapF f\n    /// apply with try protection in case of exceptions\n    let inline apply0    fr ar = applyMap map0 fr ar\n    /// apply with try protection in case of exceptions\n    let inline apply     fr ar = applyMap map  fr ar\n    let map2 f a1 a2 = apply <| apply (succeed f) a1 <| a2\n        \n    let inline failSimpleError   m = (m, false) |> ErrSimple |> fail \n    let inline failSimpleWarning m = (m, true ) |> ErrSimple |> fail \n    let inline isError (Result (v, _)) = v.IsNone\n    let inline isGood  (Result (v, _)) = v.IsSome\n\n    let (|Success|Failure|) =\n        function \n        | Result(Some x, ms) -> Success (x, ms) \n        | Result(None  , ms) -> Failure     ms  \n\n//    let successTee f result =                           // given an RopResult, call a unit function on the success branch\n//        let fSuccess (x,msgs) =                         // and pass thru the result\n//            f (x,msgs)\n//            Success (x,msgs) \n//        either fSuccess Failure result\n//\n//    let fFailure2 f errs = \n//        f errs\n//        Failure errs \n//    let failureTee f result =                           /// given an RopResult, call a unit function on the failure branch\n//        either Success (fFailure2 f) result\n//\n//    let mapMessagesR f result =                         /// given an RopResult, map the messages to a different error type\n//        match result with \n//        | Success (x,msgs) -> \n//            let msgs' = List.map f msgs\n//            Success (x, msgs')\n//        | Failure errors -> \n//            let errors' = List.map f errors \n//            Failure errors' \n//\n//    let valueOrDefault f result =                       /// given an RopResult, in the success case, return the value.\n//        match result with                               /// In the failure case, determine the value to return by \n//        | Success (x,_) -> x                            /// applying a function to the errors in the failure case\n//        | Failure errors -> f errors\n//\n//    let failIfNone message = function                   /// lift an option to a RopResult.\n//        | Some x -> succeed x                           /// Return Success if Some\n//        | None -> fail message                          /// or the given message if None\n//\n//    let failIfNoneR message = function                  /// given an RopResult option, return it\n//        | Some rop -> rop                               /// or the given message if None\n//        | None -> fail message \n\n\n///            tryCall: (exn -> Result<'b>) ->  ('a -> Result<'b>) -> 'a -> Result<'b> =\n    let inline tryCall (f:'a -> Result<'b>) (v:'a) : Result<'b> = try f v with e -> failException e |> fail\n\n    type ropBuilder() =\n        member inline this.Return     (x)                       = succeed x\n        member inline this.ReturnFrom (x)                       = x\n        member        this.Bind       (w:Result<'a>, r: 'a -> Result<'b>) = bind r w\n        member inline this.Zero       ()                        = succeed ()\n        member inline this.Delay      (f)                       = f\n        member inline this.Combine    (a, b)                    = combine a b\n        member inline this.Run        (f)                       = f()\n        member this.While(guard, body) =\n            if not (guard()) \n            then this.Zero() \n            else this.Bind( body(), fun () -> \n                this.While(guard, body))  \n        member this.TryWith(body, handler) =\n            try this.ReturnFrom(body())\n            with e -> handler e\n        member this.TryFinally(body, compensation) =\n            try this.ReturnFrom(body())\n            finally compensation()\n        member this.Using(disposable:#System.IDisposable, body) =\n            let body' = fun () -> body disposable\n            this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))              \n\n    let result = ropBuilder()\n//    let inline flow_ () = new ropBuilder ()\n\n//    let fromChoice context c =  context?????\n    let fromChoice c =\n        match c with | Choice1Of2 v -> succeed v\n                     | Choice2Of2 e -> fail    e\n\n    let fromOption m =\n        function | None   -> fail    m\n                 | Some v -> succeed v\n    let fromOptionW m =\n        function | None   -> fail    (m())\n                 | Some v -> succeed v\n\n    let toOption   (Result(o, _ )) = o\n    let toOptionMs (Result(o, ms)) = o, ms\n\n    let tryProtection() : Result<unit> = succeed ()\n\n    let failIfFalse m v : Result<unit>  = if v then succeed () else m |> fail \n    let failIfTrue  m v : Result<unit>  = if v then m |> fail  else succeed () \n            \n    let ifError   def (Result(o, _ )) = o |> Option.defaultValue            def\n    let withError f   (Result(o, ms)) = o |> Option.defaultWith  (fun () -> f ms)\n\n//    let processMessages mtype (msgs: PossibleMessages list) =\n//        msgs\n//        |> List.iter (fun o -> WebSharper.JavaScript.JS.Alert     <| mtype + \": \" + (sprintf \"%A\" o)\n//                               WebSharper.JavaScript.Console.Log o)\n//\n//    let notifyMessages R =\n//        match R with | Success (_, m) -> processMessages \"N\" m\n//                     | Failure     m  -> processMessages \"E\" m\n//\n//    let messagesDo f =\n//        function | Success (_, ms) -> f false ms\n//                 | Failure     ms  -> f true  ms\n\n    let seqCheck s = \n        s \n        |> (fun elems -> match      elems |> Seq.exists(function | Failure _    -> true    | _ -> false) with\n                         | true  -> elems |> Seq.pick  (function | Failure ms   -> Some ms | _ -> None ) |> failWithMsgs\n                         | false -> elems |> Seq.map   (function | Result (vO,_)-> vO.Value            ) |> succeed\n        )\n\n    let msgs2String   (ms: ErrMsg []) = ms |> Array.map (fun m -> m.ErrMsg)\n    let getMessages   (ms: ErrMsg []) = ms |> msgs2String |> String.concat \"\\n\"\n    let countMessages (ms: ErrMsg []) =\n        if ms = [||] then \"\" else\n        let errors   = ms |> Array.filter(fun m -> m.IsWarning |> not)\n        let warnings = ms |> Array.filter(fun m -> m.IsWarning       )\n        match errors.Length, warnings.Length with\n        | 0, 0 -> sprintf \"%s\"\n        | 1, 0 -> sprintf \"%s\"\n        | 0, 1 -> sprintf \"%s\"\n        | 1, 1 -> sprintf \"1 error, 1 warning\\n%s\"\n        | e, 0 -> sprintf \"%d errors\\n%s\" e\n        | 0, w -> sprintf \"%d warnings\\n%s\" w\n        | e, w -> sprintf \"%d errors, %d warnings\\n%s\" e w\n        <| getMessages ms\n\n    let result2String res =\n        match res with\n        | Result(vO, msgs) -> Array.append [| vO |> Option.defaultValue \"Failed: \" |] (msgs2String msgs)\n        |> String.concat \"\\n\"\n\n    let fromResultS (ResultS(v, ms)) = Result (v, ms |> Array.map (fun m -> m :> ErrMsg                     ))\n    let toResultS   (Result( v, ms)) = ResultS(v, ms |> Array.map (fun m -> ErrSimple(m.ErrMsg, m.IsWarning)))\n\n    module Seq =\n        let cons h t = h :: t\n        /// Map an AsyncResult producing function over a list to get a new AsyncResult\n        /// using monadic style\n        /// ('a -> XResult<'b>) -> 'a list -> XResult<'b list>\n        let rec traverseM f list =\n            let (>>=) v f = bind f v\n            let retn      = succeed\n            let initState = retn []\n            let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n            List.foldBack folder (Seq.toList list) initState \n        /// Transform a \"list<XResult>\" into a \"XResult<list>\"\n        /// and collect the results using bind.\n        let inline sequenceM x = traverseM id x\n    \n        /// Map a Result producing function over a list to get a new Result \n        /// using applicative style\n        /// ('a -> Result<'b>) -> 'a list -> Result<'b list>\n        let rec traverseA f list =\n            let (<*>)     = apply\n            let retn      = succeed\n            let initState = retn []\n            let folder head tail = retn cons <*> f head <*> tail\n            List.foldBack folder (Seq.toList list) initState\n        /// Transform a \"list<Result>\" into a \"Result<list>\" \n        /// and collect the results using apply.\n        let inline sequenceA x = traverseA id x\n\n\nopen Result\n\nmodule ResultS =\n    let fromResult = Result.toResultS\n    let toResult   = Result.fromResultS\n\ntype Wrap<'T> =\n| WResult of Result<'T>\n| WAsync  of Async<'T>\n| WAsyncR of Async<Result<'T>>\n| WSome   of 'T\n| WNone\n\nmodule Wrap =\n    let errOptionIsNone = ErrOptionIsNone() :> ErrMsg\n\n    let wb2arb ms = \n        function\n        | WAsync       ab  -> async { let!   b = ab\n                                      return succeedWithMsgs b               ms }\n        | WAsyncR     arb  -> async { let!   rb = arb                               \n                                      return rb |> mergeMsgs                 ms }\n        | WResult      rb  -> async { return rb |> mergeMsgs                 ms }\n        | WSome         b  -> async { return succeedWithMsgs b               ms }\n        | WNone            -> async { return failWithMsgs      (Array.append ms [| errOptionIsNone |] )}\n\n    let tryCall (f: 'a -> Wrap<'b>) (a:'a) = \n        try f a \n        with e -> failException e |> fail |> WResult\n\n    /// bind with old implementation\n    let bind0' (f: 'a -> Wrap<'b>) (wa: Wrap<'a>) :Wrap<'b> =\n        match wa with\n        | WSome           a       \n        | WResult(Success(a, [||])) -> tryCall f a\n        | WNone                     -> WNone\n        | WResult(Failure    ms ) -> failWithMsgs ms |> WResult \n        | WResult(Success(a, ms)) -> tryCall f a\n                                     |> function\n                                     | WSome           b         -> succeedWithMsgs b               ms                   |> WResult \n                                     | WNone                     -> failWithMsgs (Array.append ms [| errOptionIsNone |] )|> WResult\n                                     | WResult(Success(b, [||])) -> succeedWithMsgs b               ms                   |> WResult \n                                     | WResult(Success(b, m2  )) -> succeedWithMsgs b (Array.append ms m2)               |> WResult \n                                     | WResult(Failure    m2  )  -> failWithMsgs      (Array.append ms m2)               |> WResult \n                                     | WAsync  ab                -> async { let!  b = ab\n                                                                            return succeedWithMsgs b ms\n                                                                    } |> WAsyncR\n                                     | WAsyncR arb               -> async { let! rb = arb\n                                                                            return mergeMsgs ms rb\n                                                                    } |> WAsyncR\n        | WAsync         aa       -> async {\n                                         let! a  = aa\n                                         return! tryCall f a |> wb2arb [||]\n                                     } |> WAsyncR\n        | WAsyncR       ara       -> async {\n                                         let! ar  = ara\n                                         let  arb = match ar with\n                                                    | Success(a, ms) -> tryCall f a |> wb2arb ms\n                                                    | Failure    ms  -> async { return failWithMsgs ms }\n                                         return! arb\n                                     } |> WAsyncR\n    let Return = WSome   \n    /// map with no try protection\n    let map0 (f: 'a -> 'b) (aw: Wrap<'a>) = \n        match aw with\n        | WNone       -> WNone\n        | WSome   a   -> f a                                               |> WSome\n        | WResult ar  -> Result.map f ar                                   |> WResult\n        | WAsync  aa  -> async {\n                             let!   a  = aa\n                             return f a\n                         }                                                 |> WAsync\n        | WAsyncR ara -> async {\n                             let!   ar  = ara\n                             return Result.map  f ar\n                         }                                                 |> WAsyncR\n    /// map with try protection in case of exceptions\n    let map  (f: 'a -> 'b) (aw: Wrap<'a>) = \n        match aw with\n        | WNone       -> WNone\n        | WSome   a   -> try  f a                                          |> WSome\n                         with e -> failException e            |> fail      |> WResult\n        | WResult ar  -> Result.map f ar                                   |> WResult\n        | WAsync  aa  -> async {\n                             let!   a  = aa\n                             return try  f a                  |> succeed\n                                    with e -> failException e |> fail\n                         }                                                 |> WAsyncR\n        | WAsyncR ara -> async {\n                             let!   ar  = ara\n                             return Result.map  f ar\n                         }                                                 |> WAsyncR\n    let join aww =\n        match aww with\n        | WSome   aw                   -> aw\n        | WNone                        -> WNone\n        | WResult(Result(None   , ms)) -> WResult(Result(None, ms))\n        | WResult(Result(Some aw, ms)) -> aw\n        | WAsync  awa                  -> async {\n                                              let!  aw = awa\n                                              match aw with\n                                              | WNone       -> return            Result.fail errOptionIsNone\n                                              | WSome   a   -> return a       |> Result.succeed\n                                              | WResult ar  -> return ar\n                                              | WAsync  aa  -> let!   a  = aa\n                                                               return a       |> Result.succeed\n                                              | WAsyncR ara -> let!   ar = ara\n                                                               return ar\n                                          } |> WAsyncR\n        | WAsyncR awra                 -> async {\n                                              let!  awr = awra\n                                              match awr with\n                                              | Result(None   , ms) -> return Result.failWithMsgs ms\n                                              | Result(Some aw, ms) ->\n                                              match aw with\n                                              | WNone               -> return             Result.failWithMsgs    <| Array.append ms [| errOptionIsNone |]\n                                              | WSome   a           -> return a        |> Result.succeedWithMsgs <| ms\n                                              | WResult ar          -> return ar       |> Result.mergeMsgs ms\n                                              | WAsync  aa          -> let!   a  = aa \n                                                                       return a        |> Result.succeedWithMsgs <| ms\n                                              | WAsyncR ara         -> let!   ar = ara \n                                                                       return ar       |> Result.mergeMsgs ms\n                                          } |> WAsyncR\n    /// bind with no try protection \n    let bind0 (f: 'a -> Wrap<'b>) (aw: Wrap<'a>) :Wrap<'b> = aw |> map0 f |> join\n    /// bind with try protection in case of exceptions\n    let bind  (f: 'a -> Wrap<'b>) (aw: Wrap<'a>) :Wrap<'b> = aw |> map  f |> join\n    /// apply with no try protection\n    let apply0 (fw: Wrap<'a -> 'b>) (aw: Wrap<'a>) = fw |> bind0 (swap map0 aw)\n    /// apply with try protection in case of exceptions\n    let apply  (fw: Wrap<'a -> 'b>) (aw: Wrap<'a>) = fw |> bind  (swap map  aw)\n\n    let inline getAsyncR (wb: Wrap<'T>) =\n        match wb with\n        | WAsync      va  -> async {\n                               let! v = va\n                               return      succeed                           v}\n        | WSome       v   -> async.Return (succeed                           v)\n        | WNone           -> async.Return (Result.fail       errOptionIsNone  )\n        | WResult     v   -> async.Return                                    v\n        | WAsyncR     vra -> vra\n        \n        \n    let inline getAsyncWithDefault f w = getAsyncR w |> Async.map (Result.withError f)\n    let inline getAsync              w = getAsyncWithDefault (fun ms -> raise (exn(getMessages ms))) w\n\n    let toAsync            w = getAsync  w\n    let toAsyncResult      w = getAsyncR w\n    let toAsyncOption      w = getAsyncR w |> Async.map Result.toOption\n    let toAsyncOptionMs    w = getAsyncR w |> Async.map Result.toOptionMs\n    let toAsyncWithDefault w = getAsyncWithDefault w\n\n//    let call wb = wb |> getR Rop.notifyMessages\n    let startV (processVal: ('t option * string) ->unit) (w: Wrap<'t>) =\n        w\n        |> getAsyncR\n        |> fun asy -> Async.StartWithContinuations\n                        (asy \n                       , Result.mapMsgs Result.getMessages  >> processVal\n                       , sprintf \"%O\" >> (fun m -> None, m) >> processVal\n                       , sprintf \"%O\" >> (fun m -> None, m) >> processVal)\n                       \n    let start (printMsg: string->unit) (w: Wrap<unit>) = \n        startV (function\n                | Some (), msgs ->               msgs |> printMsg \n                | None   , msgs -> \"Failed!\\n\" + msgs |> printMsg) w\n\n    let wrapper2Async (f: 'a -> Wrap<'b>) a : Async<Result<'b>> =\n        let wb = tryCall f a\n        match wb with\n        | WNone                   \n        | WSome   _               -> wb |> wb2arb [||]\n        | WResult (Result(_, ms)) -> wb |> wb2arb ms\n        | WAsync  ab              -> async { let!   b = ab\n                                             return succeed b }\n        | WAsyncR arb             -> arb\n\n    let addMsgs errOptionIsNone ms wb =\n        if ms = [||] then wb else\n        match wb with\n        | WSome            v       -> WResult (succeedWithMsgs                        v ms)\n        | WNone                    -> WResult (fail errOptionIsNone |> Result.mergeMsgs ms)\n        | WResult r                -> WResult (r                    |> Result.mergeMsgs ms)\n        | WAsync           va      -> async {\n                                        let! v = va\n                                        return succeedWithMsgs v ms\n                                      } |> WAsyncR\n        | WAsyncR          vra     -> async {\n                                        let! vr = vra\n                                        return vr                    |> Result.mergeMsgs ms\n                                      } |> WAsyncR\n\n    let combine errOptionIsNone wa (wb: unit -> Wrap<_>) =\n        match wa with\n        | WSome               _\n        | WResult(Result(Some _,[||]))-> wb()\n        | WResult(Result(Some _, ms ))-> wb() |> addMsgs errOptionIsNone ms\n        | WAsync           aa         -> async { let!   _a = aa\n                                                 let!   br = wb() |> toAsyncResult\n                                                 return br\n                                                } |> WAsyncR\n        | WAsyncR          ara        -> async { let!  ar = ara\n                                                 match ar with\n                                                 | Failure    ms -> return Result.failWithMsgs ms\n                                                 | Success(_, ms)-> let! br = wb() |> toAsyncResult\n                                                                    return br |> Result.mergeMsgs ms\n                                               } |> WAsyncR\n        | WNone                       -> WNone\n        | WResult(Result(None, ms))   -> Result.failWithMsgs ms |> WResult\n        \n    let rec whileLoop pred body =\n        if pred() then body() |> bind (fun () -> whileLoop pred body)\n        else WSome   ()\n        //while pred() do\n        //    body() //|> ignore\n        //WSome   ()\n\n\n    type Builder() =\n//        member        this.Bind (wrapped: Async<Result<'a>>, restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WAsyncR |> bind restOfCExpr //<< cannot differentiate from next \n        member        this.Bind (wrapped: Wrap<'a>         , restOfCExpr: 'a -> Wrap<'b>) = wrapped            |> bind restOfCExpr \n        member        this.Bind (wrapped: Async<'a>        , restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WAsync  |> bind restOfCExpr  \n        member        this.Bind (wrapped: Result<'a>       , restOfCExpr: 'a -> Wrap<'b>) = match wrapped with \n                                                                                            | Result(Some v, [||]) -> WSome v\n                                                                                            | Result(None  , [||]) -> WNone\n                                                                                            | _                    -> WResult wrapped\n                                                                                            |> bind restOfCExpr \n        member        this.Bind (wrapped: 'a option        , restOfCExpr: 'a -> Wrap<'b>) = wrapped |> Option.map WSome   |> Option.defaultValue WNone |> bind restOfCExpr \n        member inline this.Zero         ( ) = WSome   ()\n        member inline this.Return       (x) = WSome   x\n        member inline this.ReturnFrom   (w) = w\n//        member inline this.ReturnFrom   (w) = WAsync  w\n//        member inline this.ReturnFrom   (w) = WResult w\n//        member inline this.ReturnFrom   (w) = WOption w        \n        member inline this.Delay        (f) = f\n        member this.Run(f) = f()\n        member        this.Combine   (a, b) = combine errOptionIsNone a b\n        member        this.While(guard, body) = whileLoop guard body\n        member this.TryWith(body, handler) =\n            async {\n                let! r = body() |> toAsyncResult |> Async.Catch \n                return\n                    match r with\n                    | Choice1Of2 v -> v\n                    | Choice2Of2 e -> handler e\n            } |> WAsyncR\n        member this.TryFinally(body, compensation) =\n            async {\n                let! r1 = body() |> toAsyncResult |> Async.Catch \n                let _r2 = compensation()     \n                return\n                    match r1 with\n                    | Choice1Of2 v -> v\n                    | Choice2Of2 e -> raise e\n            } |> WAsyncR\n        member this.Using(disposable:#System.IDisposable, body) =\n            let body' = fun () -> body disposable\n            this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))            \n    let wrap    = Builder()\n    let wrapper = Builder()  // deprecated use wrap instead\n\n    let getResult callback (wb: Wrap<'T>) =\n        match wb with\n        | WSome        s  -> s               |> succeed                                              |> callback\n        | WNone           -> errOptionIsNone |> fail                                                 |> callback\n        | WResult      rb -> rb                                                                      |> callback\n        | WAsync       ab -> Async.StartWithContinuations(ab , (fun v   -> succeed v                 |> callback), \n                                                               (fun exc -> failException exc |> fail |> callback), \n                                                                fun can -> failException can |> fail |> callback)\n        | WAsyncR     arb -> Async.StartWithContinuations(arb,                                          callback , \n                                                               (fun exc -> failException exc |> fail |> callback), \n                                                                fun can -> failException can |> fail |> callback)\n\n\n#if WEBSHARPER\n    [< Inline \"console.log('runSynchronously should not be used in Javascript')\" >]                       \n#endif\n    let runSynchronouslyR (w: Wrap<_>) =\n        w\n        |> getAsyncR\n        |> Async.RunSynchronously\n    let runSynchronouslyO count (w: Wrap<_>) =\n        w\n        |> runSynchronouslyR\n        |> (Result.mapMsgs (if count then Result.countMessages else Result.getMessages))\n    let runSynchronouslyS count (w: Wrap<_>) =\n        w\n        |> runSynchronouslyO count\n        |> function\n           | Some r, msgs -> sprintf \"%O\\n%s\" r    msgs\n           | None  , msgs -> sprintf \"Failed!\\n%s\" msgs\n           \ntype Wrap<'T> with\n    static member Start           (w:Wrap<_   >,           ?cancToken) = Async.Start           (Wrap.getAsync  w,                                ?cancellationToken= cancToken)\n    static member StartAsTask     (w:Wrap<'T  >, ?options, ?cancToken) = Async.StartAsTask     (Wrap.getAsyncR w, ?taskCreationOptions= options, ?cancellationToken= cancToken)\n#if WEBSHARPER\n    [< Inline \"console.log('RunSynchronously should not be used in Javascript')\" >]                       \n#endif\n    static member RunSynchronouslyR(w:Wrap<'T  >, ?timeout, ?cancToken) = Async.RunSynchronously(Wrap.getAsyncR w, ?timeout            = timeout, ?cancellationToken= cancToken)\n#if WEBSHARPER\n    [< Inline \"console.log('RunSynchronously should not be used in Javascript')\" >]                       \n#endif\n    static member RunSynchronously( w:Wrap<'T  >, ?timeout, ?cancToken) = Async.RunSynchronously(Wrap.getAsync  w, ?timeout            = timeout, ?cancellationToken= cancToken)\n\n\nmodule List =\n    let cons head tail = head :: tail\n    /// Map an AsyncResult producing function over a list to get a new AsyncResult\n    /// using monadic style\n    /// ('a -> Wrap<'b>) -> 'a list -> Wrap<'b list>\n    let rec traverseWrapM f list =\n        let (>>=) x f = Wrap.bind f x\n        let initState = Wrap.Return []\n        let folder head tail = f head >>= (fun h -> tail >>= (fun t -> Wrap.Return (cons h t) ))\n        List.foldBack folder list initState \n    /// Transform a \"list<Wrap>\" into a \"Wrap<list>\"\n    /// and collect the results using bind.\n    let sequenceWrapM x = traverseWrapM id x\n    \n    /// Map an AsyncResult producing function over a list to get a new AsyncResult\n    /// using monadic style\n    /// ('a -> Wrap<'b>) -> 'a list -> Wrap<'b list>\n    let rec traverseWrapA f list =\n        let (<*>)     = Wrap.apply\n        let retn      = Wrap.WSome  \n        let initState = retn []\n        let folder head tail = retn cons <*> f head <*> tail\n        List.foldBack folder list initState \n    /// Transform a \"list<Wrap>\" into a \"Wrap<list>\"\n    /// and collect the results using bind.\n    let sequenceWrapA x = traverseWrapA id x\n    \n    /// Map a Result producing function over a list to get a new Result \n    /// using applicative style\n    /// ('a -> Result<'b>) -> 'a list -> Result<'b list>\n    let rec traverseResultA f list =\n        let (<*>)            = Result.apply\n        let retn             = Result.succeed\n        let initState        = retn []\n        let folder head tail = retn cons <*> (f head) <*> tail\n        List.foldBack folder list initState\n    /// Transform a \"list<Result>\" into a \"Result<list>\" \n    /// and collect the results using apply.\n    let sequenceResultA x = traverseResultA id x\n    \n    ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[{"$":0,"Item":"657c8f34-c917-4659-825d-c9ead206efcf"},{"$":0,"Item":"7a655466-e218-4121-a7b6-f9c70a922e07"}],"id":{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Mailbox","content":"module Mailbox =\n\n    /// A simple Mailbox processor to serially process tasks\n    let iter f =\n        MailboxProcessor.Start(fun inbox ->\n            async {\n                while true do\n                    try       let!   msg = inbox.Receive()\n                              do!  f msg\n                    with e -> printfn \"%A\" e\n            }\n        )\n    \n    /// A simple Mailbox processor to serially and synchronously process tasks\n    /// invoke f with: agent.PostAndReply     (fun reply -> reply, parm)\n    ///         or     agent.PostAndReplyAsync(fun reply -> reply, parm)\n    let call f = iter (fun ((replyChannel: AsyncReplyChannel<_>), msg) -> async {\n        let! r = f msg\n        replyChannel.Reply r\n    })\n    \n    /// A Mailbox processor that maintains a state\n    let fold f initState =\n        MailboxProcessor.Start(fun inbox ->\n            let rec loop state : Async<unit> = async {\n                try       let! msg      = inbox.Receive()\n                          let! newState = f state msg\n                          return! loop newState\n                with e -> printfn \"%A\" e\n                          return! loop state\n            }\n            loop initState\n        )\n\n// object expressions work only on types not objects\n//\n//    /// A simple Mailbox processor to serially process tasks\n//    /// with a Flush option\n//    let iterFlushable f =\n//        let ff msg = match msg with \n//                     | Some m -> f m \n//                     | None   -> async { () }\n//        let mailbox = iter ff\n//        { new mailbox with member this.Flush() = mailbox.Post None }  \n//\n//    let foldFlushable f initState =\n//        let ff msg = match msg with \n//                     | Some m -> f m \n//                     | None   -> async { () }\n//        let mailbox = fold ff initState\n//        { new mailbox with member this.Flush() = mailbox.Post None }\n//        ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[{"$":0,"Item":"7a655466-e218-4121-a7b6-f9c70a922e07"}],"id":{"$":0,"Item":"aa485846-7b78-4ca8-ae22-84ba0c42d962"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Dict, LDict, IDict","content":"(* issues with websharper Type not found in JavaScript compilation: System.Collections.Generic.IDictionary`2\nmodule IDict =\n#if WEBSHARPER\n    [< Inline >]\n#endif\n    let inline tryGetValue key (dict:System.Collections.Generic.IDictionary<_, _>) =\n        let mutable res = Unchecked.defaultof<_>\n        if dict.TryGetValue(key, &res)\n        then Some res \n        else None\n    let add          key v (dict:System.Collections.Generic.IDictionary<_, _>) = if dict.ContainsKey key then      dict.[key] <- v else dict.Add(key, v)\n*)\nmodule Dict =\n#if WEBSHARPER\n    [< Inline >]\n#endif\n    let inline tryGetValue key (dict:System.Collections.Generic. Dictionary<_, _>) =\n        let mutable res = Unchecked.defaultof<_>\n        if dict.TryGetValue(key, &res)\n        then Some res \n        else None\n    let add          key v (dict:System.Collections.Generic. Dictionary<_, _>) = if dict.ContainsKey key then      dict.[key] <- v else dict.Add(key, v)\n\nmodule LDict =\n#if WEBSHARPER\n    [< Inline >]\n#endif\n    let inline containsKey  key  dict = (^a : (member ContainsKey : _ -> bool) (dict, key))\n    //let inline item         key  dict = (^a : (member get_Item    : _ -> _   ) (dict, key))\n#if WEBSHARPER\n    [< Inline >]\n#endif\n    let inline tryGetValue fitem key  dict =\n        if containsKey key dict then Some (fitem key)\n        else None\n\n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"995f98ae-4f13-4225-9d00-9aa3e630058a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"parseInt","content":"let tryParseWith tryParseFunc = tryParseFunc >> function\n        | true, v    -> Some v\n        | false, _   -> None\n\nlet parseDate   = tryParseWith System.DateTime.TryParse\nlet parseInt    = tryParseWith System.Int32   .TryParse\nlet parseSingle = tryParseWith System.Single  .TryParse\nlet parseDouble = tryParseWith System.Double  .TryParse\n// etc.\n\n// active patterns for try-parsing strings\nlet (|Date  |_|) = parseDate\nlet (|Int   |_|) = parseInt\nlet (|Single|_|) = parseSingle\nlet (|Double|_|) = parseDouble","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"af2b60c6-a99f-433d-b938-f59fefe66c01"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"REGEX","content":"#if WEBSHARPER\n\nlet (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n    if value = null then None else\n    try \n        match JavaScript.String(value).Match(RegExp(expr, opt)) with\n        | null         -> None\n        | [| |]        -> None\n        | m            -> Some m\n    with e -> None\n\nlet rexGuid = \"\"\"([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})\"\"\"\n#endif\n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"unindent, indentStr","content":"let unindent (s:string) =\n    let lines = s.Split '\\n'\n    let n     = lines.[1] |> Seq.tryFindIndex ((<>) ' ') |> Option.defaultValue 0\n    lines \n    |> Seq.map (fun l -> l.Substring n)\n    |> Seq.filter (fun s -> s.StartsWith \"# 1 \" |> not)\n\nlet unindentStr = unindent >> String.concat \"\\n\"\n\nlet indent n (s:string) =\n    s.Split '\\n'\n    |> Seq.map ((+) (String.replicate n \" \"))","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"a21525b8-a16c-4e98-b05e-8eef61ff4539"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"dprintfn, oprintfn","content":"let dprintfn       fmt = fmt |> Printf.ksprintf ignore //(fun s -> printfn \"%s\"  s)\nlet printoutfn out fmt = fmt |> Printf.ksprintf (fun s -> s + \"\\n\" |> out)\n//let printoutf  out fmt = Printf.kprintf                        out  fmt\nlet print    v = printfn \"%A\" v\nlet mapPrint v = print        v; v\n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"e24d6bc0-703c-4f12-aca8-8158af50b7cd"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"memoize","content":"#if WEBSHARPER\n[< Inline >]\n#endif\nlet memoize f = \n    let cache = System.Collections.Generic.Dictionary<_, _>()\n    fun x -> \n        let mutable res = Unchecked.defaultof<_>\n        let ok = cache.TryGetValue(x, &res)\n        if ok then res \n        else let res = f x\n             cache.[x] <- res\n             res\n             \ntype ResetableMemoize(f) =             \n    let cache = System.Collections.Generic.Dictionary<_, _>()\n    member this.ClearCache() = cache.Clear()\n    #if WEBSHARPER\n    [< Inline >]\n    #endif\n    member this.Call x =\n        let mutable res = Unchecked.defaultof<_>\n        let ok = cache.TryGetValue(x, &res)\n        if ok then res \n        else let res = f x\n             cache.[x] <- res\n             res\n    ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"8efdcd5a-95c4-4212-9c75-1ebedce83dd8"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"separateDirectives","content":"type PreproDirective =\n| PrepoR      of string\n| PrepoDefine of string\n| PrepoLoad   of string\n| PrepoLine   of string //* int\n| PrepoNoWarn of string\n| PrepoI      of string\n| PrepoIf     of string\n| PrepoElse   \n| PrepoEndIf\n| PrepoLight  of bool\n| PrepoOther  of string\n| NoPrepo\n\nlet separatePrepros removePrepoLine (code:string[]) =\n    let  quoted (line:string) = line.Trim().Split([| \"\\\"\"       |], System.StringSplitOptions.RemoveEmptyEntries) |> Seq.tryLast |> Option.defaultValue line\n    let  define (line:string) = line.Trim().Split([| \"#define \" |], System.StringSplitOptions.RemoveEmptyEntries) |> Seq.tryHead |> Option.defaultValue \"\"\n    let  comment = ((+)\"//\") \n    let  preL    = if removePrepoLine then comment else id \n    let  prepro (line:string) = match true with \n                                | true when line.StartsWith(\"#define\") -> (comment line, line |> define |> PrepoDefine)\n                                | true when line.StartsWith(\"#r\"     ) -> (comment line, line |> quoted |> PrepoR     )\n                                | true when line.StartsWith(\"#load\"  ) -> (comment line, line |> quoted |> PrepoLoad  )\n                                | true when line.StartsWith(\"#nowarn\") -> (comment line, line |> quoted |> PrepoNoWarn)\n                                | true when line.StartsWith(\"# \"     ) -> (preL    line, line |> quoted |> PrepoLine  )\n                                | true when line.StartsWith(\"#line\"  ) -> (preL    line, line |> quoted |> PrepoLine  )\n                                | true when line.StartsWith(\"#I\"     ) -> (comment line, line |> quoted |> PrepoI     )\n                                | true when line.StartsWith(\"#if\"    ) -> (        line, line           |> PrepoIf    )\n                                | true when line.StartsWith(\"#else\"  ) -> (        line,                   PrepoElse  )\n                                | true when line.StartsWith(\"#endif\" ) -> (        line,                   PrepoEndIf )\n                                | true when line.StartsWith(\"#light\" ) -> (        line, false          |> PrepoLight )\n                                | true when line.StartsWith(\"#\"      ) -> (comment line, line           |> PrepoOther )\n                                | _                                    -> (        line,                   NoPrepo    ) \n    code |> Array.map prepro\n    \nlet separateDirectives (fsNass:(string * PreproDirective) seq) =\n    let  assembs  = fsNass |> Seq.choose (snd >> (function | PrepoR assemb -> Some assemb | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  defines  = fsNass |> Seq.choose (snd >> (function | PrepoDefine d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  prepoIs  = fsNass |> Seq.choose (snd >> (function | PrepoI      d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  nowarns  = fsNass |> Seq.choose (snd >> (function | PrepoNoWarn d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  code     = fsNass |> Seq.map     fst                                                                           |> Seq.toArray\n    code, assembs, defines, prepoIs, nowarns\n\n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"ace1fc12-3dfb-4db8-80c9-5bde1e7d0597"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Save File","content":"open System.IO\n\nlet backupFile file = \n    try File.Delete(      file + \".bak\") with _ -> ()\n    try File.Copy  (file, file + \".bak\") with _ -> ()\n\nlet inline saveFile (file:string) (content: string) =\n    Wrap.wrapper {\n        do! Result.tryProtection()\n        backupFile file\n        File.WriteAllText(file, content)\n    } \n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"let doSTA act =\n    let thread = System.Threading.Thread(System.Threading.ThreadStart act)\n    thread.SetApartmentState(System.Threading.ApartmentState.STA)\n    thread.Start()\n    \nlet sCopy       txt = \n    doSTA (fun () -> System.Windows.Forms.Clipboard.SetText txt)\n    sprintf \"Copied to clipboard: %s... (%d characters)\\n\\n\" <| txt.[..min (txt.Length - 1) 100 ] <| txt.Length \n    \nlet Copy        txt = \n    sCopy txt\n    |> printf \"%s\"\n    \nlet Paste f        = doSTA (fun () -> f System.Windows.Forms.Clipboard.GetText)   ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"c7e56d1e-aea8-483a-a99a-23b7e056de0d"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"type ActionBar","content":"open System\nopen System.Text\nopen System.Drawing\nopen System.Windows.Forms\nopen System.ComponentModel\n\ntype GrowLabel (maxHeight:int) =\n  inherit Label() \n  let mutable mGrowing  = false\n  do base.AutoSize     <- false\n  member this.resizeLabel() =\n    if mGrowing then () else\n    try \n      mGrowing <- true\n      let sz       = new Size(base.Width, Int32.MaxValue)\n      let sz2      = TextRenderer.MeasureText(base.Text, base.Font, sz, TextFormatFlags.WordBreak)\n      base.Height <- min sz2.Height maxHeight\n    finally\n      mGrowing <- false\n  override this.OnTextChanged( e) = \n    base.OnTextChanged e\n    this.resizeLabel()\n  override this.OnFontChanged( e) =\n    base.OnFontChanged e\n    this.resizeLabel()\n  override this.OnSizeChanged( e) =\n    base.OnSizeChanged e\n    this.resizeLabel()\n\ntype ActionBar(actions:(string * (unit -> string)) seq) =\n    let label1 = new GrowLabel (Text = \"\", Width = 300, maxHeight = 100)\n    let newButton (txt:string) act =\n        let width = 300\n        if txt.StartsWith \"---\" || txt.StartsWith \"===\" then\n            let lbl = new Label(Text = txt, Width = width)\n            lbl :> Control\n        else\n            let btn = new Button(Text = txt, Width = width)\n            btn.Click.Add act\n            btn :> Control\n    \n    let form = new Form(Text = \"Select Action:\", Width = 400, Height = 800)\n    let panel1 = new Panel(Dock = DockStyle.Fill)\n    do  actions \n        |> Seq.map (fun (txt, f) -> newButton txt (fun _ -> label1.Text <- sprintf \"Processing %s ...\" txt\n                                                            form.Refresh()\n                                                            label1.Text <- f() ))\n        |> Seq.append [ label1 :> Control ]\n        |> Seq.toArray\n        |> panel1.Controls.AddRange\n        let reposition () =\n            panel1.Controls\n            |> Seq.cast\n            |> Seq.fold (fun (height, width) (cts: Control) -> \n                cts.Left <- 20 \n                cts.Top  <- height + 5\n                (height + cts.Height + 5, (max width cts.Width)) ) (0, 0)\n            |> (fun (height, width) -> form.Height <- height + 50 ; form.Width <- width + 50)\n        reposition ()\n        label1.Resize.Add (fun _ -> reposition () )\n        panel1.DockPadding.All <- 10\n        form.Controls.Add(panel1)\n        form.Activated.AddHandler(System.EventHandler (fun _ _ -> form.TopMost <- true(*; form.TopMost <- false*) ))\n        async {\n          do Application.Run(form) \n        } |> Async.Start\n       ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"16f618b6-0483-44dc-9c54-550f4f5b725d"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"asyncStartCancelling","content":"let asyncStartCancelling() =    \n    let mutable tokenSource : System.Threading.CancellationTokenSource option = None\n    fun a ->\n        tokenSource |> Option.iter (fun oldTokenSource -> oldTokenSource.Cancel() )\n        let newTokenSource = new System.Threading.CancellationTokenSource() \n        Async.Start(a, newTokenSource.Token)\n        tokenSource <- Some newTokenSource\n\n        ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"ece85c79-829d-4bec-a607-a1cd01f9dafa"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"UsefulDotNet","content":"module UsefulDotNet =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"Regex, Regexs","content":"#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\nopen System.Text.RegularExpressions\n\nlet (|Regex|_|) pattern input =\n    if input = null then None else\n    try \n        let m = Regex.Match(input, pattern)\n        if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])\n        else None\n    with e -> None\n\nlet (|Regexs|) pattern input =\n    if input = null then [| |] else\n    try \n        let ms = Regex.Matches(input, pattern)\n        [| for m in ms do yield m.Value |] \n    with e -> [| |]\n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[],"id":{"$":0,"Item":"7646acbc-2c28-4159-98b1-2365d19fc97c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"fSharpError2TranspilerError","content":"open Microsoft.FSharp.Compiler.SourceCodeServices\nopen Microsoft.FSharp.Compiler\nopen Useful\n\ntype FSharpErrors =\n    | WarningFSharp                 of string\n    | ErrFSharp                     of string\nwith interface ErrMsg with\n        member this.ErrMsg    = sprintf \"%A\"this\n        member this.IsWarning = match this with | WarningFSharp _ -> true | _ -> false\n\nlet getIndentFile input =\n    match input with\n    | Regex \"^\\\\((\\\\d+)\\\\)\\\\s(.*)$\" [_ ; indent ; file] -> int indent, file\n    | _                                                 -> 0         , input\n   \nlet fSharpError2TranspilerError (error : FSharpErrorInfo) =\n    let indent, file = System.IO.Path.GetFileNameWithoutExtension error.FileName |> getIndentFile  \n    sprintf \"%s (%d,%d) - (%d,%d) %s %d: %s\" \n       file \n       error.StartLineAlternate (error.StartColumn - indent) \n       error.EndLineAlternate   (error.EndColumn   - indent) \n       error.Subcategory error.ErrorNumber error.Message\n    |> (if   error.Severity = FSharpErrorSeverity.Error  \n        then ErrFSharp     \n        else WarningFSharp\n       )\n    :> ErrMsg\n    \n    ","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"7646acbc-2c28-4159-98b1-2365d19fc97c"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"9becc68c-9cc2-4f29-82df-e510d10226db"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"ResourceAgent","content":"open Useful\n\ntype ResourceAgent<'T, 'C when 'C : equality>(maxUseCount:int, ctor: 'C option ->'T, ?cleanup, ?isAlive, ?configuration: 'C) =\n    let mutable configuration = configuration\n    let mutable resource      = ctor configuration\n    let mutable useCount      = 0\n    let respawn() =\n        cleanup |> Option.iter (fun clean -> clean resource) \n        resource <- ctor configuration\n        useCount <- 0\n    let agent    = \n        MailboxProcessor.Start(fun inbox ->\n            async {\n               while true do\n                 try\n                     let! increment, config, work = inbox.Receive()\n                     isAlive |> Option.iter (fun alive -> if not (alive resource) then respawn())\n                     if config <> configuration then\n                        configuration <- config\n                        respawn()\n                     do!  work resource\n                     if increment then useCount <- useCount + 1\n                                       if useCount >= maxUseCount && maxUseCount > 0 then respawn()\n                 with _ -> respawn() \n            }\n        )\n    do agent.Error.AddHandler <| Handler (fun _ _ -> respawn())\n    member this.Process (work:'T -> Wrap<'a>, ?config, ?incrUse) =\n        agent.PostAndAsyncReply\n            (fun reply ->\n                 (defaultArg incrUse true, config, fun resource ->\n                          async {\n                               let! res = work resource |> Wrap.getAsyncR\n                               reply.Reply res\n                          } \n                 )\n            )\n    member this.Configuration  = configuration\n    member this.MaxUseCount    = maxUseCount\n    member this.UseCount       = useCount\n    interface System.IDisposable with\n        member this.Dispose () =\n            try cleanup |> Option.iter (fun clean -> clean resource) with _ -> ()\n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"f930dc48-39e8-453c-8c77-18a2cd73637a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"TempFileName","content":"type TempFileName(fn) =\n    new () = new TempFileName(System.IO.Path.GetTempFileName())\n    member this.Name = fn\n    interface System.IDisposable with\n        member this.Dispose() = if System.IO.File.Exists fn then System.IO.File.Delete fn\n        \n        ","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[],"id":{"$":0,"Item":"4137cad8-fd64-426e-98de-16a92a56388d"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"RunProcess","content":"open System.Diagnostics\nopen System.Text\nopen Useful\n\nmodule RunProcess =\n\n    let startProcess p ops =\n        let procStart   = ProcessStartInfo(p, ops)\n        let proc        = new Process()\n        proc.StartInfo <- procStart\n        proc.Start() \n    \n    let startProcessDir p ops dir =\n        let procStart   = ProcessStartInfo(p, ops, WorkingDirectory = dir)\n        let proc        = new Process()\n        proc.StartInfo <- procStart\n        proc.Start() \n    \n    type ShellExError =\n        | ShellExitCode              of int\n        | ShellOutput                of string\n        | ShellErrors                of string\n        | ShellFailWithMessage       of string\n        | ShellFinishedWithNoMessage \n        | ShellDidNotStart \n        | ShellCrashed               of string\n    with interface ErrMsg with\n            member this.ErrMsg    = \n                match this with \n                | ShellFailWithMessage msg   -> msg  \n                | ShellFinishedWithNoMessage -> \"warning - No output\"\n                | ShellOutput          msg   -> msg\n                | ShellCrashed         msg   -> \"Crashed \" + msg\n                | msg                        -> sprintf \"%A\" msg\n            member this.IsWarning =\n                match this with \n                | ShellFinishedWithNoMessage\n                | ShellOutput _              -> true\n                | _                          -> false \n    \n    \n    type ShellEx(startInfo: ProcessStartInfo, ?outHndl, ?errHndl) =\n        let proc                              = new Process()\n        let bufferOutput                      = new StringBuilder()\n        let bufferError                       = new StringBuilder()\n        let append  (sb: StringBuilder) txt   = sb.Append(txt + \"\\n\") |> ignore\n        let consume (sb: StringBuilder)       = \n            let v = sb.ToString()\n            sb.Clear() |> ignore\n            v\n        let dataHandler handler               = DataReceivedEventHandler(fun sender args -> try handler args.Data with _ -> ())\n        let outputHandler                     = append bufferOutput |> dataHandler\n        let errorHandler                      = append bufferError  |> dataHandler\n        do  startInfo.RedirectStandardInput  <- true\n            startInfo.RedirectStandardOutput <- true\n            startInfo.RedirectStandardError  <- true\n            startInfo.UseShellExecute        <- false\n            proc.StartInfo                   <- startInfo\n            proc.EnableRaisingEvents         <- true\n            outputHandler                    |>             proc.OutputDataReceived.AddHandler\n            errorHandler                     |>             proc.ErrorDataReceived .AddHandler\n            Option.map dataHandler outHndl   |> Option.iter proc.OutputDataReceived.AddHandler\n            Option.map dataHandler errHndl   |> Option.iter proc.ErrorDataReceived .AddHandler\n    //        proc.Exited            .AddHandler(System.EventHandler     (fun sender args -> try proc.Close()                                    with _ -> () ))\n        new (program, args) =             \n            let startInfo                     = new ProcessStartInfo()\n            do  startInfo.FileName           <- program\n                startInfo.Arguments          <- args\n            new ShellEx(startInfo)\n        member this.Start() = \n            let r = proc.Start() \n            proc.BeginOutputReadLine()\n            proc.BeginErrorReadLine ()\n            r\n        member this.stdOutErr2Result out errs exit =\n            if exit <> 0\n            then Result.failWithMsgs\n                    [| if out  <> \"\"              then yield ErrSimple (\"stdout: \" + out           , true ) :> ErrMsg\n                       if errs <> \"\"              then yield ErrSimple (errs                       , false) :> ErrMsg\n                       if errs  = \"\" || exit <> 1 then yield ErrSimple (sprintf \"ExitCode: %d\" exit, false) :> ErrMsg\n                    |]\n            else Result.succeedWithMsgs out \n                    [| if errs <> \"\"              then yield ErrSimple (errs                       , false) :> ErrMsg |]\n        member this.WaitToFinish() =\n            proc.WaitForExit()\n            let    output  = (consume bufferOutput).Trim()\n            let    error   = (consume bufferError ).Trim()\n            (output, error, if proc.HasExited then proc.ExitCode else -99999)\n        member this.StartAndWait() =\n            let _started = this.Start()\n            this.WaitToFinish()\n        member this.WaitForInputIdle() =\n            proc.WaitForInputIdle()\n        member this.StartAndWaitR() =\n            let r = this.StartAndWait()\n            (this :> System.IDisposable).Dispose()\n            r |||> this.stdOutErr2Result\n        member this.RunToFinish() =\n            this.StartAndWaitR()\n            |> Result.result2String\n        member this.RunOutputToFileR file =\n            proc.OutputDataReceived.RemoveHandler outputHandler\n            use stream  = new System.IO.FileStream(file, System.IO.FileMode.Create)\n            let _started = proc.Start() \n            proc.BeginErrorReadLine ()\n            proc.StandardOutput.BaseStream.CopyTo stream\n            this.WaitToFinish()\n            |||> this.stdOutErr2Result\n        member this.RunOutputToFile file =\n            this.RunOutputToFileR file\n            |> Result.result2String\n        member this.Send(txt: string)   = proc.StandardInput.WriteLine txt\n        member this.Output  ()          = consume bufferOutput\n        member this.Error   ()          = consume bufferError\n        member this.Response(out:string, err:string)  = \n            match out.Trim(), err.Trim() with\n    //        | \"\"  , \"\"  -> None\n            | good, \"\"  -> Some( Result.succeed        good                             )\n            | \"\"  , bad -> Some( Result.fail                <| ShellFailWithMessage bad )\n            | good, bad -> Some( Result.succeedWithMsg good <| ShellFailWithMessage bad )\n        member this.Response()          = this.Response(this.Output(), this.Error())\n        member this.SendAndWait(send, wait, ?onError) =\n            let waitOnError   = defaultArg onError false\n            let eventWait = \n                if waitOnError then proc.ErrorDataReceived else proc.OutputDataReceived\n                |> Event.choose (fun evArgs -> try evArgs.Data |> (fun v -> if v.Contains wait then Some <| Result.succeed v else None) with _ -> None)\n            let eventAll = Event.merge eventWait  (Event.map (fun _ -> Result.fail <| ShellCrashed startInfo.FileName) proc.Exited)\n            Wrap.wrapper {\n                do! Result.tryProtection()\n                async { \n                    do!    Async.Sleep 20 \n                    this.Send send        } |> Async.Start\n                let!   waitedR = Async.AwaitEvent eventAll\n                let!   waited  = waitedR\n                do!    Async.Sleep 200\n                let!   res =\n                       if waitOnError then \n                           this.Response(this.Output(), this.Error() |> fun msg -> msg.Split([| waited |], System.StringSplitOptions.None) |> Array.head)\n                       else this.Response()\n                       |> Option.defaultWith (fun () -> Result.succeedWithMsg \"\" ShellFinishedWithNoMessage)\n                return res\n            }\n        member this.HasExited = try proc.HasExited with _ -> true\n        member this.Abort()   = try proc.Kill   () with _ -> ()\n        interface System.IDisposable with\n            member this.Dispose () =\n                try proc.Kill   () with _ -> ()\n                try proc.Close  () with _ -> ()\n                try proc.Dispose() with _ -> ()\n    \n    \n    let runAndWaitR p ops =\n        let procStart   = ProcessStartInfo(p, ops)\n        let shell       = new ShellEx(procStart)\n        shell.StartAndWaitR() \n    \n    let runToFinish p ops =\n        let procStart   = ProcessStartInfo(p, ops)\n        let shell       = new ShellEx(procStart, printfn \"%s\", eprintfn \"%s\")\n        shell.RunToFinish() \n    \n    let runOutputToFile p ops file =\n        let procStart   = ProcessStartInfo(p, ops)\n        let shell       = new ShellEx(procStart)\n        shell.RunOutputToFile file \n    \n    ","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"copyIfMust","content":"open System.IO\n\nlet copyIfNotExistsToFile from dest =\n    let fit = FileInfo dest\n    if not fit.Exists then\n        File.Copy(from, dest, true )\n\nlet copyIfMustToFile from dest =\n    let fit = FileInfo dest\n    let must = \n        match fit.Exists with \n        | false -> true\n        | true  ->\n            let fif = FileInfo dest\n            fif.Length <> fit.Length || fif.LastWriteTime <> fit.LastWriteTime\n    if must then\n        File.Copy(from, dest, true )\n\nlet copyIfMustToDir from destDir =\n    let dest = Path.Combine(destDir, Path.GetFileName(from))\n    copyIfMustToFile from dest\n    ","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[],"id":{"$":0,"Item":"ab5ab0ca-eb45-4851-affe-4690bb75d055"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Path.Combine","content":"let inline (+/+) a b = System.IO.Path.Combine(a, b)","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[],"id":{"$":0,"Item":"15cf771f-22b1-4796-8e34-6c16f35d6506"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CompOptions","content":"module CompOptionsModule = // needs to be in a module so (?) operator does not collide with websharper\n    \n    type CompOptionClass = \n         | OpFSharp\n         | OpWebSharper\n         | OpInternal\n\n    type CompOption = \n        {\n            name   : string\n            unique : bool\n            opClass: CompOptionClass  \n            prefix : string\n        }\n    with\n        static member (/=) (op: CompOption, v: CompOptionValue) = op,           v\n        static member (/=) (op: CompOption, v                 ) = op, OpVText   v\n        static member (/=) (op: CompOption, v                 ) = op, OpVTextOF v\n    \n    and CompOptionValue =\n        | OpVText   of                 string\n        | OpVTextOF of (CompOptions -> string)\n    with \n        member this.Value ops = \n            match this with\n            | OpVText   v  -> v\n            | OpVTextOF fo -> fo ops\n    \n    and CompOptions = CompOptions of (CompOption * CompOptionValue) []\n    with\n        member this.Pairs             =  this |> function CompOptions ops ->  ops\n        member this.Exists   f        =  this.Pairs |> Array.exists f \n        member this.Find     name     =  this.Pairs |> Array.tryFind (fun (opT, opV) -> name = opT.name) |> Option.defaultWith (fun () -> raise (exn (\"option \" + name + \" not found.\")) )\n        member this.FindV    name     = (this.Find name |> snd).Value this\n        member this.Contains co       =  this.Exists (fun (opT, opV) -> co   = opT                           )\n        member this.Contains v        =  this.Exists (fun (opT, opV) -> v    = opT.prefix + (opV.Value this) )\n        member this.Get      f        =  this.Pairs |> Array.filter f |> Array.map (fun (opT, opV) ->        opT.prefix + (opV.Value this) )\n        static member FSharpOptions   = fun ({opClass=cls}, _) -> cls = OpFSharp\n        static member WSharperOptions = fun ({opClass=cls}, _) -> cls = OpFSharp || cls = OpWebSharper\n        static member (?) (ops: CompOptions, name: string) = ops.FindV name\n        static member (+) (os1: CompOptions, a2: (CompOption * CompOptionValue) seq) = \n            match os1 with \n            | CompOptions a1 -> \n                a1\n                |> Array.filter (fun (opT, _) -> (not opT.unique) || (a2 |> Seq.exists (fst >> (=) opT) |> not) )\n                |> Seq.append <| a2\n                |> Seq.toArray\n                |> CompOptions\n        static member (+) (ops: CompOptions, o:   CompOption * CompOptionValue      ) = ops + [| o |]\n        static member (+) (os1: CompOptions, os2: CompOptions                       ) = match os2 with | CompOptions a2 -> os1 + a2\n    \n    let (?) (ops:CompOptions) name = ops.FindV name\n    \n    let opSnippet     = { name = \"Snippet\"     ; unique = true  ; opClass = OpInternal   ; prefix = \"++snippet:\"   }\n    let opDirectory   = { name = \"Directory\"   ; unique = true  ; opClass = OpInternal   ; prefix = \"++directory:\" }\n    let opName        = { name = \"Name\"        ; unique = true  ; opClass = OpInternal   ; prefix = \"++name:\"      }\n    let opExtension   = { name = \"Extension\"   ; unique = true  ; opClass = OpInternal   ; prefix = \"++extension:\" }\n    let opFileName    = { name = \"Filename\"    ; unique = true  ; opClass = OpInternal   ; prefix = \"++filename:\"  }\n    let opOutputFile  = { name = \"OutputFile\"  ; unique = true  ; opClass = OpInternal   ; prefix = \"++fileout:\"   }\n    let opConfig      = { name = \"Config\"      ; unique = true  ; opClass = OpInternal   ; prefix = \"++config:\"    }\n    let opGenInternal = { name = \"GenInternal\" ; unique = false ; opClass = OpInternal   ; prefix = \"++\"           }\n    let opWebSharper  = { name = \"WebSharper\"  ; unique = true  ; opClass = OpInternal   ; prefix = \"++websharper:\"}\n        \n    let opIOption     = { name = \"IOption\"     ; unique = false ; opClass = OpFSharp     ; prefix = \"-I:\"          }\n    let opReference   = { name = \"Reference\"   ; unique = false ; opClass = OpFSharp     ; prefix = \"-r:\"          }\n    let opSource      = { name = \"Source\"      ; unique = false ; opClass = OpFSharp     ; prefix = \"\"             }\n    let opTarget      = { name = \"Target\"      ; unique = true  ; opClass = OpFSharp     ; prefix = \"--target:\"    }\n    let opOutput      = { name = \"Output\"      ; unique = true  ; opClass = OpFSharp     ; prefix = \"-o:\"          }\n    let opDebug       = { name = \"Debug\"       ; unique = true  ; opClass = OpFSharp     ; prefix = \"--debug:\"     }\n    let opDefine      = { name = \"Define\"      ; unique = false ; opClass = OpFSharp     ; prefix = \"--define:\"    }\n    let opGenFSharp1  = { name = \"GenFSharp1\"  ; unique = false ; opClass = OpFSharp     ; prefix = \"-\"            }\n    let opGenFSharp2  = { name = \"GenFSharp2\"  ; unique = false ; opClass = OpFSharp     ; prefix = \"--\"           }\n    \n    let opWebSite     = { name = \"Website\"     ; unique = true  ; opClass = OpWebSharper ; prefix = \"--wsoutput:\"  }\n    let opWsProject   = { name = \"WsProject\"   ; unique = true  ; opClass = OpWebSharper ; prefix = \"--project:\"   }\n    let opGenWSharper = { name = \"GenWSharper\" ; unique = false ; opClass = OpWebSharper ; prefix = \"--\"           }\n    \n    let dllOptions     = CompOptions [| opTarget      /= \"library\"                                                                     |]  \n    let exeOptions     = CompOptions [| opTarget      /= \"exe\"     ; opGenInternal /= \"copyassemblies\" ; opGenInternal /= \"copyconfig\" |]\n    let winExeOptions  = CompOptions [| opTarget      /= \"winexe\"  ; opGenInternal /= \"copyassemblies\" ; opGenInternal /= \"copyconfig\" |]\n    \n    let genericOptions = \n      CompOptions\n        [|\n           opSnippet     /= \"Test\"\n           opName        /= fun os -> (os?Snippet : string).Split('/') |> Array.last\n           opDirectory   /= fun os -> \"Compiled\" +/+ os?Name\n           opExtension   /= fun os -> match os?Target with | \"library\" -> \"dll\" | _ -> \"exe\"\n           opFileName    /= fun os -> os?Directory +/+ os?Name + \".fs\"\n           opSource      /= fun os -> os?Filename\n           opOutput      /= fun os -> System.IO.Path.ChangeExtension(os?Source, os?Extension)\n           opOutputFile  /= fun os -> System.IO.Path.GetFileName(os?Output)\n           opConfig      /= fun os -> os?Output + \".config\"\n           opWebSharper  /= fun os -> if (os:CompOptions).Exists (fun (opT, opV) -> opT.opClass = OpWebSharper) then \"1\" else \"0\"\n        |]\n        \n    let siteOptions =\n      CompOptions\n        [|\n           opGenWSharper /= \"ws:Site\"\n           opWebSite     /= fun os -> os?Directory +/+ \"website\"\n           opWsProject   /= fun os -> os?Name\n        |] \n     \n    let wsProjectOptions =\n      CompOptions\n        [|\n           opWsProject   /= fun os -> os?Name\n        |] \n     \n    let debugOptions = \n      CompOptions\n        [|\n           opGenFSharp1  /= \"g\"\n           opDebug       /= \"full\"\n           opDefine      /= \"DEBUG\"\n           opDefine      /= \"TRACE\"\n           opGenFSharp2  /= \"optimize-\"\n           opGenFSharp2  /= \"tailcalls-\"\n        |]\n    \n    let otherOptions =\n      CompOptions\n        [|\n           //@\"--noframework\"\n           opGenFSharp2  /= \"warn:3\"\n           opGenFSharp2  /= \"warnaserror:76\"\n           opGenFSharp2  /= \"vserrors\"\n           opGenFSharp2  /= \"utf8output\"\n           opGenFSharp2  /= \"fullpaths\"\n           opGenFSharp2  /= \"flaterrors\"\n           opGenFSharp2  /= \"subsystemversion:6.00\"\n           opGenFSharp2  /= \"highentropyva+\"\n           opGenInternal /= \"removelinedirectives\"\n        |]\n    \n    let compileOptionsDll (snp:string) = \n        genericOptions\n        + dllOptions\n        + otherOptions\n        + opSnippet     /= snp\n        \n    let compileOptionsDllDebug (snp:string) = compileOptionsDll snp + debugOptions        \n    let compileOptionsExeDebug    snp = compileOptionsDllDebug snp + exeOptions   \n    let compileOptionsWinExeDebug snp = compileOptionsDllDebug snp + winExeOptions\n        \n    let prepOptions (options:CompOptions) (code : string [], assembs : string [], defines : string [], prepoIs : string [], nowarns : string []) =\n        let  code2 =\n           [\n              yield! nowarns |> Seq.distinct |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\")\n              yield! code \n           ] |> String.concat \"\\n\"\n        let  fileName = options?Filename\n        do   System.IO.File.WriteAllText(fileName, code2)\n        let  options2 = \n             options  + [|\n                           yield! prepoIs |> Array.map ((/=) opIOption  ) \n                           yield! assembs |> Array.map ((/=) opReference)\n                           yield! defines |> Array.map ((/=) opDefine   )\n                           if options.Contains \"++staticlinkall\" then \n                               yield! assembs |> Array.map (System.IO.Path.GetFileNameWithoutExtension >> ((+) \"staticlink:\") >> ((/=) opGenFSharp2 ))         \n                        |]\n        if options.Contains \"++copyassemblies\" then \n            assembs |> Array.iter (fun f -> System.IO.Path.GetDirectoryName(fileName) |> copyIfMustToDir f)      \n        if options2.Contains \"++showoptions\"    then printfn \"%s\" (options2.Get (fun _ -> true) |> String.concat \"\\n\")               \n        options2\n    \n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"ab5ab0ca-eb45-4851-affe-4690bb75d055"},{"$":0,"Item":"15cf771f-22b1-4796-8e34-6c16f35d6506"}],"id":{"$":0,"Item":"ef053bdf-997b-49c8-a401-1611a568bd8a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"RemotingDll","content":"#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.DesignTime.dll\"\n\n#define WEBSHARPER\n//#define FSS_SERVER\n\nopen System\nopen System.Net\nopen System.Text\nopen System.IO\nopen WebSharper\n//open WebSharper.Remoting\n//open WebSharper.JavaScript\n\n//#if FSS_SERVER\nlet sendRequestRpcEP     = \"RemotingDll:FSSGlobal.UsefulDotNet.sendRequest:-426626804\"\nlet awaitRequestForRpcEP = \"RemotingDll:FSSGlobal.UsefulDotNet.awaitRequestFor:-439983525\"\nlet replyToRpcEP         = \"RemotingDll:FSSGlobal.UsefulDotNet.replyTo:-1092841374\"\n//#else\n//let sendRequestRpcEP     = \"Remote:CIPHERPrototype.Messaging.sendRequest:1096816393\"\n//let awaitRequestForRpcEP = \"Remote:CIPHERPrototype.Messaging.awaitRequestFor:278590570\"\n//let replyToRpcEP         = \"Remote:CIPHERPrototype.Messaging.replyTo:-1092841374\"\n//#endif\n\n\n#if WEBSHARPER\n[< JavaScript >]\n#endif\nmodule Messaging =\n    let mutable Debug = true\n    \n    type AddressId = AddressId of string\n    \n    type Request = {\n        toId              : AddressId\n        fromId            : AddressId\n        content           : string\n        mutable messageId : Guid option\n    }\n    \n    type MBMessage =\n    | Listener of AddressId * (Request->unit) * (exn->unit) * (OperationCanceledException->unit)\n    | Request  of Request   * (string ->unit) * (exn->unit) * (OperationCanceledException->unit)\n    | Reply    of Guid      *  string\n    \n    type POMessage =\n    | POIdentification\n    | POEcho   of string\n    | POListeners\n    | POPendingRequests\n    | POPendingReplys\n    \n    type POResponse =\n    | POString  of string\n    | POStrings of string[]\n\nopen Messaging\n\nlet extract n (s:string) = s.Substring(0, min n s.Length)\nlet now() = System.DateTime.UtcNow.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n\ntype PostOffice() =\n    let mutable listeners = [| |]\n    let mutable requests  = [| |]\n    let mutable sent      = [| |]\n    let agent = MailboxProcessor.Start(fun mail ->\n        async {\n            while true do\n                let! mbMsg = mail.Receive()\n                match mbMsg with\n                | Listener                  (listener, lfs, lfe, lfc)  ->\n                    if Messaging.Debug then printfn \"%s Listener:   %A\"       (now()) listener\n                    requests\n                    |> Seq.indexed\n                    |> Seq.tryPick (fun (i, (request , rfs, rfe, rfc)) -> \n                        if request.toId <> listener then None else\n                        requests <- Array.append requests .[0..i-1]  requests .[i+1..requests .Length - 1]\n                        if Messaging.Debug then printfn \"removed %d\" requests.Length\n                        Some(lfs, request, rfs))\n                    |> (fun v -> (if v.IsNone then \n                                    listeners <- \n                                        listeners \n                                        |> Array.filter(fun (lnr, lfs, exn, cen) -> \n                                            if lnr = listener then\n                                                //exn <| DivideByZeroException ()\n                                                //exn <| TimeoutException ()\n                                                lfs <| {\n                                                            toId      = AddressId \"\"\n                                                            fromId    = AddressId \"\"\n                                                            content   = \"{\\\"$\\\":0}\"\n                                                            messageId = None\n                                                        }\n                                                false\n                                            else true) \n                                        |> Array.append [| listener, lfs, lfe, lfc |]); v)\n                | Request                     (request , rfs, rfe, rfc)  ->\n                    if Messaging.Debug then printfn \"%s Request: %A %A %A\" (now()) request.toId request.fromId (extract 80 request.content)\n                    listeners\n                    |> Seq.indexed\n                    |> Seq.tryPick (fun (i, (listener, lfs, lfe, lfc)) -> \n                        if request.toId <> listener then None else \n                        listeners <- Array.append listeners.[0..i-1] listeners.[i+1..listeners.Length - 1]\n                        Some(lfs, request, rfs))\n                    |> (fun v -> if v.IsNone then requests  <- requests  |> Array.append <| [| request , rfs, rfe, rfc |]\n                                                  if Messaging.Debug then printfn \"appended %d\" requests.Length\n                                 v)\n                | Reply                       (reply   , response)  ->\n                    if Messaging.Debug then printfn \"%s Reply:   %s\"       (now()) (extract 100 response)\n                    sent\n                    |> Seq.indexed\n                    |> Seq.pick (fun (i, (request , rfs)) -> \n                        if request.messageId.Value <> reply then None else\n                        sent      <- Array.append sent     .[0..i-1] sent     .[i+1..sent     .Length - 1]\n                        rfs response\n                        Some ())\n                    None\n                |> Option.iter (fun (lfs, request, rfs) -> \n                    request.messageId <- Some <| Guid.NewGuid()\n                    sent <- sent |> Array.append [| request, rfs |]\n                    lfs request\n                )\n        }\n    )\n    with\n        member this.AwaitRequest    listener  fs fe fc = agent.Post <| Listener (listener, fs, fe, fc)\n        member this.SendRequest     request   fs fe fc = agent.Post <| Request  (request , fs, fe, fc) ; if Messaging.Debug then printfn \"SendRequest sent\"\n        member this.ReplyTo         request   response = agent.Post <| Reply    (request , response  )\n        member this.Listeners       ()                 = listeners |> Array.map (function | AddressId id, _, _, _ -> id)\n        member this.Requests        ()                 = requests  |> Array.map (sprintf \"%A\")\n        member this.Sent            ()                 = sent      |> Array.map (sprintf \"%A\")\n\nlet postOffice = PostOffice()\n\n[< Rpc >]\nlet awaitRequestFor (listener:AddressId) =\n    let startAsync (fs, fe, fc) = postOffice.AwaitRequest listener fs fe fc \n    Async.FromContinuations startAsync // ISSUE: fe & fc are never called even when there are exceptions\n\n[< Rpc >]\nlet replyTo    (reply:Guid) response =\n    async {\n        postOffice.ReplyTo reply response\n    }\n\nopen FSharp.Data\nopen FSharp.Data.JsonExtensions\n\n[< Rpc >]\nlet sendRequest  toId fromId content =\n    if toId = AddressId \"WebServer:PostOffice\" then\n        async {\n            let msg = Json.Deserialize<POMessage> content\n            return\n                match msg with\n                | POIdentification  -> POString     \"WebServer:PostOffice\"\n                | POEcho        txt -> POString     txt\n                | POListeners       -> POStrings <| postOffice.Listeners()\n                | POPendingRequests -> POStrings <| postOffice.Requests ()\n                | POPendingReplys   -> POStrings <| postOffice.Sent     ()\n                |> Json.Serialize \n        }\n    else\n    let startAsync (fs, fe, fc) = postOffice.SendRequest   \n                                    { toId      = toId   \n                                      fromId    = fromId \n                                      content   = content \n                                      messageId = None }\n                                    fs fe fc\n    async {\n        try \n            let! res = Async.FromContinuations startAsync // ISSUE: fe & fc are never called even when there are exceptions like timeout (this crashes FSharpStation!)\n            return res\n        with e -> \n            printfn \"%A\" e\n            return \"ERROR: exception\"\n    }\n\nlet RpcCall (url:string) method (data:string) =\n    async {\n        //printfn \"RpcCall %s\" (extract 100 data)\n        let req = WebRequest.Create(url) :?> HttpWebRequest \n        req.Timeout         <- 300_000\n        req.ProtocolVersion <- HttpVersion.Version10\n        req.Method          <- \"POST\"\n        req.ContentType     <- \"application/json\"\n        req.Headers.Add(\"x-websharper-rpc\", method            )\n        let postBytes = Encoding.ASCII.GetBytes(data)\n        req.ContentLength <- int64 postBytes.Length\n        let reqStream = req.GetRequestStream() \n        reqStream.Write(postBytes, 0, postBytes.Length);\n        reqStream.Close()\n        \n        // Obtain response and download the resulting page \n        // (The sample contains the first & last name from POST data)\n        use resp   = req.GetResponse() \n        use stream = resp.GetResponseStream() \n        use reader = new StreamReader(stream)\n        let msg    = reader.ReadToEnd()\n        //printfn \"RpcCallResponse %s\" (extract 100 msg)\n        let json   = JsonValue.Parse (if msg.[0] = '\"' then \"{\\\"$DATA\\\":\" + msg + \"}\" else msg)\n        return       json.[\"$DATA\"]\n    }\n\nlet serializeAddressId aId =\n    match aId with\n    | AddressId v -> sprintf \"\"\"{\"$\":0,\"$0\":\"%s\"}\"\"\" v\n\nlet sendRequestRpc (toId: AddressId) (fromId: AddressId) (content: string): Async<string> =\n    async {\n        let! msg =\n            [| serializeAddressId toId ; serializeAddressId fromId ; Json.Serialize content |]\n            |> String.concat \", \"\n            |> sprintf \"[%s]\"\n            |> RpcCall WebSharper.Remoting.EndPoint sendRequestRpcEP\n        return msg.AsString()\n    }\n\nlet awaitRequestForRpc (listener:AddressId) =\n    async {\n        let! msg =\n            [| serializeAddressId listener |]\n            |> String.concat \", \"\n            |> sprintf \"[%s]\"\n            |> RpcCall WebSharper.Remoting.EndPoint awaitRequestForRpcEP\n        let  v = msg.[\"$V\"]\n        let req    =\n            {\n                toId      = AddressId <| v?toId  .[\"$V\"].[\"$0\"].AsString()\n                fromId    = AddressId <| v?fromId.[\"$V\"].[\"$0\"].AsString()\n                content   = v?content                          .AsString()\n                messageId = Some <| v?messageId  .[\"$V\"].[\"$0\"].AsGuid  ()\n            }\n        return req\n    }\n\nlet replyToRpc (reply:Guid) response =\n    async {\n        let! msg =\n            [| sprintf \"\\\"%s\\\"\" <| reply.ToString() ; Json.Serialize response |]\n            |> String.concat \", \"\n            |> sprintf \"[%s]\"\n            |> RpcCall WebSharper.Remoting.EndPoint replyToRpcEP\n        return ()\n    }\n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"82ab58ca-79e8-47f9-8917-f444d3320751"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Ping","content":"open Useful\nopen System.Net.NetworkInformation\n\nlet ping (ip:string) =\n    let reply = (new Ping()).Send ip\n    reply.Status, reply.Address, reply.RoundtripTime\n    \nlet pingAsync (ip:string) =\n    async {\n        let pinger = new Ping()\n        try\n            let! reply = pinger.SendPingAsync(ip, 9000, \"Hello!\"B) |> Async.AwaitTask \n            return reply.Status.ToString(), reply.Address, reply.RoundtripTime, System.Text.Encoding.ASCII.GetString reply.Buffer\n        with e -> \n            return e.GetBaseException().GetBaseException().Message, System.Net.IPAddress(0L), 0L, \"\"\n    }\n\nlet pingOneAsync name ip =\n    async {\n        let! status, address, roundtripTime, buffer = pingAsync ip\n        return status, (name, ip), (address, roundtripTime, buffer)\n    }\n\nlet pingSeveral list = \n    list\n    |> Seq.sort\n    |> Seq.map (fun (n, ip) -> pingOneAsync n ip)\n    |> Seq.map (Async.map \n                   (function \n                    | \"Success\", (name, ip), (address, time, buffer) -> printfn \"Success %-15s %-15s %-25s %4d %s \"     name ip (address.ToString()) time buffer\n                    | msg      , (name, ip), (address, time, buffer) -> printfn \"%-15s %-15s %-15s %-25s \"  msg name ip (address.ToString())                 \n             ))\n    |> Async.Parallel \n    |> Async.RunSynchronously\n\n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"7a655466-e218-4121-a7b6-f9c70a922e07"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"bc75b72d-7942-4ac8-a71f-fc290321b875"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"ADB Android Debugger","content":"let removeBlankLines (s:string) = \n    s.Split '\\n'\n    |> Seq.filter ((<>) \"\")\n    |> String.concat \"\\n\"\n\nmodule Adb =\n    let mutable path          = @\"C:\\Program Files (x86)\\Android\\android-sdk\\platform-tools\\adb.exe\"    \n    let call command          = RunProcess.runToFinish     path command  |> removeBlankLines\n    let execOut      file cmd = RunProcess.runOutputToFile path <| sprintf \"exec-out %s\" cmd <| file\n    let connectIpPort ip port = call   <| sprintf \"connect %s:%d\" ip  port        \n    let connectIp     ip      = connectIpPort                         ip  5555        \n    let connectUSB         () = call    \"usb\"\n    let devices            () = call  \"devices\"\n    let pull      rfile lfile = call  <| sprintf \"pull \\\"%s\\\" \\\"%s\\\"\" rfile lfile\n    let shell             cmd = call  <| sprintf \"shell %s\"           cmd\n    let shellSU           cmd = shell <| sprintf \"su -c %s\"           cmd\n    let keyevent          key = shell <| sprintf \"input keyevent %d\"  key\n    let runApp            app = shell <| sprintf \"monkey -p %s 1\"     app            \n    let checkApp          app = shell <| sprintf \"ps | grep %s\"       app            \n    let ls                dir = shell <| sprintf \"ls -la %s\"          dir\n    let version            () = call    \"version\"\n    let reboot             () = call    \"reboot\"\n    let rebootByCmd        () = shellSU \"am start -a android.intent.action.REBOOT\"\n    let killServer         () = call    \"kill-server\"\n    let connectWifi        ip = printfn \"Connecting ADB via Wifi: \"; connectIp ip\n    let connectUSBMsg      () = printfn \"Connecting ADB via USB: \" ; connectUSB()\n    let runCheckApp     app   =\n        runApp          app |> ignore\n        let ps        = app |> checkApp\n        if  ps.Contains app \n        then \"IS RUNNING!!\"\n        else \"is not running at the moment.\"\n        |> printfn \"%s %s\" app\n    \n    let captureScreen local file =\n        shell <| \"screencap -p \" + local |> ignore\n        pull  local  file                |> ignore\n        //adb.Call <| sprintf \"exec-out screencap -p > \\\"%s\\\"\" file\n    \n    let captureScreen2 file = execOut file \"screencap -p\" \n    \n    let activateWifi () =\n        killServer  ()                                                           |> ignore\n        connectUSB  ()                                                           |> ignore\n        shellSU     \"setprop service.adb.tcp.port 5555 ; stop adbd ; start adbd\" |> ignore\n        killServer  ()                                                           |> ignore\n    \n    ","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"}],"id":{"$":0,"Item":"bff6817d-fe67-4777-9a13-50393e8900c4"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"SSH.NET","content":"#r \"../packages/SSH.NET/lib/net40/Renci.SshNet.dll\"\nopen Useful\nopen Renci.SshNet\n\nlet getClient    ip (port:int) user (pwd    : string        ) = new SshClient(ip, port, user, pwd    )\nlet getClientRsa ip (port:int) user (keyfile: PrivateKeyFile) = new SshClient(ip, port, user, keyfile)\n\nlet doCmdW (client:SshClient) f cmd =\n    Wrap.wrapper {\n        do! Result.tryProtection()\n        if not client.IsConnected then\n            client.Connect()\n        use cmnd  = client.CreateCommand cmd\n        let! res   = Async.FromBeginEnd(cmnd.BeginExecute, cmnd.EndExecute)\n        let! res =\n            match res, cmnd.Error with\n            | \"\"  , \"\"   -> Result.succeed \"\"\n            | \"\"  , err  -> Result.fail               <| ErrSimple(err, false)\n            | res , \"\"   -> Result.succeed        res\n            | res , err  -> Result.succeedWithMsg res <| ErrSimple(err, false)\n        return f res\n    }\n    \nlet doCmdF client f =\n    doCmdW client f\n    >> Wrap.runSynchronouslyS false\n    >> printfn \"%s\"    \n    \nlet doCmd client = doCmdF client id\n    ","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"555306ec-f8cc-455f-b01f-9d86fbb2682d"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FsStationShared","content":"#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule FsStationShared =\n","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"MessagingClient","content":"//#define FSS_SERVER\n\n//#if FSS_SERVER\nopen FSSGlobal.UsefulDotNet\nopen FSSGlobal.UsefulDotNet.Messaging\n#r @\"Compiled\\RemotingDll\\RemotingDll.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.DesignTime.dll\"\n//#else\n\n//#r \"remote.dll\"\n//open CIPHERPrototype.Messaging\n//#endif\nopen WebSharper\nopen Useful\n//open UsefulFewJS\n//open UsefulFewJS.Messaging\n\n#if WEBSHARPER\n[< Inline \"true\" >]\n#endif          \nlet inJavaScript = false\n\nlet selectF fj fn =\n    match inJavaScript with\n    | true  -> fj\n    | false -> fn\n    \n#if WEBSHARPER\nlet AsyncStart asy     = Async.StartWithContinuations(asy, id, (fun e -> JS.Alert(e.ToString()) ), fun c -> JS.Alert(c.ToString()))    \n[< Inline \"\" >]\nlet awaitRequestForRpc = awaitRequestForRpc\n[< Inline \"\" >]\nlet sendRequestRpc     = sendRequestRpc\n[< Inline \"\" >]\nlet replyToRpc         = replyToRpc\n#else\nlet AsyncStart asy     = Async.Start asy\n#endif          \n\nlet AddressId        = AddressId\nlet addressIdTxt     = function | AddressId txt -> txt\n\n#if FSS_SERVER\nlet awaitRequestForF = selectF awaitRequestFor awaitRequestFor\nlet sendRequestF     = selectF sendRequest         sendRequest\nlet replyToF         = selectF replyTo                 replyTo\n#else\nlet awaitRequestForF = selectF awaitRequestFor awaitRequestForRpc\nlet sendRequestF     = selectF sendRequest         sendRequestRpc\nlet replyToF         = selectF replyTo                 replyToRpc\n#endif\nlet AsyncStartF      = selectF AsyncStart             Async.Start\n\n[< Inline \"WebSharper.Remoting.EndPoint()\" >]\nlet getEndPoint() = \"##FSHARPSTATION_ENDPOINT##\"\n\ntype MessagingClientx(clientId, ?timeout, ?endPoint:string) =\n    //do printfn \"%s %s\" WebSharper.Remoting.EndPoint clientId\n    let mutable active = true\n    let wsEndPoint     = endPoint    |> Option.defaultValue (getEndPoint())\n    let tout           = timeout     |> Option.defaultValue 100_000\n    let fromId         = AddressId clientId\n    do WebSharper.Remoting.EndPoint <- wsEndPoint \n    let awaitMessage respond =\n        async {\n            while active do\n                printfn \"%s awaitRequest %s %s\" (nowStamp()) clientId wsEndPoint\n                let! msgA  = Async.StartChild(awaitRequestForF fromId, tout)\n                try\n                    let! msg   = msgA\n                    let! resp  = respond (addressIdTxt msg.fromId) msg.content\n                    do!          replyToF msg.messageId.Value resp\n                with \n                | :? System.TimeoutException -> ()\n                | e                          -> printfn \"%A\" e\n        } \n        |> AsyncStartF\n    let sendMessage  toId msg = sendRequestF toId fromId msg\n    let poMsg checkResponse msg =\n        async {\n            let! resp = sendMessage (AddressId \"WebServer:PostOffice\") (Json.Serialize<POMessage> msg)\n            return checkResponse (Json.Deserialize<POResponse> resp)\n        }\n    let poString resp =\n                match resp with\n                | POString  v  -> v\n                | POStrings vs -> sprintf \"%A\" vs\n    let poStrings resp =\n                match resp with\n                | POString  v  -> [| sprintf \"unexpected response: %s\" v |]\n                | POStrings vs -> vs     \n    [<Inline>] \n    let respondMessageG respond fromId txt =\n        async {\n            printfn \"respondMessageG txt: %s\" txt\n            let  msg = Json.Deserialize txt \n            printfn \"respondMessageG msg: %A\" msg\n            let! res = respond fromId msg\n            return Json.Serialize res\n        }                \n    [<Inline>] \n    let sendMessageG toId msg =\n        async {\n            let! resp = sendMessage toId (Json.Serialize msg)\n            let  acr  = resp |> Json.Deserialize\n            return acr\n        }\n  with \n    member this.AwaitMessage  respond  = awaitMessage (fun senderId request -> async { return respond senderId request })\n    member this.AwaitMessage  respondA = awaitMessage respondA\n    member this.SendMessage  toId msg  = sendMessage  toId msg\n    [<Inline>] \n    member this.AwaitMessageG respondA = awaitMessage (respondMessageG respondA)\n    [<Inline>] \n    member this.SendMessageG toId msg  = sendMessageG toId msg\n    member this.POMessage        msg   = poMsg id          msg\n    member this.POListeners      ()    = poMsg poStrings   POListeners\n    member this.EndPoint               = wsEndPoint\n    member this.ClientId               = clientId\n    member this.Deactivate       ()    = active <- false\n    static member EndPoint_            = getEndPoint()\n    interface System.IDisposable with\n           member this.Dispose () = active <- false\n\ntype GenSeverity =\n    | GenError\n    | GenWarning\n    | GenInfor\n\ntype GenResponse =\n    | StringResponse   of string\n    | OpStringResponse of string option\n    | ResultResponse   of string option * (string * GenSeverity)[]\n\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"7a655466-e218-4121-a7b6-f9c70a922e07"}],"id":{"$":0,"Item":"eb54ba64-3d11-4347-97c8-aeae9e3e3121"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CodeSnippet","content":"open Useful\n\nlet snippetName name (content: string) =\n    if name <> \"\" then name else \n    content.Split([| '\\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n    |> Seq.map    (fun l -> l.Trim())\n    |> Seq.filter (fun l -> not (l.StartsWith(\"#\") || l.StartsWith(\"[<\") || l.StartsWith(\"//\")))\n    |> Seq.tryHead\n    |> Option.defaultValue \"<empty>\"\n\nlet sanitize n =\n    let illegal = [|'\"'   ; '<'   ; '>'   ; '|'   ; '\\000'; '\\001'; '\\002'; '\\003'; '\\004'; '\\005'; '\\006';\n                    '\\007'; '\\b'  ; '\\009'; '\\010'; '\\011'; '\\012'; '\\013'; '\\014'; '\\015';\n                    '\\016'; '\\017'; '\\018'; '\\019'; '\\020'; '\\021'; '\\022'; '\\023'; '\\024';\n                    '\\025'; '\\026'; '\\027'; '\\028'; '\\029'; '\\030'; '\\031'; ':'   ; '*'   ; '?';\n                    '\\\\'  ; '/'|] //\"\n    n |> String.filter (fun c -> not <| Array.contains c illegal)\n\ntype CodeSnippetId = CodeSnippetId of System.Guid   \nwith static member New = CodeSnippetId <| System.Guid.NewGuid()\n     member this.Text  = match this with CodeSnippetId guid -> guid.ToString()\n\n[< NoComparison >]\ntype CodeSnippet = {\n    name         : string\n    content      : string\n    parent       : CodeSnippetId option\n    predecessors : CodeSnippetId list\n    id           : CodeSnippetId\n    expanded     : bool\n    level        : int\n    levelCode    : int\n    properties   : System.Collections.Generic.Dictionary<string, string>\n} with\n    member this.Name = snippetName this.name this.content\n    member this.NameSanitized =\n        this.Name\n        |> sanitize\n        |> (fun c -> this.id.Text + \" \" + c + \".fsx\")\n//    member this.ContentIndented addLinePrepos =\n//        let indent        = this.levelCode * 2\n//        let indentF, prfx = if indent = 0         then (id, \"\") else (Array.map    (fun (l, pr) -> String.replicate indent \" \" + l, pr), sprintf\"(%d)\" indent)\n//        let addLinePs     = if not addLinePrepos  then  id      else  Array.append [| sprintf \"# 1 @\\\"%s%s\\\"\" prfx this.NameSanitized |] \n//        this.content.Split('\\n') \n//        |> addLinePs\n//        |> separatePrepros (not addLinePrepos)\n//        |> indentF\n//      , indent\n\n// tail recursion does not optimize\nlet rec preds fetcher outs (ins : CodeSnippetId list) : CodeSnippetId list =\n    match ins with\n    | []         -> outs\n    | hd :: rest -> List.collect id [ rest ; hd |> fetcher |> Option.toList |> List.collect (fun s -> s.parent |> Option.toList |> List.append <| s.predecessors) ]\n                    |> preds fetcher (if outs |> Seq.contains hd then outs else hd::outs)\n\nlet predsL fetcher (ins : CodeSnippetId list) : CodeSnippetId list =\n    let mutable ins  = ins \n    let mutable outs = []\n    while not ins.IsEmpty do\n        match ins with\n        | []         -> ()\n        | hd :: rest -> if outs |> Seq.contains hd then\n                            ins  <- rest\n                        else\n                            ins  <- List.collect id [ rest ; hd |> fetcher |> Option.toList |> List.collect (fun s -> s.parent |> Option.toList |> List.append <| s.predecessors) ]\n                            outs <- hd::outs\n    outs\n\ntype CodeSnippet with\n    member this.UniquePredecessors (fetcher: CodeSnippetId -> CodeSnippet option) = predsL fetcher [ this.id ]        \n    static member TryFindByKey  snps key = snps |> Seq.tryFind (fun snp        -> snp.id = key)\n    member this.SeparateCode addLinePrepos =\n        let noLinePre     = not addLinePrepos || this.properties.ContainsKey \"NoLinePre\"\n        let indent        = this.levelCode * 2\n        let indentF, prfx = if indent = 0         then (id, \"\") else (Array.map    (fun (l, pr) -> String.replicate indent \" \" + l, pr), sprintf\"(%d)\" indent)\n        let addLinePs     = if noLinePre          then  id      else  Array.append [| sprintf \"# 1 @\\\"%s%s\\\"\" prfx this.NameSanitized |]\n        let code, assembs, defines, prepIs, nowarns  =\n            this.content.Split('\\n') \n            |> addLinePs\n            |> separatePrepros (not addLinePrepos)\n            |> indentF\n            |> separateDirectives\n        [| this.NameSanitized, code.Length, indent |] , code, assembs, defines, prepIs, nowarns\n    static member AddSeps (lines1:(string*int*int)[], code1:string[], assembs1:string[], defines1:string[], prepIs1:string[], nowarns1:string[])\n                          (lines2:(string*int*int)[], code2:string[], assembs2:string[], defines2:string[], prepIs2:string[], nowarns2:string[]) =\n        Array.append lines1   lines2\n      , Array.append code1    code2\n      , Seq  .append assembs1 assembs2 |> Seq.distinct |> Seq.toArray\n      , Seq  .append defines1 defines2 |> Seq.distinct |> Seq.toArray\n      , Seq  .append prepIs1  prepIs2  |> Seq.distinct |> Seq.toArray\n      , Seq  .append nowarns1 nowarns2 |> Seq.distinct |> Seq.toArray\n    static member ReducedCode  addLinePrepos (snippets: CodeSnippet seq) =\n        snippets\n        |> Seq.map(fun snp -> snp.SeparateCode addLinePrepos)\n        |> fun snps -> if snps |> Seq.isEmpty then seq [ [||],  [||],  [||],  [||],  [||],  [||] ] else snps\n        |> Seq.reduce CodeSnippet.AddSeps\n        |> fun (lines, code, assembs, defines, prepIs, nowarns) ->\n           (lines, code |> String.concat \"\\n\" |> Array.singleton, assembs, defines, prepIs, nowarns)\n    static member FinishCode addLinePrepos (lines:(string*int*int)[],code:string[], assembs:string[], defines:string[], prepIs:string[], nowarns:string[]) =\n        let config = defines |> Seq.sort |> Seq.map ((+)\"-d:\") |> String.concat \" \"\n        let part1  =\n          [ if config <> \"\" then yield \"////\" + config\n            yield! prepIs  |> Seq.map (sprintf \"#I @\\\"%s\\\"\"    )\n            yield! assembs |> Seq.map (sprintf \"#r @\\\"%s\\\"\"    )\n            if addLinePrepos && (nowarns |> Seq.isEmpty |> not) then yield \"# 1 \\\"required for nowarns to work\\\"\"\n            yield! nowarns |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\")\n          ]\n        Seq.append part1 code |> String.concat \"\\n\"\n      , lines \n        |> Seq.mapFold (fun firstLine (name, len, ind) -> (name, (ind, firstLine, firstLine + len)), firstLine + len) part1.Length\n        |> fst\n        |> Seq.toArray\n    static member CodeAndStarts   addLinePrepos (snippets:CodeSnippet seq) =\n        CodeSnippet.ReducedCode   addLinePrepos snippets\n        |> CodeSnippet.FinishCode addLinePrepos\n    static member CodeFsx         addLinePrepos snps = CodeSnippet.CodeAndStarts addLinePrepos snps |> fst\n//    static member CodeMerged  addLinePrepos (snippets: CodeSnippet seq) =\n//        let bySnippet = \n//            snippets\n//            |> Seq.map(fun snp -> \n//                let code, indent = snp.ContentIndented addLinePrepos\n//                snp, indent, code\n//            )\n//        (bySnippet, bySnippet |> Seq.collect (function _, _, code -> code))\n//    static member CodeParts addLinePrepos snippets =\n//        let bySnippet, merged                        = CodeSnippet.CodeMerged addLinePrepos snippets\n//        let code, assembs, defines, prepIs, nowarns  = separateDirectives merged\n//        let config = defines |> Seq.distinct |> Seq.sort |> Seq.map ((+)\"-d:\")             |> String.concat \" \"\n//        [   if config <> \"\" then yield \"////\" + config\n//            yield! prepIs  |> Seq.distinct             |> Seq.map (sprintf \"#I @\\\"%s\\\"\"    )\n//            yield! assembs |> Seq.distinct             |> Seq.map (sprintf \"#r @\\\"%s\\\"\"    )\n//            if addLinePrepos && (nowarns |> Seq.isEmpty |> not) then yield \"# 1 \\\"required for nowarns to work\\\"\"\n//            yield! nowarns |> Seq.distinct             |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\")\n//        ], code, bySnippet\n//    static member CodeFsx0 addLinePrepos (cur, snippets) =\n//        let part1, part2, bySnippet = CodeSnippet.CodeParts addLinePrepos (Array.append snippets [| cur |])\n//        [ yield! part1 ; yield! part2 ] |> String.concat \"\\n\"\n\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"657c8f34-c917-4659-825d-c9ead206efcf"},{"$":0,"Item":"b59aa3c7-13d9-4f78-98ea-307182bf4bd4"},{"$":0,"Item":"ace1fc12-3dfb-4db8-80c9-5bde1e7d0597"}],"id":{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FSMessage,FSResponse","content":"type FSMessage =\n    | GetIdentification\n    | GenericMessage        of string\n    | GetSnippetContentById of CodeSnippetId\n    | GetSnippetCodeById    of CodeSnippetId\n    | GetSnippetPredsById   of CodeSnippetId\n    | GetSnippetById        of CodeSnippetId\n    | GetSnippetContent     of string []\n    | GetSnippetCode        of string []\n    | GetSnippetPreds       of string []\n    | GetSnippet            of string []\n    | GetSnippetJSCode      of string []\n    | GetWholeFile\n    | RunSnippetUrlJSById   of CodeSnippetId * string\n    | RunSnippetUrlJS       of string []     * string\n    | RunActionCall         of name: string * action: string * parms: string[]\n\ntype FSSeverity =\n    | FSError\n    | FSWarning\n    | FSInfor\n\ntype FSResponse =\n    | IdResponse        of string\n    | StringResponse    of string option\n    | SnippetResponse   of CodeSnippet option\n    | SnippetsResponse  of CodeSnippet []\n    | StringResponseR   of string option * (string * FSSeverity)[]\n\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"}],"id":{"$":0,"Item":"f6ebdffc-049c-4493-8de8-e32072419479"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FsStationClient","content":"\ntype FsStationClientErr =\n    | FSMessage             of string * FSSeverity\n    | ``Snippet Not Found`` of string\nwith interface ErrMsg with\n        member this.ErrMsg    = \n            match this with \n            | FSMessage (msg, sev    )   -> sprintf \"%A %s\" sev msg\n            | msg                        -> sprintf \"%A\"        msg\n        member this.IsWarning =     \n            match this with \n            | FSMessage (_  , FSError)   -> true\n            | msg                        -> false\n\ntype FsStationClient(clientId, ?fsStationId:string, ?timeout, ?endPoint) =\n    let fsIds      = fsStationId |> Option.defaultValue \"##FSHARPSTATION_ID##\"\n    let msgClient  = new MessagingClient(clientId, ?timeout= timeout, ?endPoint= endPoint)\n    let toId       = AddressId fsIds\n    let stringResponseR response =\n        match response with\n        | StringResponseR (Some code, msgs) -> Result.succeedWithMsgs code (msgs |> Seq.map (fun v -> FSMessage v :> ErrMsg) |> Seq.toList)\n        | _                                 -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let stringResponse   response =\n        match response with\n        | StringResponse (Some code)        -> Result.succeed code\n        | _                                 -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let snippetsResponse response =    \n        match response with    \n        | SnippetsResponse snps             -> Result.succeed snps\n        | _                                 -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let snippetResponse  response =    \n        match response with    \n        | SnippetResponse  snp              -> Result.succeed snp\n        | _                                 -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    [< Inline >]\n    let sendMsg toId (msg: FSMessage) (checkResponse: FSResponse -> Result<'a>) =\n        let msgser =  msg |> Json.Serialize\n        let respA  =  msgClient.SendMessage toId msgser\n        Wrap.wrapper {\n            let!   response = respA\n            let!   resp     = checkResponse (Json.Deserialize<FSResponse> response)\n            return resp\n        } \n  with \n    member this.SendMessage     (toId2,  msg:FSMessage) = sendMsg toId2  msg    Result.succeed   \n    member this.SendMessage     (        msg:FSMessage) = sendMsg toId   msg    Result.succeed   \n    member this.RequestSnippet  (    snpPath:string   ) = sendMsg toId  (GetSnippet          (snpPath.Split '/'     ))    snippetResponse  \n    member this.RequestCode     (    snpPath:string   ) = sendMsg toId  (GetSnippetCode      (snpPath.Split '/'     ))    stringResponse   \n    member this.RequestJSCode   (    snpPath:string   ) = sendMsg toId  (GetSnippetJSCode    (snpPath.Split '/'     ))    stringResponseR  \n    member this.RequestPreds    (    snpPath:string   ) = sendMsg toId  (GetSnippetPreds     (snpPath.Split '/'     ))    snippetsResponse \n    member this.RequestPredsById(      snpId          ) = sendMsg toId  (GetSnippetPredsById  snpId                  )    snippetsResponse \n    member this.RequestWholeFile(                     ) = sendMsg toId   GetWholeFile                                     stringResponse   \n    member this.GenericMessage  (        txt:string   ) = sendMsg toId  (GenericMessage       txt                    )    stringResponse   \n    member this.RunSnippet      (url,snpPath:string   ) = sendMsg toId  (RunSnippetUrlJS     (snpPath.Split '/', url))    stringResponseR\n    member this.RunActionCall   (name, act, parms     ) = sendMsg toId  (RunActionCall       (name, act, parms      ))    stringResponseR\n    member this.FSStationId                             = fsIds\n    member this.MessagingClient                         = msgClient    \n    static member FSStationId_                          = \"##FSHARPSTATION_ID##\"\n\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"eb54ba64-3d11-4347-97c8-aeae9e3e3121"},{"$":0,"Item":"f6ebdffc-049c-4493-8de8-e32072419479"}],"id":{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FsStationClient Save Extension","content":"//open CIPHERPrototype.Messaging\nopen Useful\nopen System.IO\n\nlet backupFile file = \n    try File.Delete(      file + \".bak\") ; printfn \"Deleted %s.bak\" file with _ -> ()\n    try File.Copy  (file, file + \".bak\") with _ -> ()\n\ntype FsStationClient with\n    member this.Save(contentW:Wrap<string>, msgBefore, path, file, printMsg) =\n        Wrap.wrapper {\n            printMsg <| sprintf \"%s\" msgBefore\n            let! content = contentW\n            let fullName = Path.Combine(path, file)\n            backupFile fullName\n            File.WriteAllText(fullName, content)\n            printMsg <| sprintf \"Saved %s.\" fullName\n        } |> Wrap.runSynchronouslyS false |> printMsg\n    member this.Save(contentW:Wrap<string>, msgBefore, path, file) = this.Save(contentW, msgBefore, path, file, printfn \"%s\")\n    member this.SaveSnippetJS  path snippet = this.Save(this.RequestJSCode snippet, sprintf \"Compiling %s to JavaScript\" snippet, path, (snippet.Split '/' |> Seq.last) + \".js\" )\n    member this.SaveSnippetFsx path snippet = this.Save(this.RequestCode   snippet, sprintf \"Saving %s to F#\"            snippet, path, (snippet.Split '/' |> Seq.last) + \".fsx\")\n    member this.SaveWholeFile  path name    = this.Save(this.RequestWholeFile()   , sprintf \"Saving to %s.fsjson\"        name   , path, name + \".fsjson\"                        )\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"},{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"}],"id":{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FsStationClient Compile Extension","content":"#r @\"..\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.CompOptionsModule\nopen System.IO\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n\ntype CodeSnippet with\n    static member PrepareCompileOptions (options1: CompOptions) (snps: CodeSnippet seq) =\n        let  addLinePrepos =  options1.Contains \"++removelinedirectives\" |> not\n        let  lines, code, assembs, defines, prepoIs, nowarns = CodeSnippet.ReducedCode addLinePrepos snps\n        let  options2      = prepOptions options1 (code, assembs, defines, prepoIs, nowarns)\n        options2\n\ntype FsStationClient with\n    member this.PrepareCompileOptions(options1) = \n        Wrap.wrapper {\n            let  snpPath   = options1?Snippet\n            let!   preds   = this.RequestPreds snpPath\n            let    options = CodeSnippet.PrepareCompileOptions options1 preds\n            return options\n        }\n    member this.CompileFSharpW(options:CompOptions) = \n        Wrap.wrapper {\n            let! msgs, exit = options.Get CompOptions.FSharpOptions \n                              |> Array.append [| \"IGNORED_Fsc.exe\" |] \n                              |> FSharpChecker.Create().Compile\n            let  errs       = [ yield! msgs |> Array.map fSharpError2TranspilerError\n                                if exit <> 0 && (exit <> 1 || msgs.Length = 0) then yield ErrSimple (sprintf \"ExitCode: %d\" exit, false) :> ErrMsg\n                              ]\n            let! res        = if   exit <> 0\n                              then Result.failWithMsgs                errs\n                              else Result.succeedWithMsgs \"Compiled!\" errs\n            return res\n        }\n    member this.CompileWebSharperW(options:CompOptions) =\n        Wrap.wrapper {\n            if options.Contains opWebSite then\n                let  site     = options?Website\n                if options.Contains \"++createdirectory\"     then Directory.CreateDirectory(site) |> ignore\n            let! res          = options.Get CompOptions.WSharperOptions\n                                 |> Seq.map (sprintf \"%A\")\n                                 |> String.concat \"  \"\n                                 |> fun ops -> (new RunProcess.ShellEx(@\"WsFsc.exe\", ops)).StartAndWaitR()\n            return if res = \"\" then \"Compiled!\" else res\n        }\n    member this.CompileSnippetW options  = \n        Wrap.wrapper {\n            let  snpPath      = options?Snippet\n            let  config       = options?Config\n            let  directory    = options?Directory\n            do   Directory.CreateDirectory(directory) |> ignore\n            let! options2     = this.PrepareCompileOptions options\n            let  compiler     = if options2.Contains \"++websharper:1\" then this.CompileWebSharperW else this.CompileFSharpW\n            let! res          = compiler options2\n            if options2.Contains \"++copyassemblies\" then copyIfMustToDir        \"FSharp.Core.dll\"          directory\n            if options2.Contains \"++copyconfig\"     then copyIfNotExistsToFile  \"FSharpStation.exe.config\" config\n            return res\n        }\n        \n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"9becc68c-9cc2-4f29-82df-e510d10226db"},{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},{"$":0,"Item":"ef053bdf-997b-49c8-a401-1611a568bd8a"},{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},{"$":0,"Item":"15cf771f-22b1-4796-8e34-6c16f35d6506"},{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"},{"$":0,"Item":"ab5ab0ca-eb45-4851-affe-4690bb75d055"}],"id":{"$":0,"Item":"56e5bc09-e528-49cc-9d42-6359b32a0cc9"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"WebSite","content":"#define WEBSHARPER\nopen WebSharper.Sitelets\nopen WebSharper.UI.Next.Server\n\ntype EndPoint = EP\n\nlet content (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n    Content.Page( Html.html [ Html.body [ Html.h1 [ Html.text \"Hello Dolly\" ] ]])\n\nlet site = Application.MultiPage content\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"47912c89-9605-41df-9425-7facea3d6b50"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"SelfHostedServer","content":"#r @\"Owin.dll\"\n#r @\"Microsoft.Owin.dll\"\n#r @\"Microsoft.Owin.Hosting.dll\"\n#r @\"Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"Microsoft.Owin.StaticFiles.dll\"\n#r @\"Microsoft.Owin.FileSystems.dll\"\n#r @\"WebSharper.Owin.dll\"\n\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://localhost\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://*\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"file://\"\nWebSharper.Web.Remoting.DisableCsrfProtection()\n\nmodule SelfHostedServer =\n\n    open global.Owin\n    open Microsoft.Owin.Hosting\n    open Microsoft.Owin.StaticFiles\n    open Microsoft.Owin.FileSystems\n    open WebSharper.Owin\n\n    [<EntryPoint>]\n    let Main args =\n        let rootDirectory, url =\n            match args with\n            | [| rootDirectory; url |] -> rootDirectory, url\n            | [| url                |] -> \"..\"         , url\n            | [|                    |] -> \"..\"         , \"http://localhost:9001/\"\n            | _ -> eprintfn \"Usage: WebServer ROOT_DIRECTORY URL\"; exit 1\n        use server = \n            WebApp.Start(url, fun appB ->\n                appB.UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(rootDirectory)))\n                    .UseWebSharper(WebSharperOptions(ServerRootDirectory = rootDirectory\n                                                   , Sitelet             = Some site\n                                                   , BinDirectory        = \".\"\n                                                   , Debug               = true))\n                |> ignore\n                let listener = appB.Properties.[\"Microsoft.Owin.Host.HttpListener.OwinHttpListener\"] |> unbox<Microsoft.Owin.Host.HttpListener.OwinHttpListener>\n                let maxA = ref 0\n                let maxB = ref 0\n                listener.SetRequestProcessingLimits(1000, 1000)\n                listener.GetRequestProcessingLimits(maxA, maxB)\n                printfn \"Accepts: %d Requests:%d\" !maxA !maxB\n                )\n        stdout.WriteLine(\"Serving {0}\", url)\n        stdin.ReadLine() |> ignore\n        0\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"47912c89-9605-41df-9425-7facea3d6b50"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"2071bfaf-8f65-47a7-98e6-7ec138e9f905"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"WSMessagingBroker","content":"#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule WSMessagingBroker =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"64110b26-2d5c-4b29-a81b-75a5495e67a2"},"expanded":false,"level":0,"levelCode":0,"properties":{}},{"name":"WebSocket Messages","content":"#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n\nopen WebSharper\nopen Useful\n\nlet MessageBrokerId  = \"<MessageBroker>\"\n\ntype Address = Address of address:string\nwith member this.txt = match this with Address txt -> txt\n\nlet MessageBrokerAddress = Address MessageBrokerId\n\n/// Requests made to Message Broker\n[< NamedUnionCases \"type\" >]\ntype BrokerRequest = \n    | BRGetConnections  /// request for list of connections\n\n/// Replies from Message Broker\n[< NamedUnionCases \"type\" >]\ntype BrokerReply = \n    | BRConnections  of string[]\n  //  | BRPleaseClose  \n\n[< NamedUnionCases \"type\" >]\ntype MessageType = \n    | MsgInformation             // does not expect a reply, payload may or may not be structured\n    | MsgRequest                 // expects a reply, structured payload\n    | MsgReply                   // structured payload.\n    | MsgFromBroker              // Payload is BrokerMessage. Only Broker should use this\n    | MsgRequestForId            // expects reply as Information with id\n    | MsgRequestForEcho          // expects reply as Information with same payload\n\n/// Replies from Message Broker\n[< NamedUnionCases \"type\" >]\ntype BrokerMessage = \n    | BMOk\n    | BMOnlyBrokerShouldUse\n    | BMDestinationNotFound of Address  \n    | BMWebSocketError      of string\n    | BMReceiverCantReply\n    | BMUnexpectedMsgType   of MessageType\n\n[< NamedUnionCases \"type\" >]\ntype Replier = \n    | NoReply\n    | Broker\n    | Receiver\n\n[< NamedUnionCases \"type\" >]\ntype MessageGeneric = {\n    from          : Address\n    destination   : Address\n    msgType       : MessageType\n    subtype       : string      // free short string that provides information to deserialize payload\n    id            : System.Guid\n    payload       : string\n    replier       : Replier\n}\n\n[< Inline >]\nlet inline processPayload f (payload:string) : string =\n    if payload = \"\" then Unchecked.defaultof<_> else Json.Deserialize payload\n    |> f\n    |> Json.Serialize\n            \n[<  Inline >]\nlet newMsgSerialized dst payload = {\n    from          = Address \"\"\n    destination   = dst\n    msgType       = MsgRequest\n    subtype       = \"\"\n    id            = System.Guid.NewGuid()\n    payload       = payload\n    replier       = NoReply\n}\n\n[< Inline >]\nlet inline payload        pl  msg = { msg with payload       = Json.Serialize pl }\nlet inline from           frm msg = { msg with from          = frm               }\nlet inline destination    dst msg = { msg with destination   = dst               }\nlet inline msgType        typ msg = { msg with msgType       = typ               }\nlet inline subtype        sub msg = { msg with subtype       = sub               }\nlet inline replier        rpl msg = { msg with replier       = rpl               }\nlet inline msgId          id  msg = { msg with id            = id                }\n\n[<  Inline >]\nlet inline newMsg dst payload = Json.Serialize payload |> newMsgSerialized dst\n\n[<  Inline >]\nlet inline msgPayload msg = Json.Deserialize msg.payload\n\nlet mapPayload f msg = { msg with payload = f msg.payload }\n\nlet inline makeReply msg =\n    msg\n    |> msgType MsgReply\n    |> replier NoReply\n\n[<  Inline >]\nlet inline respond pyld msg =\n    msg\n    |> makeReply\n    |> payload  pyld\n\ntype IServer =\n    abstract member Post  : MessageGeneric -> unit\n    abstract member Close : unit           -> unit\n\ntype CMessage<'C2S> = WebSharper.Owin.WebSocket.Client.Message<'C2S>\n","parent":{"$":0,"Item":"64110b26-2d5c-4b29-a81b-75a5495e67a2"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"b95ef4c5-ca1b-443a-acad-ca8158403d8b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"StatefulAgent","content":"\ntype SMessage<'S2C> = WebSharper.Owin.WebSocket.Server.Message<'S2C>\n\n#if WEBSHARPER\n[< JavaScript false >]\n#endif\nmodule Broker =\n    open WebSharper\n    open WebSharper.Owin.WebSocket.Server\n    open Useful\n    open System.Collections.Generic\n    \n    type SomeState = {\n        info       : string\n    }\n    \n    type IClient =\n        abstract member Post : MessageGeneric -> unit\n        abstract member Ip   : unit           -> string\n        abstract member Id   : unit           -> string\n        abstract member Close: unit           -> unit\n\n    type BrokerAgent(_epWebSocket: WebSharper.Owin.WebSocket.Endpoint<MessageGeneric,MessageGeneric>) =\n#if FSS_SERVER                          \n        static let mutable fssWebSocketO : BrokerAgent option = None\n#endif\n        do printfn \"WebSocket server start\"\n        let mutable connections = Map.empty\n        let processBrokerRequest req = \n            match req with\n            | BRGetConnections -> connections |> Map.toSeq |> Seq.map (fun (Address cl, _) -> cl) |> Seq.toArray |> BRConnections \n            \n        let respondFromBroker pyld msg =\n            msg\n            |> respond     pyld\n            |> msgType     MsgFromBroker\n            |> subtype     \"FromBroker\"\n\n        let post reply msg =\n            match connections |> Map.tryFind msg.destination with\n            | None                      -> msg |> respondFromBroker (BMDestinationNotFound msg.destination) |> reply\n            | Some(_, clientTo:IClient) -> msg |> clientTo.Post\n            \n        let clientConnect (client: IClient) = async {\n            let clientId = client.Id()\n            let uniqueId = System.Guid.NewGuid()\n            printfn \"New Connection from %s\" clientId                           \n            let clientAddress = Address clientId\n            connections\n            |> Seq.filter(fun kp -> kp.Key = clientAddress)\n            |> Seq.iter  (fun (kp:KeyValuePair<_, _ * IClient>) -> \n                printfn \"Closing old connection from %s\" clientId\n                kp.Value \n                |> fun (_, conn) -> conn.Close()\n            )\n            connections <- connections |> Map.add clientAddress (uniqueId, client)\n            \n            let reply msg = msg |> from MessageBrokerAddress |> destination clientAddress |> client.Post\n            let checkReply msg = if msg.replier = Broker then\n                                        msg |> respondFromBroker BMOk |> reply\n            let forward msg = msg |> from clientAddress |> post reply\n                              checkReply msg\n            let respondMsg (msg:MessageGeneric) =\n                checkReply msg\n                printfn \"%A\" msg\n                match msg.msgType with\n                | MsgInformation    -> printfn \"Information from '%s': %s\" msg.from.txt (msgPayload msg)\n                | MsgReply          -> printfn              \"Reply %s: %s\" msg.from.txt  msg.payload\n                | MsgRequest        -> msg |> respond (msgPayload msg  |> processBrokerRequest)  |> reply\n                | MsgRequestForId   -> msg |> respond  MessageBrokerId |> msgType MsgInformation |> reply\n                | MsgRequestForEcho -> msg |> mapPayload id            |> msgType MsgInformation |> reply\n                | MsgFromBroker     -> ()\n            let clientIp = client.Ip()\n            return Unchecked.defaultof<_>, fun state wsmsg -> async {\n                printfn \"Received message %A from %s - %s\" state clientIp clientId\n                match wsmsg with\n                | Message msg ->\n                    if   msg.msgType     = MsgFromBroker        then msg |> respondFromBroker BMOnlyBrokerShouldUse |> reply\n                    elif msg.destination = MessageBrokerAddress then respondMsg msg\n                    else                                             forward    msg     \n                    return state\n                | Error exn -> \n                    printfn \"Error in WebSocket server connected to %s - %s: %s\" clientIp clientId (exn.ToString())\n                    newMsg clientAddress (BMWebSocketError exn.Message) |> msgId System.Guid.Empty |> msgType MsgFromBroker |> msgType MsgFromBroker |> reply\n                    return state\n                | Close ->\n                    printfn \"Closed connection to %s - %s\" clientIp clientId\n                    connections <- connections |> Map.filter (fun _ (uid, _) -> uid <> uniqueId)\n                    return state\n            }\n        }\n        member this.Post msg = post (fun m -> dprintfn \"%s\" m.payload) msg\n        member this.Start (client : WebSocketClient<MessageGeneric,MessageGeneric>) =\n            clientConnect { new IClient with\n                                member this.Post v  = client.Post v\n                                member this.Ip()    = client.Connection.Context.Request.RemoteIpAddress\n                                member this.Id()    = client.Connection.Context.Request.Query \n                                                      |> KeyVal.tryGetValue  \"ClientId\" \n                                                      |> Option.bind         Array.tryHead \n                                                      |> Option.defaultValue \"\"\n                                member this.Close() = client.Connection.Close(System.Net.WebSockets.WebSocketCloseStatus.NormalClosure, null) |> Async.AwaitTask |> Async.Start\n                          }\n#if FSS_SERVER\n        static member FssWebSocketO                = fssWebSocketO\n        static member FssWebSocketO with set value = fssWebSocketO <- value\n        member this.ConnectLocal clientId receiver = \n            clientConnect { new IClient with\n                                member this.Post v  = receiver v \n                                member this.Ip()    = \"(server)\"\n                                member this.Id()    = clientId\n                                member this.Close() = () // probably shouldn't be called at all\n                          }\n\n    let ConnectStatefulFSS uri clientId (f:IServer -> Async<int * (int -> CMessage<MessageGeneric> -> Async<int>)>) =\n        async {\n            match BrokerAgent.FssWebSocketO with \n            | None -> raise (exn \"FssWebSocketO is not set\")\n            | Some serverP ->\n            let  mutable clientBoxO : MailboxProcessor<CMessage<MessageGeneric>> option = None\n            let  receiver msg = clientBoxO |> Option.iter (fun cbox -> cbox.Post (CMessage.Message msg))\n            let! brokerInitState, brokerFunc = serverP.ConnectLocal clientId receiver\n            let  brokerBox   = Mailbox.fold brokerFunc brokerInitState\n            let! clientInitState, clientFunc = f { new IServer with\n                                                       member this.Post msg = brokerBox.Post (Owin.WebSocket.Server.Message msg)\n                                                       member this.Close()  = ()\n                                                 }\n            let  clientBox = Mailbox.fold clientFunc clientInitState\n            clientBoxO <- Some clientBox\n            clientBox.Post CMessage.Open\n        }\n#endif        \n        \n        ","parent":{"$":0,"Item":"64110b26-2d5c-4b29-a81b-75a5495e67a2"},"predecessors":[{"$":0,"Item":"e24d6bc0-703c-4f12-aca8-8158af50b7cd"},{"$":0,"Item":"7a655466-e218-4121-a7b6-f9c70a922e07"},{"$":0,"Item":"b95ef4c5-ca1b-443a-acad-ca8158403d8b"}],"id":{"$":0,"Item":"e137b990-172b-4879-bc74-8650123b7a5d"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"MessagingBroker","content":"#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net45\\Microsoft.Owin.Hosting.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net45\\Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net45\\Microsoft.Owin.StaticFiles.dll\"\n#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net45\\Microsoft.Owin.FileSystems.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net45\\WebSharper.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net45\\HttpMultipartParser.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.Core.JavaScript.dll\"\n\nopen global.Owin\nopen Microsoft.Owin.Hosting\nopen WebSharper.Owin\nopen WebSharper.Owin.WebSocket\nopen WebSharper.UI.Next.Server\n    \n[< EntryPoint >]\nlet Main args =\n    let rootDirectory, url =\n        match args with\n        | [| rootDirectory; url |] -> rootDirectory, url\n        | [| url                |] -> \"website\"    , url\n        | [|                    |] -> \"website\"    , \"http://localhost:9050\"\n        | _ -> eprintfn \"Usage: WebServer3 ROOT_DIRECTORY URL\"; exit 1\n    let epWebSocket = Endpoint.Create(url, \"/ws\", JsonEncoding.Readable)\n    let brokerAgent = Broker.BrokerAgent epWebSocket\n    //printfn \"Starting, hit <Enter>...\" ; stdin.ReadLine() |> ignore\n    use server = \n        WebApp.Start(url, fun appB ->\n            appB.UseWebSharper(WebSharperOptions(ServerRootDirectory = rootDirectory\n                                               , Sitelet             = Some (WebSharper.Application.MultiPage(fun _ _ -> Content.Page []))\n                                               , BinDirectory        = \".\"\n                                               , Debug               = true))\n                .UseWebSocket(epWebSocket, brokerAgent.Start, maxMessageSize = 500000)\n            |> ignore\n        )\n    stdout.WriteLine(\"Serving {0}\", url)\n    stdin.ReadLine() |> ignore\n    0\n    ","parent":{"$":0,"Item":"64110b26-2d5c-4b29-a81b-75a5495e67a2"},"predecessors":[{"$":0,"Item":"e137b990-172b-4879-bc74-8650123b7a5d"}],"id":{"$":0,"Item":"47bcdd6d-e61b-4884-bd1a-c30702c9508c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"ClientWebSocket .Net","content":"//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.Core.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.Core.JavaScript.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.Main.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.Collections.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.InterfaceGenerator.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.JQuery.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.JavaScript.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.Web.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.Sitelets.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.Control.dll\"\n//#r @\"..\\packages\\WebSharper.UI.Next\\lib\\net40\\WebSharper.UI.Next.dll\"\n\nopen System\nopen System.Threading\nopen System.Net.WebSockets\nopen WebSharper\nopen Useful\n\n#if WEBSHARPER\n[< JavaScript false >]\n#endif\nmodule Client =\n    let startStateFull receive f =\n        async {\n            let! initState, func = f\n            let agentBox = Mailbox.fold func initState\n            let finish a = agentBox.Post CMessage.Close ; printfn \"%A\" a\n            let error  a = agentBox.Post CMessage.Error ; finish a\n            Async.StartWithContinuations(receive agentBox, finish, error, error)\n        }\n\n    type WebSocketServer<'S2C, 'C2S>(uri:string) =\n        let conn = new ClientWebSocket()\n        let chunkSize = 8192\n        let send (txt:string)  =\n            async {\n                let buffer = System.Text.Encoding.UTF8.GetBytes txt\n                let chunks = buffer.Length / chunkSize\n                for i = 0 to chunks do\n                    let last = i = chunks\n                    let size = if last then buffer.Length % chunkSize else chunkSize\n                    do! conn.SendAsync(new ArraySegment<byte>(buffer, i * chunkSize, size), WebSocketMessageType.Binary, last, CancellationToken.None) |> Async.AwaitTask\n            }\n        let receive (receiverBox:MailboxProcessor<CMessage<'S2C>>) =\n            let buffer : byte[] = Array.create chunkSize 0uy\n            let builder         = System.Text.StringBuilder()\n            let keepgo          = ref true\n            async {\n                receiverBox.Post CMessage.Open\n                while conn.State = WebSocketState.Open && !keepgo do\n                    let! result = conn.ReceiveAsync(ArraySegment buffer, CancellationToken.None) |> Async.AwaitTask\n                    match result.MessageType with\n                    | WebSocketMessageType.Close -> keepgo := false\n                    | WebSocketMessageType.Text ->\n                        let txt = System.Text.Encoding.UTF8.GetString buffer.[0..result.Count - 1]\n                        builder.Append txt |> ignore\n                        if result.EndOfMessage then\n                            let txt = builder.ToString()\n                            builder.Clear() |> ignore\n                            Json.Deserialize txt |> CMessage.Message |> receiverBox.Post\n                    | _ -> ()\n                return \"WebSocketServer receive Closed.\"\n            }\n        let brokerBox = Mailbox.iter (Json.Serialize >> send)\n        let connect f =\n            async {\n                dprintfn \"Connecting %s\" uri\n                do! conn.ConnectAsync(new Uri(uri), CancellationToken.None) |> Async.AwaitTask\n                dprintfn \"Connected %A\" WebSocketState.Open\n                do! startStateFull receive f\n            }\n        member this.WebSocket        = conn\n        member this.Post (msg: 'C2S) = brokerBox.Post msg\n        member this.Connect          = connect\n\n    let ConnectStateful<'S2C, 'C2S> uri agent =\n        async {\n            let  server          = WebSocketServer uri\n            do!  server.Connect (agent server)\n            return server\n        }\n\n    let ConnectStatefulFS uri clientId (f:IServer -> _) =\n        let uri2 = sprintf \"ws://%s?ClientId=%s\" uri clientId\n        let func (serverP:WebSocketServer<MessageGeneric,MessageGeneric>) =\n            f { new IServer with\n                  member this.Post  v = serverP.Post v\n                  member this.Close() = serverP.WebSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, null, CancellationToken.None) \n                                        |> Async.AwaitTask |> Async.RunSynchronously            \n               }\n        ConnectStateful uri2 func\n        |> Async.map ignore\n        ","parent":{"$":0,"Item":"64110b26-2d5c-4b29-a81b-75a5495e67a2"},"predecessors":[{"$":0,"Item":"b95ef4c5-ca1b-443a-acad-ca8158403d8b"},{"$":0,"Item":"e24d6bc0-703c-4f12-aca8-8158af50b7cd"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"aa485846-7b78-4ca8-ae22-84ba0c42d962"}],"id":{"$":0,"Item":"9c253bae-ab8b-4c99-b7e5-38fc50756bec"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"WSMessagingClient","content":"#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n\nopen System\nopen Useful\nopen WebSharper.Owin.WebSocket\nopen WebSharper.Owin.WebSocket.Client\n\n//#define FSS_SERVER\n//#define WEBSHARPER\n\ntype  Server = WebSocketServer<MessageGeneric,MessageGeneric>\n\ntype ClientTypeFSharp    = FSharp\n#if WEBSHARPER\ntype ClientTypeFSStation = FSStation\ntype ClientTypeJScript   = JScript\n\n[< Inline >]\nlet ConnectStatefulJS uri clientId (f:IServer -> Async<'state * ('state -> CMessage<MessageGeneric> -> Async<'state>)>) =\n    let uri2 = sprintf \"ws://%s?ClientId=%s\" uri clientId\n    let func (serverP:WebSocketServer<MessageGeneric,MessageGeneric>) =\n        f { new IServer with\n              member this.Post  v = serverP.Post v\n              member this.Close() = serverP.Connection.Close 1000 // Normal Closure\n           }\n    let  endPoint = Endpoint.CreateRemote(uri2, JsonEncoding.Readable)\n    ConnectStateful endPoint func\n    |> Async.map ignore\n#endif\n\ntype ErrBroker(bm : BrokerMessage) =\n    interface ErrMsg with\n        member this.ErrMsg   : string = sprintf \"%A\" bm\n        member this.IsWarning: bool   = false\n\ntype WaitForReplyMsg =\n    | Add    of Guid * ((MessageGeneric -> unit) * (exn -> unit) * (OperationCanceledException -> unit))\n    | Reply  of Guid *   MessageGeneric\n    | Excpn  of Guid * (unit -> exn)\n    | Cancel of Guid * (unit -> OperationCanceledException)\n    \nlet waitingAgent defProc =    \n    Mailbox.fold (fun waitingForReply action ->\n        async {\n            match action with\n            | Add   (_ky, _fn) -> ()\n            | Reply (key, msg) -> waitingForReply |> Map.tryFind key |> Option.map  (fun (f,_,_) -> f  msg   ) \n                                  |> Option.defaultWith (fun () -> defProc msg)\n            | Excpn (key, exn) -> waitingForReply |> Map.tryFind key |> Option.iter (fun (_,f,_) -> f (exn()))\n            | Cancel(key, cnl) -> waitingForReply |> Map.tryFind key |> Option.iter (fun (_,_,f) -> f (cnl()))\n            return\n                match action with\n                | Reply (key, _  )\n                | Excpn (key, _  )\n                | Cancel(key, _  ) -> waitingForReply |> Map.remove key\n                | Add   (key, fns) -> waitingForReply |> Map.add    key fns\n        }\n    ) Map.empty\n\n[< Inline \"window.location.href\" >]\nlet getEndPoint() = \n#if FSS_SERVER\n    \"No Endpoint required, should use WSMessagingClient with FSStation parameter not FSharp\"\n#else\n    \"##FSHARPSTATION_ENDPOINT##\"\n#endif\n\nlet extractEndPoint() = \n    let ep : string = getEndPoint()\n    let ep2 = ep.Substring(ep.IndexOf \"//\" + 2)\n    ep2.Split('/').[0]\n\ntype WSMessagingClient(connectStateful: string -> string -> (IServer -> Async<int * (int -> CMessage<MessageGeneric> -> Async<int>)>) -> Async<unit>\n        , clientId:string, ?timeout:int, ?endPoint:string) =    \n    let wsEndPoint    = defaultArg endPoint (extractEndPoint() + \"/ws\")\n    let clientAddress = Address clientId\n    let wsTimeout     = defaultArg timeout 60000\n\n    let mutable out = printfn \"%s\"\n    //let printoutfn out     = 0 // just to catch printoutfn out that should not be around \n    let mutable serverO : IServer option = None\n    let mutable payloadProcessorO : (string -> Wrap<string>) option = None\n    let waiting = waitingAgent (fun msg -> printoutfn out \"Reply from '%s': %s\" msg.from.txt msg.payload)\n\n    let reply msg = serverO |> Option.iter (fun server -> msg |> from clientAddress |> destination msg.from |> server.Post)\n    let close ()  = serverO |> Option.iter (fun server -> server.Close() ; serverO <- None                                )\n\n    let processReply      msg = waiting.Post (Reply(msg.id,msg))\n    let mapPayloadWrap (fW: _ -> Wrap<_> ) msg =\n        Wrap.wrap {\n            let! r = fW msg.payload\n            return msg |> mapPayload (fun _ -> r)\n        }\n    let processMessage msg =\n        dprintfn \"%A\" msg\n        match msg.msgType with\n        | MsgFromBroker     \n        | MsgReply          -> processReply msg\n        | MsgInformation    -> printoutfn out \"Information from '%s': %s\" msg.from.txt (msgPayload msg)\n        | MsgRequest        -> match payloadProcessorO with \n                               | None           -> if msg.replier = Receiver then () // requires a reply but cannot give one, ask broker to handle it\n                               | Some processor ->\n                               msg |> mapPayloadWrap processor |> Wrap.map  (makeReply >> reply) |> Wrap<unit>.Start\n        | MsgRequestForEcho -> msg |> mapPayload     id        |> msgType MsgInformation |> reply\n        | MsgRequestForId   -> msg |> respond        clientId  |> msgType MsgInformation |> reply\n    \n    let connectToWebSocketServer() =\n        dprintfn \"in connectToWebSocketServer\"\n        async {\n            do! connectStateful wsEndPoint clientId <| fun (server: IServer) -> async {\n                return 0, fun state wsmsg -> async {\n                    try match wsmsg with\n                        | CMessage.Message msg -> processMessage msg\n                        | CMessage.Open        -> printoutfn out \"WebSocket %s connection open.\"   clientId ; serverO <- Some server\n                        | CMessage.Close       -> printoutfn out \"WebSocket %s connection closed.\" clientId ; close()\n                        | CMessage.Error       -> printoutfn out \"WebSocket %s connection error!\"  clientId\n                    with e -> printfn \"msg: %A \\nexn:%A\" wsmsg e \n                    return state\n                }\n            }\n            dprintfn \"connectToWebSocketServer with server\"\n            \n        }\n\n    let checkServer = Mailbox.call ( fun () -> async {\n        dprintfn \"getServer\"\n        if serverO.IsNone then\n            dprintfn \"getServer Connecting\"\n            do! connectToWebSocketServer()\n            do! Async.Sleep 200\n        return serverO |> Result.fromOption (ErrSimple(\"could not connect to Server\", false))\n    })        \n\n    let getServer() : Wrap<IServer> =\n        Wrap.wrap {\n            let! serverA = checkServer.PostAndAsyncReply(fun reply -> reply, ())\n            let! server  = serverA\n            return server\n        }\n        \n    let postR (server: IServer) rpl msg = \n        let m = msg |> from clientAddress |> replier rpl \n        try       server.Post m\n        with e -> serverO <- None\n                  raise e\n\n    let sendAndForget msg =\n        Wrap.wrap {\n            let! server = getServer()\n            msg |> postR server NoReply\n        }\n        \n    let sendAndReply rpl msg =\n        Wrap.wrap {\n            let! server  = getServer()\n            let  replyA  = Async.FromContinuations(fun v -> \n                Add(msg.id, v) |> waiting.Post \n                msg |> postR server rpl\n                if wsTimeout > 0 then\n                    async {\n                        do! Async.Sleep wsTimeout\n                        Excpn(msg.id, fun () -> TimeoutException(sprintf \"Did not receive reply in %d seconds for Message: %A\" (wsTimeout / 1000) msg) :> exn) |> waiting.Post\n                    } |> Async.Start\n            )\n            let! reply   = replyA\n            return reply\n        }\n        \n    let sendAndVerify msg =\n        Wrap.wrap {\n            let! reply   = sendAndReply Broker msg \n            do!  match reply.msgType with\n                 | MsgFromBroker  -> let  bm = msgPayload reply\n                                     if   bm = BMOk \n                                     then Result.succeed () \n                                     else Result.fail (ErrBroker bm)\n                 | _              ->      Result.fail (ErrBroker (BMUnexpectedMsgType reply.msgType))\n        }\n    \n    let sendGetReply msg =\n        Wrap.wrap {\n            let! reply   = sendAndReply Receiver msg \n            let! result =\n                match reply.msgType with\n                | MsgReply      -> Result.succeed reply.payload\n                | MsgFromBroker -> let bm = msgPayload reply\n                                   Result.fail (ErrBroker bm)\n                | _             -> Result.fail (ErrBroker (BMUnexpectedMsgType reply.msgType))\n            return result\n        }\n\n    let getListeners() =\n        Wrap.wrap {\n            let  msg    = newMsg MessageBrokerAddress BRGetConnections\n            let! reply  = sendGetReply msg\n            match Json.Deserialize<BrokerReply> reply with\n            | BRConnections listeners -> return listeners\n            //| _ -> ()\n        } \n        \n    let sendMsg msg =\n        Wrap.wrap {\n            if msg.replier = NoReply\n            then do!     sendAndForget msg\n                 return  \"\"\n            else return! sendGetReply  msg\n        }\n    member this.MBListeners            = getListeners()\n    member this.EndPoint               = wsEndPoint\n    member this.ClientId               = clientId\n    member this.SendMsg           msg  = sendMsg msg\n    [<  Inline >]\n    member this.SendAndForget dst pyld = newMsg dst pyld |> sendAndForget\n    [<  Inline >]\n    member this.SendAndVerify dst pyld = newMsg dst pyld |> sendAndVerify\n    [<  Inline >]\n    member this.SendGetReply  dst pyld = newMsg dst pyld |> sendGetReply  |> Wrap.map Json.Deserialize\n    member this.Out with set fout      = out <- fout\n    [<  Inline >]\n    member this.ProcessIncoming   pro  = payloadProcessorO <- Some (Json.Deserialize >> pro >> (Wrap.map Json.Serialize))\n                                         newMsg MessageBrokerAddress \"Registering Processor\" \n                                         |> msgType MsgInformation\n                                         |> sendAndForget |> Wrap<unit>.Start\n    interface IDisposable with\n        member this.Dispose() = close()\n\n#if FSS_SERVER   \n    [< JavaScript false >]\n    new (clientId:string, FSStation, ?timeout, ?endPoint) = new WSMessagingClient(Broker.ConnectStatefulFSS, clientId, ?timeout = timeout, ?endPoint = endPoint)\n#endif\n#if WEBSHARPER\n    [< JavaScript false >]\n    new (clientId:string, FSharp   , ?timeout, ?endPoint) = new WSMessagingClient(Client.ConnectStatefulFS , clientId, ?timeout = timeout, ?endPoint = endPoint)\n    new (clientId:string,            ?timeout, ?endPoint) = new WSMessagingClient(       ConnectStatefulJS , clientId, ?timeout = timeout, ?endPoint = endPoint)\n#else    \n    new (clientId:string,            ?timeout, ?endPoint) = new WSMessagingClient(Client.ConnectStatefulFS , clientId, ?timeout = timeout, ?endPoint = endPoint)\n#endif\n\n","parent":{"$":0,"Item":"64110b26-2d5c-4b29-a81b-75a5495e67a2"},"predecessors":[{"$":0,"Item":"e137b990-172b-4879-bc74-8650123b7a5d"},{"$":0,"Item":"9c253bae-ab8b-4c99-b7e5-38fc50756bec"},{"$":0,"Item":"e24d6bc0-703c-4f12-aca8-8158af50b7cd"},{"$":0,"Item":"b95ef4c5-ca1b-443a-acad-ca8158403d8b"}],"id":{"$":0,"Item":"e665bede-c870-4041-b7ed-8be419c52a83"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FStationMessaging","content":"open FsStationShared\n\ntype FsStationClientErr =\n    | FSMessage             of string * FSSeverity\n    | ``Snippet Not Found`` of string\nwith interface ErrMsg with\n        member this.ErrMsg    = \n            match this with \n            | FSMessage (msg, sev    )   -> sprintf \"%A %s\" sev msg\n            | msg                        -> sprintf \"%A\"        msg\n        member this.IsWarning =     \n            match this with \n            | FSMessage (_  , FSError)   -> true\n            | _msg                       -> false\n\ntype FStationMessaging(msgClient:WSMessagingClient, _clientId, ?fsStationId:string) =\n    let mutable fsIds      = fsStationId |> Option.defaultValue \"##FSHARPSTATION_ID##\"\n    let         toId()     = Address fsIds\n    let stringResponseR response =\n        match response with\n        | StringResponseR (Some code, msgs) -> Result.succeedWithMsgs code (msgs |> Seq.map (fun v -> FSMessage v :> ErrMsg) |> Seq.toArray)\n        | _                                 -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let stringResponse   response =\n        match response with\n        | StringResponse (Some code)        -> Result.succeed code\n        | _                                 -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let snippetsResponse response =    \n        match response with    \n        | SnippetsResponse snps             -> Result.succeed snps\n        | _                                 -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let snippetResponse  response =    \n        match response with    \n        | SnippetResponse  snp              -> Result.succeed snp\n        | _                                 -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    [< Inline >]\n    let sendMsg toId (msg: FSMessage) (checkResponse: FSResponse -> Result<'a>) =\n        Wrap.wrap {\n            let!   res   = msgClient.SendGetReply toId msg\n            let!   check = checkResponse res\n            return check\n        } \n  with \n    member this.SendMessage     (toId2,  msg:FSMessage) = sendMsg  toId2    msg    Result.succeed   \n    member this.SendMessage     (        msg:FSMessage) = sendMsg (toId())  msg    Result.succeed   \n    member this.RequestSnippet  (    snpPath:string   ) = sendMsg (toId()) (GetSnippet          (snpPath.Split '/'     ))    snippetResponse  \n    member this.RequestCode     (    snpPath:string   ) = sendMsg (toId()) (GetSnippetCode      (snpPath.Split '/'     ))    stringResponse   \n    member this.RequestJSCode   (    snpPath:string   ) = sendMsg (toId()) (GetSnippetJSCode    (snpPath.Split '/'     ))    stringResponseR  \n    member this.RequestPreds    (    snpPath:string   ) = sendMsg (toId()) (GetSnippetPreds     (snpPath.Split '/'     ))    snippetsResponse \n    member this.RequestPredsById(      snpId          ) = sendMsg (toId()) (GetSnippetPredsById  snpId                  )    snippetsResponse \n    member this.RequestWholeFile(                     ) = sendMsg (toId())  GetWholeFile                                     stringResponse   \n    member this.GenericMessage  (        txt:string   ) = sendMsg (toId()) (GenericMessage       txt                    )    stringResponse   \n    member this.RunSnippet      (url,snpPath:string   ) = sendMsg (toId()) (RunSnippetUrlJS     (snpPath.Split '/', url))    stringResponseR\n    member this.RunActionCall   (name, act, parms     ) = sendMsg (toId()) (RunActionCall       (name, act, parms      ))    stringResponseR\n    member this.FSStationId                             = fsIds\n    member this.FSStationId with set id                 = fsIds <- id\n    member this.MessagingClient                         = msgClient    \n    static member FSStationId_                          = \"##FSHARPSTATION_ID##\"\n#if FSS_SERVER   \n    [< JavaScript false >]\n    new (clientId, FSStation, ?fsStationId:string, ?timeout, ?endPoint) = FStationMessaging(new WSMessagingClient(clientId, FSStation, ?timeout= timeout, ?endPoint= endPoint), clientId, ?fsStationId = fsStationId)\n#endif\n    [< JavaScript false >]\n#if WEBSHARPER\n    new (clientId, FSharp   , ?fsStationId:string, ?timeout, ?endPoint) = FStationMessaging(new WSMessagingClient(clientId, FSharp   , ?timeout= timeout, ?endPoint= endPoint), clientId, ?fsStationId = fsStationId)\n#endif    \n    new (clientId,            ?fsStationId:string, ?timeout, ?endPoint) = FStationMessaging(new WSMessagingClient(clientId,            ?timeout= timeout, ?endPoint= endPoint), clientId, ?fsStationId = fsStationId)\n\n\n","parent":{"$":0,"Item":"64110b26-2d5c-4b29-a81b-75a5495e67a2"},"predecessors":[{"$":0,"Item":"f6ebdffc-049c-4493-8de8-e32072419479"},{"$":0,"Item":"e665bede-c870-4041-b7ed-8be419c52a83"}],"id":{"$":0,"Item":"4413b3ee-f968-458d-8a5f-7a7c9281c38f"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FStationMessaging Compile Extension","content":"#r @\"..\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.CompOptionsModule\nopen System.IO\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n\ntype CodeSnippet with\n    static member PrepareCompileOptions (options1: CompOptions) (snps: CodeSnippet seq) =\n        let  addLinePrepos =  options1.Contains \"++removelinedirectives\" |> not\n        let  lines, code, assembs, defines, prepoIs, nowarns = CodeSnippet.ReducedCode addLinePrepos snps\n        let  options2      = prepOptions options1 (code, assembs, defines, prepoIs, nowarns)\n        options2\n\ntype FStationMessaging with\n    member this.PrepareCompileOptions(options1) = \n        Wrap.wrapper {\n            let  snpPath   = options1?Snippet\n            let!   preds   = this.RequestPreds snpPath\n            let    options = CodeSnippet.PrepareCompileOptions options1 preds\n            return options\n        }\n    member this.CompileFSharpW(options:CompOptions) = \n        Wrap.wrapper {\n            let! msgs, exit = options.Get CompOptions.FSharpOptions \n                              |> Array.append [| \"IGNORED_Fsc.exe\" |] \n                              |> FSharpChecker.Create().Compile\n            let  errs       = [| yield! msgs |> Array.map fSharpError2TranspilerError\n                                 if exit <> 0 && (exit <> 1 || msgs.Length = 0) then yield ErrSimple (sprintf \"ExitCode: %d\" exit, false) :> ErrMsg\n                              |]\n            let! res        = if   exit <> 0\n                              then Result.failWithMsgs                errs\n                              else Result.succeedWithMsgs \"Compiled!\" errs\n            return res\n        }\n    member this.CompileWebSharperW(options:CompOptions) : Wrap<string> =\n        Wrap.wrapper {\n            if options.Contains opWebSite then\n                let  site     = options?Website\n                if options.Contains \"++createdirectory\"     then Directory.CreateDirectory(site) |> ignore\n            let! res          = options.Get CompOptions.WSharperOptions\n                                 |> Seq.map (sprintf \"%A\")\n                                 |> String.concat \"  \"\n                                 |> fun ops -> (new RunProcess.ShellEx(@\"WsFsc.exe\", ops)).StartAndWaitR()\n            return if res = \"\" then \"Compiled!\" else res\n        }\n    member this.CompileSnippetW options  = \n        Wrap.wrapper {\n            let  snpPath      = options?Snippet\n            let  config       = options?Config\n            let  directory    = options?Directory\n            do   Directory.CreateDirectory(directory) |> ignore\n            let! options2     = this.PrepareCompileOptions options\n            let  compiler     = if options2.Contains \"++websharper:1\" then this.CompileWebSharperW else this.CompileFSharpW\n            let! res          = compiler options2\n            if options2.Contains \"++copyassemblies\" then copyIfMustToDir        \"FSharp.Core.dll\"          directory\n            if options2.Contains \"++copyconfig\"     then copyIfNotExistsToFile  \"FSharpStation.exe.config\" config\n            return res\n        }\n        \n","parent":{"$":0,"Item":"64110b26-2d5c-4b29-a81b-75a5495e67a2"},"predecessors":[{"$":0,"Item":"9becc68c-9cc2-4f29-82df-e510d10226db"},{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},{"$":0,"Item":"ef053bdf-997b-49c8-a401-1611a568bd8a"},{"$":0,"Item":"4413b3ee-f968-458d-8a5f-7a7c9281c38f"}],"id":{"$":0,"Item":"d9c4540a-85f5-4c62-91be-fcb2d60e9f17"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"compile & run Messaging Broker","content":"open System.IO\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.CompOptionsModule\nopen RunProcess\n\nWrap.wrapper {\n    let  options      = compileOptionsExeDebug \"FSSGlobal/F# Code/WSMessagingBroker/MessagingBroker\"\n                        + (opGenInternal /= \"showoptions\")\n    let! res          = FStationMessaging(\"compile & run Messaging Broker\", FSharp).CompileSnippetW options\n    do   printfn        \"Starting MessagingBroker.exe\"\n    do   startProcess   options?Output \"\" |> ignore\n    return res\n} |> Wrap.runSynchronouslyS true |> printfn \"%s\"\n","parent":{"$":0,"Item":"64110b26-2d5c-4b29-a81b-75a5495e67a2"},"predecessors":[{"$":0,"Item":"d9c4540a-85f5-4c62-91be-fcb2d60e9f17"}],"id":{"$":0,"Item":"a044767b-4c0d-4527-9bad-c4633469f216"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FSAutoCompleteIntermediary","content":"module FSAutoCompleteIntermediary =\n","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"b6577554-e62e-41ed-983e-d4dd12e3512f"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"FSAutocompleteCall","content":"#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.DesignTime.dll\"\n#r @\"..\\packages\\NewtonSoft.JSon\\lib\\net45\\NewtonSoft.JSon.dll\"\n\nopen System.Net\nopen System.Text\nopen System.IO\nopen FSharp.Data\nopen FSharp.Data.JsonExtensions\nopen Useful\nopen Useful.Result\nopen Newtonsoft.Json\n\nopen Utils\n\n#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule CommTypes =\n    type ResponseError =\n        {\n          Code: int\n          Message: string\n          //AdditionalData: 'T\n        }\n    type Location =\n      {\n        File: string\n        Line: int\n        Column: int\n      }\n    type CompletionResponse =\n      {\n        Name: string\n        ReplacementText: string\n        Glyph: string\n        GlyphChar: string\n      }\n    //type ProjectResponse =\n    //  {\n    //    Project: ProjectFilePath\n    //    Files: List<SourceFilePath>\n    //    Output: string\n    //    References: List<ProjectFilePath>\n    //    Logs: Map<string, string>\n    //  }\n    type OverloadDescription =\n      {\n        Signature: string\n        Comment: string\n      }\n    type OverloadParameter =\n      {\n        Name : string\n        CanonicalTypeTextForSorting : string\n        Display : string\n        Description : string\n      }\n    type Overload =\n      {\n        Tip : OverloadDescription list list\n        TypeText : string\n        Parameters : OverloadParameter list\n        IsStaticArguments : bool\n      }\n    type Parameter = {\n        Name : string\n        Type : string\n      }\n    type SignatureData = {\n        OutputType : string\n        Parameters : Parameter list list\n      }\n    type MethodResponse =\n      {\n        Name : string\n        CurrentParameter : int\n        Overloads : Overload list\n      }\n    type SymbolUseRange =\n      {\n        FileName: string\n        StartLine: int\n        StartColumn: int\n        EndLine: int\n        EndColumn: int\n        IsFromDefinition: bool\n        IsFromAttribute : bool\n        IsFromComputationExpression : bool\n        IsFromDispatchSlotImplementation : bool\n        IsFromPattern : bool\n        IsFromType : bool\n      }\n    type SymbolUseResponse =\n      {\n        Name: string\n        Uses: SymbolUseRange list\n      }\n    type HelpTextResponse =\n      {\n        Name: string\n        Overloads: OverloadDescription list list\n      }\n    type CompilerLocationResponse =\n      {\n        Fsc: string\n        Fsi: string\n        MSBuild: string\n      }\n    type FSharpErrorInfo =\n      {\n        FileName: string\n        StartLine:int\n        EndLine:int\n        StartColumn:int\n        EndColumn:int\n       // Severity:FSharpErrorSeverity\n        Message:string\n        Subcategory:string\n      }\n    type ErrorResponse =\n      {\n        File: string\n        Errors: FSharpErrorInfo []\n      }\n    type Colorization =\n      {\n    //    Range: Range\n        Kind: string\n      }\n    type Declaration =\n      {\n        UniqueName: string\n        Name: string\n        Glyph: string\n        GlyphChar: string\n        IsTopLevel: bool\n    //  Range     : Utils.Range\n    //    BodyRange : Utils.Range\n        File : string\n        EnclosingEntity: string\n        IsAbstract: bool\n      }\n    type DeclarationResponse = {\n        Declaration : Declaration;\n        Nested : Declaration []\n    }\n    type OpenNamespace = {\n      Namespace : string\n      Name : string\n      Type : string\n      Line : int\n      Column : int\n      MultipleNames : bool\n    }\n    type QualifySymbol = {\n      Name : string\n      Qualifier : string\n    }\n    type ResolveNamespaceResponse = {\n      Opens : OpenNamespace []\n      Qualifies: QualifySymbol []\n      Word : string\n    }\n    type UnionCaseResponse = {\n      Text : string\n    //  Position : Pos\n    }\n    type Kind = \n    | KInfo             of string\n    | KError            of ResponseError\n    | KHelpText         of HelpTextResponse\n    | KCompletion       of CompletionResponse  []\n    | KSymbolUse        of SymbolUseResponse\n    | KHelp             of string\n    | KMethod           of MethodResponse\n    | KErrors           of ErrorResponse\n    | KColorizations    of Colorization list\n    | KFindDecl         of Location\n    | KDeclarations     of DeclarationResponse []\n    | KToolTip          of OverloadDescription [][]\n    | KTypeSig          of string\n    | KSignatureData    of SignatureData\n    | KCompilerLocation of CompilerLocationResponse\n    | KNamespaces       of ResolveNamespaceResponse\n    | KUnionCase        of UnionCaseResponse\n    | KMultiple         of Kind                []\n    \n    type ACMessage =\n    | ACMIdentification\n    | ACMEcho             of string\n    | ACMToolTip          of string * int * int\n    | ACMToolTip2         of string * int * int *  string\n    | ACMSignature        of string * int * int\n    | ACMSignature2       of string * int * int *  string\n    | ACMFindDeclaration  of string * int * int\n    | ACMFindDeclaration2 of string * int * int *  string\n    | ACMComplete         of string * int * int *  string\n    | ACMComplete2        of string * int * int *  string *  string\n    | ACMParse            of string * string    * (string * (int * int * int)) []\n    | ACMMustParse        of string * string\n\nopen CommTypes\n\ntype ParseRequest         = { FileName  : string ; IsAsync    : bool   ; Lines : string[]           ; Version : int                                            }\ntype DeclarationsRequest  = { FileName  : string ;                       Lines : string[]           ; Version : int                                            }\ntype CompletionRequest    = { FileName  : string ; SourceLine : string ; Line  : int                ; Column  : int ; Filter : string; IncludeKeywords : bool  }\ntype PositionRequest      = { FileName  : string ;                       Line  : int                ; Column  : int ; Filter : string                          }\ntype ProjectRequest       = { FileName  : string                                                                                                               }\ntype LintRequest          = { FileName  : string                                                                                                               }\ntype HelptextRequest      = { Symbol    : string                                                                                                               }\ntype WorkspacePeekRequest = { Directory : string ; Deep       : int    ; ExcludedDirs : string []                                                              }\n\ntype FARequest =\n    | FarParse         of ParseRequest         \n    | FarDeclarations  of DeclarationsRequest  \n    | FarCompletion    of CompletionRequest    \n    | FarPosition      of PositionRequest      \n    | FarProject       of ProjectRequest       \n    | FarLint          of LintRequest          \n    | FarHelptext      of HelptextRequest      \n    | FarWorkspacePeek of WorkspacePeekRequest    \nwith\n  member this.Json =\n    match this with \n    | FarParse         data -> JsonConvert.SerializeObject data \n    | FarDeclarations  data -> JsonConvert.SerializeObject data \n    | FarCompletion    data -> JsonConvert.SerializeObject data \n    | FarPosition      data -> JsonConvert.SerializeObject data \n    | FarProject       data -> JsonConvert.SerializeObject data \n    | FarLint          data -> JsonConvert.SerializeObject data \n    | FarHelptext      data -> JsonConvert.SerializeObject data \n    | FarWorkspacePeek data -> JsonConvert.SerializeObject data    \n\nlet fromJson<'a> json = JsonConvert.DeserializeObject(json, typeof<'a>) :?> 'a\nlet jsonData2Obj item = item?Data.ToString() |> fromJson\n\nlet UrlAddress = \"http://localhost:9001/\"\n\nlet HttpRequestCall (url:string) (data:string) =\n    async {\n        //printfn \"RpcCall %s\" (extract 100 data)\n        let req = WebRequest.Create(url) :?> HttpWebRequest \n        req.Timeout         <- 300_000\n        req.ProtocolVersion <- HttpVersion.Version10\n        req.Method          <- \"POST\"\n        req.ContentType     <- \"application/json\"\n        let postBytes = Encoding.ASCII.GetBytes(data)\n        //printfn \"<---\\n%s\\n\" data\n        req.ContentLength <- int64 postBytes.Length\n        let reqStream = req.GetRequestStream() \n        reqStream.Write(postBytes, 0, postBytes.Length);\n        reqStream.Close()\n        \n        // Obtain response and download the resulting page \n        // (The sample contains the first & last name from POST data)\n        use resp   = req.GetResponse() \n        use stream = resp.GetResponseStream() \n        use reader = new StreamReader(stream)\n        let msg    = reader.ReadToEnd()\n        printfn \"\\n----> \\n%s\\n\" (extract 100 msg)\n        let jsonV  = JsonValue.Parse msg\n        return       jsonV\n    }\n\nlet KindError msg = KError { Code = 0 ; Message = msg }\n\nlet json2Kind (v:JsonValue) = \n    let item =JsonValue.Parse <| v.AsString()\n    match item?Kind.AsString() with\n    | \"info\"             -> jsonData2Obj item |> KInfo\n    | \"error\"            -> jsonData2Obj item |> KError\n    | \"errors\"           -> jsonData2Obj item |> KErrors\n    | \"tooltip\"          -> jsonData2Obj item |> KToolTip\n    | \"typesig\"          -> jsonData2Obj item |> KTypeSig\n    | \"completion\"       -> jsonData2Obj item |> KCompletion\n    | \"signatureData\"    -> jsonData2Obj item |> KSignatureData\n    | \"finddecl\"         -> jsonData2Obj item |> KFindDecl\n    | \"compilerlocation\" -> jsonData2Obj item |> KCompilerLocation\n    | _                  -> KindError <| v.ToString()\n\nlet FSAutocompleteCall cmd f (req: FARequest) =\n    Wrap.wrapper {\n        let  data         = req.Json\n        let! jsonV        = HttpRequestCall (UrlAddress + cmd) data\n        let  several      = jsonV.AsArray() |> Array.map json2Kind\n        let  good, others = several |> Array.partition f\n        let  msgs         = others  |> Seq.map (fun v -> (v.ToString(), match v with | KInfo _ -> true | _ -> false) |> ErrSimple :> ErrMsg) |> Seq.toArray\n        let! result       = Result (Seq.tryHead good, msgs) \n        return result\n    } \n\nlet parseCode file code =\n    Wrap.wrapper {\n        let!  result = FSAutocompleteCall \"parse\" (function | KErrors _ -> true | _ -> false) <|\n                             FarParse\n                                 { FileName   = System.IO.Path.GetFullPath file\n                                   IsAsync    = true   \n                                   Lines      = code           \n                                   Version    = 0\n                                 }\n        return result\n    } \n\nlet toolTip file lin col filter =\n    Wrap.wrapper {\n        let!  result = FSAutocompleteCall \"tooltip\" (function | KToolTip _ -> true | _ -> false) <|\n                             FarPosition\n                                 { FileName   = System.IO.Path.GetFullPath file\n                                   Line       = lin         \n                                   Column     = col\n                                   Filter     = filter\n                                 }\n        return result\n    } \n\nlet signature file lin col filter =\n    Wrap.wrapper {\n        let!  result = FSAutocompleteCall \"signatureData\" (function | KSignatureData _ -> true | _ -> false) <|\n                             FarPosition\n                                 { FileName   = System.IO.Path.GetFullPath file\n                                   Line       = lin         \n                                   Column     = col\n                                   Filter     = filter\n                                 }\n        return result\n    } \n\nlet completion file lin col lineText filter =\n    Wrap.wrapper {\n        let!  result = FSAutocompleteCall \"completion\" (function | KCompletion _ -> true | _ -> false) <|\n                             FarCompletion\n                                 { FileName        = System.IO.Path.GetFullPath file\n                                   Line            = lin         \n                                   Column          = col\n                                   Filter          = filter\n                                   SourceLine      = lineText \n                                   IncludeKeywords = false                                     \n                                 }\n        return result\n    } \n\ntype FsAutoCompleteErr =\n    | ``Code has not been parsed, use Parse F#``\n    | ``This snippet has not been previosuly parsed, use Parse F#``\n    | ``Cached typecheck results not yet available``\n    | ``Error FileCheckerOptions`` of string\nwith interface ErrMsg with\n        member this.ErrMsg    = match this with | msg -> sprintf \"%A\" msg\n        member this.IsWarning = false    \n        \n/// this converts from Result to Rop.Result\nlet fromResult' f = \n    function \n    | Failure s  -> Result.fail <| f s\n    | Success v  -> Result.succeed v\n\ntype Responder2() =\n    //let commands = Commands()\n    let starts : Map<string, Map<string, int * int * int>> ref = ref Map.empty\n    \n    let getDelta fname snpIdO =\n        Wrap.wrapper {\n            do!  Result.tryProtection()\n            let  file = System.IO.Path.GetFullPath fname\n            match snpIdO with\n            | Some _snpI -> let! fileMap          = (!starts) |> Map.tryFind file         |> Result.fromOption ``Code has not been parsed, use Parse F#``\n                            let! ind, first, _las = fileMap   |> Map.tryFind snpIdO.Value |> Result.fromOption ``This snippet has not been previosuly parsed, use Parse F#``\n                            return file, first, ind\n            | None       -> return file, 0    , 0 \n        }\n    let getDeltaBack fname line =\n        Wrap.wrapper {\n            do!  Result.tryProtection()\n            let  file             = System.IO.Path.GetFullPath fname\n            let! fileMap          = (!starts) |> Map.tryFind file |> Result.fromOption ``Code has not been parsed, use Parse F#``\n            let! snp, first, ind  = fileMap \n                                    |> Seq.map     (fun kv -> kv.Key, kv.Value) \n                                    |> Seq.tryPick (fun (snp, (ind, first, last)) -> if line >= first && line < last then Some (snp, first, ind) else None) \n                                    |> Result.fromOption ``This snippet has not been previosuly parsed, use Parse F#``\n            return snp, first, ind                        \n        }\n    let mustParse fname snpId =\n        getDelta  fname (Some snpId)\n        |> Wrap.map              (fun _ -> false)\n        |> Wrap.RunSynchronouslyR \n        |> Result.withError      (fun _ -> true )\n\n    let findDeclaration file lin col filter =\n        Wrap.wrapper {\n            //File.WriteAllText(file, \" \")\n            let!  result = FSAutocompleteCall \"finddeclaration\" (function | KFindDecl _ -> true | _ -> false) <|\n                                 FarPosition\n                                     { FileName   = System.IO.Path.GetFullPath file\n                                       Line       = lin         \n                                       Column     = col\n                                       Filter     = filter\n                                     }\n            //File.Delete file                         \n            match result with\n            | KFindDecl decl -> let! snp, dln, dcol = getDeltaBack decl.File decl.Line\n                                let resultAdj = \n                                 {  File    = snp\n                                    Line    = decl.Line   - dln\n                                    Column  = decl.Column - dcol\n                                 } |> KFindDecl\n                                return resultAdj\n            | _              -> return result\n        } \n\n    let getPosition (getKind: string -> int -> int -> string -> Wrap<Kind>) fname ln col (snpIdO:string option) =\n        Wrap.wrapper {\n            let! _fil, dln, dcol = getDelta fname snpIdO\n            let! res             = getKind fname (ln + dln) (col + dcol) \"\"\n            return res\n        } \n        |> Wrap.RunSynchronouslyR\n        |> Result.withError (Result.getMessages >> KindError)\n\n    let getCompletion fname ln col lineText (snpIdO:string option) =\n        Wrap.wrapper {\n            let! _fil, dln, dcol = getDelta fname snpIdO\n            let! res             = completion fname (ln + dln) (col + dcol) ((String.replicate dcol \" \") + lineText) \"Contains\"\n            return res\n        } \n        |> Wrap.RunSynchronouslyR\n        |> Result.withError (Result.getMessages >> KindError)\n        \n    member this.Respond (msg:ACMessage) =\n        match msg with\n        | ACMIdentification              -> KInfo \"FSAutoCompleteIntermedirary\"\n        | ACMEcho   txt                  -> KInfo txt \n        | ACMMustParse(fname, snpId    ) -> mustParse fname snpId |> sprintf \"%b\" |> KInfo\n        | ACMParse    (fname, code, sts) ->\n            async {\n                let  file = System.IO.Path.GetFullPath (fname)\n                do   starts := !starts |> Map.add file (Map sts)\n                //printfn \"\\n%A\\n\" sts\n                let! errors = parseCode file (code.Split '\\n') |> Wrap.getAsync\n                let  fixedErrors =\n                    match errors with\n                    | KErrors ers -> \n                          KErrors { ers with \n                                      Errors = ers.Errors \n                                        |> Array.map (fun err ->\n                                          sts \n                                          |> Array.tryFind (fun (_snpN, (_in, first, last)) -> err.StartLine >= first && err.StartLine <= last)\n                                          |> Option.map    (fun (snpNm, (ind, first, _las)) ->\n                                              { err with FileName    = snpNm\n                                                         StartLine   = err.StartLine   - first\n                                                         EndLine     = err.EndLine     - first\n                                                         StartColumn = err.StartColumn - ind\n                                                         EndColumn   = err.EndColumn   - ind   }) \n                                          |> Option.defaultValue err)\n                                  } \n                    | _ -> errors\n                return fixedErrors \n            }\n            |> Async.RunSynchronously\n        | ACMToolTip         (fname, ln, col)             -> getPosition   toolTip         fname ln col None\n        | ACMToolTip2        (fname, ln, col,      snpId) -> getPosition   toolTip         fname ln col (Some snpId)\n        | ACMSignature       (fname, ln, col)             -> getPosition   signature       fname ln col None\n        | ACMSignature2      (fname, ln, col,      snpId) -> getPosition   signature       fname ln col (Some snpId)\n        | ACMFindDeclaration (fname, ln, col)             -> getPosition   findDeclaration fname ln col None\n        | ACMFindDeclaration2(fname, ln, col,      snpId) -> getPosition   findDeclaration fname ln col (Some snpId)\n        | ACMComplete        (fname, ln, col, txt)        -> getCompletion                 fname ln col txt None\n        | ACMComplete2       (fname, ln, col, txt, snpId) -> getCompletion                 fname ln col txt (Some snpId)\n\n","parent":{"$":0,"Item":"b6577554-e62e-41ed-983e-d4dd12e3512f"},"predecessors":[{"$":0,"Item":"7a655466-e218-4121-a7b6-f9c70a922e07"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"319e0842-b83e-4036-9f57-602ca4a30ac5"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FSAutoCompleteIntermediaryClient","content":"#define FSAUTOCOMPLETE\n\nopen Useful\n//open FsStationShared\nopen WSMessagingBroker\nopen WebSharper\nopen WebSharper.Remoting\n\n#if FSS_SERVER\n\nlet responder = Responder2()\n\nlet fssClient = new WSMessagingBroker.FStationMessaging(\"FSAutoComplete\", FSStation)\nasync {\n    do! Async.Sleep 1000\n    fssClient.MessagingClient.ProcessIncoming (responder.Respond >> WSome)\n} |> Async.Start\n\n[< Rpc >]\nlet sendMessageRpc msg = async { return responder.Respond msg }\n\n[< JavaScript >]\nlet sendMessage  (msg:ACMessage) : Async<Kind> = \n    async {\n        let!   res = sendMessageRpc (msg |> box |> unbox)\n        return res                       |> box |> unbox\n    }\n#endif\n\n#if WEBSHARPER\n[< JavaScript >]\n#endif\ntype FSAutoCompleteIntermediaryClient(clientId, ?endPoint:string) =\n     #if FSS_SERVER\n     #else\n     let msgClient = new WSMessagingClient(clientId, ?endPoint = endPoint)\n     let toId      = Address \"FSAutoComplete\"\n     let sendMessage (msg:ACMessage) : Async<Kind> = msgClient.SendGetReply toId msg |> Wrap.getAsyncWithDefault (Result.getMessages >> KInfo)\n     #endif\n     let Async_map f aa = \n         async { \n             let! a = aa\n             return f a\n         }\n     let rec comp2Strings comp =\n         match comp with \n         | KCompletion cs -> cs |> Array.map (fun cs -> cs.Name, cs.ReplacementText, cs.Glyph, cs.GlyphChar)\n         | KHelpText   _  -> [||]\n         | KMultiple   ks -> ks |> Array.collect comp2Strings \n         | m              -> [| sprintf \"%A\" m, \"\", \"ErrorMsg\", \"E\" |] \n     let tip2String tip =\n         match tip with \n         | KToolTip ts -> ts |> Seq.collect id |> Seq.collect (fun t -> [ t.Signature ; t.Comment ] ) |> String.concat \"\\n\"\n         | m           -> sprintf \"%A\" m \n     let errors2String errs =\n         match errs with \n         | KErrors  es -> \n             es.Errors \n             |> Seq.map (fun er -> sprintf \"ErrFSharp \\\"F# %s.fsx (%d,%d) - (%d,%d) %s:%s\\\"\" \n                                      er.FileName er.StartLine er.StartColumn er.EndLine er.EndColumn er.Subcategory er.Message) \n             |> String.concat \"\\n\"\n         | m           -> sprintf \"%A\" m \n     let info2Bool inf =\n         match inf with\n         | KInfo \"true\" -> true\n         | _            -> false\n        \n   with\n     member this.MustParse(fname,                 sId) = sendMessage (ACMMustParse       (fname,                  sId)) |> Async_map info2Bool\n     member this.Parse    (fname, txt , sts          ) = sendMessage (ACMParse           (fname, txt , sts           )) |> Async_map errors2String\n     member this.Parse    (fname, txt                ) = sendMessage (ACMParse           (fname, txt , [||]          )) |> Async_map errors2String\n     member this.ToolTip  (fname, line, col          ) = sendMessage (ACMToolTip         (fname, line, col           )) |> Async_map tip2String\n     member this.ToolTip  (fname, line, col,      sId) = sendMessage (ACMToolTip2        (fname, line, col ,      sId)) |> Async_map tip2String\n     member this.Complete (fname, txt, line, col     ) = sendMessage (ACMComplete        (fname, line, col , txt     )) |> Async_map comp2Strings\n     member this.Complete (fname, txt, line, col, sId) = sendMessage (ACMComplete2       (fname, line, col , txt, sId)) |> Async_map comp2Strings\n     member this.FindDecl (fname, line, col          ) = sendMessage (ACMFindDeclaration (fname, line, col           )) |> Async_map id\n     member this.FindDecl (fname, line, col,      sId) = sendMessage (ACMFindDeclaration2(fname, line, col ,      sId)) |> Async_map id\n     #if FSS_SERVER\n     #else\n     member this.MessagingClient                       = msgClient    \n     member this.ToId                                  = toId\n     #endif\n","parent":{"$":0,"Item":"b6577554-e62e-41ed-983e-d4dd12e3512f"},"predecessors":[{"$":0,"Item":"e665bede-c870-4041-b7ed-8be419c52a83"},{"$":0,"Item":"319e0842-b83e-4036-9f57-602ca4a30ac5"}],"id":{"$":0,"Item":"466e6783-0751-48d5-b79b-165aaa7d2173"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FsEvaluator","content":"module FsEvaluator =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"a70b4838-75d6-40c3-9a0c-5bd03c57cce5"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"evalFsiExe","content":"open Useful\n\nmodule Evaluator =\n    open System.Diagnostics\n    open UsefulDotNet\n    open RunProcess\n    \n    let endToken = \"xXxY\" + \"yYyhH\"\n    let mutable silent    = false\n    type FsiExe(config, ?outHndl, ?errHndl) =\n        let fsiexe                    = if config |> Seq.contains \"-d:FSI32BIT\" then \"fsi.exe\" else \"fsianycpu.exe\"\n        let startInfo                 = ProcessStartInfo(fsiexe, config |> String.concat \" \")             \n        let shell                     = new ShellEx(startInfo, ?outHndl = outHndl, ?errHndl = errHndl)  // --noninteractive\n        do  startInfo.CreateNoWindow <- false\n            shell.Start() |> ignore\n        member this.Eval txt =\n            Wrap.wrapper {\n                do! Result.tryProtection()\n                shell.Send txt \n                shell.Send \";;\"\n                let! res = shell.SendAndWait(\"printfn \\\"\" + endToken + \"\\\";;\", endToken)\n                //shell.WaitForInputIdle() |> ignore\n                //let! resR = shell.Response()\n                //let! res  = resR\n                return res\n            }\n        member this.IsAlive = not shell.HasExited\n        member this.Abort() = shell.Abort()\n        interface System.IDisposable with\n            member this.Dispose () = \n                (shell :> System.IDisposable).Dispose()\n\n#if FSS_SERVER\n    printfn \"FSS_SERVER\"\n    let fssClient = FSAutoCompleteIntermediary.fssClient //WSMessagingBroker.FStationMessaging(\"<FsEvaluator>\", WSMessagingBroker.FSStation)\n    let queueOutput =\n        let output      = new System.Text.StringBuilder()\n        let append  txt = output.Append((if output.Length = 0 then \"\" else \"\\n\") + txt) |> ignore\n        let consume ()  = let v = output.ToString()\n                          output.Clear() |> ignore\n                          v\n        Mailbox.iter (fun msg -> async {\n            match msg with\n            | Some txt -> append txt\n            | None     -> let txt2send =  consume()\n                          if  txt2send <> \"\" then\n                              fssClient.RunActionCall(\"OutText\", \"actOutText\", [| \"+\" ; txt2send |])\n                              |> Wrap.RunSynchronously \n                              |> ignore\n          })\n    let queueText txt = \n        txt |> Some |> queueOutput.Post\n        async { do! Async.Sleep 100\n                queueOutput.Post None } |> Async.Start\n    let outHndl (txt:string) = if not silent then txt.Replace(endToken, \"Done!\")   |> queueText\n    let errHndl (txt:string) = if not silent then if txt <> \"\" then \"ERR : \" + txt |> queueText\n    let setFsid id ep = if id <> fssClient.FSStationId && id <> \"\" then fssClient.FSStationId <- id ; printfn \"setFSid = %s\" id\n#else\n    let outHndl       = ignore\n    let errHndl       = ignore\n    let setFsid _i _e = ()\n#endif\n\n    let fsiExe = lazy new ResourceAgent<_, string> (70\n                                                  , (fun config ->\n                                                          printfn \"FsiExe %s\" (defaultArg config \"\")\n                                                          new FsiExe([ \"--nologo\"\n                                                                       \"--quiet\"\n                                                                       defaultArg config \"\"\n                                                                     ], outHndl, errHndl))\n                                                  , (fun fsi -> (fsi :> System.IDisposable).Dispose()), (fun fsi -> fsi.IsAlive), \"\")\n\n    #if WEBSHARPER\n    [< JavaScript >]\n    #endif\n    let extractConfig (code:string) = if code.StartsWith \"////-d:\" then code.[4..code.IndexOf '\\n' - 1] else \"\"\n\n    let evalFsiExe (code:string) incrUseCount =\n        Wrap.wrapper {\n            let  config = extractConfig code\n            let! resR   = fsiExe.Value.Process(fun fsi -> \n                Wrap.wrapper {\n                  return! fsi.Eval code \n                }\n            , config, incrUseCount)\n            let! res    = resR\n            return res\n        }\n        \n    let evalSilent (config:string option) fs = \n        Wrap.wrapper {\n            silent <- true\n            let! resR   = fsiExe.Value.Process(fun fsi -> \n                Wrap.wrapper {\n                  return! fsi.Eval fs\n                }\n            , config \n              |> Option.orElse fsiExe.Value.Configuration\n              |> Option.defaultValue \"\"\n            , false)\n            let! res    = resR\n            silent <- false\n            return res\n        }\n        |> Wrap.runSynchronouslyS false \n        |> fun s -> s.Split('\\n').[0]     \n        \n    let installPresence configO = evalSilent configO \"\"\"\nmodule CodePresence =\n    let mutable present : Map<string, string>  = Map.empty\n    let presenceOf    k   = present |> Map.tryFind k |> Option.defaultValue \"--\" |> printfn \"%s\"\n    let addPresenceOf k v = present <- present |> Map.add k v ; printfn \"ok\"\n\"\"\"\n\n    #if WEBSHARPER\n    [< Rpc >]\n    #endif\n    let addPresence (name:string) (v:string) = \n        async {\n            let code = sprintf \"CodePresence.addPresenceOf %A %A\" (name.Replace(\"\\\"\", \"\\\\\\\"\")) v\n            evalSilent None code\n            |> function\n               | \"ok\" -> ()\n               | _    -> installPresence None      |> ignore\n                         evalSilent      None code |> ignore\n        }\n    #if WEBSHARPER\n    [< Rpc >]\n    #endif\n    let getPresence config (name:string)   = \n        async {\n            let code = sprintf \"CodePresence.presenceOf    %A\" (name.Replace(\"\\\"\", \"\\\\\\\"\"))\n            return\n                evalSilent (Some config) code\n                |> function\n                   | v when v = endToken -> installPresence (Some config) |> ignore\n                                            None\n                   | \"--\"                -> None\n                   | v                   -> Some v\n        }\n        \n    #if WEBSHARPER\n    [< Rpc >]\n    #endif\n    let abortFsiExe () = \n        fsiExe.Value.Process(fun fsi -> Wrap.wrap { fsi.Abort() }) \n        |> WAsyncR \n        |> Wrap.toAsync\n\n    type EVMessage =\n    | EVMEvaluate of string\n    | EVMAbort\n    \n    type EVResponse =\n    | EVROk\n    | EVRResult   of ResultS<string>\n\n    let respond msg = \n        Wrap.wrap {\n            match msg with\n            | EVMEvaluate fs -> let!   r =  evalFsiExe fs true |> Wrap.toAsyncResult\n                                return r |> Result.toResultS   |> EVRResult\n            | EVMAbort       -> do! abortFsiExe()\n                                return EVROk\n        }\n\n","parent":{"$":0,"Item":"a70b4838-75d6-40c3-9a0c-5bd03c57cce5"},"predecessors":[{"$":0,"Item":"4413b3ee-f968-458d-8a5f-7a7c9281c38f"},{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},{"$":0,"Item":"f930dc48-39e8-453c-8c77-18a2cd73637a"}],"id":{"$":0,"Item":"82c8fbfd-6b85-4b5c-8bd0-81bcd8de1e58"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"evaluateAR","content":"#define WEBSHARPER\nopen WebSharper\n\n[< Rpc >]\nlet evaluateAS (fsid:string) (ep:string) incrUseCount source =\n    async {\n        Evaluator.setFsid fsid ep\n        let!    res  = Evaluator.evalFsiExe source incrUseCount |> Wrap.getAsyncR \n        return  res |> Result.mapMsgs (Seq.map (fun (e:ErrMsg) -> e.ErrMsg, e.IsWarning) >> Seq.toArray)\n    }\n    \n[< JavaScript >]\nlet evaluateAR fsid ep incrUseCount source =\n    async {\n        let!   vO, msgs = evaluateAS fsid ep incrUseCount source \n        return  Result (vO,  msgs |> Seq.map (fun (msg, wrn) -> ErrSimple(msg, wrn) :> ErrMsg) |> Seq.toArray)\n    }\n\n[< JavaScript >]\nlet abortFsiExe () = Evaluator.abortFsiExe() |> Async.Start \n\n#if FSS_SERVER\n\nlet fssClient = new WSMessagingBroker.FStationMessaging(\"FSEvaluator\", WSMessagingBroker.FSStation)\n\nasync {\n    do! Async.Sleep 1000\n    fssClient.MessagingClient.ProcessIncoming Evaluator.respond\n} |> Async.Start\n\n#else\n\n#if FSS_SERVER\n#else\ntype WSMessagingBroker.WSMessagingClient with\n#if WEBSHARPER\n[< JavaScript >]\n#endif\n     member this.EvaluateFS fs = \n         Wrap.wrap {\n             let! repS = Evaluator.EVMEvaluate fs |> this.SendGetReply (WSMessagingBroker.Address \"FSEvaluator\")\n             let! rep  = match repS with\n                         | Evaluator.EVROk       -> Result.fail (ErrSimple (\"Unexpected EVROk reply received\", false))\n                         | Evaluator.EVRResult r -> Result.fromResultS r\n             return rep\n         }\n#endif\n#endif\n","parent":{"$":0,"Item":"a70b4838-75d6-40c3-9a0c-5bd03c57cce5"},"predecessors":[{"$":0,"Item":"82c8fbfd-6b85-4b5c-8bd0-81bcd8de1e58"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},{"$":0,"Item":"f930dc48-39e8-453c-8c77-18a2cd73637a"},{"$":0,"Item":"b7c2d8cd-7246-4ad1-af46-ffbb7acde6e0"},{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"}],"id":{"$":0,"Item":"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FsTranslator","content":"module FsTranslator =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"FsTranslator","content":"#r @\"..\\packages\\WebSharper.FSharp\\tools\\System.Reflection.Metadata.dll\"\n#r @\"..\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n#r @\"..\\packages\\WebSharper.Compiler\\lib\\net461\\WebSharper.Compiler.dll\"\n#r @\"..\\packages\\WebSharper.Compiler\\lib\\net461\\WebSharper.Compiler.FSharp.dll\"\n#r @\"..\\packages\\Mono.Cecil\\lib\\net40\\Mono.Cecil.dll\"\n#r @\"..\\packages\\Mono.Cecil\\lib\\net40\\Mono.Cecil.Pdb.dll\"\n#r @\"..\\packages\\Mono.Cecil\\lib\\net40\\Mono.Cecil.Mdb.dll\"\n//#r @\"System.Reflection.Metadata.dll\"\n\nmodule Translator =\n    open Useful\n    open UsefulDotNet\n    open System\n    open System.IO\n    open System.Reflection\n    \n    module Re = WebSharper.Core.Resources\n    module P  = WebSharper.PathConventions\n    open WebSharper.Compiler\n    open WebSharper.Compiler.FrontEnd\n    open WebSharper.Core\n    open WebSharper.Core.Resources\n    open WebSharper.Compiler.CommandTools\n    open Microsoft.FSharp.Compiler.SourceCodeServices\n    open Microsoft.FSharp.Compiler\n    \n    type WebSharperError = AST.SourcePos option * CompilationError\n    type TranslatorError =\n        | MustProvideAssemblyOutputPath\n        | MustProvideProjectPath\n        | ErrWebSharper                 of string\n        | NothingToTranslateToJavaScript\n        | OutputAssemblyNotFound        of string\n    with interface ErrMsg with\n            member this.ErrMsg =\n                if this = NothingToTranslateToJavaScript then \"WebSharper found nothing that required translation to JavaScript. Possibly a [< JavaScript >] attribute is missing.\" else\n                sprintf \"%A\"this\n            member this.IsWarning = false\n    \n    let webSharperError2TranspilerError: WebSharperError -> ErrMsg =\n        fun                              (posO, error)   ->\n            posO \n            |> Option.map (fun pos -> sprintf \"%s %A - %A \" pos.FileName pos.Start pos.End )\n            |> Option.defaultValue \"\"\n            |>  sprintf \"%s%s\" <| error.ToString()\n            |> ErrWebSharper\n            :> ErrMsg\n            \n    let PrintGlobalError err = eprintfn \"WebSharper error FS9001: %s\" (ErrorPrinting.NormalizeErrorString err)\n    \n    let CompileToJsW: WsConfig -> Wrap<string> =\n        fun           config   -> Wrap.wrapper {\n            do!  config.ProjectFile  = null       |> Result.failIfTrue  MustProvideProjectPath\n            do!  config.AssemblyFile = null       |> Result.failIfTrue  MustProvideAssemblyOutputPath\n            let  fsharpChecker       = FSharpChecker.Create(keepAssemblyContents = true)\n            let! errors, exitCode    = fsharpChecker.Compile(config.CompilerArgs)\n            let  fsErrors            = errors |> Array.map fSharpError2TranspilerError \n            do!  (if exitCode = 0 then Result.succeedWithMsgs () else Result.failWithMsgs) <| fsErrors\n            do!  File.Exists config.AssemblyFile  |> Result.failIfFalse (OutputAssemblyNotFound config.AssemblyFile)\n            let  assemblyBytes       = File.ReadAllBytes config.AssemblyFile\n            do   System.IO.File.Delete config.AssemblyFile\n            let  paths               = [   for r in config.References -> \n                                               Path.GetFullPath r\n                                           yield Path.GetFullPath config.AssemblyFile\n                                       ]        \n            let  aR                  = AssemblyResolver.Create().SearchPaths(paths)\n            let  loader              = Loader.Create aR (printfn \"%s\")\n            let  refs                = [ for r in config.References -> loader.LoadFile(r, false) ]\n            let wsRefsMeta =\n                System.Threading.Tasks.Task.Run(fun () ->\n                    let mutable refError = false\n                    let wsRefs, metas = \n                        refs |> List.choose (fun r -> \n                            match TryReadFromAssembly FullMetadata r with\n                            | None -> None\n                            | Some (Ok m) -> Some (r, m)\n                            | Some (Error e) ->\n                                refError <- true\n                                PrintGlobalError e\n                                None\n                        ) |> List.unzip\n                    if refError then None\n                    elif List.isEmpty metas then Some ([], [], WebSharper.Core.Metadata.Info.Empty) \n                    else\n                        try\n                            Some (\n                                wsRefs, metas,\n                                { \n                                    WebSharper.Core.Metadata.Info.UnionWithoutDependencies metas with\n                                        Dependencies = WebSharper.Core.DependencyGraph.Graph.NewWithDependencyAssemblies(metas |> Seq.map (fun m -> m.Dependencies)).GetData()\n                                }\n                            )\n                        with e ->\n                            refError <- true\n                            PrintGlobalError (\"Error merging WebSharper metadata: \" + e.Message)\n                            None\n                )\n            let refMeta = wsRefsMeta.ContinueWith(fun (t: System.Threading.Tasks.Task<_>) -> \n                            match t.Result with \n                            | Some (_, _, m) -> Some m \n                            | _ -> None )\n            let  referencedAsmNames     = paths\n                                          |> Seq.map (fun i -> \n                                              let n = Path.GetFileNameWithoutExtension(i)\n                                              n, i\n                                          ) |> Map.ofSeq\n            let  thisName               = Path.GetFileNameWithoutExtension config.AssemblyFile\n            let  assemblyResolveHandler = ResolveEventHandler(fun _ e ->\n                    //printfn \"assemblyResolveHandler %s\" e.Name\n                    let assemblyName    = AssemblyName(e.Name).Name\n                    match Map.tryFind assemblyName referencedAsmNames with\n                    | Some p when assemblyName = \"FSharp.Core\" -> typeof<option<_>>.Assembly\n                    | Some p when assemblyName = thisName      -> Assembly.Load assemblyBytes\n                    | Some p                                   -> Assembly.LoadFrom(p)\n                    | _                                        -> null\n                )\n            System.AppDomain.CurrentDomain.add_AssemblyResolve(assemblyResolveHandler)\n            let! comp        = WebSharper.Compiler.FSharp.WebSharperFSharpCompiler(printfn \"%s\", fsharpChecker)\n                                        .Compile(refMeta, config.CompilerArgs, config, config.ProjectFile) \n            let  wsErrors    = comp.Errors |> Seq.map webSharperError2TranspilerError |> Seq.toArray\n            do! if wsErrors |> Seq.isEmpty then Result.succeed () else\n                Result.failWithMsgs wsErrors\n            let  assem       = loader.LoadRaw assemblyBytes None\n            let  getRefMeta()= match wsRefsMeta.Result with | Some (_, _, m) -> m | _ -> WebSharper.Core.Metadata.Info.Empty\n            let jsO, currentMeta, sources = ModifyAssembly (Some comp) \n                                              (getRefMeta()) \n                                              (comp.ToCurrentMetadata(config.WarnOnly)) \n                                              config.SourceMap config.AnalyzeClosures assem\n            let! js, jsMin   = jsO |> Result.fromOption NothingToTranslateToJavaScript\n            let  thisProject = Path.GetFileNameWithoutExtension config.ProjectFile\n            use  stringW     = new System.IO.StringWriter()\n            use  writer      = new HtmlTextWriter(stringW)\n            let  pu          = P.PathUtility.VirtualPaths(\"/\")\n            let ctx : Resources.Context =\n                {\n                    WebRoot                 = \"\"\n                    DebuggingEnabled        = true\n                    DefaultToHttp           = false\n                    GetSetting              = fun (name: string) -> None //printfn \"GetSetting %s\" name ; None\n\n                    GetAssemblyRendering    = fun name ->\n                        //printfn \"GetAssemblyRendering %s\" name\n                        if name = thisProject || name = config.ProjectFile\n                        then WebSharper.Core.Resources.Rendering.Skip else\n                        name\n                        |> P.AssemblyId.Create\n                        |> pu.JavaScriptPath \n                        |> Re.RenderLink\n                    GetWebResourceRendering = fun ty resource ->\n                        //printfn \"GetWebResourceRendering %A\" ty\n                        let id = P.AssemblyId.Create(ty)\n                        let kind =\n                            if resource.EndsWith(\".js\") || resource.EndsWith(\".ts\")\n                                then P.ResourceKind.Script\n                                else P.ResourceKind.Content\n                        P.EmbeddedResource.Create(kind, id, resource)\n                        |> pu.EmbeddedPath\n                        |> Re.RenderLink\n                    RenderingCache          = System.Collections.Concurrent.ConcurrentDictionary()\n                    ResourceDependencyCache = System.Collections.Concurrent.ConcurrentDictionary()\n                }            \n            comp.Graph.Nodes |> comp.Graph.GetDependencies |> comp.Graph.GetResources |> Seq.iter(fun r -> r.Render ctx (fun _ -> writer) )\n            //js.RenderDependencies(ctx, writer)\n            let  includes = stringW.ToString()\n            let  incs     = includes.Split([| \"src=\"; \"href=\" ; \"<\" ; \">\" |], System.StringSplitOptions.RemoveEmptyEntries)\n                            |> Seq.choose(fun v -> if v.[0] = '\"' then v.Split([| '\"' |], System.StringSplitOptions.RemoveEmptyEntries).[0] |> sprintf \"%A\" |> Some else None)\n                            |> String.concat \", \"\n            let! f        = Result.succeedWithMsgs js.[1..js.Length - 7] (comp.Warnings |> Seq.map (fun v -> (sprintf \"%A\" v, true) |> ErrSimple :> ErrMsg) |> Seq.toArray)\n            return          sprintf \"CIPHERSpaceLoadFiles([%s], %s);\" incs f\n        }\n    \n    let compileMainW: string[] -> Wrap<string> =\n      fun             argv     ->\n        let resSplit (r:string) = \n            match r.Split(',') with \n            | [| res           |] -> (res, None         )\n            | [| res; fullName |] -> (res, Some fullName)\n            | _ -> argError (\"Unexpected value --resource:\" + r)\n        let wsArgs    = ref WsConfig.Empty\n        let refs      = ResizeArray()\n        let resources = ResizeArray()\n        let fscArgs   = ResizeArray()\n        let cArgv     =\n            [|\n                let isRNext = ref false\n                for a in argv do\n                    match a with\n                    | \"-r\" ->\n                        isRNext := true\n                    | _ ->\n                        if !isRNext then\n                            isRNext := false   \n                            yield \"-r:\" + a\n                        else\n                            yield a\n            |]\n        for a in cArgv do\n            let setProjectType t = wsArgs := { !wsArgs with ProjectType = Some t }\n            try\n                match a with\n                | \"--wig\"                          -> setProjectType WIG\n                | \"--bundle\"                       -> setProjectType Bundle\n                | \"--html\"                         -> setProjectType Html\n                | \"--site\"                         -> setProjectType Website\n                | StartsWith \"--ws:\" wsProjectType ->\n                    match wsProjectType.ToLower() with\n                    | \"site\" \n                    | \"web\" \n                    | \"website\" \n                    | \"export\"                     -> setProjectType Website\n                    | \"extension\"                  \n                    | \"interfacegenerator\"         -> setProjectType WIG\n                    | \"bundle\"                     -> setProjectType Bundle\n                    | \"html\"                       -> setProjectType Html\n                    | \"ignore\"                     -> ()\n                    | \"library\"                    -> ()\n                    | _                            -> invalidArg \"type\" (\"Invalid project type: \" + wsProjectType)\n                | StartsWith \"--project:\"        p -> wsArgs := { !wsArgs with ProjectFile   = p      } //Path.Combine(Directory.GetCurrentDirectory(), p) }\n                | StartsWith \"--wsoutput:\"       o -> wsArgs := { !wsArgs with OutputDir     = Some o }\n                | StartsWith \"--keyfile:\"        k -> wsArgs := { !wsArgs with KeyFile       = Some k }\n                | \"--jsmap\"                        -> wsArgs := { !wsArgs with SourceMap     = true   } \n                | \"--dts\"                          -> wsArgs := { !wsArgs with TypeScript    = true   } \n                | \"--wswarnonly\"                   -> wsArgs := { !wsArgs with WarnOnly      = true   } \n                | \"--printjs\"                      -> wsArgs := { !wsArgs with PrintJS       = true   }\n                | \"--debug\"                      \n                | \"--debug+\"                     \n                | \"--debug:full\"                 \n                | \"-g\"                           \n                | \"-g+\"                          \n                | \"-g:full\"                        -> wsArgs := { !wsArgs with IsDebug       = true   } ; fscArgs.Add a\n                | \"--vserrors\"                     -> wsArgs := { !wsArgs with VSStyleErrors = true   } ; fscArgs.Add a\n                | StartsWith \"-o:\"               o \n                | StartsWith \"--out:\"            o -> wsArgs := { !wsArgs with AssemblyFile = o       } ; fscArgs.Add a\n                | StartsWith \"--doc:\"            d -> wsArgs := { !wsArgs with Documentation = Some d } ; fscArgs.Add a\n                | StartsWith \"-r:\"               r             \n                | StartsWith \"--reference:\"      r -> refs.Add      r                                   ; fscArgs.Add a\n                | StartsWith \"--resource:\"       r -> resources.Add (resSplit r)                        ; fscArgs.Add a\n                | _                                ->                                                     fscArgs.Add a  \n            with e ->\n                failwithf \"Parsing argument failed: '%s' - %s\" a e.Message\n        fscArgs.Add \"--define:FSHARP41\"\n        wsArgs := \n            { !wsArgs with \n                References   = refs |> Seq.map (fun s -> s.ToLower()) |> Seq.distinct |> Array.ofSeq\n                Resources    = resources.ToArray()\n                CompilerArgs = fscArgs  .ToArray() \n            }\n        CompileToJsW !wsArgs\n\n    let Process args =  \n        compileMainW args \n        |> Wrap.runSynchronouslyR\n        |> fun (Result(jsO, msgs)) -> \n               jsO |> Option.iter (printfn \"%s\")\n               if msgs |> Seq.isEmpty |> not then Result.getMessages msgs |> eprintfn \"%O\"\n               match jsO with\n               | Some js -> 0\n               | None    -> 1\n               \n    let endToken = sprintf \"//---------------%s-----------------\" \"EOF\"\n\n    [< EntryPoint >]\n    let Main args =\n        Console.SetIn(new StreamReader(Console.OpenStandardInput 30000))\n        let mutable cycle = true\n        if args = [| \"++loop\" |] \n        then while cycle do\n               let line = Console.ReadLine()\n               if line = null ||  line = \"++end\" then cycle <- false else\n               let argsL = match line with Regexs \"(\\\".*?\\\"|\\S+)\" ms -> ms |> Array.map (function | Regex \"(\\\"(.*)\\\")\" [_ ; m] | m -> m)\n               if Process argsL = 0 then \"success\" else \"fail\"\n               |> printfn \"//%s\"\n               eprintfn \"%s\" endToken\n             0\n        else Process args \n","parent":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"predecessors":[{"$":0,"Item":"7646acbc-2c28-4159-98b1-2365d19fc97c"},{"$":0,"Item":"9becc68c-9cc2-4f29-82df-e510d10226db"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},{"$":0,"Item":"b7c2d8cd-7246-4ad1-af46-ffbb7acde6e0"}],"id":{"$":0,"Item":"cfe0b3ef-9176-4f30-853c-27177faef6b0"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"TranslatorCaller","content":"module TranslatorCaller =\n    open Useful\n    open UsefulDotNet\n    open UsefulDotNet.RunProcess\n    open CompOptionsModule\n    open System\n    open System.IO\n    open System.Diagnostics\n    \n    type TranslatorExe(config) =\n        let startInfo                 = ProcessStartInfo(@\"Compiled\\FsTranslator\\FsTranslator.exe\", config |> String.concat \" \")             \n        let shell                     = new ShellEx(startInfo)  // --noninteractive\n        let endToken                  = sprintf \"//---------------%s-----------------\" \"EOF\"\n        do  startInfo.CreateNoWindow <- false\n            shell.Start() |> ignore\n        member this.Translate txt =\n            Wrap.wrapper {\n                do! Result.tryProtection()\n                let! res1 = shell.SendAndWait(txt, endToken, true)\n                let! res2 = if res1.EndsWith \"//success\" then Result.succeed res1 else Result.fail (ErrSimple (\"Translator Failed\", false))\n                return res2\n            }\n        member this.IsAlive = not shell.HasExited\n        interface System.IDisposable with\n            member this.Dispose () = \n                (shell :> System.IDisposable).Dispose()    \n\n    let translator = lazy new ResourceAgent<_, string> (20, (fun config -> new TranslatorExe([\"++loop\"; defaultArg config \"\"] )), (fun exe -> (exe :> System.IDisposable).Dispose()), (fun exe -> exe.IsAlive), \"\")\n    \n    let extractConfig (code:string[]) = if code.[0].StartsWith \"////-d:\" then code.[0].[4..] else \"\"\n\n    let getJSW (minified:bool) (options0 : (CompOption * CompOptionValue) seq) (fsCode:string) =\n        Wrap.wrapper {\n            do!  Result.tryProtection()\n            let  code           = fsCode.Split '\\n'\n            let  defines0       = (extractConfig code).Split([| \" \" ; \"-d:\" |], StringSplitOptions.RemoveEmptyEntries) \n            let  fs, assembs, defines1, prepIs, nowarns = separatePrepros false code |> separateDirectives\n            let  defines        = Array.append defines0 defines1\n            let  codeBase       = Path.GetFullPath \"bin\"\n            let  name           = \"Temp_\" + Path.GetFileNameWithoutExtension(Path.GetRandomFileName())\n            let  options1       = compileOptionsDll name\n                                  + opDirectory   /= Path.GetDirectoryName(codeBase)\n                                  + opWsProject   /= name\n                                 // + opIOption   /= @\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\bin\"\n                                  + options0\n            let  options2       = prepOptions options1 (fs, assembs, defines, prepIs, nowarns)\n            use  toErase        = new TempFileName(options2?Source)\n            let  ops            = options2.Get CompOptions.WSharperOptions\n                                  |> Seq.append [ \"IGNORED\" ]\n                                  |> Seq.map (sprintf \"%A\")\n                                  |> String.concat \" \"\n            let! jsR            = translator.Value.Process (fun tra -> tra.Translate ops)\n            let! js             = jsR\n            return js\n        }\n\n\n","parent":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"predecessors":[{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},{"$":0,"Item":"ef053bdf-997b-49c8-a401-1611a568bd8a"},{"$":0,"Item":"ace1fc12-3dfb-4db8-80c9-5bde1e7d0597"},{"$":0,"Item":"4137cad8-fd64-426e-98de-16a92a56388d"},{"$":0,"Item":"f930dc48-39e8-453c-8c77-18a2cd73637a"}],"id":{"$":0,"Item":"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Test FsTranslator.exe","content":"open Useful\nopen UsefulDotNet\nopen CompOptionsModule\n\nWrap.wrapper {\n    let    snippet = \"FSSGlobal/F# STATION TUTORIALS/1 - Hello World\" //\"FSSGlobal/WebSharper Code/WebSharper Snippets1/Test mouse\" //\"FSSGlobal/F# Code/Snippets/Failed to load argument type\"\n    //let    snippet = \"FSSGlobal/F# Code/Snippets/Failed to load argument type\"\n    let!   code    = WSMessagingBroker.FStationMessaging(\"Test FsTranslator.exe\").RequestCode snippet\n    let!   js      = TranslatorCaller.getJSW false [ (* opGenInternal /= \"showoptions\" *) ] code\n    return js\n} \n|> Wrap.runSynchronouslyS false\n|> printfn \"%A\"\n","parent":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"predecessors":[{"$":0,"Item":"d9c4540a-85f5-4c62-91be-fcb2d60e9f17"},{"$":0,"Item":"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"},{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},{"$":0,"Item":"ef053bdf-997b-49c8-a401-1611a568bd8a"}],"id":{"$":0,"Item":"f587e7a5-825a-4c95-ac79-a53f43ed52c8"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"translateAR","content":"open Useful\nopen WebSharper\n\n[< Rpc >]\nlet translateAS source minified = \n    async {\n        let!    res  = TranslatorCaller.getJSW minified [] source |> Wrap.getAsyncR\n        return  res |> Result.mapMsgs (Seq.map (fun (e:ErrMsg) -> e.ErrMsg, e.IsWarning) >> Seq.toArray)\n    }\n    \n[< JavaScript >]\nlet translateAR source minified = \n    async {\n        let!   vO, msgs = translateAS source minified\n        return  Result (vO,  msgs |> Seq.map (fun (msg, wrn) -> ErrSimple(msg, wrn) :> ErrMsg) |> Seq.toArray)\n    }\n    ","parent":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},{"$":0,"Item":"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"}],"id":{"$":0,"Item":"95a237c8-a9ff-40d1-bd72-bd298b20af8c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Snippets","content":"module Snippets =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"","content":"let private displayHtml html = \n  let url = Server.instance.Value.AddPage(html)\n  System.Diagnostics.Process.Start(url) |> ignore\n\nfsi.AddPrinter(fun (chart:XPlot.GoogleCharts.GoogleChart) ->\n  let ch = chart |> XPlot.GoogleCharts.Chart.WithSize (800, 600)\n  ch.GetHtml() |> displayHtml\n  \"(Google Chart)\")\n\nfsi.AddPrinter(fun (chart:XPlot.Plotly.PlotlyChart) ->\n  \"\"\"<!DOCTYPE html>\n  <html>\n  <head>\n      <title>Plotly Chart</title>\n      <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script>\n  </head>\n  <body>\"\"\" + chart.GetInlineHtml() + \"</body></html>\" |> displayHtml","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"e620b2e0-e518-4992-86f3-bc9623015345"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Free Monad","content":"(**\nFree Monad - Interpreter pattern in F#\n================================\n\nAn analysis of the Free Monad - Interpreter pattern in F# from a definition\ncreated by erdeszt and based on: http://programmers.stackexchange.com/a/242803/145941\n\nThe DSL\n-------\n\nFirst we define a DSL for our actions. Each action points to the next action using the `'next` generic type, \nevery action has a `'next` that in turn could be a DSL, thus chaining them.\n*)\ntype DSL<'next> =\n    | Set of key: string * value: string *  'next\n    | Get of key: string *       (string -> 'next)\n(** \n* `Get` returns a string which is passed to a function. `id` function can be used to finish the chain.\n* `Set` doesn't return anything, so the `'next` portion is the next DSL element in the chain, or a constant like `()` to finish.\n\nNote that used this way `'next` can be anything. It does not have to be a DSL value, so there is no real implication of a chain of DSLs.\n\nThis is what 3 actions in the DSL may look like.\n*)\nlet ex1 = Set (\"name\", \"John\"\n             , Get (\"name\"\n                  , fun name -> Set (\"greeting\", sprintf \"Hello %s\" name, () )\n                   )\n              )\n(**\n`val ex1 : DSL<DSL<DSL<unit>>> =\n  Set (\"name\",\"John\",Get (\"name\",<fun:ex1@23-4>))`\n\nNotice how the resulting type `DSL<DSL<DSL<unit>>>` is nested and not generic. \nThis means a strongly type function cannot process all posible values.\n\nThe Free Monad\n--------------\n\nHere comes the Free Monad `ChainDSL` to the rescue.\n*)\n\ntype ChainDSL<'a> =\n    | Do     of DSL<ChainDSL<'a>>\n    | Return of 'a\n\n(**\nThe `Do` option creates a chain of `ChainDSL`s that ends with the `Return` option.\nThis chain ends up having a type equal to the last `DSL` in the chain.\nThis is almost like creating a `List` of `DSL`s (`List<DSL<'a>> or DSL<'a> list`), \nexcept that each `DSL` in the chain can be of a different type.\n\nLets look at the same value above with `ChainDSL`:\n*)\n\nlet exF1 = Do (Set (\"name\", \"John\"\n                  , Do (Get (\"name\"\n                           , fun name -> Do (Set (\"greeting\", sprintf \"Hello %s\" name, Return () )) \n                            )\n                       )\n                   )\n              )\n(**\n`val exF1 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:exF1@49-3>))))`\n\nCompare the resulting type with the prior case: `ChainDSL<unit>` vs `DSL<DSL<DSL<unit>>>`.\nNo matter how deep the chain is, the value will always be of type `ChainDSL<unit>` or `ChainDSL<string>`.\n\n\nBut creating the chain is much more complex than before.\nTo solve that, lets create two helper functions: get and set.\n*)\nlet get key       = Do (Get (key, fun value -> Return value))\nlet set key value = Do (Set (key,     value,   Return ()   ))    \n(**\n`val get : key:string -> ChainDSL<string>`\n\n`val set : key:string -> value:string -> ChainDSL<unit>`\n\nNotice `get` returns a `ChainDSL<string>` and `set` returns a `ChainDSL<unit>`.\nThey both return a `ChainDSL` chain with a single `DSL` action.\n\nWith these functions we can create Get & Set operations like this:\n*)\nlet setName     name = set \"name\"     name\nlet getName          = get \"name\"\nlet setGreeting name = set \"greeting\" (sprintf \"Hello %s\" name)\n(**\nbut they are not chained together like before.\n\nBinding it together\n-------------------\n\nTo chain them we will need to define a bind function for the ChainDSL.\nWe start with a map function for DSL, thus making DSL a functor:\n*)\nlet mapDSL: ('a -> 'b) -> DSL<'a> -> DSL<'b> = \n    fun     f             action  ->\n        match action with\n        | Get (key,        fNext) -> Get (key,        fNext >> f)\n        | Set (key, value,  next) -> Set (key, value,  next |> f)\n\n(**\nAll `mapDSL` does is apply the function `f` to the `'next` part of the `DSL`.\nIn other words go to the next node in the chain.\n\nNext we define the bind function for ChainDSL, finally making it a monad:\n*)\nlet bindChain: ('a -> ChainDSL<'b>) -> ChainDSL<'a> -> ChainDSL<'b> =\n    fun        fChain                  chainTo      ->\n        let rec appendTo chain =\n            match chain with\n            | Return a   -> fChain a\n            | Do     dsl -> Do (mapDSL appendTo dsl)\n        appendTo chainTo\n(** \n`bindChain` is similar and acts like the List.append function, it concatenates two chains of `ChainDSL`s. \nThe difference is that the chain to be appended `fChain` is passed within a function.\n`bindChain` navigates recursively down `chainTo` and replaces the last element with the result of `fChain`:\n\n* On the `Do` side `bindChain` calls `mapDSL` to apply the function to the next `ChainDSL` node.\n* On the `Return` side it replaces the 'Return a' for a call to the chain to be appended `fChain`.\n\nIn a sense `ChainDSL` is actually the opposite of a `List<DSL<'a>>`. In a List new elements are\ninserted at the head, here they are attached at the tail end.\n\nNow we can bind setName, getName & setResult from above like this: *)\n\nlet exF2 = setName \"John\" \n           |> bindChain (fun _    -> getName         )\n           |> bindChain (fun name -> setGreeting name)\n\n(** \n`val exF2 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nwhich is the same as this: *)\n\nlet exF3 = set \"name\" \"John\" \n           |> bindChain (fun _ -> get \"name\"                           )\n           |> bindChain (fun v -> set \"greeting\" (sprintf \"Hello %s\" v))\n(** \n`val exF3 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nand this: *)\nlet (>>=) v f = bindChain f v\n\nlet exF4 = set \"name\" \"John\" \n           >>= fun _    -> get \"name\" \n           >>= fun name -> set \"greeting\" (sprintf \"Hello %s\" name)\n(**\n`val exF4 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nUsing Computational Expressions\n-------------------------------\n\nNow lets try it with Computational Expressions.\nFirst we define a builder class.\n*)\n\ntype ChainDSLBuilder () =\n    member this.Return      v = Return v\n    member this.ReturnFrom mv = mv\n    member this.Zero       () = Return ()\n    member this.Bind   (v, f) = v >>= f\n\nlet chainDSL = ChainDSLBuilder ()\n\n(**\nAnd now we use the computational expression like this.\n*)\n\nlet exF5 = chainDSL {\n    do!         set \"name\"     \"John\"\n    let! name = get \"name\"\n    do!         set \"greeting\" (sprintf \"Hello %s\" name)\n}\n(**\n`val exF5 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nThe Interpreter(s)\n------------------\n  \nNow we are going to create an interpreter to execute the AST created.\n\nThis first version is very simple it does not store or retrieve any values, just prints out the commands.\n*)\n(*** define-output:interpreter1 ***)    \nlet rec interpreter1: ChainDSL<'a> -> 'a =\n    fun               chain        ->\n        match chain with\n        | Return v -> printfn \"return %A\" v\n                      v\n        | Do   dsl -> \n            match dsl with\n            | Get(key,        nextF) -> printfn \"Get %s\" key\n                                        nextF (sprintf \"<get.%s>\" key) \n            | Set(key, value, next ) -> printfn \"Set %s '%s'\" key value\n                                        next                           \n            |> interpreter1\n\ninterpreter1 exF5\n(*** include-output:interpreter1 ***)\n(**\nThis next version actually stores and retrieves the values in a `Map` object, and when finished prints its content. \n*)\n(*** define-output:interpreter2 ***)    \nlet interpreter2 chain = \n    let rec interpreter2r: Map<string, string> -> ChainDSL<'a> -> 'a =\n        fun                dataStore              chain        ->\n            match chain with\n            | Return v -> printfn \"return %A\\n%A\" v dataStore\n                          v\n            | Do   dsl -> \n                match dsl with\n                | Get(key,        nextF) -> dataStore \n                                            |> Map.find key \n                                            |> (fun v -> printfn \"Get %s -> '%s'\" key v ; v )\n                                            |> nextF\n                                            |> interpreter2r dataStore\n                | Set(key, value, next ) -> printfn \"Set %s '%s'\" key value\n                                            next\n                                            |> interpreter2r (dataStore |> Map.add key value)\n\n    interpreter2r (Map.ofList []) chain\n\ninterpreter2 exF5\n(*** include-output:interpreter2 ***)\n\n(**\nA slightly longer example:\n*)\n\n(*** define-output:interpreter2b ***)    \n\nchainDSL {\n    do!           set \"first-name\" \"John\"\n    do!           set \"last-name\"  \"Smith\"\n    let! first  = get \"first-name\"\n    let! last   = get \"last-name\"\n    do!           set \"full-name\" (first + \" \"  + last)\n    let! full   = get \"full-name\"\n    return        sprintf \"Hello %s\" full\n}\n|> interpreter2\n(** Output:*)\n(*** include-output:interpreter2b ***)\n(** Return value:*)\n(*** include-it:interpreter2b ***)\n(**\nTrying to replicate this last example without the computational expression \nrequires explicitly nesting some of the calls.\n\nIt would look like this:\n\n*)\n(*** define-output:interpreter2c ***)    \n\nset \"first-name\" \"John\" \n>>= fun _     -> set \"last-name\"  \"Smith\"            \n>>= fun _     -> get \"first-name\"                    \n>>= fun first -> get \"last-name\" \n                 >>= fun last -> set \"full-name\" (first + \" \"  + last)\n>>= fun _     -> get \"full-name\"\n>>= fun full  -> Return (sprintf \"Hello %s\" full)\n|> interpreter2\n(** Output:*)\n(*** include-output:interpreter2c ***)\n(** Return value:*)\n(*** include-it:interpreter2c ***)\n\n(**\nTwo in one\n----------\n\nSo, do we really need two types, the Free Monad and the DSL?\n\nI do not think it is necessary, the free monad helps in binding the elements of the DSL. \nThe same can be achieved just by adding the `Return` option to the DSL.\n\nHere is the same implementation with just the DSL type:\n*)\n\nmodule DSL2 =\n    type DSL<'a> =\n        | Set of key: string * value: string *  DSL<'a>\n        | Get of key: string *       (string -> DSL<'a>)\n        | Return of 'a\n    \n    let set key value = Set (key, value,          Return ())\n    let get key       = Get (key,        fun v -> Return v )\n    \n    let bind: ('a -> DSL<'b>) -> DSL<'a> -> DSL<'b> =\n        fun   fChain             chainTo ->\n           let rec appendTo chain =\n               match chain with\n               | Set (k, v,  next) -> Set (k, v,  next |> appendTo)\n               | Get (k,    fNext) -> Get (k,    fNext >> appendTo)\n               | Return  v         -> fChain v\n           appendTo chainTo\n\n    let (>>=) v f = bind f v\n\n    let interpreter2 dsl =\n        let rec interpreter2r: Map<string, string> -> DSL<'a> -> 'a =\n            fun                dataStore              dslR    ->\n                match dslR with\n                | Return v               -> printfn \"return %A\\n%A\" v dataStore\n                                            v\n                | Get(key,        nextF) -> dataStore \n                                            |> Map.find key \n                                            |> (fun v -> printfn \"Get %s -> '%s'\" key v ; v )\n                                            |> nextF\n                                            |> interpreter2r dataStore\n                | Set(key, value, next ) -> printfn \"Set %s '%s'\" key value\n                                            next\n                                            |> interpreter2r (dataStore |> Map.add key value)\n        interpreter2r (Map.ofList []) dsl\n\n(**\nThere you have it the DSL definition, helper functions, the bind function and the interpreter.\nHere is the last example again.\n*)\n(*** define-output:dsl2 ***)    \n\n    set \"first-name\" \"John\" \n    >>= fun _     -> set \"last-name\"  \"Smith\"            \n    >>= fun _     -> get \"first-name\"                    \n    >>= fun first -> get \"last-name\" \n                     >>= fun last -> set \"full-name\" (first + \" \"  + last)\n    >>= fun _     -> get \"full-name\"\n    >>= fun full  -> Return (sprintf \"Hello %s\" full)\n    |> interpreter2\n(** Output:*)\n(*** include-output:dsl2 ***)\n(** Return value:*)\n(*** include-it:dsl2 ***)    \n(*** hide ***)\ninterpreter2 exF1\ninterpreter2 exF2\ninterpreter2 exF3\ninterpreter2 exF4\ninterpreter2 exF5\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"8ee6b535-3615-4066-8917-9125cf8a1f20"},"expanded":true,"level":0,"levelCode":0,"properties":{"CSS":".CodeMirror span.cm-comment {\nbackground: white;\nfont-style: normal;\nfont-weight: 600;\ncolor: black;\n}"}},{"name":"UNLOAD FSI","content":"#define UNLOAD_FSI\n\n#if WEBSHARPER\n#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Core.JavaScript.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.JavaScript.dll\"\nopen WebSharper\n[< JavaScript >]\n#endif\nlet a = 9 + 8\n\n7 * 3\n|> printfn \"%A\"\n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"1d18fdb5-2488-4ac9-813a-c96a66b9cd13"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FSharp.Compiler.Service.Tests.Common","content":"open System.IO\nopen System.Collections.Generic\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n\n#if FX_RESHAPED_REFLECTION\nopen ReflectionAdapters\n#endif\n\n#if DOTNETCORE\nlet readRefs (folder : string) (projectFile: string) =\n    let runProcess (workingDir: string) (exePath: string) (args: string) =\n        let psi = System.Diagnostics.ProcessStartInfo()\n        psi.FileName <- exePath\n        psi.WorkingDirectory <- workingDir\n        psi.RedirectStandardOutput <- false\n        psi.RedirectStandardError <- false\n        psi.Arguments <- args\n        psi.CreateNoWindow <- true\n        psi.UseShellExecute <- false\n\n        use p = new System.Diagnostics.Process()\n        p.StartInfo <- psi\n        p.Start() |> ignore\n        p.WaitForExit()\n\n        let exitCode = p.ExitCode\n        exitCode, ()\n\n    let runCmd exePath args = runProcess folder exePath (args |> String.concat \" \")\n    let msbuildExec = Dotnet.ProjInfo.Inspect.dotnetMsbuild runCmd\n    let result = Dotnet.ProjInfo.Inspect.getProjectInfo ignore msbuildExec Dotnet.ProjInfo.Inspect.getFscArgs [] projectFile\n    match result with\n    | Ok(Dotnet.ProjInfo.Inspect.GetResult.FscArgs x) ->\n        x\n        |> List.filter (fun s -> s.StartsWith(\"-r:\"))\n        |> List.map (fun s -> s.Replace(\"-r:\", \"\"))\n    | _ -> []\n#endif\n\n\n// Create one global interactive checker instance\nlet checker = FSharpChecker.Create()\n\ntype TempFile(ext, contents) = \n    let tmpFile =  Path.ChangeExtension(System.IO.Path.GetTempFileName() , ext)\n    do File.WriteAllText(tmpFile, contents)\n    interface System.IDisposable with \n        member x.Dispose() = try File.Delete tmpFile with _ -> ()\n    member x.Name = tmpFile\n\n#nowarn \"57\"\n\nlet getBackgroundParseResultsForScriptText (input) = \n    use file =  new TempFile(\"fsx\", input)\n    let checkOptions, _diagnostics = checker.GetProjectOptionsFromScript(file.Name, input) |> Async.RunSynchronously\n    checker.GetBackgroundParseResultsForFileInProject(file.Name, checkOptions)  |> Async.RunSynchronously\n\n\nlet getBackgroundCheckResultsForScriptText (input) = \n    use file =  new TempFile(\"fsx\", input)\n    let checkOptions, _diagnostics = checker.GetProjectOptionsFromScript(file.Name, input) |> Async.RunSynchronously\n    checker.GetBackgroundCheckResultsForFileInProject(file.Name, checkOptions) |> Async.RunSynchronously\n\n\nlet sysLib nm = \n#if !FX_ATLEAST_PORTABLE\n    if System.Environment.OSVersion.Platform = System.PlatformID.Win32NT then // file references only valid on Windows \n        let programFilesx86Folder = System.Environment.GetEnvironmentVariable(\"PROGRAMFILES(X86)\")\n        programFilesx86Folder + @\"\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\\" + nm + \".dll\"\n    else\n#endif\n#if FX_NO_RUNTIMEENVIRONMENT\n        let sysDir = System.AppContext.BaseDirectory\n#else\n        let sysDir = System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory()\n#endif\n        let (++) a b = System.IO.Path.Combine(a,b)\n        sysDir ++ nm + \".dll\" \n\n[<AutoOpen>]\nmodule Helpers = \n    open System\n    type DummyType = A | B\n    let PathRelativeToTestAssembly p = Path.Combine(Path.GetDirectoryName(Uri(typeof<Microsoft.FSharp.Compiler.SourceCodeServices.FSharpChecker>.Assembly.CodeBase).LocalPath), p)\n\nlet fsCoreDefaultReference() = \n    PathRelativeToTestAssembly \"FSharp.Core.dll\"\n\n(*\n#if !FX_ATLEAST_PORTABLE\n     if System.Environment.OSVersion.Platform = System.PlatformID.Win32NT then // file references only valid on Windows \n        let programFilesx86Folder = System.Environment.GetEnvironmentVariable(\"PROGRAMFILES(X86)\")\n        programFilesx86Folder + @\"\\Reference Assemblies\\Microsoft\\FSharp\\.NETFramework\\v4.0\\4.4.0.0\\FSharp.Core.dll\"  \n     else \n#endif\n        sysLib \"FSharp.Core\"\n*)\n\nlet mkStandardProjectReferences () = \n#if DOTNETCORE\n            let file = \"Sample_NETCoreSDK_FSharp_Library_netstandard1.6.fsproj\"\n            let projDir = Path.Combine(__SOURCE_DIRECTORY__, \"../projects/Sample_NETCoreSDK_FSharp_Library_netstandard1.6\")\n            readRefs projDir file\n#else\n            [ yield sysLib \"mscorlib\"\n              yield sysLib \"System\"\n              yield sysLib \"System.Core\"\n              yield fsCoreDefaultReference() ]\n#endif              \n\nlet mkProjectCommandLineArgs (dllName, fileNames) = \n  let args = \n    [|  yield \"--simpleresolution\" \n        yield \"--noframework\" \n        yield \"--debug:full\" \n        yield \"--define:DEBUG\" \n#if NETCOREAPP1_0\n        yield \"--targetprofile:netcore\" \n#endif\n        yield \"--optimize-\" \n        yield \"--out:\" + dllName\n        yield \"--doc:test.xml\" \n        yield \"--warn:3\" \n        yield \"--fullpaths\" \n        yield \"--flaterrors\" \n        yield \"--target:library\" \n        for x in fileNames do \n            yield x\n        let references = mkStandardProjectReferences ()\n        for r in references do\n            yield \"-r:\" + r\n     |]\n  printfn \"dllName = %A, args = %A\" dllName args\n  args\n\n#if DOTNETCORE\nlet mkProjectCommandLineArgsForScript (dllName, fileNames) = \n    [|  yield \"--simpleresolution\" \n        yield \"--noframework\" \n        yield \"--debug:full\" \n        yield \"--define:DEBUG\" \n#if NETCOREAPP1_0\n        yield \"--targetprofile:netcore\" \n#endif\n        yield \"--optimize-\" \n        yield \"--out:\" + dllName\n        yield \"--doc:test.xml\" \n        yield \"--warn:3\" \n        yield \"--fullpaths\" \n        yield \"--flaterrors\" \n        yield \"--target:library\" \n        for x in fileNames do \n            yield x\n        let references = mkStandardProjectReferences ()\n        for r in references do\n            yield \"-r:\" + r\n     |]\n#endif\n\nlet parseAndCheckScript (file, input) = \n\n#if DOTNETCORE\n    let dllName = Path.ChangeExtension(file, \".dll\")\n    let projName = Path.ChangeExtension(file, \".fsproj\")\n    let args = mkProjectCommandLineArgsForScript (dllName, [file])\n    printfn \"file = %A, args = %A\" file args\n    let projectOptions = checker.GetProjectOptionsFromCommandLineArgs (projName, args)\n\n#else    \n    let projectOptions, _diagnostics = checker.GetProjectOptionsFromScript(file, input) |> Async.RunSynchronously\n    printfn \"projectOptions = %A\" projectOptions\n#endif\n\n    let parseResult, typedRes = checker.ParseAndCheckFileInProject(file, 0, input, projectOptions) |> Async.RunSynchronously\n    \n    // if parseResult.Errors.Length > 0 then\n    //     printfn \"---> Parse Input = %A\" input\n    //     printfn \"---> Parse Error = %A\" parseResult.Errors\n\n    match typedRes with\n    | FSharpCheckFileAnswer.Succeeded(res) -> parseResult, res\n    | res -> failwithf \"Parsing did not finish... (%A)\" res\n\nlet parseSourceCode (name: string, code: string) =\n    let location = Path.Combine(Path.GetTempPath(),\"test\"+string(hash (name, code)))\n    try Directory.CreateDirectory(location) |> ignore with _ -> ()\n\n    let projPath = Path.Combine(location, name + \".fsproj\")\n    let filePath = Path.Combine(location, name + \".fs\")\n    let dllPath = Path.Combine(location, name + \".dll\")\n    let args = mkProjectCommandLineArgs(dllPath, [filePath])\n    let options, errors = checker.GetParsingOptionsFromCommandLineArgs(List.ofArray args)\n    let parseResults = checker.ParseFile(filePath, code, options) |> Async.RunSynchronously\n    parseResults.ParseTree\n\n/// Extract range info \nlet tups (m:Range.range) = (m.StartLine, m.StartColumn), (m.EndLine, m.EndColumn)\n\n/// Extract range info  and convert to zero-based line  - please don't use this one any more\nlet tupsZ (m:Range.range) = (m.StartLine-1, m.StartColumn), (m.EndLine-1, m.EndColumn)\n\nlet attribsOfSymbolUse (s:FSharpSymbolUse) = \n    [ if s.IsFromDefinition then yield \"defn\" \n      if s.IsFromType then yield \"type\"\n      if s.IsFromAttribute then yield \"attribute\"\n      if s.IsFromDispatchSlotImplementation then yield \"override\"\n      if s.IsFromPattern then yield \"pattern\" \n      if s.IsFromComputationExpression then yield \"compexpr\" ] \n\nlet attribsOfSymbol (s:FSharpSymbol) = \n    [ match s with \n        | :? FSharpField as v -> \n            yield \"field\"\n            if v.IsCompilerGenerated then yield \"compgen\"\n            if v.IsDefaultValue then yield \"default\"\n            if v.IsMutable then yield \"mutable\"\n            if v.IsVolatile then yield \"volatile\"\n            if v.IsStatic then yield \"static\"\n            if v.IsLiteral then yield sprintf \"%A\" v.LiteralValue.Value\n\n\n        | :? FSharpEntity as v -> \n            v.TryFullName |> ignore // check there is no failure here\n            if v.IsNamespace then yield \"namespace\"\n            if v.IsFSharpModule then yield \"module\"\n            if v.IsByRef then yield \"byref\"\n            if v.IsClass then yield \"class\"\n            if v.IsDelegate then yield \"delegate\"\n            if v.IsEnum then yield \"enum\"\n            if v.IsFSharpAbbreviation then yield \"abbrev\"\n            if v.IsFSharpExceptionDeclaration then yield \"exn\"\n            if v.IsFSharpRecord then yield \"record\"\n            if v.IsFSharpUnion then yield \"union\"\n            if v.IsInterface then yield \"interface\"\n            if v.IsMeasure then yield \"measure\"\n#if EXTENSIONTYPING\n            if v.IsProvided then yield \"provided\"\n            if v.IsStaticInstantiation then yield \"staticinst\"\n            if v.IsProvidedAndErased then yield \"erased\"\n            if v.IsProvidedAndGenerated then yield \"generated\"\n#endif\n            if v.IsUnresolved then yield \"unresolved\"\n            if v.IsValueType then yield \"valuetype\"\n\n        | :? FSharpMemberOrFunctionOrValue as v -> \n            if v.IsActivePattern then yield \"apat\"\n            if v.IsDispatchSlot then yield \"slot\"\n            if v.IsModuleValueOrMember && not v.IsMember then yield \"val\"\n            if v.IsMember then yield \"member\"\n            if v.IsProperty then yield \"prop\"\n            if v.IsExtensionMember then yield \"extmem\"\n            if v.IsPropertyGetterMethod then yield \"getter\"\n            if v.IsPropertySetterMethod then yield \"setter\"\n            if v.IsEvent then yield \"event\"\n            if v.EventForFSharpProperty.IsSome then yield \"clievent\"\n            if v.IsEventAddMethod then yield \"add\"\n            if v.IsEventRemoveMethod then yield \"remove\"\n            if v.IsTypeFunction then yield \"typefun\"\n            if v.IsCompilerGenerated then yield \"compgen\"\n            if v.IsImplicitConstructor then yield \"ctor\"\n            if v.IsMutable then yield \"mutable\" \n            if v.IsOverrideOrExplicitInterfaceImplementation then yield \"overridemem\"\n            if v.IsInstanceMember && not v.IsInstanceMemberInCompiledCode && not v.IsExtensionMember then yield \"funky\"\n            if v.IsExplicitInterfaceImplementation then yield \"intfmem\"\n//            if v.IsConstructorThisValue then yield \"ctorthis\"\n//            if v.IsMemberThisValue then yield \"this\"\n//            if v.LiteralValue.IsSome then yield \"literal\"\n        | _ -> () ]\n\nlet rec allSymbolsInEntities compGen (entities: IList<FSharpEntity>) = \n    [ for e in entities do \n          yield (e :> FSharpSymbol) \n          for gp in e.GenericParameters do \n            if compGen || not gp.IsCompilerGenerated then \n             yield (gp :> FSharpSymbol)\n          for x in e.MembersFunctionsAndValues do\n             if compGen || not x.IsCompilerGenerated then \n               yield (x :> FSharpSymbol)\n             for gp in x.GenericParameters do \n              if compGen || not gp.IsCompilerGenerated then \n               yield (gp :> FSharpSymbol)\n          for x in e.UnionCases do\n             yield (x :> FSharpSymbol)\n             for f in x.UnionCaseFields do\n                 if compGen || not f.IsCompilerGenerated then \n                     yield (f :> FSharpSymbol)\n          for x in e.FSharpFields do\n             if compGen || not x.IsCompilerGenerated then \n                 yield (x :> FSharpSymbol)\n          yield! allSymbolsInEntities compGen e.NestedEntities ]\n\n\nlet coreLibAssemblyName =\n#if DOTNETCORE\n    \"System.Runtime\"\n#else\n    \"mscorlib\"\n#endif\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"560bbd44-ad59-4b88-81d7-c27a14b0ad2e"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FsUnit NUnit","content":"\n// To run the tests in this file:\n//\n// Technique 1: Compile VisualFSharp.Unittests.dll and run it as a set of unit tests\n//\n// Technique 2:\n//\n//   Enable some tests in the #if EXE section at the end of the file, \n//   then compile this file as an EXE that has InternalsVisibleTo access into the\n//   appropriate DLLs.  This can be the quickest way to get turnaround on updating the tests\n//   and capturing large amounts of structured output.\n(*\n    cd Debug\\net40\\bin\n    .\\fsc.exe --define:EXE -r:.\\Microsoft.Build.Utilities.Core.dll -o VisualFSharp.Unittests.exe -g --optimize- -r .\\FSharp.LanguageService.Compiler.dll -r nunit.framework.dll ..\\..\\..\\tests\\service\\FsUnit.fs ..\\..\\..\\tests\\service\\Common.fs /delaysign /keyfile:..\\..\\..\\src\\fsharp\\msft.pubkey ..\\..\\..\\tests\\service\\EditorTests.fs \n    .\\VisualFSharp.Unittests.exe \n*)\n// Technique 3: \n// \n//    Use F# Interactive.  This only works for FSHarp.Compiler.Service.dll which has a public API\n\n#if INTERACTIVE\n#r @\"D:\\Abe\\CIPHERWorkspace\\visualfsharp\\fcs\\FSharp.Compiler.Service\\obj\\Debug\\FSharp.Compiler.Service.dll\" \n#r \"../packages/NUnit/lib/net45/nunit.framework.dll\"\n#r \"../packages/FsUnit/lib/net45/FsUnit.NUnit.dll\"\n#load \"FsUnit.fs\"\n#load \"Common.fs\"\n#else\nmodule Tests.Service.Editor\n#endif\n\nopen NUnit.Framework\nopen FsUnitTyped\nopen System\nopen System.IO\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n\nlet stringMethods = \n#if DOTNETCORE\n    [\"Chars\"; \"CompareTo\"; \"Contains\"; \"CopyTo\"; \"EndsWith\"; \"Equals\";\n    \"GetHashCode\"; \"GetType\"; \"IndexOf\";\n    \"IndexOfAny\"; \"Insert\"; \"LastIndexOf\"; \"LastIndexOfAny\";\n    \"Length\"; \"PadLeft\"; \"PadRight\"; \"Remove\"; \"Replace\"; \"Split\";\n    \"StartsWith\"; \"Substring\"; \"ToCharArray\"; \"ToLower\"; \"ToLowerInvariant\";\n    \"ToString\"; \"ToUpper\"; \"ToUpperInvariant\"; \"Trim\"; \"TrimEnd\"; \"TrimStart\"]\n#else\n    [\"Chars\"; \"Clone\"; \"CompareTo\"; \"Contains\"; \"CopyTo\"; \"EndsWith\"; \"Equals\";\n    \"GetEnumerator\"; \"GetHashCode\"; \"GetType\"; \"GetTypeCode\"; \"IndexOf\";\n    \"IndexOfAny\"; \"Insert\"; \"IsNormalized\"; \"LastIndexOf\"; \"LastIndexOfAny\";\n    \"Length\"; \"Normalize\"; \"PadLeft\"; \"PadRight\"; \"Remove\"; \"Replace\"; \"Split\";\n    \"StartsWith\"; \"Substring\"; \"ToCharArray\"; \"ToLower\"; \"ToLowerInvariant\";\n    \"ToString\"; \"ToUpper\"; \"ToUpperInvariant\"; \"Trim\"; \"TrimEnd\"; \"TrimStart\"]\n#endif\n\nlet input = \n  \"\"\"\n  open System\n  \n  let foo() = \n    let msg = String.Concat(\"Hello\",\" \",\"world\")\n    if true then \n      printfn \"%s\" msg.\n  \"\"\"\n\n[<Test>]\nlet ``Intro test`` () = \n\n    // Split the input & define file name\n    let inputLines = input.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults =  parseAndCheckScript(file, input) \n    let identToken = FSharpTokenTag.IDENT\n//    let projectOptions = checker.GetProjectOptionsFromScript(file, input) |> Async.RunSynchronously\n\n    // We only expect one reported error. However,\n    // on Unix, using filenames like /home/user/Test.fsx gives a second copy of all parse errors due to the\n    // way the load closure for scripts is generated. So this returns two identical errors\n    (match typeCheckResults.Errors.Length with 1 | 2 -> true | _ -> false)  |> shouldEqual true\n\n    // So we check that the messages are the same\n    for msg in typeCheckResults.Errors do \n        printfn \"Good! got an error, hopefully with the right text: %A\" msg\n        msg.Message.Contains(\"Missing qualification after '.'\") |> shouldEqual true\n\n    // Get tool tip at the specified location\n    let tip = typeCheckResults.GetToolTipText(4, 7, inputLines.[1], [\"foo\"], identToken) |> Async.RunSynchronously\n    // (sprintf \"%A\" tip).Replace(\"\\n\",\"\") |> shouldEqual \"\"\"FSharpToolTipText [Single (\"val foo : unit -> unitFull name: Test.foo\",None)]\"\"\"\n    // Get declarations (autocomplete) for a location\n    let decls =  typeCheckResults.GetDeclarationListInfo(Some parseResult, 7, 23, inputLines.[6], [], \"msg\", (fun _ -> []), fun _ -> false)|> Async.RunSynchronously\n    CollectionAssert.AreEquivalent(stringMethods,[ for item in decls.Items -> item.Name ])\n    // Get overloads of the String.Concat method\n    let methods = typeCheckResults.GetMethods(5, 27, inputLines.[4], Some [\"String\"; \"Concat\"]) |> Async.RunSynchronously\n\n    methods.MethodName  |> shouldEqual \"Concat\"\n\n    // Print concatenated parameter lists\n    [ for mi in methods.Methods do\n        yield methods.MethodName , [ for p in mi.Parameters do yield p.Display ] ]\n        |> shouldEqual\n              [(\"Concat\", [\"[<ParamArray>] args: obj []\"]);\n               (\"Concat\", [\"[<ParamArray>] values: string []\"]);\n               (\"Concat\", [\"values: Collections.Generic.IEnumerable<'T>\"]);\n               (\"Concat\", [\"values: Collections.Generic.IEnumerable<string>\"]);\n               (\"Concat\", [\"arg0: obj\"]); (\"Concat\", [\"arg0: obj\"; \"arg1: obj\"]);\n               (\"Concat\", [\"str0: string\"; \"str1: string\"]);\n               (\"Concat\", [\"arg0: obj\"; \"arg1: obj\"; \"arg2: obj\"]);\n               (\"Concat\", [\"str0: string\"; \"str1: string\"; \"str2: string\"]);\n#if !DOTNETCORE\n               (\"Concat\", [\"arg0: obj\"; \"arg1: obj\"; \"arg2: obj\"; \"arg3: obj\"]);\n#endif               \n               (\"Concat\", [\"str0: string\"; \"str1: string\"; \"str2: string\"; \"str3: string\"])]\n\n\n#if !INTERACTIVE && !DOTNETCORE // InternalsVisibleTo on IncrementalBuild.LocallyInjectCancellationFault not working for some reason?\n[<Test>]\nlet ``Basic cancellation test`` () = \n   try \n    printfn \"locally injecting a cancellation condition in incremental building\"\n    use _holder = IncrementalBuild.LocallyInjectCancellationFault()\n    \n    // Split the input & define file name\n    let inputLines = input.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    async { \n        checker.ClearLanguageServiceRootCachesAndCollectAndFinalizeAllTransients()\n        let! checkOptions, _diagnostics = checker.GetProjectOptionsFromScript(file, input) \n        let! parseResult, typedRes = checker.ParseAndCheckFileInProject(file, 0, input, checkOptions) \n        return parseResult, typedRes\n    } |> Async.RunSynchronously\n      |> ignore\n    Assert.Fail(\"expected a cancellation\")\n   with :? OperationCanceledException -> ()\n#endif\n\n[<Test>]\nlet ``GetMethodsAsSymbols should return all overloads of a method as FSharpSymbolUse`` () =\n\n    let extractCurriedParams (symbol:FSharpSymbolUse) =\n        match symbol.Symbol with\n        | :? FSharpMemberOrFunctionOrValue as mvf ->\n            [for pg in mvf.CurriedParameterGroups do \n                for (p:FSharpParameter) in pg do \n                    yield p.DisplayName, p.Type.Format (symbol.DisplayContext)]\n        | _ -> []\n\n    // Split the input & define file name\n    let inputLines = input.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults =  parseAndCheckScript(file, input)\n    let methodsSymbols = typeCheckResults.GetMethodsAsSymbols(5, 27, inputLines.[4], [\"String\"; \"Concat\"]) |> Async.RunSynchronously\n    match methodsSymbols with\n    | Some methods ->\n        [ for ms in methods do\n            yield ms.Symbol.DisplayName, extractCurriedParams ms ]\n        |> List.sortBy (fun (_name, parameters) -> parameters.Length, (parameters |> List.map snd ))\n        |> shouldEqual\n            [(\"Concat\", [(\"values\", \"Collections.Generic.IEnumerable<'T>\")]);\n             (\"Concat\", [(\"values\", \"Collections.Generic.IEnumerable<string>\")]);\n             (\"Concat\", [(\"arg0\", \"obj\")]);\n             (\"Concat\", [(\"args\", \"obj []\")]);\n             (\"Concat\", [(\"values\", \"string []\")]);\n             (\"Concat\", [(\"arg0\", \"obj\"); (\"arg1\", \"obj\")]);\n             (\"Concat\", [(\"str0\", \"string\"); (\"str1\", \"string\")]);\n             (\"Concat\", [(\"arg0\", \"obj\"); (\"arg1\", \"obj\"); (\"arg2\", \"obj\")]);\n             (\"Concat\", [(\"str0\", \"string\"); (\"str1\", \"string\"); (\"str2\", \"string\")]);\n#if !DOTNETCORE\n             (\"Concat\", [(\"arg0\", \"obj\"); (\"arg1\", \"obj\"); (\"arg2\", \"obj\"); (\"arg3\", \"obj\")]);\n#endif\n             (\"Concat\", [(\"str0\", \"string\"); (\"str1\", \"string\"); (\"str2\", \"string\"); (\"str3\", \"string\")])]\n    | None -> failwith \"No symbols returned\"\n\n\nlet input2 = \n        \"\"\"\n[<System.CLSCompliant(true)>]\nlet foo(x, y) = \n    let msg = String.Concat(\"Hello\",\" \",\"world\")\n    if true then \n        printfn \"x = %d, y = %d\" x y \n        printfn \"%s\" msg\n\ntype C() = \n    member x.P = 1\n        \"\"\"\n\n[<Test>]\nlet ``Symbols basic test`` () = \n\n    let file = \"/home/user/Test.fsx\"\n    let untyped2, typeCheckResults2 = parseAndCheckScript(file, input2)\n\n    let partialAssemblySignature = typeCheckResults2.PartialAssemblySignature\n    \n    partialAssemblySignature.Entities.Count |> shouldEqual 1  // one entity\n\n[<Test>]\nlet ``Symbols many tests`` () = \n\n    let file = \"/home/user/Test.fsx\"\n    let untyped2, typeCheckResults2 = parseAndCheckScript(file, input2)\n\n    let partialAssemblySignature = typeCheckResults2.PartialAssemblySignature\n    \n    partialAssemblySignature.Entities.Count |> shouldEqual 1  // one entity\n    let moduleEntity = partialAssemblySignature.Entities.[0]\n\n    moduleEntity.DisplayName |> shouldEqual \"Test\"\n\n    let classEntity = moduleEntity.NestedEntities.[0]\n\n    let fnVal = moduleEntity.MembersFunctionsAndValues.[0]\n\n    fnVal.Accessibility.IsPublic |> shouldEqual true\n    fnVal.Attributes.Count |> shouldEqual 1\n    fnVal.CurriedParameterGroups.Count |> shouldEqual 1\n    fnVal.CurriedParameterGroups.[0].Count |> shouldEqual 2\n    fnVal.CurriedParameterGroups.[0].[0].Name.IsSome |> shouldEqual true\n    fnVal.CurriedParameterGroups.[0].[1].Name.IsSome |> shouldEqual true\n    fnVal.CurriedParameterGroups.[0].[0].Name.Value |> shouldEqual \"x\"\n    fnVal.CurriedParameterGroups.[0].[1].Name.Value |> shouldEqual \"y\"\n    fnVal.DeclarationLocation.StartLine |> shouldEqual 3\n    fnVal.DisplayName |> shouldEqual \"foo\"\n    fnVal.EnclosingEntity.Value.DisplayName |> shouldEqual \"Test\"\n    fnVal.EnclosingEntity.Value.DeclarationLocation.StartLine |> shouldEqual 1\n    fnVal.GenericParameters.Count |> shouldEqual 0\n    fnVal.InlineAnnotation |> shouldEqual FSharpInlineAnnotation.OptionalInline\n    fnVal.IsActivePattern |> shouldEqual false\n    fnVal.IsCompilerGenerated |> shouldEqual false\n    fnVal.IsDispatchSlot |> shouldEqual false\n    fnVal.IsExtensionMember |> shouldEqual false\n    fnVal.IsPropertyGetterMethod |> shouldEqual false\n    fnVal.IsImplicitConstructor |> shouldEqual false\n    fnVal.IsInstanceMember |> shouldEqual false\n    fnVal.IsMember |> shouldEqual false\n    fnVal.IsModuleValueOrMember |> shouldEqual true\n    fnVal.IsMutable |> shouldEqual false\n    fnVal.IsPropertySetterMethod |> shouldEqual false\n    fnVal.IsTypeFunction |> shouldEqual false\n\n    fnVal.FullType.IsFunctionType |> shouldEqual true // int * int -> unit\n    fnVal.FullType.GenericArguments.[0].IsTupleType |> shouldEqual true // int * int \n    let argTy1 = fnVal.FullType.GenericArguments.[0].GenericArguments.[0]\n\n    argTy1.TypeDefinition.DisplayName |> shouldEqual \"int\" // int\n\n    argTy1.HasTypeDefinition |> shouldEqual true\n    argTy1.TypeDefinition.IsFSharpAbbreviation |> shouldEqual true // \"int\"\n\n    let argTy1b = argTy1.TypeDefinition.AbbreviatedType\n    argTy1b.TypeDefinition.Namespace |> shouldEqual (Some \"Microsoft.FSharp.Core\")\n    argTy1b.TypeDefinition.CompiledName |> shouldEqual \"int32\" \n\n    let argTy1c = argTy1b.TypeDefinition.AbbreviatedType\n    argTy1c.TypeDefinition.Namespace |> shouldEqual (Some \"System\")\n    argTy1c.TypeDefinition.CompiledName |> shouldEqual \"Int32\" \n\n    let typeCheckContext = typeCheckResults2.ProjectContext\n    \n    typeCheckContext.GetReferencedAssemblies() |> List.exists (fun s -> s.FileName.Value.Contains(coreLibAssemblyName)) |> shouldEqual true\n    \n\nlet input3 = \n  \"\"\"\nlet date = System.DateTime.Now.ToString().PadRight(25)\n  \"\"\"\n\n[<Test>]\nlet ``Expression typing test`` () = \n\n    printfn \"------ Expression typing test -----------------\"\n    // Split the input & define file name\n    let inputLines = input3.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults =  parseAndCheckScript(file, input3) \n    let identToken = FSharpTokenTag.IDENT\n\n    for msg in typeCheckResults.Errors do \n        printfn \"***Expression typing test: Unexpected  error: %A\" msg.Message\n\n    typeCheckResults.Errors.Length |> shouldEqual 0\n\n    // Get declarations (autocomplete) for a location\n    //\n    // Getting the declarations at columns 42 to 43 with [], \"\" for the names and residue \n    // gives the results for the string type. \n    // \n    for col in 42..43 do \n        let decls =  typeCheckResults.GetDeclarationListInfo(Some parseResult, 2, col, inputLines.[1], [], \"\", (fun _ -> []), fun _ -> false)|> Async.RunSynchronously\n        let autoCompleteSet = set [ for item in decls.Items -> item.Name ]\n        autoCompleteSet |> shouldEqual (set stringMethods)\n\n// The underlying problem is that the parser error recovery doesn't include _any_ information for\n// the incomplete member:\n//    member x.Test = \n\n[<Test; Ignore(\"Currently failing, see #139\")>]\nlet ``Find function from member 1`` () = \n    let input = \n      \"\"\"\ntype Test() = \n    let abc a b c = a + b + c\n    member x.Test = \"\"\" \n\n    // Split the input & define file name\n    let inputLines = input.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults =  parseAndCheckScript(file, input) \n\n    let decls = typeCheckResults.GetDeclarationListInfo(Some parseResult, 4, 21, inputLines.[3], [], \"\", (fun _ -> []), fun _ -> false)|> Async.RunSynchronously\n    let item = decls.Items |> Array.tryFind (fun d -> d.Name = \"abc\")\n    decls.Items |> Seq.exists (fun d -> d.Name = \"abc\") |> shouldEqual true\n\n[<Test>]\nlet ``Find function from member 2`` () = \n    let input = \n      \"\"\"\ntype Test() = \n    let abc a b c = a + b + c\n    member x.Test = a\"\"\" \n\n    // Split the input & define file name\n    let inputLines = input.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults =  parseAndCheckScript(file, input) \n\n    let decls = typeCheckResults.GetDeclarationListInfo(Some parseResult, 4, 22, inputLines.[3], [], \"\", (fun _ -> []), fun _ -> false)|> Async.RunSynchronously\n    let item = decls.Items |> Array.tryFind (fun d -> d.Name = \"abc\")\n    decls.Items |> Seq.exists (fun d -> d.Name = \"abc\") |> shouldEqual true\n \n[<Test>]\nlet ``Find function from var`` () = \n    let input = \n      \"\"\"\ntype Test() = \n    let abc a b c = a + b + c\n    let test = \"\"\" \n\n    // Split the input & define file name\n    let inputLines = input.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults =  parseAndCheckScript(file, input) \n\n    let decls = typeCheckResults.GetDeclarationListInfo(Some parseResult, 4, 15, inputLines.[3], [], \"\", (fun _ -> []), fun _ -> false)|> Async.RunSynchronously\n    decls.Items |> Seq.exists (fun d -> d.Name = \"abc\") |> shouldEqual true\n\n[<Test; Ignore(\"Currently failing, see #139\")>]\nlet ``Symbol based find function from member 1`` () = \n    let input = \n      \"\"\"\ntype Test() = \n    let abc a b c = a + b + c\n    member x.Test = \"\"\" \n\n    // Split the input & define file name\n    let inputLines = input.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults =  parseAndCheckScript(file, input) \n\n    let decls = typeCheckResults.GetDeclarationListSymbols(Some parseResult, 4, 21, inputLines.[3], [], \"\", fun _ -> false)|> Async.RunSynchronously\n    //decls |> List.map (fun d -> d.Head.Symbol.DisplayName) |> printfn \"---> decls = %A\"\n    decls |> Seq.exists (fun d -> d.Head.Symbol.DisplayName = \"abc\") |> shouldEqual true\n\n[<Test>]\nlet ``Symbol based find function from member 2`` () = \n    let input = \n      \"\"\"\ntype Test() = \n    let abc a b c = a + b + c\n    member x.Test = a\"\"\" \n\n    // Split the input & define file name\n    let inputLines = input.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults =  parseAndCheckScript(file, input) \n\n    let decls = typeCheckResults.GetDeclarationListSymbols(Some parseResult, 4, 22, inputLines.[3], [], \"\", fun _ -> false)|> Async.RunSynchronously\n    //decls |> List.map (fun d -> d.Head.Symbol.DisplayName) |> printfn \"---> decls = %A\"\n    decls |> Seq.exists (fun d -> d.Head.Symbol.DisplayName = \"abc\") |> shouldEqual true\n\n[<Test>]\nlet ``Symbol based find function from var`` () = \n    let input = \n      \"\"\"\ntype Test() = \n    let abc a b c = a + b + c\n    let test = \"\"\" \n\n    // Split the input & define file name\n    let inputLines = input.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults =  parseAndCheckScript(file, input) \n\n    let decls = typeCheckResults.GetDeclarationListSymbols(Some parseResult, 4, 15, inputLines.[3], [], \"\", fun _ -> false)|> Async.RunSynchronously\n    //decls |> List.map (fun d -> d.Head.Symbol.DisplayName) |> printfn \"---> decls = %A\"\n    decls |> Seq.exists (fun d -> d.Head.Symbol.DisplayName = \"abc\") |> shouldEqual true\n\n[<Test>]\nlet ``Printf specifiers for regular and verbatim strings`` () = \n    let input = \n      \"\"\"let os = System.Text.StringBuilder()\nlet _ = Microsoft.FSharp.Core.Printf.printf \"%A\" 0\nlet _ = Printf.printf \"%A\" 0\nlet _ = Printf.kprintf (fun _ -> ()) \"%A\" 1\nlet _ = Printf.bprintf os \"%A\" 1\nlet _ = sprintf \"%*d\" 1\nlet _ = sprintf \"%7.1f\" 1.0\nlet _ = sprintf \"%-8.1e+567\" 1.0\nlet _ = sprintf @\"%-5s\" \"value\"\nlet _ = printfn @\"%-A\" -10\nlet _ = printf @\"\n            %-O\" -10\nlet _ = sprintf \"\n\n            %-O\" -10\nlet _ = List.map (sprintf @\"%A\n                           \")\nlet _ = (10, 12) ||> sprintf \"%A\n                              %O\"\nlet _ = sprintf \"\\n%-8.1e+567\" 1.0\nlet _ = sprintf @\"%O\\n%-5s\" \"1\" \"2\" \nlet _ = sprintf \"%%\"\nlet _ = sprintf \" %*%\" 2\nlet _ = sprintf \"  %.*%\" 2\nlet _ = sprintf \"   %*.1%\" 2\nlet _ = sprintf \"    %*s\" 10 \"hello\"\nlet _ = sprintf \"     %*.*%\" 2 3\nlet _ = sprintf \"      %*.*f\" 2 3 4.5\nlet _ = sprintf \"       %.*f\" 3 4.5\nlet _ = sprintf \"        %*.1f\" 3 4.5\nlet _ = sprintf \"         %6.*f\" 3 4.5\nlet _ = sprintf \"          %6.*%\" 3\nlet _ =  printf \"           %a\" (fun _ _ -> ()) 2\nlet _ =  printf \"            %*a\" 3 (fun _ _ -> ()) 2\n\"\"\"\n\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults = parseAndCheckScript(file, input) \n\n    typeCheckResults.Errors |> shouldEqual [||]\n    typeCheckResults.GetFormatSpecifierLocationsAndArity() \n    |> Array.map (fun (range,numArgs) -> range.StartLine, range.StartColumn, range.EndLine, range.EndColumn, numArgs)\n    |> shouldEqual\n         [|(2, 45, 2, 47, 1); (3, 23, 3, 25, 1); (4, 38, 4, 40, 1); (5, 27, 5, 29\n, 1);\n          (6, 17, 6, 20, 2); (7, 17, 7, 22, 1); (8, 17, 8, 23, 1); (9, 18, 9, 22, 1);\n          (10, 18, 10, 21, 1); (12, 12, 12, 15, 1); (15, 12, 15, 15, 1);\n          (16, 28, 16, 30, 1); (18, 30, 18, 32, 1); (19, 30, 19, 32, 1);\n          (20, 19, 20, 25, 1); (21, 18, 21, 20, 1); (21, 22, 21, 26, 1);\n          (22, 17, 22, 19, 0); (23, 18, 23, 21, 1); (24, 19, 24, 23, 1);\n          (25, 20, 25, 25, 1); (26, 21, 26, 24, 2); (27, 22, 27, 27, 2);\n          (28, 23, 28, 28, 3); (29, 24, 29, 28, 2); (30, 25, 30, 30, 2);\n          (31, 26, 31, 31, 2); (32, 27, 32, 32, 1); (33, 28, 33, 30, 2);\n          (34, 29, 34, 32, 3)|]\n\n[<Test>]\nlet ``Printf specifiers for triple-quote strings`` () = \n    let input = \n      \"\nlet _ = sprintf \\\"\\\"\\\"%-A\\\"\\\"\\\" -10\nlet _ = printfn \\\"\\\"\\\"\n            %-A\n                \\\"\\\"\\\" -10\nlet _ = List.iter(printfn \\\"\\\"\\\"%-A\n                             %i\\\\n%O\n                             \\\"\\\"\\\" 1 2)\"\n\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults = parseAndCheckScript(file, input) \n\n    typeCheckResults.Errors |> shouldEqual [||]\n    typeCheckResults.GetFormatSpecifierLocationsAndArity() \n    |> Array.map (fun (range,numArgs) -> range.StartLine, range.StartColumn, range.EndLine, range.EndColumn, numArgs)\n    |> shouldEqual [|(2, 19, 2, 22, 1);\n                     (4, 12, 4, 15, 1);\n                     (6, 29, 6, 32, 1);\n                     (7, 29, 7, 31, 1); \n                     (7, 33, 7, 35,1 )|]\n \n[<Test>]\nlet ``Printf specifiers for user-defined functions`` () = \n    let input = \n      \"\"\"\nlet debug msg = Printf.kprintf System.Diagnostics.Debug.WriteLine msg\nlet _ = debug \"Message: %i - %O\" 1 \"Ok\"\nlet _ = debug \"[LanguageService] Type checking fails for '%s' with content=%A and %A.\\nResulting exception: %A\" \"1\" \"2\" \"3\" \"4\"\n\"\"\"\n\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults = parseAndCheckScript(file, input) \n\n    typeCheckResults.Errors |> shouldEqual [||]\n    typeCheckResults.GetFormatSpecifierLocationsAndArity() \n    |> Array.map (fun (range, numArgs) -> range.StartLine, range.StartColumn, range.EndLine, range.EndColumn, numArgs)\n    |> shouldEqual [|(3, 24, 3, 26, 1); \n                     (3, 29, 3, 31, 1);\n                     (4, 58, 4, 60, 1); \n                     (4, 75, 4, 77, 1); \n                     (4, 82, 4, 84, 1); \n                     (4, 108, 4, 110, 1)|]\n\n[<Test>]\nlet ``should not report format specifiers for illformed format strings`` () = \n    let input = \n      \"\"\"\nlet _ = sprintf \"%.7f %7.1A %7.f %--8.1f\"\nlet _ = sprintf \"ABCDE\"\n\"\"\"\n\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults = parseAndCheckScript(file, input) \n    typeCheckResults.GetFormatSpecifierLocationsAndArity() \n    |> Array.map (fun (range, numArgs) -> range.StartLine, range.StartColumn, range.EndLine, range.EndColumn, numArgs)\n    |> shouldEqual [||]\n\n[<Test>]\nlet ``Single case discreminated union type definition`` () = \n    let input = \n      \"\"\"\ntype DU = Case1\n\"\"\"\n\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults = parseAndCheckScript(file, input) \n    typeCheckResults.GetAllUsesOfAllSymbolsInFile()\n    |> Async.RunSynchronously\n    |> Array.map (fun su -> \n        let r = su.RangeAlternate \n        r.StartLine, r.StartColumn, r.EndLine, r.EndColumn)\n    |> shouldEqual [|(2, 10, 2, 15); (2, 5, 2, 7); (1, 0, 1, 0)|]\n\n[<Test>]\nlet ``Synthetic symbols should not be reported`` () = \n    let input = \n      \"\"\"\nlet arr = [|1|]\nlet number1, number2 = 1, 2\nlet _ = arr.[0..number1]\nlet _ = arr.[..number2]\n\"\"\"\n\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults = parseAndCheckScript(file, input) \n    typeCheckResults.GetAllUsesOfAllSymbolsInFile()\n    |> Async.RunSynchronously\n    |> Array.map (fun su -> \n        let r = su.RangeAlternate \n        su.Symbol.ToString(), (r.StartLine, r.StartColumn, r.EndLine, r.EndColumn))\n    |> shouldEqual \n        [|(\"val arr\", (2, 4, 2, 7)); \n          (\"val number2\", (3, 13, 3, 20));\n          (\"val number1\", (3, 4, 3, 11)); \n          (\"val arr\", (4, 8, 4, 11));\n          (\"OperatorIntrinsics\", (4, 11, 4, 12)); \n          (\"Operators\", (4, 11, 4, 12));\n          (\"Core\", (4, 11, 4, 12)); \n          (\"FSharp\", (4, 11, 4, 12));\n          (\"Microsoft\", (4, 11, 4, 12)); \n          (\"val number1\", (4, 16, 4, 23));\n          (\"val arr\", (5, 8, 5, 11)); \n          (\"OperatorIntrinsics\", (5, 11, 5, 12));\n          (\"Operators\", (5, 11, 5, 12)); \n          (\"Core\", (5, 11, 5, 12));\n          (\"FSharp\", (5, 11, 5, 12)); \n          (\"Microsoft\", (5, 11, 5, 12));\n          (\"val number2\", (5, 15, 5, 22)); \n          (\"Test\", (1, 0, 1, 0))|]\n\n\n[<Test>]\nlet ``Enums should have fields`` () =\n    let input = \"\"\"\ntype EnumTest = One = 1 | Two = 2 | Three = 3\nlet test = EnumTest.One\nlet test2 = System.StringComparison.CurrentCulture\nlet test3 = System.Text.RegularExpressions.RegexOptions.Compiled\n\"\"\"\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults = parseAndCheckScript(file, input) \n    let allSymbols = typeCheckResults.GetAllUsesOfAllSymbolsInFile() |> Async.RunSynchronously\n    let enums =\n        allSymbols\n        |> Array.choose(fun s -> match s.Symbol with :? FSharpEntity as e when e.IsEnum -> Some e | _ -> None)\n        |> Array.distinct\n        |> Array.map(fun e -> (e.DisplayName, e.FSharpFields\n                                              |> Seq.map(fun f -> f.Name, f.LiteralValue )\n                                              |> Seq.toList))\n\n    enums |> shouldEqual\n        [| \"EnumTest\", [ (\"value__\", None)\n                         (\"One\", Some (box 1))\n                         (\"Two\", Some (box 2))\n                         (\"Three\", Some (box 3))\n                       ]\n           \"StringComparison\", [ (\"value__\", None)\n                                 (\"CurrentCulture\", Some (box 0))\n                                 (\"CurrentCultureIgnoreCase\", Some (box 1))\n                                 (\"InvariantCulture\", Some (box 2))\n                                 (\"InvariantCultureIgnoreCase\", Some (box 3))\n                                 (\"Ordinal\", Some (box 4))\n                                 (\"OrdinalIgnoreCase\", Some (box 5))\n                               ]\n           \"RegexOptions\", [ (\"value__\", None)\n                             (\"None\", Some (box 0))\n                             (\"IgnoreCase\", Some (box 1))\n                             (\"Multiline\", Some (box 2))\n                             (\"ExplicitCapture\", Some (box 4))\n                             (\"Compiled\", Some (box 8))\n                             (\"Singleline\", Some (box 16))\n                             (\"IgnorePatternWhitespace\", Some (box 32))\n                             (\"RightToLeft\", Some (box 64))\n                             (\"ECMAScript\", Some (box 256))\n                             (\"CultureInvariant\", Some (box 512))\n                           ]\n        |]\n\n[<Test>]\nlet ``IL enum fields should be reported`` () = \n    let input = \n      \"\"\"\nopen System\n\nlet _ =\n    match ConsoleKey.Tab with\n    | ConsoleKey.OemClear -> ConsoleKey.A\n    | _ -> ConsoleKey.B\n\"\"\"\n\n    let file = \"/home/user/Test.fsx\"\n    let _, typeCheckResults = parseAndCheckScript(file, input) \n    typeCheckResults.GetAllUsesOfAllSymbolsInFile()\n    |> Async.RunSynchronously\n    |> Array.map (fun su -> \n        let r = su.RangeAlternate \n        su.Symbol.ToString(), (r.StartLine, r.StartColumn, r.EndLine, r.EndColumn))\n    |> shouldEqual \n        [|(\"ConsoleKey\", (5, 10, 5, 20))\n          (\"field Tab\", (5, 10, 5, 24))\n          (\"ConsoleKey\", (6, 6, 6, 16))\n          (\"field OemClear\", (6, 6, 6, 25))\n          (\"ConsoleKey\", (6, 29, 6, 39))\n          (\"field A\", (6, 29, 6, 41))\n          (\"ConsoleKey\", (7, 11, 7, 21))\n          (\"field B\", (7, 11, 7, 23))\n          (\"Test\", (1, 0, 1, 0))|]\n\n[<Test>]\nlet ``Literal values should be reported`` () = \n    let input = \n      \"\"\"\nmodule Module1 =\n    let [<Literal>] ModuleValue = 1\n\n    let _ =\n        match ModuleValue + 1 with\n        | ModuleValue -> ModuleValue + 2\n        | _ -> 0\n\ntype Class1() =\n    let [<Literal>] ClassValue = 1\n    static let [<Literal>] StaticClassValue = 2\n    \n    let _ = ClassValue\n    let _ = StaticClassValue\n\n    let _ =\n        match ClassValue + StaticClassValue with\n        | ClassValue -> ClassValue + 1\n        | StaticClassValue -> StaticClassValue + 2\n        | _ -> 3\n\"\"\"\n\n    let file = \"/home/user/Test.fsx\"\n    let _, typeCheckResults = parseAndCheckScript(file, input) \n    typeCheckResults.GetAllUsesOfAllSymbolsInFile()\n    |> Async.RunSynchronously\n    |> Array.map (fun su -> \n        let r = su.RangeAlternate \n        su.Symbol.ToString(), (r.StartLine, r.StartColumn, r.EndLine, r.EndColumn))\n    |> shouldEqual \n        [|(\"LiteralAttribute\", (3, 10, 3, 17))\n          (\"LiteralAttribute\", (3, 10, 3, 17))\n          (\"member .ctor\", (3, 10, 3, 17))\n          (\"val ModuleValue\", (3, 20, 3, 31))\n          (\"val op_Addition\", (6, 26, 6, 27))\n          (\"val ModuleValue\", (6, 14, 6, 25))\n          (\"val ModuleValue\", (7, 10, 7, 21))\n          (\"val op_Addition\", (7, 37, 7, 38))\n          (\"val ModuleValue\", (7, 25, 7, 36))\n          (\"Module1\", (2, 7, 2, 14))\n          (\"Class1\", (10, 5, 10, 11))\n          (\"member .ctor\", (10, 5, 10, 11))\n          (\"LiteralAttribute\", (11, 10, 11, 17))\n          (\"LiteralAttribute\", (11, 10, 11, 17))\n          (\"member .ctor\", (11, 10, 11, 17))\n          (\"val ClassValue\", (11, 20, 11, 30))\n          (\"LiteralAttribute\", (12, 17, 12, 24))\n          (\"LiteralAttribute\", (12, 17, 12, 24))\n          (\"member .ctor\", (12, 17, 12, 24))\n          (\"val StaticClassValue\", (12, 27, 12, 43))\n          (\"val ClassValue\", (14, 12, 14, 22))\n          (\"val StaticClassValue\", (15, 12, 15, 28))\n          (\"val op_Addition\", (18, 25, 18, 26))\n          (\"val ClassValue\", (18, 14, 18, 24))\n          (\"val StaticClassValue\", (18, 27, 18, 43))\n          (\"val ClassValue\", (19, 10, 19, 20))\n          (\"val op_Addition\", (19, 35, 19, 36))\n          (\"val ClassValue\", (19, 24, 19, 34))\n          (\"val StaticClassValue\", (20, 10, 20, 26))\n          (\"val op_Addition\", (20, 47, 20, 48))\n          (\"val StaticClassValue\", (20, 30, 20, 46))\n          (\"member .cctor\", (10, 5, 10, 11))\n          (\"Test\", (1, 0, 1, 0))|]\n          \n[<Test>]\nlet ``GetDeclarationLocation should not require a physical file`` () = \n    let input = \"let abc = 1\\nlet xyz = abc\"\n    let file = \"/home/user/Test.fsx\"\n    let _, typeCheckResults = parseAndCheckScript(file, input) \n    let location = typeCheckResults.GetDeclarationLocation(2, 13, \"let xyz = abc\", [\"abc\"]) |> Async.RunSynchronously\n    match location with\n    | FSharpFindDeclResult.DeclFound r -> Some (r.StartLine, r.EndLine, r.StartColumn, r.EndColumn, \"Found in the right place.\") \n    | _                                -> Some (0          , 0        , 0            , 0          , \"Not Found. Missing file.\" )\n    |> shouldEqual                       (Some (1          , 1        , 4            , 7          , \"Found in the right place.\"))\n``GetDeclarationLocation should not require a physical file`` ()          \n\n//-------------------------------------------------------------------------------\n\n\n#if TEST_TP_PROJECTS\nmodule internal TPProject = \n    open System.IO\n\n    let fileName1 = Path.ChangeExtension(Path.GetTempFileName(), \".fs\")\n    let base2 = Path.GetTempFileName()\n    let dllName = Path.ChangeExtension(base2, \".dll\")\n    let projFileName = Path.ChangeExtension(base2, \".fsproj\")\n    let fileSource1 = \"\"\"\nmodule M\nopen Samples.FSharp.RegexTypeProvider\n[<Literal>]\nlet REGEX = \"ABC\"\nlet _ = RegexTypedStatic.IsMatch  // TEST: intellisense when typing \"<\"\nlet _ = RegexTypedStatic.IsMatch<REGEX>( ) // TEST: param info on \"(\"\nlet _ = RegexTypedStatic.IsMatch<\"ABC\" >( ) // TEST: param info on \"(\"\nlet _ = RegexTypedStatic.IsMatch<\"ABC\" >( (*$*) ) // TEST: meth info on ctrl-alt-space at $\nlet _ = RegexTypedStatic.IsMatch<\"ABC\" >( null (*$*) ) // TEST: param info on \",\" at $\nlet _ = RegexTypedStatic.IsMatch< > // TEST: intellisense when typing \"<\"\nlet _ = RegexTypedStatic.IsMatch< (*$*) > // TEST: param info when typing ctrl-alt-space at $\nlet _ = RegexTypedStatic.IsMatch<\"ABC\" (*$*) > // TEST: param info on Ctrl-alt-space at $\nlet _ = RegexTypedStatic.IsMatch<\"ABC\" (*$*) >(  ) // TEST: param info on Ctrl-alt-space at $\nlet _ = RegexTypedStatic.IsMatch<\"ABC\", (*$ *) >(  ) // TEST: param info on Ctrl-alt-space at $\nlet _ = RegexTypedStatic.IsMatch<\"ABC\" >(  (*$*) ) // TEST: no assert on Ctrl-space at $\n    \"\"\"\n\n    File.WriteAllText(fileName1, fileSource1)\n    let fileLines1 = File.ReadAllLines(fileName1)\n    let fileNames = [fileName1]\n    let args = Array.append (mkProjectCommandLineArgs (dllName, fileNames)) [| \"-r:\" + PathRelativeToTestAssembly(@\"UnitTests\\MockTypeProviders\\DummyProviderForLanguageServiceTesting.dll\") |]\n    let options =  checker.GetProjectOptionsFromCommandLineArgs (projFileName, args)\n    let cleanFileName a = if a = fileName1 then \"file1\" else \"??\"\n\n[<Test>]\nlet ``Test TPProject all symbols`` () = \n\n    let wholeProjectResults = checker.ParseAndCheckProject(TPProject.options) |> Async.RunSynchronously\n    let allSymbolUses = wholeProjectResults.GetAllUsesOfAllSymbols() |> Async.RunSynchronously\n    let allSymbolUsesInfo =  [ for s in allSymbolUses -> s.Symbol.DisplayName, tups s.RangeAlternate, attribsOfSymbol s.Symbol ]\n    //printfn \"allSymbolUsesInfo = \\n----\\n%A\\n----\" allSymbolUsesInfo\n\n    allSymbolUsesInfo |> shouldEqual\n        [(\"LiteralAttribute\", ((4, 2), (4, 9)), [\"class\"]);\n         (\"LiteralAttribute\", ((4, 2), (4, 9)), [\"class\"]);\n         (\"LiteralAttribute\", ((4, 2), (4, 9)), [\"member\"]);\n         (\"REGEX\", ((5, 4), (5, 9)), [\"val\"]);\n         (\"RegexTypedStatic\", ((6, 8), (6, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((6, 8), (6, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((7, 8), (7, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"REGEX\", ((7, 33), (7, 38)), [\"val\"]);\n         (\"IsMatch\", ((7, 8), (7, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((8, 8), (8, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((8, 8), (8, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((9, 8), (9, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((9, 8), (9, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((10, 8), (10, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((10, 8), (10, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((11, 8), (11, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((11, 8), (11, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((12, 8), (12, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((12, 8), (12, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((13, 8), (13, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((13, 8), (13, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((14, 8), (14, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((14, 8), (14, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((15, 8), (15, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((15, 8), (15, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((16, 8), (16, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((16, 8), (16, 32)), [\"member\"]);\n         (\"M\", ((2, 7), (2, 8)), [\"module\"])]\n\n\n[<Test>]\nlet ``Test TPProject errors`` () = \n    let wholeProjectResults = checker.ParseAndCheckProject(TPProject.options) |> Async.RunSynchronously\n    let parseResult, typeCheckAnswer = checker.ParseAndCheckFileInProject(TPProject.fileName1, 0, TPProject.fileSource1, TPProject.options) |> Async.RunSynchronously\n    let typeCheckResults = \n        match typeCheckAnswer with\n        | FSharpCheckFileAnswer.Succeeded(res) -> res\n        | res -> failwithf \"Parsing did not finish... (%A)\" res\n\n    let errorMessages = [ for msg in typeCheckResults.Errors -> msg.StartLineAlternate, msg.StartColumn, msg.EndLineAlternate, msg.EndColumn, msg.Message.Replace(\"\\r\",\"\").Replace(\"\\n\",\"\") ]\n    //printfn \"errorMessages = \\n----\\n%A\\n----\" errorMessages\n\n    errorMessages |> shouldEqual\n        [(15, 47, 15, 48, \"Expected type argument or static argument\");\n         (6, 8, 6, 32, \"This provided method requires static parameters\");\n         (7, 39, 7, 42, \"This expression was expected to have type    'string'    but here has type    'unit'    \");\n         (8, 40, 8, 43, \"This expression was expected to have type    'string'    but here has type    'unit'    \");\n         (9, 40, 9, 49, \"This expression was expected to have type    'string'    but here has type    'unit'    \");\n         (11, 8, 11, 35, \"The static parameter 'pattern1' of the provided type or method 'IsMatch' requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. 'IsMatch<pattern1=...>'.\");\n         (12, 8, 12, 41, \"The static parameter 'pattern1' of the provided type or method 'IsMatch' requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. 'IsMatch<pattern1=...>'.\");\n         (14, 46, 14, 50, \"This expression was expected to have type    'string'    but here has type    'unit'    \");\n         (15, 33, 15, 38, \"No static parameter exists with name ''\");\n         (16, 40, 16, 50, \"This expression was expected to have type    'string'    but here has type    'unit'    \")]\n``Test TPProject errors`` ()\nlet internal extractToolTipText (FSharpToolTipText(els)) = \n    [ for e in els do \n        match e with\n        | FSharpToolTipElement.Group txts -> for item in txts do yield item.MainDescription\n        | FSharpToolTipElement.CompositionError err -> yield err\n        | FSharpToolTipElement.None -> yield \"NONE!\" ] \n\n[<Test>]\nlet ``Test TPProject quick info`` () = \n    let wholeProjectResults = checker.ParseAndCheckProject(TPProject.options) |> Async.RunSynchronously\n    let parseResult, typeCheckAnswer = checker.ParseAndCheckFileInProject(TPProject.fileName1, 0, TPProject.fileSource1, TPProject.options) |> Async.RunSynchronously\n    let typeCheckResults = \n        match typeCheckAnswer with\n        | FSharpCheckFileAnswer.Succeeded(res) -> res\n        | res -> failwithf \"Parsing did not finish... (%A)\" res\n\n    let toolTips  =\n      [ for lineNum in 0 .. TPProject.fileLines1.Length - 1 do \n         let lineText = TPProject.fileLines1.[lineNum]\n         if lineText.Contains(\".IsMatch\") then \n            let colAtEndOfNames = lineText.IndexOf(\".IsMatch\") + \".IsMatch\".Length\n            let res = typeCheckResults.GetToolTipTextAlternate(lineNum, colAtEndOfNames, lineText, [\"RegexTypedStatic\";\"IsMatch\"], FSharpTokenTag.IDENT) |> Async.RunSynchronously \n            yield lineNum, extractToolTipText  res ]\n    //printfn \"toolTips = \\n----\\n%A\\n----\" toolTips\n\n    toolTips |> shouldEqual\n        [(5, [\"RegexTypedStatic.IsMatch() : int\"]);\n         (6, [\"RegexTypedStatic.IsMatch() : int\"]);\n         // NOTE: This tool tip is sub-optimal, it would be better to show RegexTypedStatic.IsMatch<\"ABC\">\n         //       This is a little tricky to implement\n         (7, [\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"]);\n         (8, [\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"]);\n         (9, [\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"]);\n         (10, [\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"]);\n         (11, [\"RegexTypedStatic.IsMatch() : int\"]);\n         (12, [\"RegexTypedStatic.IsMatch() : int\"]);\n         (13, [\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"]);\n         (14, [\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"]);\n         (15, [\"RegexTypedStatic.IsMatch() : int\"])]\n\n\n[<Test>]\nlet ``Test TPProject param info`` () = \n    let wholeProjectResults = checker.ParseAndCheckProject(TPProject.options) |> Async.RunSynchronously\n    let parseResult, typeCheckAnswer = checker.ParseAndCheckFileInProject(TPProject.fileName1, 0, TPProject.fileSource1, TPProject.options) |> Async.RunSynchronously\n    let typeCheckResults = \n        match typeCheckAnswer with\n        | FSharpCheckFileAnswer.Succeeded(res) -> res\n        | res -> failwithf \"Parsing did not finish... (%A)\" res\n\n    let paramInfos =\n      [ for lineNum in 0 .. TPProject.fileLines1.Length - 1 do \n         let lineText = TPProject.fileLines1.[lineNum]\n         if lineText.Contains(\".IsMatch\") then \n            let colAtEndOfNames = lineText.IndexOf(\".IsMatch\")  + \".IsMatch\".Length\n            let meths = typeCheckResults.GetMethodsAlternate(lineNum, colAtEndOfNames, lineText, Some [\"RegexTypedStatic\";\"IsMatch\"]) |> Async.RunSynchronously \n            let elems = \n                [ for meth in meths.Methods do \n                   yield extractToolTipText  meth.Description, meth.HasParameters, [ for p in meth.Parameters -> p.ParameterName ], [ for p in meth.StaticParameters -> p.ParameterName ] ]\n            yield lineNum, elems]\n    //printfn \"paramInfos = \\n----\\n%A\\n----\" paramInfos \n\n    // This tests that properly statically-instantiated methods have the right method lists and parameter info\n    paramInfos |> shouldEqual\n        [(5, [([\"RegexTypedStatic.IsMatch() : int\"], true, [], [\"pattern1\"])]);\n         (6, [([\"RegexTypedStatic.IsMatch() : int\"], true, [], [\"pattern1\"])]);\n         // NOTE: this method description is sub-optimal, it would be better to show RegexTypedStatic.IsMatch<\"ABC\">\n         (7,[([\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"], true,[\"input\"], [\"pattern1\"])]);\n         (8,[([\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"], true,[\"input\"], [\"pattern1\"])]);\n         (9,[([\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"], true,[\"input\"], [\"pattern1\"])]);\n         (10,[([\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"], true, [\"input\"], [\"pattern1\"])]);\n         (11, [([\"RegexTypedStatic.IsMatch() : int\"], true, [], [\"pattern1\"])]);\n         (12, [([\"RegexTypedStatic.IsMatch() : int\"], true, [], [\"pattern1\"])]);\n         (13,[([\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"], true,[\"input\"], [\"pattern1\"])]);\n         (14,[([\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"], true,[\"input\"], [\"pattern1\"])]);\n         (15, [([\"RegexTypedStatic.IsMatch() : int\"], true, [], [\"pattern1\"])])]\n\n#endif // TEST_TP_PROJECTS\n\n#if EXE\n\n``Intro test`` () \n//``Test TPProject all symbols`` () \n//``Test TPProject errors`` () \n//``Test TPProject quick info`` () \n//``Test TPProject param info`` () \n``Basic cancellation test`` ()\n``Intro test`` () \n#endif","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"560bbd44-ad59-4b88-81d7-c27a14b0ad2e"}],"id":{"$":0,"Item":"38e6c579-4305-4929-9666-44b3890c7a6a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"GetDeclarationListInfo","content":"   ParsedFileResultsOpt             : FSharpParseFileResults option\n * line                             : int\n * colAtEndOfPartialName            : int\n * lineText                         : string\n * qualifyingNames                  : string list\n * partialName                      : string\n * getAllSymbols                    : (unit -> AssemblySymbol list)\n * hasTextChangedSinceLastTypecheck : (obj * range -> bool) option\n * userOpName                       : string option\n\nGetDeclarationListInfo(\n  Some parseResult\n, 7\n, 23\n, inputLines.[6]\n, []\n, \"msg\"\n, (fun _ -> [])\n, fun _ -> false)\n\nFSharpCheckFileResults.GetDeclarationListInfo :\n  ParsedFileResultsOpt:FSharpParseFileResults option\n* line:int\n* lineText:string\n* partialName:PartialLongName\n* getAllSymbols:(unit -> AssemblySymbol list)\n* ?hasTextChangedSinceLastTypecheck:(obj * Range.range -> bool)\n* ?userOpName:string -> Async<FSharpDeclarationListInfo>\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"128c1c1d-e96f-41e7-bf89-9466b8dff4ee"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Substring, Regex","content":"let extract n (s:string) = s.Substring(0, min n s.Length)\nlet s = \"1234567890123456789012345678901234567890\"\nprintfn \"%s\" <| extract 100 s\n\nopen System\nprintfn \"%s\" <| System.DateTime.UtcNow.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n\nopen UsefulDotNet\n//Example:\nlet phone = \"(555) 555-5555\"\nmatch phone with\n| Regex @\"\\(([0-9]{3})\\)[-. ]?([0-9]{3})[-. ]?([0-9]{4})\" [ area; prefix; suffix ] ->\n    printfn \"Area: %s, Prefix: %s, Suffix: %s\" area prefix suffix\n| _ -> printfn \"Not a phone number\"\n\nlet code = \"let a = \\\"123\\\" |> St\"\nmatch code with\n| Regex @\"([a-zA-Z_]\\w+)$\" [ txt ] -> printfn \"%s\" txt\n| _                                -> printfn \"<No match>\"\n\nlet line = \" hello how \\\"are you\\\" good \\\"and you\\\"\"\nmatch line with \n| Regexs \"(\\\".*?\\\"|\\S+)\" ms -> \n    ms \n    |> Seq.iter\n        (function | Regex \"(\\\"(.*?)\\\")\" [_ ; m] | m -> printfn \"%A\" m)\n//| Regex \"(\\\"([^\\\"]*)\\\"|\\S*)*\" r -> printfn \"%A\" r\n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"7646acbc-2c28-4159-98b1-2365d19fc97c"}],"id":{"$":0,"Item":"5df15cf1-361e-4d57-a565-683ab0b72082"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Stack Overflow","content":"let rec recursive i = 1 + recursive i\nrecursive 1","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"3d704638-8ba4-4bc8-b810-29e023a222fc"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Calculate primes","content":"open System\nopen System.ComponentModel\nopen System.Windows.Forms\n\ntype BackgroundWorker with\n        member this.AsyncRunWorker (computation, argument : 'T, progressChangedHandler) : Async<'U> =\n            let workerAsync =\n                Async.FromContinuations (fun (cont, econt, ccont) ->\n                            let handler = new RunWorkerCompletedEventHandler (fun sender args ->          \n                                if args.Cancelled then\n                                    ccont (new OperationCanceledException()) \n                                elif args.Error <> null then\n                                    econt args.Error\n                                else\n                                    cont (args.Result :?> 'U))\n                            this.WorkerSupportsCancellation <- true;\n                            this.WorkerReportsProgress <- true\n                            this.DoWork.AddHandler(new DoWorkEventHandler(fun sender args ->\n                                args.Result <- computation(argument, this, args)))\n                            this.ProgressChanged.AddHandler(progressChangedHandler)\n                            this.RunWorkerCompleted.AddHandler(handler)\n                            this.RunWorkerAsync(argument)\n                        )\n\n            async { \n                use! holder = Async.OnCancel(fun _ -> this.CancelAsync())\n                return! workerAsync\n             }\n\nlet factorial number =\n    let rec fact number =\n        match number with\n        | value when value < 0I ->\n            raise (InvalidOperationException(sprintf \"Cannot compute the factorial of a negative number: %s.\" (value.ToString())))\n        | value when value > 2000I ->\n            raise (InvalidOperationException(sprintf \"Input too large: %s\" (value.ToString())))\n        | value when value = 0I -> 1I\n        | value when value = 1I -> 1I\n        | number -> number * fact (number - 1I)\n    fact number\n\n// Recursive isprime function.\nlet isprime number =\n    let rec check count =\n        count > number/2 || (number % count <> 0 && check (count + 1))\n    check 2\n\nlet isprimeBigInt number =\n    let rec check count =\n        count > number/2I || (number % count <> 0I && check (count + 1I))\n    check 2I\n\nlet computeNthPrime (number, worker: BackgroundWorker, eventArgs: DoWorkEventArgs) =\n     if (number < 1) then\n         invalidOp <| sprintf \"Invalid input for nth prime: %s.\" (number.ToString())\n     let mutable count = 0\n     let mutable num = 1I\n     let isDone = false\n     while (count < number && not eventArgs.Cancel ) do\n         if (worker.CancellationPending) then\n             eventArgs.Cancel <- true\n         else\n             let percentComplete = int ((float count) / (float number) * 100.0)\n             worker.ReportProgress(percentComplete, num.ToString())\n         num <- num + 1I\n         if (num < bigint System.Int32.MaxValue) then\n             while (not (isprime (int num))) do\n                 num <- num + 1I\n         else\n             while (not (isprimeBigInt num)) do\n                 num <- num + 1I\n         count <- count + 1\n     num\n         \nlet async1 (progressBar:ProgressBar) (label:Label) value =\n     let worker = new BackgroundWorker()\n     label.Text <- \"Computing...\"\n     let computation value = worker.AsyncRunWorker(computeNthPrime, value,\n                                                   (fun sender (eventArgs:ProgressChangedEventArgs) ->\n                                                       label.Text <- \"Scanning ... \" + eventArgs.UserState.ToString()\n                                                       progressBar.Value <- eventArgs.ProgressPercentage ))\n     Async.StartWithContinuations(\n         computation value,\n         (fun result -> label.Text <- sprintf \"Result: %s\" (result.ToString())),\n         (fun exn -> label.Text <- \"Operation failed with error:\" + exn.Message),\n         (fun _ -> label.Text <- \"Operation canceled.\"))\n\n#if INTERACTIVE\nlet main =\n#else\n[< EntryPoint ; STAThread >]\nlet main args =\n#endif\n    Application.EnableVisualStyles()\n    let form = new Form(Text = \"Test Form\", Width = 400, Height = 400)\n    let panel1 = new Panel(Dock = DockStyle.Fill)\n    panel1.DockPadding.All <- 10\n    let spacing = 5\n    let button1 = new Button(Text = \"Start\")\n    let button2 = new Button(Text = \"Start Invalid\", Top = button1.Height + spacing)\n    let button3 = new Button(Text = \"Cancel\", Top = 2 * (button1.Height + spacing))\n    let updown1 = new System.Windows.Forms.NumericUpDown(Top = 3 * (button1.Height + spacing), \n                                                         Value = 20m,\n                                                         Minimum = 0m,\n                                                         Maximum = 1000000m)\n    let label1 = new Label (Text = \"\", Top = 4 * (button1.Height + spacing),\n                            Width = 300, Height = 2 * button1.Height)\n    let progressBar = new ProgressBar(Top = 6 * (button1.Height + spacing),\n                                      Width = 300)\n    panel1.Controls.AddRange [| button1; button2; button3; updown1; label1; progressBar; |]\n    form.Controls.Add(panel1)\n    button1.Click.Add(fun args -> async1 progressBar label1 (int updown1.Value))\n    button2.Click.Add(fun args -> async1 progressBar label1 (int (-updown1.Value)))\n    button3.Click.Add(fun args -> Async.CancelDefaultToken())\n    form.Activated.AddHandler(System.EventHandler (fun _ _ -> form.TopMost <- true(*; form.TopMost <- false*) ))\n#if INTERACTIVE\n    form.ShowDialog() |> ignore\n#else\n    form |> Application.Run\n#endif\n    0\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"bd716e89-0546-4d6b-8964-26473ddcd121"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Form test and Messaging","content":"open System\nopen System.ComponentModel\nopen System.Windows.Forms\n\nlet label1 = new Label (Text = \"\", Width = 300)\nlet newButton txt =\n    let btn = new Button(Text = txt)\n    btn.Click.Add (fun args -> label1.Text <- txt)\n    btn :> Control\n        \n\nlet spacing = 5\nlet button1 = newButton \"Start\"\nlet button2 = newButton \"Start Invalid\"\nlet button3 = newButton \"Cancel\"\n\nlet updown1 = new System.Windows.Forms.NumericUpDown(Value   = 20m     ,\n                                                     Minimum = 0m      ,\n                                                     Maximum = 1000000m)\n\nlet progressBar = new ProgressBar(Top = 6 * (button1.Height + spacing),\n                                  Width = 300)\nlet panel1 = new Panel(Dock = DockStyle.Fill)\n\n[| button1    \n   button2    \n   button3    \n   updown1     :> Control\n   label1      :> Control\n   progressBar :> Control\n|]\n|> Array.mapi (fun i cts -> cts.Top <- i * 25 ; cts)\n|> panel1.Controls.AddRange\npanel1.DockPadding.All <- 10\n//button1.Click.Add(fun args -> async1 progressBar label1 (int updown1.Value))\n//button2.Click.Add(fun args -> async1 progressBar label1 (int (-updown1.Value)))\n//button3.Click.Add(fun args -> Async.CancelDefaultToken())\nlet form = new Form(Text = \"Select Actions\", Width = 400, Height = 400)\nform.Controls.Add(panel1)\nform.Activated.AddHandler(System.EventHandler (fun _ _ -> form.TopMost <- true(*; form.TopMost <- false*) ))\nasync {\n  do Application.Run(form) \n} |> Async.Start\n\n//open CIPHERPrototype.Messaging\nopen Useful\nopen FsStationShared\n\n#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.Web.dll\"\n#nowarn \"1125\"\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Remoting\n\nlet fsClient = FsStationClient(\"ButtonTest\")\n\nbutton1.Click.Add (fun args ->                                                      \n    Wrap.wrapper {\n        let! response = fsClient.GenericMessage \"Hello\"\n        label1.Text <- response\n    } |> Wrap.Start\n)\n\n//let requestCode (snpName:string) = \n//    async {\n//        let! response = sendRequestRpc toId fromId (snpName.Split '/' |> GetSnippetCode |> Json.Serialize)\n//        let resp =\n//            match response |> Json.Deserialize<FSResponse> with\n//            | SnippetResponse(Some snp )    -> snp  |> Json.Serialize\n//            | StringResponse (Some code)    -> code\n//            | IdResponse     (AddressId id) -> id.ToString()\n//            | _                             -> sprintf \"<Incomplete response: %s>\" response\n//        return resp\n//    }    \n//\n//open Rop\n//Wrap.wrapper {\n//    let! code   = requestCode \"module FSharpStationMD   =/Evaluate F# Code/module Snippets =/Calculate primes\"\n//    let! result = processCode (compileCode \"TESTCODE\") code\n//    result |> Seq.map (sprintf \"%A\") |> String.concat \"\\n\" |> printfn \"%s\"\n//} |> Wrap.getAsyncR |> Async.Start\n\nlet respondMessage fromId (msg:string) : string =\n    label1.Text <- msg\n    match msg |> Json.Deserialize<FSMessage> with\n    | GenericMessage        txt  -> label1.Text <- txt\n                                    StringResponse <| (Some <| \"Message received: \" + txt)\n    | GetIdentification          -> IdResponse fromId \n    | _                          -> StringResponse <| (Some <| \"Message received: \" + msg)\n    |> Json.Serialize\n\nfsClient.MessagingClient.AwaitMessage respondMessage\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"}],"id":{"$":0,"Item":"dc44bbe1-876a-4910-a39a-5d74bc2304ee"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"JSON Serializer","content":"#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Core.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Collections.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Main.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.JavaScript.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Web.dll\"\n#r @\"..\\packages\\Zafir.UI.Next\\lib\\net40\\WebSharper.UI.Next.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Sitelets.dll\"\n\n//open CIPHERPrototype.Messaging\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Remoting\n\n\ntype FSMessage =\n    | GetSnippetContentById of string //CodeSnippetId\n    | GetSnippetCodeById    of string //CodeSnippetId\n    | GetSnippetById        of string //CodeSnippetId\n    | GetSnippetContent     of string []\n    | GetSnippetCode        of string []\n    | GetSnippet            of string []\n    | GenericMessage        of string\n    | GetIdentification\n\ntype FSResponse =\n    | SnippetResponse   of string //CodeSnippet option\n    | StringResponse    of string option\n//    | IdResponse        of CIPHERPrototype.Messaging.AddressId\n\nGenericMessage \"Hello\" \n|> Json.ServerSideProvider.GetEncoder().Encode\n|> Json.ServerSideProvider.Pack\n|> printfn \"%A\"\n\ntype Response = {\n    ``$TYPES`` : string[]\n    ``$DATA``  : string\n}\n\n\"\"\"{\"$TYPES\":[],\"$DATA\":\"{\\\"$\\\":1,\\\"Item\\\":\\\"Message received: Hello\\\"}\"}\"\"\"\n|> Json.Deserialize<Response>\n|> (fun r -> r.``$DATA``)\n|> Json.Deserialize<FSResponse>\n|> printfn \"%A\"\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"46450fbf-b073-4a66-ab42-587be0afc45f"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"System.IO.File.Delete(@\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\EPFileX\\CodeEditor.fsx.bak\")","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"b4a9f681-f5c2-443b-8f6e-146a6d6cd093"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"let rand = System.Random()\nlet randomNumbers = seq { while true do yield rand.Next(100) }\nlet firstTenRandomNumbers =\n randomNumbers\n |> Seq.truncate 10\n |> Seq.toList\n \nprintfn \"%+A\" firstTenRandomNumbers  \n//printfn \"%t\" (fun w -> w.WriteLine 6)  \n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"210f90c1-81fc-43bd-b838-6a5dc2a8e46b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Failed to load argument type","content":"#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Collections.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.UI.Next.dll\"\n#r @\"WebSharper.JavaScript.dll\"\n#r @\"WebSharper.Web.dll\"\n#r @\"WebSharper.UI.Next.dll\"\n#r @\"WebSharper.Sitelets.dll\"\n\nopen WebSharper\n\n[< JavaScript >]\ntype AddressId = AddressId of string\n\n[< Rpc >]\nlet sendRequest  (toId:AddressId) =\n        async {\n            return \"HELLO\"\n        }\n\n[< JavaScript >]\nlet tried() =\n    let f = AddressId \"XXX\"\n    let v = sendRequest f\n    (f, v)\n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"f850ce38-14e5-47a4-81ed-df02d7979f8e"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Rules Alea","content":"let accounts =\n  [|\n    \"30\", \"Net Income After M. I. & Taxes \"\n    \"35\", \"Income (Loss) before Taxes \"\n    \"36\", \"Income (Loss) before taxes and M.I. \"\n    \"37\", \"Income from Continuing Operations \"\n    \"38\", \"Operating Income/(Loss) \"\n    \"39\", \"Actual Gross Income \"\n    \"300\", \"Total Net Revenue \"\n    \"301\", \"Orders Available to Ship \"\n    \"310\", \"Total Projected Sales Orders \"\n    \"320\", \"Plus:Orders In Backlog \"\n    \"350\", \"Less:Proj. Ending Backlog \"\n    \"360\", \"Non Interco Revenue \"\n    \"370\", \"Interco Revenue \"\n    \"400\", \"Cost of Goods Sold-Actual \"\n    \"401\", \"Memo Only:Inventory Receipts \"\n    \"402\", \"Memo Only:Interco inventory \"\n    \"410\", \"Cost of Goods Sold \"\n    \"430\", \"Standard COGS-Non Interco \"\n    \"440\", \"Standard COGS-Interco \"\n    \"500\", \"Total Mfg./Distr. Variances \"\n    \"510\", \"Purchase Price/Freight/Reclass \"\n    \"520\", \"Material Usage \"\n    \"530\", \"Inventory Adjustment \"\n    \"540\", \"Labor Performance/Rate \"\n    \"580\", \"Overhead Variance \"\n    \"5800\", \"Overhead Spending \"\n    \"5810\", \"Bonus Accrual for Overhead \"\n    \"5820\", \"Less:Overhead Absorption \"\n    \"40\", \"Actual Gross Margin %   \"\n    \"41\", \"Plan Gross Margin %  \"\n    \"60\", \"Total Expenses \"\n    \"610\", \"Engineering \"\n    \"620\", \"Sales \"\n    \"630\", \"General & Administrative \"\n    \"640\", \"ESOP/401K Contributions \"\n    \"650\", \"Bonus Accrual \"\n    \"660\", \"Warranty Expense-Total \"\n    \"700\", \"Total Non-Operating Income/(Expense) \"\n    \"710\", \"Other Income \"\n    \"720\", \"JV Profit Allocation \"\n    \"730\", \"Other (Expense) \"\n    \"740\", \"Management Fees \"\n    \"750\", \"Interest (Expense)/Income \"\n    \"810\", \"Inventory Disposal Program \"\n    \"910\", \"Minority Interest \"\n    \"920\", \"Federal State Other Income Tax \"\n    \"31\", \"P.A.T. % \"\n    \"32\", \"PLAN INCOME AFTER TAXES & M.I. \"\n    \"33\", \"$ VARIANCE TO PLAN \"\n    \"Cash Flow Statement\", \"Cash Flow Statement \"\n    \"C1\", \"Projected Ending Loan Balance \"\n    \"C10\", \"Beginning Loan Balance \"\n    \"C20\", \"NET PROJECTED CASH + (-) \"\n    \"C201\", \"Other Items- \"\n    \"C202\", \"Other Income \"\n    \"C203\", \"JV Profit Allocation \"\n    \"C204\", \"Other Expense \"\n    \"C205\", \"Management Fees \"\n    \"C206\", \"Capital Additions & Investments \"\n    \"C207\", \"Interest (Expense)/Income \"\n    \"C208\", \"Note principal payments \"\n    \"C209\", \"Other State & Fed Taxes \"\n    \"C210\", \"Tax Distributions to Holdings \"\n    \"C211\", \"Tax Dist. to Other Shareholders \"\n    \"C212\", \"Non-Tax Distributions to Holdings \"\n    \"C213\", \"Non-Tax Dist. to Other Shareholders \"\n    \"C30\", \"Net Cash Flow from Operations \"\n    \"C31\", \"= Gross Cash Inflow(Outflow) \"\n    \"C310\", \"= Net Collections \"\n    \"C311\", \"Gross Collections \"\n    \"C312\", \"Less Core Credits \"\n    \"C321\", \"Payments \"\n    \"C322\", \"Materials \"\n    \"C323\", \"Less Warranty Recovery \"\n    \"C324\", \"Freight Payments \"\n    \"C325\", \"Direct Labor \"\n    \"C326\", \"Overhead Spending \"\n    \"C33\", \"Total Expenses \"\n    \"C331\", \"Engineering \"\n    \"C332\", \"Sales \"\n    \"C333\", \"General & Administrative \"\n    \"C334\", \"ESOP/401K Contributions \"\n    \"C335\", \"Bonus Payments \"\n    \"C336\", \"Gross Warranty Payments \"\n    \"C39\", \"Add back: Depreciation \"\n    \"C2\", \"PLAN Loan Balance \"\n    \"C3\", \"$ VARIANCE TO PLAN (under) \"\n    \"Return On Assets\", \"Return On Assets \"\n    \"R10\", \"Opinion ROA (annualized) \"\n    \"R11\", \"Year End ROA Plan \"\n    \"R5\", \"Year End Net Income Plan \"\n    \"R100\", \"Net Income Calculations \"\n    \"R3\", \"YTD Comparison to Plan \"\n    \"R1\", \"Total Net Income (opinion & YTD) \"\n    \"R110\", \"Last Month Projected Net Income YTD \"\n    \"R120\", \"This Month Opinion Net Income \"\n    \"R2\", \"Net Income YTD Plan \"\n    \"R4\", \"Annualized Projected - Actual, Opinion & Plan \"\n    \"R8\", \"Assets Month to Plan (better) \"\n    \"R6\", \"Total This Month Ending Assets Opinion \"\n    \"R600\", \"Total Assets Calculation \"\n    \"R610\", \"Projected Last Month Ending Assets \"\n    \"R620\", \"Total Net Change in Assets \"\n    \"R630\", \"Total Net Change Inventory \"\n    \"R631\", \"Net Change in Inventory \"\n    \"R632\", \"Total Into Inventory \"\n    \"R633\", \"Material Receipts \"\n    \"R634\", \"Material Usage Variance \"\n    \"R635\", \"Labor \"\n    \"R636\", \"Labor Variance \"\n    \"R637\", \"Overhead Absorbed \"\n    \"R638\", \"Material Recovery from Warranty \"\n    \"R639\", \"COGS Out \"\n    \"R640\", \"Total Net Change Fixed Assets \"\n    \"R641\", \"Net Change in Fixed Assets \"\n    \"R642\", \"Capital and Investments \"\n    \"R643\", \"Depreciation \"\n    \"R650\", \"Total Net Change in A/R \"\n    \"R651\", \"Net Change in Accts Rec \"\n    \"R652\", \"Shipments \"\n    \"R653\", \"Gross Collections \"\n    \"R7\", \"Plan This Month Ending Assets \"\n    \"R9\", \"Year Ending Asset Plan \"\n    \"Earnings\", \"Earnings \"\n    \"E1\", \"EBITDA Dollar Calculations \"\n    \"E2\", \"EBITDA YTD Opinion to Plan (worse) \"\n    \"E20\", \"Annualized Projected  \"\n    \"E21\", \"Total EBITDA Dollars (opinion & YTD) \"\n    \"E22\", \"Projected Last Month EBITDA YTD \"\n    \"E23\", \"This Month Opinion EBITDA Dollars \"\n    \"E231\", \"This Month-- Profit Before Tax and M.I. \"\n    \"E232\", \"This Month-- Interest \"\n    \"E233\", \"This Month-- Depreciation/Amortization \"\n    \"E24\", \"EBITDA Plan Remaining Year \"\n    \"E25\", \"Annual EBITDA Dollars -- FROM PLAN \"\n    \"E3\", \"EBITDA Month Opinion to Plan (worse) \"\n    \"E30\", \"Plan EBITDA Dollars This Month \"\n    \"E31\", \"This Month Opinion EBITDA Dollars \"\n    \"E40\", \"Opinion EBITDA/Assets (annualized) \"\n    \"E41\", \"Annual EBITDA/Month Assets Plan \"\n    \"E42\", \"Annual EBITDA/Annual Assets Plan \"\n    \"R8\", \"Assets Month to Plan (better) \"\n    \"R6\", \"Total This Month Ending Assets Opinion \"\n    \"R600\", \"Total Assets Calculation \"\n    \"R610\", \"Projected Last Month Ending Assets \"\n    \"R620\", \"Total Net Change in Assets \"\n    \"R630\", \"Total Net Change Inventory \"\n    \"R631\", \"Net Change in Inventory \"\n    \"R632\", \"Total Into Inventory \"\n    \"R633\", \"Material Receipts \"\n    \"R634\", \"Material Usage Variance \"\n    \"R635\", \"Labor \"\n    \"R636\", \"Labor Variance \"\n    \"R637\", \"Overhead Absorbed \"\n    \"R638\", \"Material Recovery from Warranty \"\n    \"R639\", \"COGS Out \"\n    \"R640\", \"Total Net Change Fixed Assets \"\n    \"R641\", \"Net Change in Fixed Assets \"\n    \"R642\", \"Capital and Investments \"\n    \"R643\", \"Depreciation \"\n    \"R650\", \"Total Net Change in A/R \"\n    \"R651\", \"Net Change in Accts Rec \"\n    \"R652\", \"Shipments \"\n    \"R653\", \"Gross Collections \"\n    \"R7\", \"Plan This Month Ending Assets \"\n    \"R9\", \"Year Ending Asset Plan \"\n    \"Shipments\", \" \"\n    \"S1\", \"Current Shipments \"\n  |]\n  \nlet rules = \n  [| \n    \"[Version:'Projection'] =IF([Version:'Final Projection']<>0, [Version:'Final Projection'],IF([Version:'Week 5']<>0, [Version:'Week 5'],IF([Version:'Week 4']<>0, [Version:'Week 4'], IF([Version:'Week 3']<>0, [Version:'Week 3'],IF([Version:'Week 2']<>0, [Version:'Week 2'],IF([Version:'Week 1']<>0, [Version:'Week 1'],0))))));\", \"##[Projection] FROM [FP,W5,W4,W3,W2,W1] RULE: IF([Version:'Final Projection']<>0, [Version:'Final Projection'],IF([Version:'Week 5']<>0, [Version:'Week 5'],IF([Version:'Week 4']<>0, [Version:'Week 4'], IF([Version:'Week 3']<>0, [Version:'Week 3'],IF([Version:'Week 2']<>0, [Version:'Week 2'],IF([Version:'Week 1']<>0, [Version:'Week 1'],0))))))\"\n    \"[Version:'Actual\\Projection']=B:IF(NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),1,4))*100+NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),6,2))> NUMBR(!YEAR)*100+NUMBR(SUBST(!PERIOD, 2, 2)),['Actual'], ['Projection']);\", \"##[Actual\\Projection] FROM ['Actual'], ['Projection'] RULE: IF(NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),1,4))*100+NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),6,2))> NUMBR(!YEAR)*100+NUMBR(SUBST(!PERIOD, 2, 2)),['Actual'], ['Projection'])\"\n    \"[Currency:'USD'] =B:[Currency:'LC'] * DB('XRates',!YEAR, !PERIOD, !VERSION, GETATTR('ACCOUNT', !Account, 1, 'XRate'),GETATTR('UNIT', !Unit, 1, 'Currency'));\", \"##[Currency] FROM LC RULE: [Currency:'LC'] * DB('XRates',!YEAR, !PERIOD, !VERSION, GETATTR('ACCOUNT', !Account, 1, 'XRate'),GETATTR('UNIT', !Unit, 1, 'Currency'))\"\n    \"[Period:'YTD']=[Period:'YTD_12'];\", \"##[YTD] FROM [YTD_12] RULE: [Period:'YTD_12']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'310'] =B:-1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370'];\", \"##ELIM [Total Projected Sales Orders] FROM [Interco Revenue] RULE: -1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'370']=-1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370'];\", \"##ELIM [Interco Revenue]                     FROM [Interco Revenue]  RULE: -1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'401']=[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'370']\", \"##ELIM Memo [Only:Inventory Receipts] FROM [Interco Revenue] RULE: [Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'370']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'440'] =B:-1*[Level:'Net Reported', Unit:'Consolidated wo Elims', Account:'440'];\", \"##ELIM [Standard COGS-Interco] FROM [Standard COGS-Interco] RULE: -1*[Level:'Net Reported', Unit:'Consolidated wo Elims', Account:'440']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'430'] =B:-1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']+[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'440'];\", \"##ELIM [Standard COGS-Non Interco] FROM [Interco Revenue] AND [Standard COGS-Interco] RULE: -1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']+[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'440']\"\n    \"[Account:'910', Version:'Plan']=#NA;\", \"##[Minority Interest] RULE: #NA\"\n    \"[Level:'Adjustments', Account:'910']=B:-1*([Account:'36',Level:'Net Reported'])*DB('UNITSET',!YEAR, !PERIOD, !UNIT, 'Minority %');\", \"##[Minority Interest] FROM [Income (Loss) before taxes and M.I.] RULE: -1*([Account:'36',Level:'Net Reported'])*DB('UNITSET',!YEAR, !PERIOD, !UNIT, 'Minority %')\"\n    \"[Account:'40'] =[Account:'39']/[Account:'300'];\", \"##[Actual Gross Margin %] FROM [Actual Gross Income] / [Total Net Revenue] RULE: [Account:'39']/[Account:'300']\"\n    \"[Account:'41'] =[Account:'39',Version:'Plan']/[Account:'300',Version:'Plan'];\", \"##[Plan Gross Margin %] FROM [Actual Gross Income] / [Total Net Revenue] RULE: [Account:'39',Version:'Plan']/[Account:'300',Version:'Plan']\"\n    \"[Account:'31'] =[Account:'30']/[Account:'360'];\", \"##[P.A.T. %] FROM [Net Income After M. I. & Taxes] / [Income (Loss) before taxes and M.I.] RULE: [Account:'30']/[Account:'360']\"\n    \"[Account:'32'] =[Account:'30',Version:'Plan'];\", \"##[PLAN INCOME AFTER TAXES & M.I.] FROM [Net Income After M. I. & Taxes] RULE: [Account:'30',Version:'Plan']\"\n    \"[Account:'33'] =B:[Account:'30']-[Account:'32'];\", \"##[$ VARIANCE TO PLAN] FROM [Net Income After M. I. & Taxes] - [PLAN INCOME AFTER TAXES & M.I.] RULE: [Account:'30']-[Account:'32']\"\n    \"###[Account:'C326']=B:-1*([Account:'5800']-[Account:'5810'])\", \"##[Overhead Spending] FROM [Overhead Spending] - [Bonus Accrual for Overhead] RULE: -1*([Account:'5800']-[Account:'5810'])\"\n    \"[Account:'C331']=-1*([Account:'610']);\", \"##[Engineering] FROM [Engineering] RULE: -1*([Account:'610'])\"\n    \"[Account:'C332']=-1*([Account:'620']);\", \"##[Sales] FROM [Sales] RULE: -1*([Account:'620'])\"\n    \"[Account:'C333']=-1*([Account:'630']);\", \"##[General & Administrative] FROM [General & Administrative] RULE: -1*([Account:'630'])\"\n    \"[Account:'C334']=-1*[Account:'640'];\", \"##[ESOP/401K Contributions] FROM [ESOP/401K Contributions] RULE: -1*([Account:'640'])\"\n    \"[Account:'C205']=B:[Account:'740'];\", \"##[Management Fees] FROM [Management Fees] RULE: [Account:'740']\"\n    \"[Account:'C207']=[Account:'750'];\", \"##[Interest (Expense)/Income] FROM [Interest (Expense)/Income] RULE: [Account:'750']\"\n    \"[Account:'C3'] =[Account:'C1']-[Account:'C2'];\", \"##[$ VARIANCE TO PLAN (under)] FROM [Projected Ending Loan Balance] - [PLAN Loan Balance] RULE: [Account:'C1']-[Account:'C2']\"\n    \"[Account:'C2']=B:IF(!VERSION@='Plan',STET,[Version:'Plan', Account:'C2']);\", \"##[PLAN Loan Balance] FROM [PLAN Loan Balance] RULE: IF(!VERSION@='Plan',STET,[Version:'Plan', Account:'C2'])\"\n    \"[Account:'R110']=B:IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), !VERSION, !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE));\", \"##BC [Last Month Projected Net Income YTD] FROM [Income (Loss) before taxes and M.I.] RULE: IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), !VERSION, !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE))\"\n    \"[Account:'R110']=C:IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Account:'36'], STET);\", \"##CC [Last Month Projected Net Income YTD] FROM [Income (Loss) before taxes and M.I.] RULE: IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Account:'36'], STET)\"\n    \"[Account:'R120'] =[Account:'30'];\", \"##[This Month Opinion Net Income] FROM [Net Income After M. I. & Taxes] RULE: [Account:'30']\"\n    \"[Account:'R2']=B:DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##BC [Net Income YTD Plan] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'R2']=C:IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Version:'Plan', Account:'36'], STET);\", \"##CC [Net Income YTD Plan] FROM [Income (Loss) before taxes and M.I.] RULE: IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Version:'Plan', Account:'36'], STET)\"\n    \"[Account:'R610']=B:IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.SIBLING('Period',!PERIOD,-1), 'Projection', !CURRENCY, !LEVEL, !UNIT, 'R6', !MEASURE));\", \"##[Projected Last Month Ending Assets] FROM [Total This Month Ending Assets Opinion] RULE: IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.SIBLING('Period',!PERIOD,-1), 'Projection', !CURRENCY, !LEVEL, !UNIT, 'R6', !MEASURE))\"\n    \"[Account:'R7']=[Version:'Plan',Account:'R6'];\", \"##[Plan This Month Ending Assets] FROM [Total This Month Ending Assets Opinion] RULE: [Version:'Plan',Account:'R6']\"\n    \"[Account:'R9']=[Period:'Year', Version:'Plan', Account:'R6'];\", \"##[Year Ending Asset Plan] FROM [Total This Month Ending Assets Opinion] RULE: [Period:'Year', Version:'Plan', Account:'R6']\"\n    \"###[Account:'R3'] =[Account:'R1']-[Account:'R2']\", \"##[YTD Comparison to Plan] FROM [Total Net Income (opinion & YTD)] - [Net Income YTD Plan] RULE: [Account:'R1']-[Account:'R2']\"\n    \"[Account:R633] =[Account:401];\", \"##[Material Receipts] FROM [Memo Only:Inventory Receipts] RULE: [Account:401]\"\n    \"[Account:R634] =-1*[Account:520];\", \"##[Material Usage Variance] FROM [Material Usage] RULE: -1*[Account:520]\"\n    \"[Account:R635] =-1*[Account:C325];\", \"##[Labor] FROM [Direct Labor] RULE: -1*[Account:C325]\"\n    \"[Account:R637] =-1*[Account:5820];\", \"##[Overhead Absorbed] FROM [Less:Overhead Absorption] RULE: -1*[Account:5820]\"\n    \"[Account:R636] =-1*[Account:540];\", \"##[Labor Variance] FROM [Labor Performance/Rate] RULE: -1*[Account:540]\"\n    \"[Account:R638] =[Account:C323];\", \"##[Material Recovery from Warranty] FROM [Less Warranty Recovery] RULE: [Account:C323]\"\n    \"[Account:R639] =-1*[Account:'410'];\", \"##[COGS Out] FROM [Cost of Goods Sold] RULE: -1*[Account:'410']\"\n    \"[Account:R642] =-1*[Account:C206];\", \"##[Capital and Investments] FROM [Capital Additions & Investments] RULE: -1*[Account:C206]\"\n    \"[Account:R643] =-1*[Account:C39];\", \"##[Depreciation] FROM [Add back: Depreciation] RULE: -1*[Account:C39]\"\n    \"[Account:R652] =[Account:300];\", \"##[Shipments] FROM [Total Net Revenue] RULE: [Account:300]\"\n    \"[Account:R653] =[Account:C311];\", \"##[Gross Collections] FROM [Gross Collections] RULE: [Account:C311]\"\n    \"[Account:'R10']=[Account:'R4']/[Account:'R6'];\", \"##[Opinion ROA (annualized)] FROM [Annualized Projected - Actual, Opinion & Plan] / [Total This Month Ending Assets Opinion] RULE: [Account:'R4']/[Account:'R6']\"\n    \"[Account:'R11']=[Account:'R5']/[Account:'R9'];\", \"##[Year End ROA Plan] FROM [Year End Net Income Plan] / [Year Ending Asset Plan] RULE: [Account:'R5']/[Account:'R9']\"\n    \"[Account:'E22']=DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), 'Projection', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##[Projected Last Month EBITDA YTD] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), 'Projection', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'E24']=DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)-DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##[EBITDA Plan Remaining Year] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)-DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'E25']=DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##[Annual EBITDA Dollars -- FROM PLAN] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'E30']=[Version:'Plan',Account:'36'];\", \"##[Plan EBITDA Dollars This Month] FROM [Income (Loss) before taxes and M.I.] RULE: [Version:'Plan',Account:'36']\"\n    \"[Account:'E31']=[Account:'E23'];\", \"##[This Month Opinion EBITDA Dollars] FROM [This Month Opinion EBITDA Dollars] RULE: [Account:'E23']\"\n    \"[Account:'E231']=[Account:'36'];\", \"##[This Month-- Profit Before Tax and M.I.] FROM [Income (Loss) before taxes and M.I.] RULE: [Account:'36']\"\n    \"[Account:'E233']=[Account:'C39'];\", \"##[This Month-- Depreciation/Amortization] FROM [Add back: Depreciation] RULE: [Account:'C39']\"\n    \"[Account:'E232']=-1*[Account:'750'];\", \"##[This Month-- Interest] FROM [Interest (Expense)/Income] RULE: -1*[Account:'750']\"\n    \"[Account:'E40']=[Account:'E20']/[Account:'R6'];\", \"##[Opinion EBITDA/Assets (annualized)] FROM [Annualized Projected ] / [Total This Month Ending Assets Opinion] RULE: [Account:'E20']/[Account:'R6']\"\n    \"[Account:'E41']=[Account:'E25']/[Account:'R7'];\", \"##[Annual EBITDA/Month Assets Plan] FROM [Annual EBITDA Dollars -- FROM PLAN] / [Plan This Month Ending Assets] RULE: [Account:'E25']/[Account:'R7']\"\n    \"[Account:'E42']=[Account:'E25']/[Account:'R9'];\", \"##[Annual EBITDA/Annual Assets Plan] FROM [Annual EBITDA Dollars -- FROM PLAN] / [Year Ending Asset Plan] RULE: [Account:'E25']/[Account:'R9']\"\n  |]  \n  \n#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\nopen System.Text.RegularExpressions\n\nlet AccountP = @\"(\\[((.+?),)*\\s*Account\\s*:\\s*'?(.+?)'?(,(.+?))*\\])\"\nlet input    = @\"[Level:'Adjustments', Account:'910']=B:-1*([Account:'36',Level:'Net Reported'])*DB('UNITSET',!YEAR, !PERIOD, !UNIT, 'Minority %');\"\n\nlet splitRule r =\n    Regex.Match(r, @\"(.+?)=(.+)\")\n    |> (fun m -> m.Groups.[1].Value, m.Groups.[2].Value)\n\nlet replace input =\n    Regex.Matches(input, AccountP)\n    |> Seq.cast<Match>\n    |> Seq.map (fun m -> \n        let whole = m.Groups.[0]\n        let acct  = m.Groups.[4]\n        let pres  = m.Groups.[3].Captures |> Seq.cast<Capture>\n        let sufs  = m.Groups.[6].Captures |> Seq.cast<Capture>\n        accounts \n        |> Seq.tryFind (fst >> ((=) acct.Value)) \n        |> Option.map snd \n        |> Option.defaultValue (\"Not Found: \" + acct.Value) \n        |> (fun s -> \n            let txt  = \n                [ yield s.Trim()\n                  for pre in pres do yield pre.Value\n                  for suf in sufs do yield suf.Value \n                ] \n                |> String.concat \"~\" \n                |> sprintf \"{%s}\" \n            txt, whole.Index, whole.Length)\n       )\n    |> Seq.fold (fun (txt:string, i, out) (v, s, l) -> (txt.[s + l - i ..], s + l, out + txt.[0 .. s - i - 1] + v) ) (input, 0, \"\")\n    |> fun (res, _, out) -> out + res\n    \nrules\n|> Seq.iter (\n    fun (r, c) ->\n        let a, b = splitRule r\n        printfn \"%s\\t%s\\t%s\" (replace a) (replace b) c\n \n)","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"dfc80990-ada5-4f24-8192-85bfe3b115a5"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FSharpPlus","content":"#r \"..\\packages\\FSharpPlus\\lib\\net45\\FSharpPlus.dll\"\n\nopen FSharpPlus\n\nlet doF f v = f v; v\n\nlet getType (obj:obj) = if obj = null then null else obj.GetType()\n\nlet print v = printfn \"val it : %O = %A\" (getType v) v\n    \n//let pythags = \nmonad {\n    let! z = [| 1..50    |]\n    let! x = [| 1..z - 1 |]\n    let! y = [| x..z - 1 |]\n    do! guard (x*x + y*y = z*z)\n    return (x, y, z)\n}    \n|> print\n\n//let pythags' = \nmonad.plus {\n      let! z = [1..50   ]\n      let! x = [1..z - 1]\n      let! y = [x..z - 1]\n      do! guard (x*x + y*y = z*z)\n      return (x, y, z)\n}    \n|> print\n\n//let allCombinations = \n//sequence [['a'; 'b'; 'c']; ['1'; '2']]\n//|> print\n\n//let asyncValue = \n(let  a = (printfn \"I'm not async\"; 2)\n async {\n    printfn \"started\"\n    let  b =              (printfn \"I'm kind of async\";  3)\n    let! c = async.Return (printfn \"I'm async too\"    ; 10)\n    return a + b + c\n })\n|> doF print    \n|> Async.RunSynchronously\n|> printfn \"%d\" \n\n//let lazyValue = \n(let  a = (printfn \"I'm not lazy\"; 2)\n monad {\n    printfn \"started\"\n    let  b =      (printfn \"I'm kind of lazy\" ;  2)\n    let! c = lazy (printfn \"I'm lazy too\"     ; 10)\n    return a + b + c\n })\n|> doF print    \n|> fun f -> f.Value\n|> printfn \"%d\" \n    \n//let maybeWithSideFx = \nmonad.fx.strict {  \n//monad.fx {  // without strict we get infinite loop\n        let! a = Some 3\n        let b = ref 0\n        while !b < 10 do \n          let! n = Some ()\n          incr b\n        if a = 3 then printfn \"got 3\"\n        else printfn \"got something else (will never print this)\"\n        return a \n}\n|> print    \n// val maybeWithSideFx : int option = Some 3\n\nlet lst = [None; None; Some 2; Some 4; Some 10; None]\n\n//let maybeManyTimes = \nmonad.plus.strict {\n//monad.plus { // without strict we get Stack Overflow\n        let defaultValue = 42\n        let mutable i = 0\n        return! None\n        while i < 5 do\n            printfn \"looping %i\" i\n            i <- i + 1\n            return! lst.[i]\n        printfn \"halfway\"\n        return! None\n        printfn \"near the end\"\n        return defaultValue \n}\n|> print\n// val maybeManyTimes : int option = Some 2\nprintfn \"--------------------------------------------------------------\"\n\nmap string [|2;3;4;5|]\n// val it : string [] = [|\"2\"; \"3\"; \"4\"; \"5\"|]\n|> print\n\nmap ((+) 9) (Some 3)\n// val it : int option = Some 12\n|> print\n\n//map string (NonEmptyList.create 2 [3;4;5])\n// val it : NonEmptyList<string> = {Head = \"2\"; Tail = [\"3\"; \"4\"; \"5\"];}\n//|> print\n\n[\"hello\";\" \";\"world\"] >>= (fun x -> Seq.toList x)\n|> print\n// val x : char list = ['h'; 'e'; 'l'; 'l'; 'o'; ' '; 'w'; 'o'; 'r'; 'l'; 'd']\n\n\nlet tryParseInt : string -> int option = tryParse\nlet tryDivide x n = if n = 0 then None else Some (x / n)\n\nSome \"20\" >>= tryParseInt >>= tryDivide 100\n|> print\n// val y : int option = Some 5\n\nlet parseAndDivide100By = tryParseInt >=> tryDivide 100\n\nparseAndDivide100By \"20\"   // Some 5\n|> print\nparseAndDivide100By \"zero\" // None\n|> print\nparseAndDivide100By \"0\"    // None\n|> print\n\nlet parseElement n = List.tryItem n >=> tryParseInt\nparseElement 2 [\"0\"; \"1\";\"2\"]\n|> print\n\nlet tryParseInt' x : Choice<int, string> = \n    match tryParse x with \n    | Some x -> Choice1Of2 x\n    | None   -> Choice2Of2 (\"Failed to parse \" + x)\n        \n\nlet tryDivide' x n = \n    if n = 0 then Choice2Of2 \"Can't divide by zero\"\n    else Choice1Of2 (x / n)\n    \nlet parseAndDivide100By' = tryParseInt' >=> tryDivide' 100\n\nparseAndDivide100By' \"20\"   // Some 5\n|> print\nparseAndDivide100By' \"zero\" // None\n|> print\nparseAndDivide100By' \"0\"    // None\n|> print\n\nSome (+) <*> Some 2 <*> Some 10     // val sumAllOptions : int option = Some 12\n|> print\n\n[(+)] <*> [10; 100] <*> [1; 2; 3]   // int list = [11; 12; 13; 101; 102; 103]\n|> print\n\nopen FSharpPlus.Lens\n\n\n(\"hello\",\"world\")^. FSharpPlus.Lens._2\n// val it : string = \"world\"\n|> print\n\nsetl _2 42 (\"hello\",\"world\", 8)\n// val it : string * int = (\"hello\", 42)\n|> print\n\n(\"hello\",(\"world\",\"!!!\"))^.(_2 << _1)\n// val it : string = \"world\"\n|> print\n\nsetl (_2 << _1) 42 (\"hello\",(\"world\",\"!!!\"))             \n// val it : string * (int * string) = (\"hello\", (42, \"!!!\"))\n|> print\n\n\"hello\"^.to' length\n// val it : int = 5\n|> print\n\n(\"hello\",(\"world\",\"!!!\"))^. (_2 << _2 << to' length)\n// val it : int = 3\n|> print\n\n_1 .-> \"hello\" <| ((),\"world\")\n// val it : string * string = (\"hello\", \"world\")\n|> print\n\n((), \"world\") |> _1 .-> \"hello\"\n|> print // val it : string * string = (\"hello\", \"world\")\n\nview _2 (10,20)\n|> print // val it : int = 20\n\nlet x = -5\nlet y =  3\nlet t = \"Hello\"\n//printfn \"%d\"    abs(x + y)   // clear to humans but computer says no: FS0597\n//printfn \"%d\"    abs (x + y)  // wrong two parameters not one\nprintfn \"%d\"   (abs(x + y))  // ok = 2 but too many parenthesis\nprintfn \"%d\"   (abs x + y )  // wrong = 8\nabs(x + y)   |> printfn \"%d\" // ok = 2 idiomatic, but ...\nx + y |> abs |> printfn \"%d\" // ok = 2 also idiomatic, but ...\nprintfn \"%d\" <| abs(x + y)   // ok = 2 but not as clean or clear as: printfn \"%d\" abs(y)\nprintfn \"%d\" t.Left(3).Length\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"3def8b16-6c90-40f4-a78e-b2b293df699a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Expr GADT's","content":"module Case0 =\n    type Expr =\n        | I of int\n        | Add of Expr * Expr\n        | Mul of Expr * Expr\n                \n    let rec eval (e: Expr) : int =   \n        match e with\n        | I   n      -> n\n        | Add (a, b) -> eval a + eval b\n        | Mul (a, b) -> eval a * eval b\n\n    let ( + ) a b = Add(a, b)\n    let ( * ) a b = Mul(a, b)\n\n    printfn \"Case0\"\n    (I 5 + I 1) * I 7\n    |> fun e -> printfn \"%A = %A\" e <| eval e\n\nmodule Case1 =\n    type Expr =\n        | I of int\n        | B of bool\n        | Add of Expr * Expr\n        | Mul of Expr * Expr\n        | Eq  of Expr * Expr        \n        \n    let rec eval (e: Expr) : int =   \n        match e with\n        | I   n      -> n\n        | B   b      -> if b then 1 else 0\n        | Add (a, b) -> eval a + eval b\n        | Mul (a, b) -> eval a * eval b\n        | Eq  (a, b) -> eval a = eval b |> B |> eval\n\n    let ( +  ) a b = Add(a, b)\n    let ( *  ) a b = Mul(a, b)\n    let ( == ) a b = Eq (a, b)\n\n    printfn \"Case1\"\n    I 5 + I 1 == I 7\n    |> fun e -> printfn \"%A = %A\" e <| eval e\n        \nmodule Case2 =\n    type Expr =\n        | I of int\n        | B of bool\n        | Add of Expr * Expr\n        | Mul of Expr * Expr\n        | Eq  of Expr * Expr\n        \n    let rec eval (e: Expr) : Choice<int, bool> option =   \n        match e with\n        | I    n                                       -> n               |> Choice1Of2 |> Some\n        | B    b                                       -> b               |> Choice2Of2 |> Some\n        | Add (a, b) ->             \n            match eval a, eval b with            \n            | Some (Choice1Of2 a), Some (Choice1Of2 b) -> a + b           |> Choice1Of2 |> Some\n            | _                                        ->                                  None\n        | Mul (a, b) ->             \n            match eval a, eval b with            \n            | Some (Choice1Of2 a), Some (Choice1Of2 b) -> a * b           |> Choice1Of2 |> Some\n            | _                                        ->                                  None\n        | Eq  (a, b)                                   -> eval a = eval b |> Choice2Of2 |> Some\n\n    let ( +  ) a b = Add(a, b)\n    let ( *  ) a b = Mul(a, b)\n    let ( == ) a b = Eq (a, b)\n\n    printfn \"Case2\"\n    I 5 + I 1 == I 7\n    |> fun e -> printfn \"%A = %A\" e <| eval e\n\n    B true + I 5\n    |> fun e -> printfn \"%A = %A\" e <| eval e\n\nmodule Case3a =\n    type Expr =\n        | I   of int\n        | B   of bool\n        | Add of Expr * Expr\n        | Mul of Expr * Expr\n        | Eq  of Expr * Expr\n    type ExprT<'T> = ExprT of Expr\n        \n    let Add (ExprT a: ExprT<int>, ExprT b: ExprT<int>) : ExprT<int > = Add(a, b) |> ExprT\n    let Mul (ExprT a: ExprT<int>, ExprT b: ExprT<int>) : ExprT<int > = Mul(a, b) |> ExprT\n    let Eq  (ExprT a: ExprT<_  >, ExprT b: ExprT<_  >) : ExprT<bool> = Eq (a, b) |> ExprT\n    let I n                                            : ExprT<int > = I n       |> ExprT\n    let B b                                            : ExprT<bool> = B b       |> ExprT\n\n    let rec eval (e: ExprT<'T>) : Choice<int, bool> option =   \n        match e with\n        | ExprT(I    n    )                            -> n                               |> Choice1Of2 |> Some\n        | ExprT(B    b    )                            -> b                               |> Choice2Of2 |> Some\n        | ExprT(Add (a, b)) ->             \n            match eval (ExprT a), eval (ExprT b) with            \n            | Some (Choice1Of2 a), Some (Choice1Of2 b) -> a + b                           |> Choice1Of2 |> Some\n            | _                                        ->                                                  None\n        | ExprT(Mul (a, b)) ->             \n            match eval (ExprT a), eval (ExprT b) with            \n            | Some (Choice1Of2 a), Some (Choice1Of2 b) -> a * b                           |> Choice1Of2 |> Some\n            | _                                        ->                                                  None\n        | ExprT(Eq  (a, b))                            -> eval (ExprT a) = eval (ExprT b) |> Choice2Of2 |> Some\n\n    let ( +  ) a b = Add(a, b)\n    let ( *  ) a b = Mul(a, b)\n    let ( == ) a b = Eq (a, b)\n\n    printfn \"Case3a\"\n    I 5 + I 1 == I 7\n    |> fun e -> printfn \"%A = %A\" e <| eval e\n\n//    B true + I 5\n//    |> fun e -> printfn \"%A = %A\" e <| eval e\n\nmodule Case3b =\n    type Expr =\n        | I   of int\n        | B   of bool\n        | Add of Expr * Expr\n        | Mul of Expr * Expr\n        | Eq  of Expr * Expr\n    type ExprT<'T> = ExprT of Expr\n        \n    let Add (ExprT a: ExprT<int>, ExprT b: ExprT<int>) : ExprT<int > = Add(a, b) |> ExprT\n    let Mul (ExprT a: ExprT<int>, ExprT b: ExprT<int>) : ExprT<int > = Mul(a, b) |> ExprT\n    let Eq  (ExprT a: ExprT<_  >, ExprT b: ExprT<_  >) : ExprT<bool> = Eq (a, b) |> ExprT\n    let I n                                            : ExprT<int > = I n       |> ExprT\n    let B b                                            : ExprT<bool> = B b       |> ExprT\n    \n    type Eval() =     \n        static let rec eval e = \n            match e with\n            | ExprT(I    n    )                            -> n                               |> Choice1Of2 |> Some\n            | ExprT(B    b    )                            -> b                               |> Choice2Of2 |> Some\n            | ExprT(Add (a, b)) ->             \n                match eval (ExprT a), eval (ExprT b) with            \n                | Some (Choice1Of2 a), Some (Choice1Of2 b) -> a + b                           |> Choice1Of2 |> Some\n                | _                                        ->                                                  None\n            | ExprT(Mul (a, b)) ->             \n                match eval (ExprT a), eval (ExprT b) with            \n                | Some (Choice1Of2 a), Some (Choice1Of2 b) -> a * b                           |> Choice1Of2 |> Some\n                | _                                        ->                                                  None\n            | ExprT(Eq  (a, b))                            -> eval (ExprT a) = eval (ExprT b) |> Choice2Of2 |> Some\n        static let fail t = failwith <| sprintf \"Result is not of type <%s>\" t\n    with\n      static member Eval (e:ExprT<int >) =\n        match eval e with\n        | Some (Choice1Of2 a) -> a\n        | _                   -> fail \"int\"\n      static member Eval (e:ExprT<bool>) =\n        match eval e with\n        | Some (Choice2Of2 a) -> a\n        | _                   -> fail \"bool\"\n\n    let ( +  ) a b = Add(a, b)\n    let ( *  ) a b = Mul(a, b)\n    let ( == ) a b = Eq (a, b)\n\n    printfn \"Case3b\"\n    I 5 + I 1 == I 7\n    |> fun e -> printfn \"%A = %A\" e <| Eval.Eval e\n\n//    B true + I 5\n//    |> fun e -> printfn \"%A = %A\" e <| Eval.Eval e\n\n\nmodule Case3c =\n    type I      = I   of int\n    and  B      = B   of bool\n    and  Add    = Add of Expr<int > * Expr<int >\n    and  Mul    = Mul of Expr<int > * Expr<int >\n    and  EqI    = EqI of Expr<int > * Expr<int >\n    and  EqB    = EqB of Expr<bool> * Expr<bool>\n    and  Expr<'T> =\n        | TI   of I   \n        | TB   of B   \n        | TAdd of Add \n        | TMul of Mul \n        | TEqI of EqI  \n        | TEqB of EqB \n        \n    let Add (a: Expr<int>, b: Expr<int>) : Expr<int > = Add(a, b) |> TAdd\n    let Mul (a: Expr<int>, b: Expr<int>) : Expr<int > = Mul(a, b) |> TMul\n    let EqI (a: Expr<_  >, b: Expr<_  >) : Expr<bool> = EqI(a, b) |> TEqI\n    let EqB (a: Expr<_  >, b: Expr<_  >) : Expr<bool> = EqB(a, b) |> TEqB\n    let I n                              : Expr<int > = I   n     |> TI\n    let B b                              : Expr<bool> = B   b     |> TB\n\n    type Eval() =     \n        static let fail t = failwith <| sprintf \"Result is not of type <%s>\" t\n    with\n      static member Eval (I   n                              ) : int  = n \n      static member Eval (B   b                              ) : bool = b\n      static member Eval (Add(a : Expr<int >, b : Expr<int >)) : int  = Eval.Eval a + Eval.Eval b\n      static member Eval (Mul(a : Expr<int >, b : Expr<int >)) : int  = Eval.Eval a * Eval.Eval b\n      static member Eval (EqI(a : Expr<int >, b : Expr<int >)) : bool = Eval.Eval a = Eval.Eval b\n      static member Eval (EqB(a : Expr<bool>, b : Expr<bool>)) : bool = Eval.Eval a = Eval.Eval b\n      static member Eval (    e : Expr<int >                 ) : int  = \n          match e with\n          | TI   e -> Eval.Eval e   \n          | TAdd e -> Eval.Eval e\n          | TMul e -> Eval.Eval e\n          | _      -> fail \"int\"\n      static member Eval (    e : Expr<bool>                 ) : bool = \n          match e with\n          | TB   e -> Eval.Eval e\n          | TEqI e -> Eval.Eval e\n          | TEqB e -> Eval.Eval e\n          | _      -> fail \"bool\"   \n\n    let ( +  ) a b = Add(a, b)\n    let ( *  ) a b = Mul(a, b)\n    let ( == ) a b = EqI(a, b)\n    let ( =@ ) a b = EqB(a, b)\n\n    printfn \"Case3c\"\n    (I 5 + I 1) == I 7\n    |> fun e -> printfn \"%A = %A\" e <| Eval.Eval e\n\n    (I 5 == I 1) =@ B false\n    |> fun e -> printfn \"%A = %A\" e <| Eval.Eval e\n\n//    B true + I 5\n//    |> fun e -> printfn \"%A = %A\" e <| Eval.Eval e\n\n(*module Case4 =   \n    type Expr<'T> = \n        | I   of int\n        | B   of bool\n        | Add of Expr<'T> * Expr<'T>\n        | Mul of Expr<'T> * Expr<'T>\n        | Eq  of Expr<'T> * Expr<'T>                              // using the phantom type 'T fails for Eq\n        \n    let Add (a: Expr<int>, b: Expr<int>) : Expr<int > = Add(a, b)\n    let Mul (a: Expr<int>, b: Expr<int>) : Expr<int > = Mul(a, b)\n    let Eq  (a: Expr<'a >, b: Expr<'a >) : Expr<bool> = Eq (a, b) // because of this\n    let I n                              : Expr<int > = I n   \n    let B b                              : Expr<bool> = B b   \n\n    let rec eval (e: Expr<'T>) : Choice<int, bool> option =   \n        match e with\n        | I    n                                       -> n               |> Choice1Of2 |> Some\n        | B    b                                       -> b               |> Choice2Of2 |> Some\n        | Add (a, b) ->             \n            match eval a, eval b with            \n            | Some (Choice1Of2 a), Some (Choice1Of2 b) -> a + b           |> Choice1Of2 |> Some\n            | _                                        ->                                  None\n        | Mul (a, b) ->             \n            match eval a, eval b with            \n            | Some (Choice1Of2 a), Some (Choice1Of2 b) -> a * b           |> Choice1Of2 |> Some\n            | _                                        ->                                  None\n        | Eq  (a, b)                                   -> eval a = eval b |> Choice2Of2 |> Some\n\n    printfn \"Case4\"\n    Eq(Add(I 5, I 1), I 7)\n    |> fun e -> printfn \"%A = %A\" e <| eval e\n\n //   Add(B true, I 5)\n //   |> fun e -> printfn \"%A = %A\" e <| eval e\n\n*)\n\nprintfn \"Case SafeList\"\n\ntype EmptyList    = EmptyList\ntype NonEmptyList = NonEmptyList\ntype BaseList<'T> =\n    | Nil\n    | Cons of 'T * BaseList<'T>\ntype SafeList<'T, 'E> = SafeList of BaseList<'T>\n\nlet Nil                 : SafeList<_, EmptyList   > = SafeList    Nil\nlet Cons(e, SafeList l) : SafeList<_, NonEmptyList> = SafeList <| Cons(e, l)\n\nlet SafeHead(a: SafeList<_, NonEmptyList>) = match a with | SafeList (Cons (e, l)) -> e | _ -> failwith \"not possible\"\n\nCons(\"Hello\", Nil)\n|> fun e -> printfn \"SafeHead of %A = %A\" e <| SafeHead e \n\n//Nil\n//|> fun e -> printfn \"SafeHead of %A = %A\" e <| SafeHead e \n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"89c87a53-75dd-4f6b-aa52-c1de4d1d4ff0"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Fable inline Errors","content":"let counter =\n    let mutable i = 0\n    fun () ->\n        i <- i + 1\n        i\n    \ntype Type = {\n    a     : int\n    b     : int\n    c     : int\n    d     : int\n    count : int\n}\n  with\n    static member New(n) = {\n        a     = n\n        b     = n * 2\n        c     = n * 3\n        d     = n * 4\n        count = counter()\n      }\n      \n    member        this.Method  (v:bool) = { this with a = this.a * if v then 2 else 3 }\n    member inline this.MethodI (v:bool) = { this with a = this.a * if v then 2 else 3 }\n    member        this.Method  ()       = { this with a = this.a * 10 }\n    member inline this.MethodI ()       = { this with a = this.a * 10 }\n\nType.New(5).Method(false).Method(true).Method()\n|> printfn \"not inline: %A\"\n    \nType.New(5).MethodI(false).MethodI(true).MethodI()\n|> printfn \"inline: %A\"\n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"b1a33b33-1d1d-4c5f-be94-988886b74c31"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"System.IO.Path.GetRandomFileName()\n|> printfn \"%s\"","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"c8d8aeb9-a872-45dc-b240-b7846e076d1a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Check All F# Code 1","content":"#define JUSTCHECKING","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"3def8b16-6c90-40f4-a78e-b2b293df699a"},{"$":0,"Item":"89c87a53-75dd-4f6b-aa52-c1de4d1d4ff0"},{"$":0,"Item":"b1a33b33-1d1d-4c5f-be94-988886b74c31"},{"$":0,"Item":"c8d8aeb9-a872-45dc-b240-b7846e076d1a"},{"$":0,"Item":"dfc80990-ada5-4f24-8192-85bfe3b115a5"},{"$":0,"Item":"f850ce38-14e5-47a4-81ed-df02d7979f8e"},{"$":0,"Item":"210f90c1-81fc-43bd-b838-6a5dc2a8e46b"},{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},{"$":0,"Item":"b4a9f681-f5c2-443b-8f6e-146a6d6cd093"},{"$":0,"Item":"08e9600a-804b-4aba-a262-85f22e0cc8de"},{"$":0,"Item":"8efdcd5a-95c4-4212-9c75-1ebedce83dd8"},{"$":0,"Item":"c7e56d1e-aea8-483a-a99a-23b7e056de0d"},{"$":0,"Item":"16f618b6-0483-44dc-9c54-550f4f5b725d"},{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},{"$":0,"Item":"56e5bc09-e528-49cc-9d42-6359b32a0cc9"},{"$":0,"Item":"8ee6b535-3615-4066-8917-9125cf8a1f20"},{"$":0,"Item":"1d18fdb5-2488-4ac9-813a-c96a66b9cd13"},{"$":0,"Item":"5df15cf1-361e-4d57-a565-683ab0b72082"},{"$":0,"Item":"3d704638-8ba4-4bc8-b810-29e023a222fc"},{"$":0,"Item":"bd716e89-0546-4d6b-8964-26473ddcd121"},{"$":0,"Item":"dc44bbe1-876a-4910-a39a-5d74bc2304ee"},{"$":0,"Item":"46450fbf-b073-4a66-ab42-587be0afc45f"}],"id":{"$":0,"Item":"caa2898b-b46a-4e93-99ba-63cc8e5726d0"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Test FSharp.Compiler.Service","content":"let input = \"\"\"\n(**)#r @\"D:\\Abe\\CIPHERWorkspace\\Repos\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\nopen System\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n\n// Create an interactive checker instance \n#if HELLO\nlet checker = FSharpChecker.Create()\n#endif\n// Sample input as a multi-line string\nlet input = \"\"\n// Split the input & define file name\nlet inputLines = input.Split('\\n')\nlet file = \"/home/user/Test.fsx\"\n\nasync {\n    let! projOptions                   = checker.GetProjectOptionsFromScript(file, input)\n    let! parseResults, checkFileAnswer = checker.ParseAndCheckFileInProject(file, 0, input, projOptions) \n    let! tip                           =\n        match checkFileAnswer with\n        | FSharpCheckFileAnswer.Succeeded res -> async { let! tip = res.GetToolTipTextAlternate(4, 13, inputLines.[1], [\"foo\"], FSharpTokenTag.Identifier) \n                                                         return sprintf \"%A\" tip                              }\n        | res                                 -> async { return sprintf \"Parsing did not finish... (%A)\" res }      \n    printfn \"%s\" tip\n} |> Async.RunSynchronously\n\"\"\"              \n\n#define FSHARP40\n#r @\"D:\\Abe\\CIPHERWorkspace\\Repos\\packages\\ServiceStack.Text\\lib\\net45\\ServiceStack.Text.dll\"\n#if FHSARP40\n#r @\"D:\\Abe\\CIPHERWorkspace\\Repos\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n#else\n#r @\"FSharp.Compiler.Service.dll\"\n#endif\n\nopen System\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\nopen ServiceStack.Text\n\nlet checker = FSharpChecker.Create()\n\nlet file       = @\"Compiled\\Test.fsx\"\nlet inputLines = input.Split('\\n')\nlet line       = 2\nlet lineStr    = inputLines.[line - 1]\nasync {\n    #if FSHARP40 \n    let! projOptions0    = checker.GetProjectOptionsFromScript(file, input)\n    #else\n    let! projOptions02, errors           = checker.GetProjectOptionsFromScript(file, input)\n    printfn \"ERRORS: %A\" errors\n    #endif\n    let  projOptions     = { projOptions0 with OtherOptions = Array.append projOptions0.OtherOptions [| \"-d:HELLO\" |]}\n    let! parseResults, checkFileAnswer = checker.ParseAndCheckFileInProject(file, 0, \"////-d:HELLO\\nlet a = 1\", projOptions)\n    let! tip                           =\n        match checkFileAnswer with\n        | FSharpCheckFileAnswer.Succeeded res -> \n//                 sprintfn \"answer:%A\" res.GetAllUsesOfAllSymbolsInFile\n                 async { let! tip = res.GetToolTipTextAlternate(2, 5, \"let a = 1\", [\"a\"], FSharpTokenTag.IDENT) \n//                 async { //let tip = res.//GetAllUsesOfAllSymbolsInFile() \n                         //.Replace(\" \", \"_\")\n                               //|> Seq.map (fun u -> u.DisplayContext, u.FileName, u.RangeAlternate, u.Symbol)\n                               // |> Seq.map (sprintf \"%A\")\n                               // |> String.concat \"\\n\"\n                         return sprintf \"%A\" tip }\n        | res -> async { return sprintf \"Parsing did not finish... (%A)\" res }      \n    printfn \"%s\" tip\n    printfn \":%s\" lineStr\n    printfn \"PROJECT: %A\" projOptions\n    //parseResults.PrintDump()\n    let res = checker.TryGetRecentCheckResultsForFile(file, projOptions)\n    printfn \"RES: %A\" res\n    match res with\n    | None  -> ()\n    | Some  (_, res,_) ->\n        let! tip2 = res.GetToolTipTextAlternate(2, 5, \"let a = 1\", [\"a\"], FSharpTokenTag.IDENT) \n        printfn \"TIP2: %A\" tip2\n} |> Async.RunSynchronously","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"d54a55c5-1462-4983-a966-4feb4cfccb2a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Check All F# Code 2","content":"// separate check for FSAutoComplete because it uses a different version of Compiler.Services.dll than Compile\n#define JUSTCHECKING","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"d54a55c5-1462-4983-a966-4feb4cfccb2a"},{"$":0,"Item":"971e9b81-6e5d-4f11-a604-f87504d7c950"}],"id":{"$":0,"Item":"11e21cf6-f497-4f73-a287-a2d5ff5b0445"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Snippets2","content":"module Snippets2 =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"a4f1955e-4ac9-4e56-9991-4f960e601597"},"expanded":false,"level":0,"levelCode":0,"properties":{}},{"name":"FSLab (not working)","content":"#nowarn \"211\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages\\FsLab\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Deedle/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Deedle.1.2.4/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Deedle.RPlugin/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Deedle.RPlugin.1.2.4/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/FSharp.Charting/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/FSharp.Charting.0.90.14/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/FSharp.Data/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/FSharp.Data.2.3.0/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Foogle.Charts/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Foogle.Charts.0.0.5/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/MathNet.Numerics/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/MathNet.Numerics.3.11.1/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/MathNet.Numerics.FSharp/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/MathNet.Numerics.FSharp.3.11.1/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/DynamicInterop/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/DynamicInterop.0.7.4/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/R.NET.Community/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/R.NET.Community.1.6.5/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/R.NET.Community.FSharp/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/R.NET.Community.FSharp.1.6.5/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/RProvider/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/RProvider.1.1.20/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/XPlot.Plotly/lib/net45\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/XPlot.Plotly.1.3.1/lib/net45\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/XPlot.GoogleCharts/lib/net45\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/XPlot.GoogleCharts.1.3.1/lib/net45\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/XPlot.GoogleCharts.Deedle/lib/net45\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/XPlot.GoogleCharts.Deedle.1.3.1/lib/net45\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Google.DataTable.Net.Wrapper/lib\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Google.DataTable.Net.Wrapper.3.1.2.0/lib\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Newtonsoft.Json/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Newtonsoft.Json.8.0.3/lib/net40\"\n#r \"Deedle.dll\"\n#r \"Deedle.RProvider.Plugin.dll\"\n#r \"System.Windows.Forms.DataVisualization.dll\"\n#r \"FSharp.Charting.dll\"\n#r \"FSharp.Data.dll\"\n#r \"Foogle.Charts.dll\"\n#r \"MathNet.Numerics.dll\"\n#r \"MathNet.Numerics.FSharp.dll\"\n#r \"DynamicInterop.dll\"\n#r \"RDotNet.dll\"\n#r \"RDotNet.NativeLibrary.dll\"\n#r \"RDotNet.FSharp.dll\"\n#r \"RProvider.Runtime.dll\"\n#r \"RProvider.dll\"\n#r \"XPlot.Plotly.dll\"\n#r \"XPlot.GoogleCharts.dll\"\n#r \"XPlot.GoogleCharts.Deedle.dll\"\n#r \"Google.DataTable.Net.Wrapper.dll\"\n#r \"Newtonsoft.Json.dll\"\n//namespace FsLab\n\n#if NO_FSI_ADDPRINTER\n#else\nmodule FsiAutoShow =\n  open FSharp.Charting\n  open RProvider\n\n  fsi.AddPrinter(fun (printer:Deedle.Internal.IFsiFormattable) ->\n    \"\\n\" + (printer.Format()))\n  fsi.AddPrinter(fun (ch:FSharp.Charting.ChartTypes.GenericChart) ->\n    ch.ShowChart() |> ignore; \"(Chart)\")\n  fsi.AddPrinter(fun (synexpr:RDotNet.SymbolicExpression) ->\n    synexpr.Print())\n\n  open System.IO\n  open Foogle\n  open Foogle.SimpleHttp\n\n  let server = ref None\n  let tempDir = Path.GetTempFileName()\n  let pid = System.Diagnostics.Process.GetCurrentProcess().Id\n  let counter = ref 1\n\n  do File.Delete(tempDir)\n  do Directory.CreateDirectory(tempDir) |> ignore\n\n  let displayHtml html = \n    match server.Value with\n    | None -> server := Some (HttpServer.Start(\"http://localhost:8084/\", tempDir))\n    | _ -> ()\n    let file = sprintf \"show_%d_%d.html\" pid counter.Value\n    File.WriteAllText(Path.Combine(tempDir, file), html)\n    System.Diagnostics.Process.Start(\"http://localhost:8084/\" + file) |> ignore\n    incr counter\n      \n  fsi.AddPrinter(fun (chart:FoogleChart) ->\n    chart\n    |> Foogle.Formatting.Google.CreateGoogleChart\n    |> Foogle.Formatting.Google.GoogleChartHtml\n    |> displayHtml \n    \"(Foogle Chart)\" )\n\n  fsi.AddPrinter(fun (chart:XPlot.GoogleCharts.GoogleChart) ->\n    let ch = chart |> XPlot.GoogleCharts.Chart.WithSize (800, 600)\n    ch.Html |> displayHtml\n    \"(Google Chart)\")\n\n  fsi.AddPrinter(fun (chart:XPlot.Plotly.PlotlyChart) ->\n    \"\"\"<!DOCTYPE html>\n    <html>\n    <head>\n        <title>Plotly Chart</title>\n        <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script>\n    </head>\n    <body>\"\"\" + chart.GetInlineHtml() + \"</body></html>\" |> displayHtml\n    \"(Plotly Chart)\" )\n#endif\n\n//namespace FSharp.Charting\nopen FSharp.Charting\nopen Deedle\n\n[<AutoOpen>]\nmodule FsLabExtensions =\n  type FSharp.Charting.Chart with\n    static member Line(data:Series<'K, 'V>, ?Name, ?Title, ?Labels, ?Color, ?XTitle, ?YTitle) =\n      Chart.Line(Series.observations data, ?Name=Name, ?Title=Title, ?Labels=Labels, ?Color=Color, ?XTitle=XTitle, ?YTitle=YTitle)\n    static member Column(data:Series<'K, 'V>, ?Name, ?Title, ?Labels, ?Color, ?XTitle, ?YTitle) =\n      Chart.Column(Series.observations data, ?Name=Name, ?Title=Title, ?Labels=Labels, ?Color=Color, ?XTitle=XTitle, ?YTitle=YTitle)\n    static member Pie(data:Series<'K, 'V>, ?Name, ?Title, ?Labels, ?Color, ?XTitle, ?YTitle) =\n      Chart.Pie(Series.observations data, ?Name=Name, ?Title=Title, ?Labels=Labels, ?Color=Color, ?XTitle=XTitle, ?YTitle=YTitle)\n    static member Area(data:Series<'K, 'V>, ?Name, ?Title, ?Labels, ?Color, ?XTitle, ?YTitle) =\n      Chart.Area(Series.observations data, ?Name=Name, ?Title=Title, ?Labels=Labels, ?Color=Color, ?XTitle=XTitle, ?YTitle=YTitle)\n    static member Bar(data:Series<'K, 'V>, ?Name, ?Title, ?Labels, ?Color, ?XTitle, ?YTitle) =\n      Chart.Bar(Series.observations data, ?Name=Name, ?Title=Title, ?Labels=Labels, ?Color=Color, ?XTitle=XTitle, ?YTitle=YTitle)\n\n//namespace Foogle\nopen Deedle\n\n[<AutoOpen>]\nmodule FoogleExtensions =\n\n  type Foogle.Chart with\n    static member PieChart(frame:Frame<_, _>, column, ?Label, ?PieHole) =\n      Foogle.Chart.PieChart\n        ( frame.GetColumn<float>(column) |> Series.observations,\n          ?Label=Label, ?PieHole=PieHole)\n    static member GeoChart(frame:Frame<_, _>, column, ?Label, ?Region, ?DisplayMode) =\n      Foogle.Chart.GeoChart\n        ( frame.GetColumn<float>(column) |> Series.observations,\n          ?Label=Label, ?Region=Region, ?DisplayMode=DisplayMode)\n\n//namespace MathNet.Numerics.LinearAlgebra\nopen MathNet.Numerics.LinearAlgebra\nopen Deedle\n\nmodule Matrix =\n  let inline toFrame matrix = matrix |> Matrix.toArray2 |> Frame.ofArray2D\nmodule DenseMatrix =\n  let inline ofFrame frame = frame |> Frame.toArray2D |> DenseMatrix.ofArray2\nmodule SparseMatrix =\n  let inline ofFrame frame = frame |> Frame.toArray2D |> SparseMatrix.ofArray2\nmodule Vector =\n  let inline toSeries vector = vector |> Vector.toSeq |> Series.ofValues\nmodule DenseVector =\n  let inline ofSeries series = series |> Series.values |> Seq.map (float) |> DenseVector.ofSeq\nmodule SparseVector =\n  let inline ofSeries series = series |> Series.values |> Seq.map (float) |> SparseVector.ofSeq\n\n\n//namespace Deedle\nopen Deedle\nopen MathNet.Numerics.LinearAlgebra\n\nmodule Frame =\n  let inline ofMatrix matrix = matrix |> Matrix.toArray2 |> Frame.ofArray2D\n  let inline toMatrix frame = frame |> Frame.toArray2D |> DenseMatrix.ofArray2\n\n  let ofCsvRows (data:FSharp.Data.Runtime.CsvFile<'T>) =\n    match data.Headers with\n    | None -> Frame.ofRecords data.Rows\n    | Some names -> Frame.ofRecords data.Rows |> Frame.indexColsWith names\n\nmodule Series =\n  let inline ofVector vector = vector |> Vector.toSeq |> Series.ofValues\n  let inline toVector series = series |> Series.values |> Seq.map (float) |> DenseVector.ofSeq\n","parent":{"$":0,"Item":"a4f1955e-4ac9-4e56-9991-4f960e601597"},"predecessors":[],"id":{"$":0,"Item":"8a27056f-c4c9-41a3-bfbb-7869240575ab"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"WorldBankProvider","content":"#r \"../packages/FSharp.Data/lib/net40/FSharp.Data.dll\"\n#r \"../packages/XPlot.Plotly/lib/net45/XPlot.Plotly.dll\"\n\nopen FSharp.Data\nopen XPlot.Plotly\n \nlet wb = WorldBankData.GetDataContext()\n\nlet cs = wb.Countries\n\n//wb.Countries.``European Union``.Indicators.``Women who believe a husband is justified in beating his wife when she argues with him (%)``.Years\ncs\n|> Seq.choose(fun c -> \n    c.Indicators.``Women who believe a husband is justified in beating his wife when she argues with him (%)``.Values \n    |> Seq.tryLast\n    |> Option.map (fun v -> c, v)\n   )\n|> Seq.sortByDescending snd\n|> Seq.map (sprintf \"%A\")\n|> String.concat \"\\n\"\n|> printfn \"%s\"\n","parent":{"$":0,"Item":"a4f1955e-4ac9-4e56-9991-4f960e601597"},"predecessors":[],"id":{"$":0,"Item":"2cb87fcf-2fb6-487b-a9ee-aa46802f7d64"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"type Person = { name: string; age: int }\ntype DB = { people: Person list }\n//let db' : DB = database(\"People\")\n\nlet printout v =\n    v\n    |> String.concat \"\\n\"\n    |> printfn \"%s\"\n\nmodule naive =\n\n    let db' =\n        { people = \n            [\n               { name = \"Alex\"; age = 40 }\n               { name = \"Bert\"; age = 30 }\n               { name = \"Cora\"; age = 35 }\n               { name = \"Drew\"; age = 60 }\n               { name = \"Edna\"; age = 25 }\n               { name = \"Fred\"; age = 70 }\n            ]}\n    \n    let youths': Person list =\n        [\n            for u in db'.people do\n              for v in db'.people do\n                if u.name = \"Alex\" && v.age < u.age then\n                  yield {name= v.name;  age = v.age}  \n        ]                \n    \n    youths'\n    |> Seq.map (fun p -> sprintf \"%s %d\" p.name p.age )\n    |> printout\n    \nmodule quotations =\n    open Microsoft.FSharp.Quotations\n\n    let db =\n        <@\n            { people = \n                [\n                   { name = \"Alex\"; age = 40 }\n                   { name = \"Bert\"; age = 30 }\n                   { name = \"Cora\"; age = 35 }\n                   { name = \"Drew\"; age = 60 }\n                   { name = \"Edna\"; age = 25 }\n                   { name = \"Fred\"; age = 70 }\n                ]} \n        @>\n    \n    let youths: Expr<Person list> =\n       <@ [\n            for u in (%db).people do\n              for v in (%db).people do\n                if u.name = \"Alex\" && v.age < u.age then\n                  yield {name= v.name;  age = v.age} \n        ] @>               \n\n    let run (query: Expr<_ list>) =\n        // does something\n        [ sprintf \"%A\" query ]\n\n    run youths\n    |> printout\n    \n    let range = \n        <@ fun(a,b) ->\n          [\n            for w in (%db).people do\n                if a <= w.age && w.age < b then\n                    yield w.name\n          ]\n        @>\n        \n    run <@ (%range)(30, 40) @>\n    |> printout\n    \n    let satisfies = \n        <@ fun p ->\n          [\n            for w in (%db).people do\n                if p w.age then\n                    yield w.name\n          ]\n        @>\n        \n    run <@ (%satisfies)(fun x -> 30 <= x && x < 40) @>\n    |> printout\n    \n    let inline lift x : Expr<_> = <@ x @>\n    \n    type Predicate =\n        | Above of int\n        | Below of int\n        | And of Predicate * Predicate\n        \n    let rec P(t: Predicate) : Expr<int -> bool> =\n        match t with \n        | Above a   -> <@ fun x -> (%lift a)  <= x          @>\n        | Below a   -> <@ fun x -> x          <  (%lift a)  @>\n        | And(u, v) -> <@ fun x -> ((%P u) x) && ((%P v) x) @>\n        \n    run <@ (%satisfies) (%P(And(Above 30, Below 40))) @>\n    |> printout\n    \n    let rec P'(t: Predicate)(x:Expr<int>) : Expr<bool> =\n        match t with \n        | Above a   -> <@ (%lift a) <= (%x)      @>\n        | Below a   -> <@ (%x)      <  (%lift a) @>\n        | And(u, v) -> <@ (%P' u x) && (%P' v x) @>\n        \n    run <@ (%satisfies) (%P(And(Above 30, Below 40))) @>\n    |> printout\n    \n                ","parent":{"$":0,"Item":"a4f1955e-4ac9-4e56-9991-4f960e601597"},"predecessors":[],"id":{"$":0,"Item":"5e163957-a783-4e82-9bb8-5d116d8c653e"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Testing op precedence associativity","content":"type N = N of string * N list\nwith member this.Add c = match this with N(n, l) -> N(n, l @ [c])\n\nlet rec toStrL lvl (N(n, l)) =\n    (sprintf \"%s%s\" \n        <| String.replicate lvl \"  \" \n        <| n) :: [ yield! l |> Seq.map (toStrL (lvl + 1)) ]\n    |> String.concat \"\\n\"\n\nlet toStr n = toStrL 0 n\n\nlet inline N n l = N(n, l)\nlet inline a ch  = N \"a\" ch\nlet inline b ch  = N \"b\" ch\nlet inline c ch  = N \"c\" ch\nlet inline d ch  = N \"d\" ch\nlet inline e ch  = N \"e\" ch\nlet inline f ch  = N \"f\" ch\nlet inline g ch  = N \"g\" ch\n\nmodule Try1 =\n\n    //let inline ( -- ) (f:N list -> N) (chn) : (N list -> N) = fun l -> f (chn :: l)\n    let inline ( |- ) (f:N list -> N) (chn) : (N list -> N) = fun l -> f (chn :: l)\n    let inline ( == ) (f:N list -> N) (chn) : (N list -> N) = fun l -> f (chn :: l)\n    let inline ( ** ) (f:N list -> N) (chn) : (N list -> N) = fun l -> f (chn :: l)\n    \n    let inline ( -+ ) (f:N list -> N) (r:N list -> N) : (N list -> N) = fun l -> f [ r l ]\n    let inline ( -= ) (f:N list -> N) (chn) : (N list -> N) = fun l -> f (chn :: l)\n    let inline ( *+ ) (f:N list -> N) (r:N list -> N) : (N list -> N) = fun l -> f [ r l ]\n    let inline ( *= ) (f:N list -> N) (chn) : (N list -> N) = fun l -> f (chn :: l)\n    let inline ( *- ) (f:N list -> N) (chn) : (N list -> N) = fun l -> f (chn :: l)\n    \n    let inline ( -  ) (f:N list -> N) (chn) : (N list -> N) = fun l -> f (chn :: l)\n    let inline ( +  ) (f:N list -> N) (r:N list -> N) : (N list -> N) = fun l -> f [ r l ]\n    let inline ( +- ) (f:N list -> N) (chn) : (N list -> N) = fun l -> f (chn :: l)\n    \n    //let inline ( -- ) (f:N list -> N) (n:int) = \n    \n    let def =\n        a\n        + b\n          + c \n            - d []\n        +-e []\n        - f []\n    \n    \n    def []\n    |> toStr\n    |> printfn \"try 1 : \\n%s\"\n    \n\nmodule Try2 =\n    let inline ( -  ) (ps:N list) (chn) : N list = \n        match ps with \n        | h :: tail -> h.Add chn :: tail\n        | [] -> []        \n    let inline ( +  ) (ps:N list) (r:N list -> N) : (N list) = r [] ::ps\n    \n    let root (r:N list -> N)                     = [ r [] ]\n    let inline ( *  ) (r:N list -> N) : (N list) = [ r [] ]\n    let out (ps:N list) =\n        match ps with\n        | [ ]            -> [ ]\n        | [h]            -> [h]\n        | h :: p :: tail -> p.Add h :: tail\n\n    let inline ( -<<- ) (ps:N list) (_) : N list = out ps\n    let inline ( ---- ) (ps:N list) (_) : N list = out ps\n\n    let x = 0\n\n    let rec finish (ps:N list) =\n        match ps with\n        | [ ]            -> None\n        | [h]            -> Some h\n        | h :: p :: tail -> finish <| out ps        \n\n    let def =\n        root a\n        + b\n          + c \n            - d []\n          ----x\n        ----x\n        - e []\n        - f []                 \n\n    finish def\n    |> Option.map toStr\n    |> Option.iter ( printfn \"try 2 : \\n%s\")\n","parent":{"$":0,"Item":"a4f1955e-4ac9-4e56-9991-4f960e601597"},"predecessors":[],"id":{"$":0,"Item":"9ef41d54-1c84-4aa6-915d-864ce05c289f"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Quotations Transformation","content":"open Microsoft.FSharp.Quotations\nopen Microsoft.FSharp.Quotations.DerivedPatterns\nopen Microsoft.FSharp.Quotations.ExprShape\n\nlet rec evilTransform quotation =\n    let minus l r = <@@ %%l - %%r @@>\n    match quotation with\n    | SpecificCall <@ (+) @> (expoO, types, [ l ; r ] ) -> minus (evilTransform l) (evilTransform r)\n    | ShapeVar                                v         -> Expr.Var v\n    | ShapeLambda                            (v, expr ) -> Expr.Lambda (v,evilTransform expr)\n    | ShapeCombination                       (o, exprs) -> RebuildShapeCombination (o, List.map evilTransform exprs)\n\n\n#r \"../packages/FSharp.Quotations.Evaluator/lib/net40/FSharp.Quotations.Evaluator.dll\"\nopen FSharp.Quotations.Evaluator\n\n\nlet mult a b = a * b\n\nlet a = 2\nlet b = 3\nlet before = <@ 1 + (mult a 3) + 5 @>.Substitute (function | v -> printfn \"Var %A\" v; Some <@@ b @@> )\n\nbefore |> printfn \"before: %A\"\n\nlet call p = \n    let x = evilTransform p \n    x.EvaluateUntyped() \n\nlet doIt = <@ call before @>\n\nprintfn \"before %A\" <| before.EvaluateUntyped()\nprintfn \"doIt   %A\" <| doIt  .EvaluateUntyped()\n\ndoIt.ToLinqExpressionUntyped().Reduce().ToString()\n|> printfn \"%A\"","parent":{"$":0,"Item":"a4f1955e-4ac9-4e56-9991-4f960e601597"},"predecessors":[],"id":{"$":0,"Item":"63b982fe-0a84-47b1-bc43-db48033de3f3"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Test EvalFsiExe","content":"open Useful\nopen FsEvaluator.Evaluator\n\nevalFsiExe\n  \"\"\"\nprintfn \"Hello\"\n\"\"\"\n  false\n|> Wrap.runSynchronouslyS false\n|> printfn \"%s\"\n\n\n","parent":{"$":0,"Item":"a4f1955e-4ac9-4e56-9991-4f960e601597"},"predecessors":[{"$":0,"Item":"82c8fbfd-6b85-4b5c-8bd0-81bcd8de1e58"}],"id":{"$":0,"Item":"68320a0c-b1b1-4812-bac1-f4ef8a6fe0d3"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Alea Dimension","content":"open Useful\n\nlet path = @\"C:\\Users\\Abelardo\\OneDrive - Cipher Business Solutions\\Clientes\\Hotel Demo\\Modelo\"\n\nlet processDimension dim =\n    \n    let input  = System.IO.File.ReadAllLines (sprintf @\"%s\\%s.Dim\" path dim)\n\n    let columns =\n        input\n        |> Seq.filter ((<>) \"\")\n        |> Seq.map (fun s -> s.Split '\\t')\n        |> Seq.filter (Array.length >> (__ (>=) 2))\n        |> Seq.map (fun l -> l.[0].Trim(), l.[1].Trim())\n    \n    let elements =\n        columns\n        |> Seq.map snd\n        |> Seq.distinct\n    \n    let pairs =\n        columns\n        |> Seq.mapFold (fun p (l,r) -> if l = \"\" then (Some (p,r), p) else (None, r)) \"\"\n        |> fst\n        |> Seq.choose id\n    \n    let withParents =\n        pairs\n        |> Seq.map snd\n        |> Seq.distinct\n    \n    let parents =\n        elements\n        |> Seq.filter (fun e -> withParents |> Seq.exists ((=) e) |> not)\n    \n    let addChildrens x =\n        x \n        |> Seq.collect (fun e ->\n            pairs \n            |> Seq.filter (fst >> ((=) (e |> Array.last)))\n            |> Seq.map (fun (_, ch) ->  e |> Array.append <| [| ch |])\n            |> fun r -> if r |> Seq.isEmpty then e |> Array.append <| [| \"\" |] |> Seq.singleton else r\n        )\n        \n    let rec addChildrensRec x =\n        let r = addChildrens x\n        if Seq.length r = Seq.length x then x else addChildrensRec r\n    \n    parents\n    |> Seq.map Array.singleton\n    |> addChildrensRec\n    |> Seq.map (String.concat \"\\t\")\n    |> fun txt -> System.IO.File.WriteAllLines(sprintf @\"%s\\output\\%s.Flat\" path dim, txt)\n\nprocessDimension \"BEVERAGE\"\nprocessDimension \"BSOURCE\"\nprocessDimension \"DATATYPE\"\nprocessDimension \"DAYMONTH\"\nprocessDimension \"DAYWEEK\"\nprocessDimension \"DCOMP\"\nprocessDimension \"DMEAS_MA\"\nprocessDimension \"DTIME\"\nprocessDimension \"DUITEMS1\"\nprocessDimension \"HOLIDAY\"\nprocessDimension \"MEAL\"\nprocessDimension \"OUTLET\"\nprocessDimension \"PERIOD\"\nprocessDimension \"PERIODM\"\nprocessDimension \"POSITION\"\nprocessDimension \"ROOM\"\nprocessDimension \"SEASON\"\nprocessDimension \"TCALC\"\nprocessDimension \"TCALC2\"\nprocessDimension \"TDAY\"\nprocessDimension \"TLAUNDRY\"\nprocessDimension \"TPHONE\"\n\nSystem.IO.Directory.GetFiles path\n|> Seq.filter (fun f -> f.EndsWith \".Dim\")\n|> Seq.map  (fun f -> f.[path.Length + 1 .. f.Length - 5])\n|> Seq.iter (printfn \"processDimension %A\")\n\n","parent":{"$":0,"Item":"a4f1955e-4ac9-4e56-9991-4f960e601597"},"predecessors":[{"$":0,"Item":"657c8f34-c917-4659-825d-c9ead206efcf"}],"id":{"$":0,"Item":"df325114-ae81-4bd5-bdeb-617e77b19352"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"toRomanNumerals","content":"let getAllIs n = \"I\" |> String.replicate n\n\nlet rep_IIIII_V  (r:string) = r.Replace(\"IIIII\", \"V\")\nlet rep_VV_X     (r:string) = r.Replace(\"VV\"   , \"X\")\nlet rep_XXXXX_L  (r:string) = r.Replace(\"XXXXX\", \"L\")\nlet rep_LL_C     (r:string) = r.Replace(\"LL\"   , \"C\")\n\nlet rep_LXXXX_XC (r:string) = r.Replace(\"LXXXX\", \"XC\")\nlet rep_XXXX_XL  (r:string) = r.Replace(\"XXXX\" , \"XL\")\nlet rep_VIIII_IX (r:string) = r.Replace(\"VIIII\", \"IX\")\nlet rep_IIII_IV  (r:string) = r.Replace(\"IIII\" , \"IV\")\n\nlet toRomanNumerals n =\n    n\n    |> getAllIs\n    |> rep_IIIII_V    \n    |> rep_VV_X\n    |> rep_XXXXX_L\n    |> rep_LL_C\n    |> rep_LXXXX_XC\n    |> rep_XXXX_XL\n    |> rep_VIIII_IX\n    |> rep_IIII_IV\n\nlet replace (old:string) newv (s:string) = s.Replace(old, newv)\nlet printlist l = l |> Seq.iter (printfn \"%A\")\n\nlet numerals = [\n    \"I\",    1\n    \"V\",    5\n    \"X\",   10\n    \"L\",   50\n    \"C\",  100\n    \"D\",  500\n    \"M\", 1000\n]\n\nlet firstPass =\n    numerals\n    |> List.pairwise\n    |> List.map (fun ((ll, lv),(hl, hv)) -> replace (String.replicate (hv / lv) ll) hl)\n\nprintlist numerals\n\nlet secondPass =\n    numerals\n    |> List.pairwise\n    |> List.pairwise\n    |> List.map (fun ((a,b),(c,d)) -> a,b,d)\n    |> List.filter (fun ((_,v),_,_) -> (string v).[0] = '1')\n    |> List.map(fun ((ll,lv),(ml,mv),(hl,hv)) ->\n        replace (ml + String.replicate 4 ll) (ll + hl)\n        >> replace (String.replicate 4 ll) (ll + ml)\n    )\n\nlet toRomanNumerals2 n =\n    let allIs = getAllIs n\n    firstPass @ secondPass\n    |> List.fold (fun s f -> f s) allIs\n\nfor i = 1 to 2000 do\n    toRomanNumerals2 i\n    |> printfn \"%d = %s\" i\n    |> ignore\n\n","parent":{"$":0,"Item":"a4f1955e-4ac9-4e56-9991-4f960e601597"},"predecessors":[],"id":{"$":0,"Item":"079efcaa-4544-4ac8-ad7c-0c2b76dbc93d"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FizzBuzz","content":"type CarbonatedNumbers =\n     | Carbonated   of string\n     | Uncarbonated of int\n     \nlet carbonate div name n =\n    if n % div = 0\n    then Carbonated   name\n    else Uncarbonated n\n\nlet print = printfn \"%A\"    \n\n10 |> carbonate 3 \"Fizz\" |> print\n12 |> carbonate 3 \"Fizz\" |> print\n15 |> carbonate 5 \"Buzz\" |> print\n\nlet result n = Uncarbonated n\nlet bind f cn =\n    match cn with\n    | Carbonated _   -> cn\n    | Uncarbonated n -> f n\n    \nlet FizzBuzz n =\n    n\n    |>       carbonate 15 \"FizzBuzz\"\n    |> bind (carbonate  3 \"Fizz\")\n    |> bind (carbonate  5 \"Buzz\")\n\nlet toText cn =\n    match cn with\n    | Carbonated   v -> v\n    | Uncarbonated n -> string n\n\nfor i = 1 to 50 do\n    printfn \"%d => %s\" i (FizzBuzz i |> toText)","parent":{"$":0,"Item":"a4f1955e-4ac9-4e56-9991-4f960e601597"},"predecessors":[],"id":{"$":0,"Item":"9407b622-c7ae-4f43-872b-fc65d331df13"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Linq","content":"\nopen System.Linq\nopen System.Linq.Expressions\n\nlet words = \"the quick brown fox jumps over the lazy dog\".Split ' '\n\nwords\n    .Select(  fun w -> w.ToUpper())\n    .GroupBy( fun w -> w.Length)\n    .Select(  fun g -> g.Key, g)\n    .OrderBy( fun t -> fst t)\n|> Seq.iter (printfn \"%A\")\n\nquery {\n    for w in words do\n    groupValBy (w.ToUpper()) w.Length into g\n    sortBy g.Key\n    select (g.Key, g)\n}\n|> Seq.iter   (printfn \"%A\")\n\nwords\n|> Seq.map    (fun w -> w.ToUpper())\n|> Seq.groupBy(fun w -> w.Length   )\n|> Seq.sortBy  fst\n|> Seq.iter   (printfn \"%A\")\n\nwords\n    .GroupBy((fun w -> w.Length), fun w -> w.ToUpper())\n    .Select(  fun g -> g.Key, g)\n    .OrderBy( fun t -> fst t)\n|> Seq.iter (printfn \"%A\")\n\nquery {\n    for w in words do\n    groupValBy (w.ToUpper()) w.Length into g\n    sortBy g.Key\n    select (g.Key, g)\n}\n|> Seq.iter   (printfn \"%A\")\n","parent":{"$":0,"Item":"a4f1955e-4ac9-4e56-9991-4f960e601597"},"predecessors":[],"id":{"$":0,"Item":"36960fad-ce00-4882-866b-9c02402603b6"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"JsonSD request","content":"#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.DesignTime.dll\"\n#r @\"..\\packages\\NewtonSoft.JSon\\lib\\net45\\NewtonSoft.JSon.dll\"\n\nopen System.Net\nopen System.Text\nopen System.IO\nopen FSharp.Data\nopen FSharp.Data.JsonExtensions\nopen Newtonsoft.Json\n\nmodule JsonSD =\n    type ParseRequest         = { FileName  : string ; IsAsync    : bool   ; Lines : string[]           ; Version : int                                            }\n    let value = {\n        FileName  = \"hello.fsx\"\n        IsAsync   = true\n        Lines     = [| \"line1\" ; \"line2\" ; \"line3\" |]\n        Version   = 8\n    }\n    let json = JsonConvert.SerializeObject value\n    let des  = JsonConvert.DeserializeObject json \n    \n    let HttpRequestCall (url:string) (data:string) =\n        async {\n            //printfn \"RpcCall %s\" (extract 100 data)\n            let req = WebRequest.Create(url) :?> HttpWebRequest \n            req.Timeout         <- 300_000\n            req.ProtocolVersion <- HttpVersion.Version10\n            req.Method          <- \"POST\"\n            req.ContentType     <- \"application/json\"\n            let postBytes = Encoding.ASCII.GetBytes(data)\n            //printfn \"<---\\n%s\\n\" data\n            req.ContentLength <- int64 postBytes.Length\n            let reqStream = req.GetRequestStream() \n            reqStream.Write(postBytes, 0, postBytes.Length);\n            reqStream.Close()\n            \n            // Obtain response and download the resulting page \n            // (The sample contains the first & last name from POST data)\n            use resp   = req.GetResponse() \n            use stream = resp.GetResponseStream() \n            use reader = new StreamReader(stream)\n            let msg    = reader.ReadToEnd()\n            let jsonV  = JsonValue.Parse msg\n            return       jsonV\n        }\n        \n    printfn \"%A\" value\n    printfn \"%s\" json                 \n    printfn \"%A\" des \n    printfn \"calling ...\"\n    \n    async { \n        let! r = HttpRequestCall \"https://requestb.in/q01t7aq0\"  json \n        //let! r = HttpRequestCall \"http://localhost:9001/parse\" json \n        printfn \"result = %A\" r\n    } |> Async.Start\n\n","parent":{"$":0,"Item":"a4f1955e-4ac9-4e56-9991-4f960e601597"},"predecessors":[],"id":{"$":0,"Item":"1609359e-513a-4184-b5dc-d5049574891f"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"words","content":"let words0 = \"able\nabove\nacross\nadd\nagainst\nago\nalmost\namong\nanimal\nanswer\nbecame\nbecome\nbegan\nbehind\nbeing\nbetter\nblack\nbest\nbody\nbook\nboy\nbrought\ncall\ncannot\ncar\ncertain\nchange\nchildren\ncity\nclose\ncold\ncountry\ncourse\ncut\ndidn't\ndog\ndone\ndoor\ndraw\nduring\nearly\nearth\neat\nenough\never\nexample\neye\nface\nfamily\nfar\nfather\nfeel\nfeet\nfire\nfish\nfive\nfood\nform\nfour\nfront\ngave\ngiven\ngot\ngreen\nground\ngroup\ngrow\nhalf\nhand\nhard\nheard\nhigh\nhimself\nhowever\nI'll\nI'm\nidea\nimportant\ninside\nJohn\nkeep\nkind\nknew\nknown\nland\nlater\nlearn\nlet\nletter\nlife\nlight\nlive\nliving\nmaking\nmean\nmeans\nmoney\nmorning\nmother\nmove\nMrs.\nnear\nnight\nnothing\nonce\nopen\norder\npage\npaper\nparts\nperhaps\npicture\nplay\npoint\nready\nred\nremember\nrest\nroom\nrun\nschool\nsea\nsecond\nseen\nsentence\nseveral\nshort\nshown\nsince\nsix\nslide\nsometime\nsoon\nspace\nStates\nstory\nsun\nsure\ntable\nthough\ntoday\ntold\ntook\ntop\ntoward\ntree\ntry\nturn\nUnited\nuntil\nupon\nusing\nusually\nwhite\nwhole\nwind\nwithout\nyes\nyet\nyoung\nabout\nafter\nagain\nair\nall\nalong\nalso\nan\nand\nanother\nany\nare\naround\nas\nat\naway\nback\nbe\nbecause\nbeen\nbefore\nbelow\nbetween\nboth\nbut\nby\ncame\ncan\ncome\ncould\nday\ndid\ndifferent\ndo\ndoes\ndon't\ndown\neach\nend\neven\nevery\nfew\nfind\nfirst\nfor\nfound\nfrom\nget\ngive\ngo\ngood\ngreat\nhad\nhas\nhave\nhe\nhelp\nher\nhere\nhim\nhis\nhome\nhouse\nhow\nI\nif\nin\ninto\nis\nit\nits\njust\nknow\nlarge\nlast\nleft\nlike\nline\nlittle\nlong\nlook\nmade\nmake\nman\nmany\nmay\nme\nmen\nmight\nmore\nmost\nMr.\nmust\nmy\nname\nnever\nnew\nnext\nno\nnot\nnow\nnumber\nof\noff\nold\non\none\nonly\nor\nother\nour\nout\nover\nown\npart\npeople\nplace\nput\nread\nright\nsaid\nsame\nsaw\nsay\nsee\nshe\nshould\nshow\nsmall\nso\nsome\nsomething\nsound\nstill\nsuch\ntake\ntell\nthan\nthat\nthe\nthem\nthen\nthere\nthese\nthey\nthing\nthink\nthis\nthose\nthought\nthree\nthrough\ntime\nto\ntogether\ntoo\ntwo\nunder\nup\nus\nuse\nvery\nwant\nwater\nway\nwe\nwell\nwent\nwere\nwhat\nwhen\nwhere\nwhich\nwhile\nwho\nwhy\nwill\nwith\nword\nwork\nworld\nwould\nwrite\nyear\nyou\nyour\nwas\nalready\nalthough\nam\nAmerica\nanything\narea\nball\nbeautiful\nbeginning\nBill\nbirds\nblue\nboat\nbottom\nbox\nbring\nbuild\nbuilding\nbuilt\ncan't\ncare\ncarefully\ncarried\ncarry\ncenter\ncheck\nclass\ncoming\ncommon\ncomplete\ndark\ndeep\ndistance\ndoing\ndry\neasy\neither\nelse\neveryone\neverything\nfact\nfall\nfast\nfelt\nfield\nfinally\nfine\nfloor\nfollow\nfoot\nfriend\nfull\ngame\ngetting\ngirl\nglass\ngoes\ngold\ngone\nhappened\nhaving\nheart\nheavy\nheld\nhold\nhorse\nhot\nhour\nhundred\nice\nIndian\ninstead\nitself\njob\nkept\nlanguage\nlay\nleast\nleave\nlet's\nlist\nlonger\nlow\nmain\nmap\nmatter\nmind\nMiss\nmoon\nmountain\nmoving\nmusic\nneeded\nnotice\noutside\npast\npattern\nperson\npiece\nplant\npoor\npossible\npower\nprobably\nproblem\nquestion\nquickly\nquite\nrain\nran\nreal\nriver\nroad\nrock\nround\nsat\nscientist\nshall\nship\nsimple\nsize\nsky\nslowly\nsnow\nsomeone\nspecial\nstand\nstart\nstate\nstay\nstood\nstop\nstopped\nstrong\nsuddenly\nsummer\nsurface\nsystem\ntaken\ntalk\ntall\nten\nthat's\nthemselves\nthird\ntiny\ntown\ntried\nvoice\nwalk\nwarm\nwatch\nweather\nwhether\nwide\nwild\nwinter\nwithin\nwriting\nwritten\"\n\nlet words = words0.Split '\\n' |> Array.map (fun s -> s.Trim())","parent":{"$":0,"Item":"a4f1955e-4ac9-4e56-9991-4f960e601597"},"predecessors":[],"id":{"$":0,"Item":"eff9765f-ca6a-4921-a687-f10c8831409b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"DrillThru data","content":"open System.IO\nopen System\nopen System.Text\nopen Useful\n\ntype System.Random with\n    /// Generates an infinite sequence of random numbers within the given range.\n    member this.GetValues(minValue, maxValue) = Seq.initInfinite (fun _ -> this.Next      (minValue, maxValue))\n    member this.GetValues(minValue, maxValue) = Seq.initInfinite (fun _ -> this.NextDouble() * (maxValue - minValue) + minValue)\n\nlet separateNumber (fs: string[]) = fs.[0..fs.Length - 2], double fs.[fs.Length - 1]\n\nlet random = System.Random()\n\nlet capitalize (s:string) = s.[0..0].ToUpper() + s.[1..]\n\nlet getRandomPhrase() = \n    let n  = random.Next(3, 6)\n    random.GetValues(0, words.Length - 1) |> Seq.take n |> Seq.map (swap Array.item words) |> Seq.map (fun w -> if random.Next(0,5) < 2 then capitalize w else w) |> String.concat \" \"\n\nlet costPeriodCol   = 0 \nlet costScenarioCol = 1\nlet costUnitCol     = 4\nlet costAcctCol     = 6\nlet balancingAcct   = \"ACC999999\"\n\nlet generateRecords (fs: string[], v:double) =\n    let n  = random.Next(1, 10)\n    let r  = v / double n * 1.5\n    let vs = random.GetValues(-r, r) |> Seq.take (n - 1) |> Seq.cache\n    let vf = v - Seq.sum vs\n    let pe = fs.[costPeriodCol]\n    let ds = random.GetValues(1, 28) |> Seq.take  n |> Seq.map (fun d -> sprintf \"%2s-%02d-%4s\" (pe.Substring(0, 2)) d (pe.Substring(3, 4)))\n    let dv = Seq.zip ds (Seq.append vs [vf])\n    dv \n    |> Seq.map (fun (d, v) -> \n        let jn = sprintf \"%s-%2s%2s%2d\" <| fs.[costUnitCol] <| pe.Substring(5, 2) <| pe.Substring(0, 2) <| random.Next(21, 49)\n        Array.collect id [| [| jn ; d ;  |] ; fs ; [| getRandomPhrase() |] |], v)\n\nlet processFile fn =\n\n    let input = \n        File.ReadAllLines(fn)\n        |> Seq.map     (fun s  -> s.Split '\\t'                   )\n        |> Seq.filter  (fun fs -> fs.[costScenarioCol] = \"Actual\")\n        |> Seq.map     separateNumber\n    //    |> Seq.take 1\n    \n    \n    let generated = input |> Seq.collect generateRecords |> Seq.cache\n    \n    let totalJournals =\n        generated\n        |> Seq.groupBy (fun (fs, v ) -> fs.[0])\n        |> Seq.map     (fun (jn, rs) -> \n            let v     = rs |> Seq.map snd |> Seq.sum\n            let d     = rs |> Seq.map fst |> Seq.map (Array.item 1) |> Seq.max\n            let fs, _ = rs |> Seq.head\n            fs.[1              ] <- d\n            fs.[costAcctCol + 2] <- balancingAcct\n            fs, -v\n        )\n    \n    let getRecord (fs: string [], v:double) =\n        seq [\n            yield! fs\n            yield  sprintf \"%f\" v\n        ] |> String.concat \"\\t\"\n    \n    let showRecords rs = \n        rs \n        |> Seq.truncate 20 \n        |> Seq.map  getRecord\n        |> Seq.iter (printfn \"%s\")\n    \n    let showTotal   rs = rs |> Seq.map snd |> Seq.sum |> printfn \"Total   %f\"\n    \n    //input         |> showRecords\n    //input         |> showTotal\n    generated     |> showRecords\n    //generated     |> showTotal\n    totalJournals |> showRecords\n    //totalJournals |> showTotal\n    \n    File.WriteAllLines( Path.GetFileNameWithoutExtension(fn) + \" gen.txt\"\n        , Seq.append generated totalJournals |> Seq.map getRecord)\n    \n       \nprocessFile @\"C:\\Users\\Abelardo\\OneDrive - Cipher Business Solutions\\Clientes\\Goodman\\COST.DATA.TXT\"","parent":{"$":0,"Item":"a4f1955e-4ac9-4e56-9991-4f960e601597"},"predecessors":[{"$":0,"Item":"657c8f34-c917-4659-825d-c9ead206efcf"},{"$":0,"Item":"eff9765f-ca6a-4921-a687-f10c8831409b"}],"id":{"$":0,"Item":"a5ef35a4-0915-4a27-8c0d-dec5bbb581b7"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"AdventOfCode","content":"#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule AdventOfCode =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"ebc10936-8796-43e0-b809-8f6b539b31a2"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableFable":"0","DisableWebSharper":"0"}},{"name":"Day 1","content":"let input = \"8231753674683997878179259195565332579493378483264978184143341284379682788518559178822225126625428318115396632681141871952894291898364781898929292614792884883249356728741993224889167928232261325123447569829932951268292953928766755779761837993812528527484487298117739869189415599461746944992651752768158611996715467871381527675219481185217357632445748912726487669881876129192932995282777848496561259839781188719233951619188388532698519298142112853776942545211859134185231768952888462471642851588368445761489225786919778983848113833773768236969923939838755997989537648222217996381757542964844337285428654375499359997792679256881378967852376848812795761118139288152799921176874256377615952758268844139579622754965461884862647423491918913628848748756595463191585555385849335742224855473769411212376446591654846168189278959857681336724221434846946124915271196433144335482787432683848594487648477532498952572515118864475621828118274911298396748213136426357769991314661642612786847135485969889237193822718111269561741563479116832364485724716242176288642371849569664594194674763319687735723517614962575592111286177553435651952853878775431234327919595595658641534765455489561934548474291254387229751472883423413196845162752716925199866591883313638846474321161569892518574346226751366315311145777448781862222126923449311838564685882695889397531413937666673233451216968414288135984394249684886554812761191289485457945866524228415191549168557957633386991931186773843869999284468773866221976873998168818944399661463963658784821796272987155278195355579386768156718813624559264574836134419725187881514665834441359644955768658663278765363789664721736533517774292478192143934318399418188298753351815388561359528533778996296279366394386455544446922653976725113889842749182361253582433319351193862788433113852782596161148992233558144692913791714859516653421917841295749163469751479835492713392861519993791967927773114713888458982796514977717987598165486967786989991998142488631168697963816156374216224386193941566358543266646516247854435356941566492841213424915682394928959116411457967897614457497279472661229548612777155998358618945222326558176486944695689777438164612198225816646583996426313832539918\"\n\nlet numbers = input.ToCharArray() |> Array.map (fun c -> System.Int32.Parse <| c.ToString())\nlet l       = numbers |> Seq.length\n    \nnumbers\n|> Seq.mapi   (fun i n -> n, numbers.[(i + 1) % l])\n|> Seq.filter (fun (a,b) -> a = b)\n|> Seq.map     fst\n|> Seq.reduce (+)\n|> printfn \"Puzzle 1.1 = %A\"\n\n\nnumbers\n|> Seq.mapi   (fun i n -> n, numbers.[(i + l / 2) % l])\n|> Seq.filter (fun (a,b) -> a = b)\n|> Seq.map     fst\n|> Seq.reduce (+)\n|> printfn \"Puzzle 1.2 = %A\"","parent":{"$":0,"Item":"ebc10936-8796-43e0-b809-8f6b539b31a2"},"predecessors":[],"id":{"$":0,"Item":"62be52fd-08c3-4afa-8178-39b7b338d67e"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Day 2","content":"let input = \"\"\"104\t240\t147\t246\t123\t175\t372\t71\t116\t230\t260\t118\t202\t270\t277\t292\n740\t755\t135\t205\t429\t822\t844\t90\t828\t115\t440\t805\t526\t91\t519\t373\n1630\t991\t1471\t1294\t52\t1566\t50\t1508\t1367\t1489\t55\t547\t342\t512\t323\t51\n1356\t178\t1705\t119\t1609\t1409\t245\t292\t1434\t694\t405\t1692\t247\t193\t1482\t1407\n2235\t3321\t3647\t212\t1402\t3711\t3641\t1287\t2725\t692\t1235\t3100\t123\t144\t104\t101\n1306\t1224\t1238\t186\t751\t734\t1204\t1275\t366\t149\t1114\t166\t1118\t239\t153\t943\n132\t1547\t1564\t512\t2643\t2376\t2324\t2159\t1658\t107\t1604\t145\t2407\t131\t2073\t1878\n1845\t91\t1662\t108\t92\t1706\t1815\t1797\t1728\t1150\t1576\t83\t97\t547\t1267\t261\n78\t558\t419\t435\t565\t107\t638\t173\t93\t580\t338\t52\t633\t256\t377\t73\n1143\t3516\t4205\t3523\t148\t401\t3996\t3588\t300\t1117\t2915\t1649\t135\t134\t182\t267\n156\t2760\t1816\t2442\t2985\t990\t2598\t1273\t167\t821\t138\t141\t2761\t2399\t1330\t1276\n3746\t3979\t2989\t161\t4554\t156\t3359\t173\t3319\t192\t3707\t264\t762\t2672\t4423\t2924\n3098\t4309\t4971\t5439\t131\t171\t5544\t595\t154\t571\t4399\t4294\t160\t6201\t4329\t5244\n728\t249\t1728\t305\t2407\t239\t691\t2241\t2545\t1543\t55\t2303\t1020\t753\t193\t1638\n260\t352\t190\t877\t118\t77\t1065\t1105\t1085\t1032\t71\t87\t851\t56\t1161\t667\n1763\t464\t182\t1932\t1209\t640\t545\t931\t1979\t197\t1774\t174\t2074\t1800\t939\t161\"\"\"\n\nlet numbers = \n    input.Split '\\n'\n    |> Array.map (fun r -> \n        r.Split '\\t'\n        |> Array.map System.Int32.Parse\n    )\n\nnumbers\n|> Array.map (fun r -> Array.max r - Array.min r)\n|> Array.reduce (+)\n|> printfn \"Puzzle 2.1 = %A\"\n\nlet allPairs s1 s2 =\n    s1 |> Seq.collect (fun e1 -> s2 |> Seq.map (fun e2 -> e1, e2) ) \n\nlet divPair ns =\n    allPairs ns ns\n    |> Seq.filter (fun (a,b) -> a <> b && a % b = 0)\n    |> Seq.head\n    ||> (/)\n\nnumbers\n|> Array.map divPair\n|> Array.reduce (+)\n|> printfn \"Puzzle 2.1 = %A\"\n","parent":{"$":0,"Item":"ebc10936-8796-43e0-b809-8f6b539b31a2"},"predecessors":[],"id":{"$":0,"Item":"1e403dfe-1572-4cbc-85f5-c92b1b743e83"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Day 3","content":"let input = 277678\n\nlet     squareOf         n = n * n\nlet     sideOfSquare     i = (i - 1) * 2 + 1\nlet     sizeOfSquare     i =    sideOfSquare i |> squareOf\nlet rec findSquareForR v i = if sizeOfSquare i >= v then i else findSquareForR v (i + 1)\nlet     findSquareFor  v   =                                    findSquareForR v      1\n\nlet solution n =\n    let square   = findSquareFor  n\n    let side     = sideOfSquare square - 1\n    let index    = n - sizeOfSquare (square - 1)\n    let position = index % side\n    let steps    = System.Math.Abs(position - (side / 2))\n    steps + (square - 1)\n\nlet verify1() =\n    [12, 3 ; 23, 2; 1024, 31; input, 0]\n    |> List.map (fun (n, s) -> n, s, solution n)\n    |> List.iter (fun (a,b,c) -> printfn \"Puzzle 3.1 = for %d: %d = %A\" a b c)\n\nsolution input\n|> printfn \"Puzzle 3.1 = %A\"\n\ntype Step = Normal | Ledge | Turn | Turn0 | Corner\n\nlet get nmbs i = if i >= List.length nmbs then 0 else  List.item i nmbs\n\nlet step (nmbs, i) ts =\n    let p = get nmbs 0 + get nmbs i\n    match ts with\n    | Normal -> p + get nmbs (i + 1) + get nmbs (i - 1) :: nmbs, i\n    | Turn   -> p + get nmbs      1  + get nmbs (i - 1) :: nmbs, i \n    | Turn0  -> p + get nmbs      1                     :: nmbs, i + 1\n    | Corner -> p + get nmbs (i + 1)                    :: nmbs, i + 1\n    | Ledge  -> p                                       :: nmbs, i + 1\n\nlet getVals steps =\n    let nmbs, i =\n        steps\n        |> Seq.fold step ([1 ; 1], 1)\n    nmbs\n\nlet createSide n = [\n    yield  Ledge\n    yield  Turn\n    for i in 5..n do yield Normal\n    yield Corner\n]\n\nlet createSquare n = [\n    yield! createSide (n - 1)\n    yield! createSide  n\n    yield! createSide  n\n    yield! createSide (n + 1)\n]\n\nlet verify2() =\n    \n    let stepsNExpected = [\n        Ledge   ,   2\n        Turn0   ,   4\n        Ledge   ,   5\n        Turn0   ,  10\n        Ledge   ,  11\n        Turn    ,  23\n        Corner  ,  25\n        Ledge   ,  26\n        Turn    ,  54\n        Corner  ,  57\n        Ledge   ,  59\n        Turn    , 122\n        Normal  , 133\n        Corner  , 142\n        Ledge   , 147\n        Turn    , 304\n        Normal  , 330\n        Corner  , 351\n        Ledge   , 362\n        Turn    , 747\n        Normal  , 806\n    ]\n    \n    let steps, expected = List.unzip stepsNExpected\n    \n    getVals steps\n    |> List.zip ([Normal, 1 ; Normal, 1 ] @ stepsNExpected)\n    |> List.iter (printfn \"%A\")\n    \n    //let steps2 = steps |> List.take 4 |> \n\nlet stepsFor n = \n    seq {\n        yield  Ledge\n        yield  Turn0\n        yield  Ledge\n        yield  Turn0\n        yield! createSide   3\n        for i in 5 .. 2 .. n do\n            yield! createSquare i\n    }\n   \nstepsFor 9   \n|> getVals \n|> Seq.filter ((<) input)\n|> Seq.last\n|> printfn \"Puzzle 3.2 = %A\"\n\n\n//verify2()","parent":{"$":0,"Item":"ebc10936-8796-43e0-b809-8f6b539b31a2"},"predecessors":[],"id":{"$":0,"Item":"1e372ba4-5147-47e8-b4a1-4f23d94f01e5"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Day 4","content":"let input = \"\"\"sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp\nxmuf znkhaes pggrlp zia znkhaes znkhaes\nnti rxr bogebb zdwrin\nsryookh unrudn zrkz jxhrdo gctlyz\nbssqn wbmdc rigc zketu ketichh enkixg bmdwc stnsdf jnz mqovwg ixgken\nflawt cpott xth ucwgg xce jcubx wvl qsysa nlg\nqovcqn zxcz vojsno nqoqvc hnf gqewlkd uevax vuna fxjkbll vfge\nqrzf phwuf ligf xgen vkig elptd njdm gvqiu epfzsvk urbltg dqg\nsfpku viwihi fje umdkwvi ejzhzj qrbl sfpku sad nawnow ksnku\nnzhj mfudick ueaa jnhz kpy pzk\neuiin xvl elaoelu wbdd xlv jtm nohtq gfdbgdg gdfggdb edtym\nxfmkn wyww woe hwysuh gjw dtk utryasc dela eluk vmmun\nnmag qfwe cwslmgd nlhf hpf\nifs sszo iod isf jna\npjptwg wreera leyb hmlbpf qcrbma ylgue\nrwlpo jhla rprxvgs quguh pyybwgl qqvcb\nrxtcpdy wmpci mpcwi vwvdzdn nfpnj rcsxinl itatg ycy hrctg ron wveju\nzmkfn wip pyiz pyiz tnyg dvftf elks ezhotbj wip\nsgmtfdd xdl sch sch yaxzh wphgksh knzrixp yaxzh etm czqbaa jldta\ngnbr rnpd upe eeb sbq sbq oxc rwvugoj\ncshk thcc emfxx emfxx pbtcf jpim vltkqar czy iudkac jhpcc nqs\nuzbvx fkiuyk izxdiu yutntvn dixuzi hkyfnud oyz ynutntv\newl mfns idy fphu yqccb pte unukirt unukirt fdx\nlzn tin fgena qbql qycbdw gbtn lctlysx adhjfq blu aiv\nites ites pbxzunl vljzh lqgerta pbxzunl\nvmk wjfzvhn pqkidze qfwh\ntqprmc exypl caf kwikh mdyyljc pbo hhxxo skna\nsqxgejb ejc fvup hpesvs luz fcxqwhr ypxof fxlcp pxyk xiczjri\nvjg qcw fsyqaoj mxf jha feclqqr vzdqnk verw mvmvm pvdqtcd xsfu\nfwwn ktvdh aecfv acfve yjozxwo cnujw bcgde lphnk knlph bqwlqju\nuwwapm dlln uwwapm uwwapm\nhuupab ewetcte huupab ewetcte\nwjs zipivpd klwafr ipcczg wbv uujstsw hykn\nmgojdyh hlm xruta lbmaxit pabqrnp vkyigd ptpzr glin gfau pbo\ntbwx baqxq vtz jwex tvz tzv\nefopwx wfknzb ogaxln tqzrh jne zugd zpxikma\nrdjsa arjds hqdldw fjrtl midt qjv jfrlt\ndggqohj bidaaty iah lgmug wwmlbc lggmu laonaoq erkqrb tqolnns iygv qnonlst\nmsc glwn xjfnij itt pka irrafjd euazydj silo\nzsyut znsht ldky zsyut dzcdft znsht\niit cyteu pib fgvrs iux ffctql pib zuzp zsbb ieoi\nxxtwlu kqfxjhq isj xqjhfkq dohrs haovzc cgfwfrt munqon vuyexz nouqnm\neptpqgi uiflvd acj livzq ejtt bniud cjdh jkrcken lspfy tpxri zibj\nzxme dpo fumup gly bkdcwxn lsly eglhe\nuoshw ijoyiql rcskaa vjbqv roiinzi fppqdu\nxuw vdbxie oypcx khxq xebjt oypcx uitqep vdbxie hoz\nlrjv tdksk uebo wktebvx nlapmp udhhxh uliqbm cklyyf jlzw xrmdlvx\nfosspck fosspck fosspck qyidyur hxnxmb dkpj\nrmrvlms susvos idw hzy idw tjgxbc lhgqxr tjgxbc uuq\netjmbdr hwqe lnfwzni lnfwzni good eisci etjmbdr\nyqde bmlcc yuel vpyplss vyvhho kslgiu lllhc jtkijdj uclz hfbqsf\ntlohlvv tlohlvv bdqahw tlohlvv qavcqrn penia saafy\nlvtzyt qffe eaikhv eaikhv wbnl mdkg mdkg utfrm\nluowwk magp luowwk oyao oyao hsb yms\ngnxply vsdqum nprf jik axdp ariqjpc hjqcc\nizbo nkqkb xpqg pgxq qpxg gpm jxbkvu resj\nhsgyxar hvsl ner zzmcn lcpdvqn ern\nrfjlhu xkyh hafs cvvk drg vjsk mymc iab ycmlubx kpwemiw\nwlci qhhpr vhpr oyrili cnynh sivdso ldjya wilc ioiyrl\ncdfwd mbtk sienxui jsmxzo yxbeyl bybtc covxaq yuxn ktbvztl ktbvztl rcekjhk\nptenhqv tzdt phetqvn mfkdz\nhmezeak pqvqld amsih jxqacc uferfyh nfqjsz rtuqdzz pohcx qia cpxho hgpqs\niygny dluc uxqz nlujm xkdtlm xbdgepg jwn ohl wpfll\nlnqf pcxy cpit enp zpj lqfn oowgw yoxdff ohvcfcf fuvz qkpmb\noydu jlscilm pzxen nmtdngu tslcupx ntdgmun uztpx nlhh jqn llsv\neuyx epn gyvg cwtoe ruyap yaurp uryap obbl ovo\npgo irm ksrxe qotuygd afwh qfhzfsr wafh dqjbwce dzfo hew skrxe\ndpvel dpvel ipljjxs vrrsob iakey uheuu swxu qmnmn mpjkb jqrwfmv jozj\nsempz plzxqe qvyg sempz fejux\ncqgqvg zhqir rqzih vyu fmb mfb\nuejl kjh ayz dzimg yzafvg dem vlogg\nhtfkd htfkd hwykmm htfkd\noxvgq wtai rkyyxya ldkecdv\nlvlrsu rsullv pptnrwi slvulr vxrk dpzti\ngde ixwoz nnsx nhc nzi\ndsadkj qtgya wco psyondq jayad crc lswwm purrad pof\nnocibgs hxqdejv nlqxdpu dvzd\njfaws aiwnjm tqjpgs fuiobz gwnemv hjevs xkbbgiq sakgv zmwpkuq grjllw\nxrr jwhtchs boaqkg wjhdr xrr\nvyapct tgw juzgwkz odddvof juzgwkz\nunuu kubdd dxr drwg\nqpefzz iemo fwa vhdcxx\nhseqy copss gytzub lxi mrxtwc hxqqdfx ijt kcy tafjs jit\nuevse rrq zmwyjfe xljx lhgnyzt rngvwqd\ngfvpyhq xpdhind eocgpiz ebs pcmsgjy swni iwns thspnh yvbzxz fgb\nhxr ehw ekfd ncxcs gxjmd oqszdjp fgu gwuoafw zumenf qltbw whzuxov\nwfc pawqo pim jxgt dtiwzil hdptivc slkazm htafjih hzheez rkk amy\nmgoatiy pkec ddvwyni zuya aqrcjes ubkaeus nuhhad upe qfem bpcc\nrmyeg qfq bia lzk fusqfb ltvgry vggr xaxi avwdkbg zhlzt\nzkjoeee dyi sxdwfqa irqljmw gek dgdb mrakr ddaznn zlh ajzzacf juv\nkmqcy pohbej hujdgao rsxfkn vlu\nscnpa hvl cybql lvh lbcyq msw deqqb yjpsndq\nndhjooo dpf ziey jtjlc eesag ldhgoif\ntysbae wkpst kjz stpkw sil yetsba\nghvlfq flhvgq tgkjie gqlvfh\noimn vlmsljl ocala vokhrs odyv msn dzly wcky\ncfjwmh rpsdor bttnkg jxenm mwdk mer jgsusdz cslf\nialvxk bvc qjfikr caw puhmmfl xpmsx\ntyoey egcf dijg vywd enued uxkshz nav bdrn hjugffi iobqwiy\neykhxck shpfjhk vlqg alkenz kuj okxs oeth mqbr nfvqvkv xfvyi mboo\nzbw curcajm mel jxqcw mpdscxq rhadty zrddeh wmedc wkcwt yvwm\niee hzeofmh pqlkkb azlam fpj hzeofmh ripi\nsawaqek oyoiwtb npq pisadk nnd bzgo wiqme lxnvn\nobqx ffiegn obxq for xobq\nzwway wwazy aqxg gaxq\nebssilw nuscati mofyc sogyacc yujmdwu ehxsx qcaf udvoo nlcfaz eov\nvnbe wtzzjn bczyxt crmvas zujy kukq zujy kukq\ngvltk kgltv kglvt zflikic\nhby pium gut fjqn sksoqyq kcliapa\ntbonrr prf vga jqgw ulze ukfig\nzafixw hia omgwoi noeiox fqbket iviidgp bebune kwcuotp slvy wcx\nfjq cyecn fhxvj byv kojvj iaqd aaxva rkogp\nvqbbt sjmr mxu mxu rlfj yqhtzv cuar yde yrs sjmr\niyxiyp auepgw dtpbyvu thuoai fpsfkpn bemgbsk lni ozy jogp xldyvvx fpsfkpn\njtha ibn ahbkh xzxkei tql mycvmyh ioyw\nmpsc pvdiuu wqixxlo cqwmlrw cttoz lad\nsrl xxlnofu dqf snxd zjlp htxzd\nfkv berlbyh kyna wkme qjzgh thpw frup\nirhreaj udkpbza qmgp ormlipa lbyuc\nempizc apcb ossmtj awk ttsgi bfoymzd ftx jkicph qqjv tywp fwzfe\nzaqkd ysn zaluvs rljdk ast fjp amjqr uabrya ufswzjg vcldkxt hzsmrbl\nqvy tqgnwj akibr tfjevhv vav\nmhe sxg hacoa emh kasf hid jklfy ijk dih\nqvwbenk akdctm jztmsx aqvpodu vmknns nck letcrk poba\nlhve kkvff iiixid vtsun uvgte mmlxk pgd\ngktphd aaoqwz lrvsuw ofcyvmi suvwrl dpqiol wjgj uqigjx\ntbp xoc lmz dyzlvp bjleh pxj xjp xbil\ngpzgvj tctszm tctszm pnp upqtmm rribg tctszm sllsbr\nhpm qvjnd lyqg bybpwn etz pwfigbg uqgrvpg cvniubo\ntpowus bdncyxg gmm ebfg zwoue izgkwtx gmtfeg xvudp xgmjp atrvn aqgl\nwlrxvo wvonohi owxlvr owhnvoi\nknyo aiixyi sjtqb kukhgv qkj qiuefb syhfc aoana okmot tdsmnoj eyzqjn\nszhto szhto szhto fxpsavu dtcz hnwqdvk iza\npoykme rboczge tuyiw sxr\nlpgbp bpmf aiqy exzqt gxdoow yjp fxwdmt eoklc jnps zbnbiwr ppvl\nhuecy jjhyz pwcea ffofmj tts\nahbmkw brz xdenmw mwexnd ncdxgf gcxnfd\nyhfnra vqljz bkyxzt vhtsyde ysaxt qbw\ngqhiej rofhmp soeebdp rcuiblb rcuiblb rrnh nses\npxrwe suil iihzf lhcgmfm mqasxh ttpp kqitdyf cuabaa\ncxl cwsp qyseogj dimvv igsoxu ncrexla ubrvpp oum usluv\nrkmo jqqcdjb mobqcta pbcmoi afjlh mork\nnmohoeq fezpxh fezpxh yec\nyxlncrt ivi dajo tjpim tjpim\nhzhy rcjs uhyvwz tdpxlqw itoiyf\nded apfmhe stfk ugyujv drwks zagqnw mbbzmvc aoupemq\niezre wivdwif xzytxe xwytd vpnol pljx aot phln ztncw\nozblu asda tkxh xqe pvijnl qwwh uvp bdhtgjt uynwtav cdz uqmvp\neukgtsy kdfb bdfk tnv dfkb ewdemb\nrsf cxnk cid qsa zwk oetnggn\nfpq oim zetbmlk fpq oim xgv cbaj cjrqm\nphgldt fhmkc efkztj qidri vsv bvjf lfwfgm wfuoln toamg wfuoln idrs\niuc rrdnk rrdnk asqhnz qxkigmo eeoim mmdtgif akk\nrfvsyy kopfhmd tnv ibo demeqm gxrxw hwk ukorln bep\nialo eogif sxlj xfegx nanch egoif eymwt\nkttrpjq gbnyiat kptg oarewx vkmt gbnyiat szyokf\ntjll xviodi tjll efc rliugl wfbbpq wsqvdli jur tjll bguqyu\nuecm yzjhn vqf labnc xyaksj\nhjtef zzq ellr wtrodcg drwqo ernt uzx sqiokam\nizmh ddutl bdzft jvfthh\necr xqrp qlxstu kgprd gqvtwni mkughf bulabe bvoxkx\njwsna vjwq swkycg cpp dvmyal xotxviy qkiva ffa eakwp fww yirri\nufnl lpuxw rjki nggh ajdkpvo oeuaemy bjisma vsjzc\nctxu aavlw rap fzxtcp msufn fzxtcp sdlaom vgvdvpc\nrftw cyf twyxi orifavd\nogiht ertz wcw jnqdup phvp lbw\ntplpyq jeh aobamqe bvaim qptac gssi mkjbaj\nnmklyg iitx iczojzr vjspqb uooky uooky hjk\nggnekbb bnebggk sepzjd fvqfgr\nwnfwrn yaiogv mbusuy cpbcgs thjea\natndjc dbjgdz guedeay rasa kfhame pusuu dbjgdz\nxivzyml xivzyml eqsykxo bshvz xivzyml\nnfe ayx gscy ylyp oqyl isatnpx poaelm zsrw dpd eyrdjpq yllk\nfeqktz mlm jhi yxigeu xzqa qwv yquxw emken jgqsp rojfcu\nruvfcud poubal xswer hfhpyp guf pzgzoq pzgzoq jwgxafi guf kqzzlu apg\nrxwcsdc rxwcsdc ywu rxwcsdc\ndmgsey xrtx wldwyxz avi\nyxnqv ewlx fvif ozfcbxb zqapa yudqksk wlxe mjpvgz\nozoa ozoa hwkbp ozoa\nqcv drtqn uqv kcsavgn ybzs tkw\nnjmloq wapa srm srm ifurca\nezm ccj rub yuaww xhee liikjee kcabgic sbgqx vrpyo pzmesdp ksvv\nhycyne raaksm nylsc lcpgn akasrm vxwoaum\nzhugs pqquitv bae lyozb fhij pcdcc bae rygsgm pqquitv pizz\noxx bzk grpis qiqljwh svkn\nqcq qqc fzgn sqg\nlclad motw ukz zghp\nglr okzfs zgv ygsvv sauuog glr amxr vvmwmu khy eyh\nukpxpy rgnqyaw ncm coeblf\nqdbr ortzo spvnrnq uomtj vffbeva\nmiwar bidfxp eibo qyee\nyldec ghwj mxlemvi imac klkvmg fekxhp kevlzfr fcgnoq fncgqo\nhlm vlol qdic rltij nlzxfys rzpoh\nkrpwspb yrosr hioqla dbpgzgu dvkvvc vvdckv lcjzb qbsbr acbi rtnk\niqtvk jcldzuv smly whmnte mdwlse mkxw mfnkv mkxw kes owkfh\niwcjmkt rnb bjcdjl furhzuu exs\nkjwu iuaj ixkujoa jzeau whpn\ntvj zrdy fwsbagh zrdy czuzum lxotprx wbohaai\ncrsyzod jouf osxntw iwzzie bodu scze gjxn vgxvqo gjxn mmthykb\ndabjfb vjqz cvr gsymwoe qzpusj twvwhw gyvlqd kdrdkzm bdljp cvr\nvmswdz lgjsvxz yjkgqkg tzmjkfp uzbmwxe kuqa dzomt hep jjlibs oxvpvq cix\niqgd btwdjd ncdrovj ltxqc orwhdlo orwhdlo\nnxro uxj ovgha elvzl xmlzssr wonimvb urecfx dbfn kope\ntbes cgyh fypswue fgxjqtd dxdrfm pzhnaeu kugspa\neouzw qrpokyb fyhpb bcvfvze brdwey gpaa fpqutw pbqkroy axtc egamku gxk\nxdrovpt peeww wkcin suir gvrbix\nhgsjks juvod jtii iijt\nyaw hzifa wpagkd tgvmc iru yyeuy mgcvt fhiza\nlsk lks kls edypaxo\ntjz qjs mgoyd gomyd ztjbex nprwk vvw rtjsq quvf vuziqtb oygdm\nkftodz xua lyxt zfadf fgdwt zfadf xua ehwykd wniahd mqoarg\nqgiapb xptk iscyf zfspn qvrpva egufqte zfspn hksw xwxrs dkdruku vegfs\nwqifs wfsevg iwnjjpi oajju tkvhpl lemuw\nrzbmhso pbvb lfgpq fzjwxxh pqlgf rbhsomz\nufi aiyd gxozgx hygjp dtma uughdc ojumcf yuadt\ncaami tqzkvor tqzkvor tqzkvor\nvhtnvyx myxdywi mwpwq hjxadd qkcj vvytxnh dmbea\njvjtcjg mbiwyad cup xkrfk puz uxpmutf rjxyxyn mfchc\nocrak zprfbgu pjjzl zoehfkm xqn qki uxq tcv emknqjp wvmkas\nnxg myr myr vnfzpoy\ngwu ezt kbmeouj sxue cxax gcquz ieegnal xecusia vxf\nxermi xermi qporwc mzemns ticltnz ddpsstr ddpsstr slgbn\nxnujwtw bvzv xjwntuw unxwtjw\ntipo akp fkmcls wglmjq fnrtsv\nfan dfbya qrp lcvxqqu ldpm gucmeky mrzy fixaph rygneb ocm pjh\novtrqs ujmbnal geihpe mijhy eewuic toaxbp ipy tvb evlmrtd lbujmna\nlsmbwwd hvurk ihbuek hvoyq erzomhn gue lpq dihon dgzvst\nfuoshq hfrzeu zfrhue ufqohs\nicgwnbi gmhogxu gmguohx toixb hfwj haxlav hbe jdpxeyi xtgfi\nvfakk ioil hddqu sdztx hduqd bmiuyr vmas\nmcvjjhf sfgt sfgt lambvp dnqc pfecquk\nxgr omy bmoadg afbna mar nicpazd iveku zdioyo\nrpipon dwg wgd pironp\nfkyx wjefuy mfesst ztlf gnnceb rsbvuk ckilt kliqnm iuifcvu\nlmgzx oknwr wmttry luipa vcttj nuqdmy\niota efrxkk daqzm certtoi nnvqrwz qrqgza tllwp efrxkk\nalde wqmdjy erh txrtqm zuljg hspbnrd pvsnebh bkue pvsnebh txrtqm txtthn\nhgggm rswwfpj uctzrv bylqeen dpbnw ostsjwn jtjiyuh ofxu mmmqlg ayhza opbgdrv\nqmhkh orbeokv agosach lhujcju jzpp wmxtcy jcxglu iuwmzrv xwkgz sxlzld\ndzcdm lwal xpujjm xpujjm lpfojz lqqcon qmqrg\ngmwugq ceslt rxcogaq jwkraq\njoxr brdy yixlou brdy lnr lnr\nwbut pxlsclt igigapq zeacg jxiezn hvws wwz ujpbl fdjtfjw opod kea\ntsodswf pufo zqrt zvcpu\nnyy mrqmg zkt tslzsf zkt\nhxywv lbmogd hhv npyzgjy whfvv mlfqjr ggjz owijo zmesslo gtvizw\nxzz dvpzxbd wxwlp cye rcqpgrr gynzo nhy gzpk fpfmb\nnhaakbv iazpdc yadqbe kmqm dffq lidnh cegjosw kgd hwivd wijj\ncwmdyf huoy awihev qav cwmdyf rdwck hahj pesfyk uoju zrirjdu\nqabl vwcwbb phnd xnp huuzwxl rukbp kod sfu ngcvgrt buncnfw\nregyd gjzfwf hpuv zmm vphu gwffjz\nrdf emo crsoeo bksetj aqfzm pphny\nopbmboi iakvj ymjwm vxoq qvox yafk zkch adlusz\nqhm jul zasv xhu qnhjwzx\nmjmyvd mezfuls upbdpzw awc qxta bzrx tjpjmj dxfyewc zorm\nbko kfokm htcpoqc liuvj xhmpcu ccqphot dthvo pfj dtxpmu xoocm cmxoo\nkxv eenns qhpfsvo gqoyv jzjho aoscl fetug agxmfea aygpt\njavmegf jlmt epdwy egfs hwv uszcqvn foixpz iukh dbuhqgs zgb\nzrex zrex xtx ydan maomp hqdhh mfvan broh wvwhqbu\nphatsot joipm pmniq arqzmbe vurl bgy iwbwk oyhngcv vnzbzgm bgy\nxprufgn vhca nrs abuh zwsxmhk mqrj tyslsij ojkdzom wepxg koodzv ypvyy\nvop nnpz mcod mlli ntyhz laqztb kauqkla gmrfte pcuhaci\nvrenj lypors prknc djbdkzv amofdx\nlgig lojnrw obusoc fkwe ggnv pydcraq bvdivl vev mrojjs rxa\nqeg tap jocwlsm vqxa lmjscow\ngptlrgq vdasm erdc oparmw\nrgbsa nacqhvm pczf anupcp upudwgp\njbnobi ifhzrd ihrkkf osw wos lrnwv\naiuntpl fcxpmz fplacs fplacs tipm gfotkx\nfsbnd qoc ozmbi rqv fmbxh tuso kfoxvjn ocja zzs jwplx\nmuaklvq ghozoxh nwxbh mgoou ufptl ouhh reyuf jougckd dgprag\ngwbnqwv dtrd mkzxinl erxl zmfa skuu crxmp wwao wwvdpk nxbn lglzy\nqeejk wvnypc yfzyfcr eeqkj\nnmcp fmkgfyi grfthau azw\nkkallxz rjke ukbt ixkhfb bktu jkre\npxj mnwe djrjde gpsc enqz pdbydx cktfs jjeddr\nmgplj yyunujc vis odee ccesa yyg yjcnuyu doo utse\nflyy juvxomm vcdcyva lfyy ozxnuzw bmgns\nkmsypi zpbyiv rrycnb qos sslwyeo jgbyv njltzt fuwk nwfb ozcf xqnf\nsdcvgmy sdcvgmy hzv uyq sdcvgmy\nfyox vmgxahj ywaxbmm ugy ruwc mys yrjwr ozsxb vaq\ngjpyc sgdn kgm fbvq cziui nzy bwu ezjkkus jrag\nkxcr tgjxss xkcr bembjv rbbiw bwbri\ndcz rrhvdc zbonfzy ubjt\nrvq yjnzswt vatkopb xlj dwxig dqlt qts iva\nlylclc jptz rbidu lbt byxk\nlwre vwriwh afixsi vwriwh\nkmvbflr nfptw fbglxh pyas dxmn hemf segaz zrs\ndvbey zmj xfoi bma udtxhb\nyryng geiwgz bbrvjp ala\nolzicp olzicp qhhslry olzicp\nexf xdmwh xdwhm nhjsssn rmlkdb excguia fex\nxkwgeso htys sjdk jizciy gjjl phgqdjh wzdb izew zcrumu llxfp\nfrkohf oifsm aisebkt ijsfkot ukk\nkoqf xvoior tpe erfpnp npnx\nsneysk nsxki wpmhd mdor akrpvgz moicncj sbsj owfhj exw\noqqbvk xztx gtxlms icmo\nlfy ltq dlzqlvi ovbrsa gzm nhcjq umbtgm nhcjq\niuopdzq cqaeuu xuzngq kxlx laml slvvr frtml tvioiez vyoomw xickbqh\nckahov mepeku gtaf gtaf\ntlto cnnz kzsbkjo kzsbkjo\nkqf comkf dvrkyl jdsqi rnwvb vxvd pok\nhncq xcx yuykfs egrruvw yqh smcou\ntywyq xeq cix yywqt jhzptci hybcoe\nzsw zsgot wnu sumd azmuos qawjaz rpf zkxgwdu iom igh\nvmxmelt gll ysbbt yboqoyz ykdglk cnypf otn owsz ipn epfeka bkmy\nwxjpce etzyavi whb sxzft bfu dgwnbgc nfw sxcteis qqpk\nkofv dgoyme vlza oxhbo lrqt uic tvfqiyy iaqm afnk\nnsmpg wkibdcz dxbw tlxzm zgwe nqwjji eacbhn blk\nshlgws eencr rtufah kjyvqw transt ecsq otbf\nobs xsjceex ffqj sob djpq jcda zlskve\nrfqtle klarp mtzrx rasr eisqovk rpt vymibt zwrif ilsnd\nldu ffd ldu tizfexr fwpmyan\nflxso tzec pzn flxso kzdouon tkvkj\ntvd arh qywql uev btvnpm\nwtwx kzafvk ybyzmhv mdbrphy vamlvr gbxhod tyulba krcqj ikotmla qfhpa\nbnfin ebngj agfdfzu rhjtj aaqzh fsyp nilar uwurjnu hhmso hhmso\nuanmesj vshh syosjdt xkormf syosjdt ifvytwl qnw vshh jkg\nepyzcn pgdxgye lecnx nebg jzdhvge hfy imiyft\nzonbcnv vuvg sxtuty zdhmiow lmud cuegzg\nbxgft mxhzrh unqd pqpsnce khykn qlb oujdxpq pxrd jzxjuxr tij\nqss mqirowz ijjswjm jjer utwn kuedqxx bxshuok qkfag dmfwcr\njgln zdohd xitfbge xbokj xxeuv wqhvhjo erg cua fhc mhwy\neuo ousht ipxt tpzq vnbmlo wvbjpb yjg bwpjbv nzvsea aerhsqv\naxhmi bcf zdx vplso xhmai qsk psolv\nydnpmyo pfba zmo nat ykwxvm ydnpmyo rtd uuvqqr hcfccbd rtd\nytp guw ydmyf rww oucmpf gemhpj labc\nedpbefn awgg qzpe aat cupig\nmmi ghdaoh ibx fbyj gge vmmssen nplt mmqcra omcvm uwa fxypxfc\nkjaw mtijne cfmsigd zwcjjd ajxjlqr tbp bnilc\nfse ele vcsyiv bfe udny vznrao mgrjfgw\nhadl nikvvpf gmdg bkmgt ugj\nxkis qmr cgz nresp gms zrii coxkke vfsqiil\nwmicbf bkk wcwklfg vpcbeg kfmjab vabc dax tnao tnao fvvzeyq fqm\nbct tvj tra soo stqao kqua ikupoy wulcu nauxkkb pvqxy bfu\nwpz txdduxq gaehfki kxo lvjzpxu iqon swr eyihl nbbec\nfuphnbj bdtz huwu zdtb ilgzpa uyaut vpy viff tuuya\ncvusbh bgy apsao qsupha\njtzlbd ljfvh wkjrw xsah sef jygb pqym zbcwok zdmug qpym\nhbibuax iorqc dqjrs daeb iorqc qiw sagyt rkc sagyt khbr\nshz mgn pqrdbm jvace gfhnq ann zosq wdwzmuf kswsg dzt brlavyo\nqiw cdvwds dckpruy pybjra lfvgfn cwj bajtud pojehb rzrzvwe\ntxfyk zkgeeu zkgeeu zkgeeu wskcv nccoz\neettnxq gbgr uiqonyz wqtgs ozfjbn gbgr\nsvd thmmr rbbtxn sxkq isxlnhf tamdlbe bqrgvu nmpvlkc spko\nqmn rspbjme ikjddkq kdb ugpegi egipgu\nufffijo revqpep zfw kwd pnya blqo rnntzx anpy\npiaeyf vbeye uuqd vbeye\nhamd hap ekk lgla twto\nisniinr crz sjpmfxn uskwj\nlzeofk tavbq ijcglqy lvy jliqcyg lwlip\nuhyyyw itlrf tdc iabeocv jzwnjh vqxll nefze pyrxmx eispxnm hzlksce\nucuh mlam bhyej rgzkew ctbo iswqnvg\nytmb toppqgp ytmb gqgpr gqgpr vps ebv\neavn atkqltv bjvojs kaskr vqltakt uiktr xglc eyb rkkas fhnf eaorqm\njmfipc ujggeh hdxpfa xtab ydkibi ycxn ujggeh icheh vpznael oprbf\nxazqxg khlemu awh uwz vhnixk vdcty hkk\ngcl kayi hfozask grpseyn zviy tzoum qywnr wqkhq\nctrrcpw wqfbylp wqfbylp wqfbylp\ngtk lqohf hqeaku mdj zrfkmxn bcqgf msing\nluhpel kexokpx vojap ldaexs bbbtz\noimnqb esg zyjmbfh dfyhcf khpo zjtgm yelztbs ugj zjtgm mxro xyfxpk\ndgtsu vvk wwfugbx aai zlxab beyxcg bpx chc bnxui\nirrwbo orwibr lqt qtl tqknh\nihjsg ihjsg powwy pycyqo ihjsg\nxdcu outh fnqrc eihkss bdylm sjunib eihkss\njpnw ycimse rffu ismyce uhxl feai\nyyodnh dvwshkx vulh pvxj ydhyno hyodny\nvuuweg pfguvyu orhei orhei wrm amkr xecja lmnveth\nwriwe xgtnvj tdmxf gadtqh bezjvz lifu\neuft tchbm xmtlwji tchbm\ncfi zudn zludl pwiu axe psed\ndbtfwf ajxcudj uaxdjcj dxuajjc zouyy\nfmycmej bqhe jyfecmm kkrv kcdvjoy\ngrtb uzs rkxzt hivhic brtg hwyc lsl iivhch qbcp\nymn xfpka hqm sldz dblvsoe\nqrcapma hntgmy difrkpk difrkpk xlsph\nflvqh akcw boxrz ywhq boxrz esnxzv boxrz\nzrvh jskaw mfs fkj\nabveb qxfnlfq abveb kbwiyvd abveb\npgarl nbfrenx rnxgx bdlkix liltdm dzcokeg fubupcg iwp xfayp obfaz nevfw\nnuhvaci blyv fcsp adlanka sjy syj ysxl\navwakn dkoya yzuszuk lqrr oqfyd dmgbhd lqrr\npxa mcvtoug nlweso yffqc dtuagcd ovvrkz ggfhw wnlseo bpqbn ohxzs rxzo\ndjkcl kbgyfir ogquot uoqotg jtmyd ohudvle xrnbt yvsln wykqt hntc xlrhqrb\nykt tkxfmd exas kty\nzebstke msbbndq itmli ubexmht vekvd xbmb iajbj wac sta\nptdg oftwo goiulah tfmsrqs jffxvnv ozaluj qlhqjy wyffa\nxeq ezmlpw xgno xorvfo yzq vwif wsi\nhdove hqbzhu pjrxlj uafuh rizlb advmkca\njzk ddoisdh tfjh yuvikps ixpkf hnu\nkixa djx uksr ogxty dxj clda ukrs\nxgiy diwbvn vphdbg qnelyz tqptqig lenyzq ecsswj\nalx awj fpasmmg zukuh qaanvb too nvskuk too gnria\nsuo suo brw nazq suo dqv\ntan uxiz oqa xyezcd lsaicjr bosiak rmmh\nbidpomf dimcj qekero wbrc lewt kmgmlao\nbciacj eye lxfpef cbdshd dhdsbc qwnhil iuokc\nzduefht lrgfjn nclksm wpjpjr hkeqd oprsjcw\nchhdr bram swdfjr yikqra xkzsloc otptp agec hhdrc uofljf toppt wpbyrwo\nbwlpb nishr knnrysj bvr ftnb iedskch weo\nczo hsfp wblh cru kzalun intt\njvob rppz rkwv hgyhrqg\nsgo hued jnygge izf ztan kjgpcn fagff jsi ijcxzoi tgqjjp tgqjjp\nltjq zidjy rfmy yevuaa nlhfyg xytdtle wsqvzzx wfflboo nawhv golhf xhsti\nbmtzlml xcbsquq vnfsux voep lkss ioim\nntfffh gcncwu mmymn wkwlswa gcncwu iaeyumz\nkcgdm rbaau cwsoya pznnnn xzz zbbdlhw zxuelq xzz pjeq\nxrmnuct kwvykx khxr ioua xnmtrcu xrnctum ujq imnt ecee\nxjsgx fby fby fby ggtpgdm jqvuj qshewki tkml ymsazcq\nsdbyhwg kewtrte novhdcp wbuaoh dtytgtx zez whygbds hpg\ntjvaqo yrycda yrycda ldbp yrycda\nkloi tmsocmx dza sqtxc wgevs zlevs vtm\nftnx drvdm ryjfdgw nerynh cwfjpa mddvr\nwsqjyn svg ncw aesn hvuq vybajti aesn bql atxhp ipu\neye romgxj gumuke jwi jrf dtt kcj wmg waw\nptltud oymklv fgnmbc ete apanovb vpt vyospi\nclkguhu rbxs lxtnmy ferdx qbmrpg pvojnj zbcffbp\nitngp dvtlq fzxp cxrf gbxxqp aafls pfe bpxgxq\nnmikrui ddsq srfilr gnuvghu mwnacz nlbdm zcjm uylgev umzu mftz nmikrui\nbow jmnxyen bow hvz\nlksibxk lefzh lksibxk nkxsi nkxsi pldvhk\nosjlzns pihvr zpeu zxjgjb xplykfk xplykfk\nhajmfss cardd kaddjw uicfde taue\nrgwdjra sgifh ggt mpzx usghkos oob fvzx ghnyxr sblcif\ndtu gnihpry kjdpiny xvax itmluk fxvgaap bei xuq wzcy rhb hailtgo\nwwob ueldq ueldq glxc umimwv onu dxhmhis ebottoa lnysfiu\nzfbyi eyq etaj idpbkf\nqshcfjb ozzqigv raztm ymcv sgivwoc kightf dcaglk udah fdm\njmxr jrcnck enffwfl jycc jmxr cylnigo enffwfl\nbkslhv tykqw tykqw mbeqrbt tykqw\nvogf nhqltpt nhqltpt vogf kpc\nryayz ddktu rfhkmx xok xninjcm ijcrw fxu\ncmezfj zaamjrs whlcuoo mug lcaqhkb ymkdci qexa onhgk pgy\nhcrcok qri fki wbiog ptj pmgtdt\nxsl mpfxwbz bmzxpwf hrysu bmfxwzp xfja\ngybzho ktokndy rzkbr jcnp ahicq weccg pgrodkt che vaglyn omhmpo\nvdv bngjox srs faymg xrmf enseu aygfm gvsd\nnuzi xodkbag eevovl bfjuv nuzi xmejqn\nkcswegw bpa dgil insf insf\nstg tklrut poi knurfpf\npcs dgirfie yep lvkfk ype hntt athvad clfybsq ofjhegj epy qwawns\nwjtpgd wjtpgd vxnapp mwyfsm vxnapp rvcswcs jksa\nckzslrg wdzeimw cqhp nfgk zgukvd yyt tra erkx wdzeimw\nhsww avl vkmzej hsww\nmum oczj jfew rag zjoc wjfe yqynjqt cbkcsgo mri\nvjhfqdi vjhfqdi npfa pzdmy utlyw bwvbfm nqdv iiap ygpky bwvbfm eocya\newkqi ckb yviuro mqz vtrdam yzkqzv ppbj lhmj blkafo juxvwke lvewc\nljrewgx sutnb hfsavbu jofr ltml mjzkzz nmjii sutnb eonegt\ncxzv nepyrb wmejdo vwqi aeqys\nsbx fmne obzdz rdnfb gmb sbx ykcae hbzom ncwju rhpiao obzdz\nlsgfun cbmfjwk fya ktzxbwt\nica bpsk bwjwkp obloxdx uwoqdo bnnhjuc tlsx qtaacp bdooxxl jamy ade\npsus wmtkg ikvfx fkvesj upqlhfs ueje nyt abxvo\nadlbl hzskbrp ooht nps\nwtcgnvy nvqtvx tvgnycw ntvcygw kkxcp zyjmpbh\nxfxww xsddqe ewvmgw qxqwy wpabtz ppe zuiw zubcc onaqii\nkkaeec xhcakul wrrvi dtlqfy ahqdilw bnt gwimw espaivx nam yfv\nlxz jtc nkwgz nbgsao olsck emtltf xidwcvm lcjxq\neav dzh hnbp hnbp yeg\negaq yvat kavsige csar zsi sptai\npofijc ibdnoe caoazp azlnjk dqp chik lowll iby gpvjv ohm\nors lexk zcneaj rmesx jman uqkb kvkq zfufmn\nqgsyzxd hlm juerg ortfzw hxjzg\nfxwy lcoc fyxw pzhynp yfn zdzrz\ndatmws ckwghgr gbtyf lqrpfgl mbgpd dyjilr fgybt hxpg\nmxw facxdnu wxm urltwtf qfo wtpwrj\nesa srypq jauwv dpm wdgqq hrke icvudq bdmubb ellhfjh ttpjjd gxmg\ngvwvqwj cbzzuvj eckube adqinpa djutlue wcpw vrt ucqwu ekruwsn\nfhj fst zmtb yhwk dxlbozs fcb vjvuxin dxlbozs rixdvu\negfoep cvq icd prwj icyg\naojaa ezmcuf udreyi bja cyrtpl wjl\ngjeka bsbufp tbqqq vbmnqg sfqtgac odhq xzsxt\nyse gujdr ugjdr sye\ntax hntqw phf eixjwfh qkylnu nkyuql ugsuj\nwyh egum zizhfc jrq htbyug lop dsu\nexh vfdoosj ajrna jbiaz lqsgvks xklqgjv abtmdud\njuqc ormfa sab tucsfln detqfo feg kifsion juqc ovhra\nhvcrh oddhme omzmu vmy she xulvfa fecmgi\nayo gspge nkmy yblsj lrsre nkmy pwocjz gdexqqx ovovm\nacy sqcz ijl htt yjsi rly vea bck\nbniafe yore xnh rkcfd hxfuzw xlr nkzmmcs ekwggiu kgoboi wfuzxh hwfxuz\nweq crkeq cccphe dtozviy kzkkdr yku cephcc ctq zbau dewpi\nvfla rzpl bnmx uvggon foivrb fval\nziaove lawkpdn ddwl sxj krroj rqmffxv babb\nbdw dsifr kuueet hugddwt piz dwb sjixveg kmsoknq\nczl feyxf soyvbj tnmpjn kklwi akx nqepntc\nnrmhc tkkn jrxgc jrxgc tkkn\nufzn mrhiapi qrme kjlf qrme xpp qrme loyzizz xqm coli\nqvaoye mysv ydfxr iixrw\ndql tqarux fxqfn haoinu lyati xml\nkyve obatly dgfjt fjz sqrz xlbst lgwlt zovih aepy otrpl oifid\nymawam afgye lcnpkmv feilfws vonseh rxrdco\ntqij kuawg dmova slds imdtb sjsafo ffkzzl pxxenva wuakg efbgx\nyrwoaos vpw ijjpua jnbxl sev yvgdxzr mpqa vpe lboh sev\nkrwdtd uglxtcz mljcgdk lqj fgpfle nuui cqk exr nuu oyn\ndwd nwt idhclm vgkh rpubq wybhapp\nhskhgpy gzvz jztbr jwv vcx vdjmnjr jrsp\nikml ceuhcng biu zoo gra bnnforx abzan hwsmd lmki tsl yvogo\nkqfc younaz azvgfz gesajr tmwxvyb vmcdu dclwh rfjwhic slfym\npbrhjml rsacryg jga qvgks neh fcq qmi mwb juezk mjteeg alkb\npcj ujstl fkrqm eeczrle hbkcvm upbo mrb qrspjt\njbq rrk xjl rgokbnx hor ogg szxqu hysy vqj piorq wtrtrdk\nbnq ntvhcrf vrm puer kde xaxkja sfxgjf\npgcicus hqeqkkx xqekqhk qqkxhke\npuquxi hmeaehh oxe tasipw qzyg hyvy wcmpwe\nhvs fxq wvfy zjepsl dvrfxnc xnvg\nxle crcuc qkhnv crcuc oedez bjw pmwq\nxzzpiy cjwss jwscs apb bpa\nydjhhf yeltadb lwi cjdcb ovaox xrdm vkxub\nzax xza admbc lvpzfeh auxn rwasj\nkebx eild nrskdr meja jxczomh gcne\"\"\"\n\ninput.Split '\\n'\n|> Seq.map    (fun p -> p.TrimStart().Split ' ')\n|> Seq.map    (Seq.countBy id)\n|> Seq.filter (Seq.exists (snd >> ((<) 1 )) >> not)\n|> Seq.length\n|> printfn \"Puzzle 4.1 = %A\"\n\ninput.Split '\\n'\n|> Seq.map    (fun p -> p.TrimStart().Split ' ')\n|> Seq.map    (Seq.map (fun w -> w.ToCharArray() |> Array.sort |> System.String.Concat))\n|> Seq.map    (Seq.countBy id)\n|> Seq.filter (Seq.exists (snd >> ((<) 1 )) >> not)\n|> Seq.length\n|> printfn \"Puzzle 4.2 = %A\"\n\n","parent":{"$":0,"Item":"ebc10936-8796-43e0-b809-8f6b539b31a2"},"predecessors":[],"id":{"$":0,"Item":"27802317-f924-45b5-8997-da8cbfb68812"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Day 5 start","content":"let steps = \n [|","parent":{"$":0,"Item":"ebc10936-8796-43e0-b809-8f6b539b31a2"},"predecessors":[],"id":{"$":0,"Item":"61c4050b-83dd-4a8e-aafd-f64fc2ae4954"},"expanded":false,"level":0,"levelCode":0,"properties":{}},{"name":"Day 5 input","content":"2\n1\n2\n-2\n0\n0\n-5\n0\n-3\n-5\n-8\n-2\n-1\n-2\n-1\n-9\n-10\n1\n-11\n-5\n-9\n-7\n-13\n-19\n-22\n1\n0\n-3\n2\n-9\n-4\n-5\n-15\n-13\n-30\n-21\n-4\n0\n-34\n0\n-31\n0\n-29\n-42\n-1\n2\n-24\n-16\n-16\n-12\n-22\n-37\n-16\n-34\n-46\n-12\n-53\n-12\n-23\n-44\n-1\n-29\n-9\n-52\n-17\n-30\n-60\n-5\n-29\n-26\n-48\n-55\n-10\n0\n-50\n-1\n-8\n2\n-37\n-74\n-63\n-39\n-7\n-81\n-33\n-62\n-59\n-20\n-58\n-54\n-23\n-19\n-80\n-39\n0\n0\n-92\n-75\n-24\n0\n-73\n-36\n-14\n1\n-102\n-97\n-30\n-105\n-99\n-84\n-46\n-67\n-88\n-86\n-94\n-53\n-88\n0\n-100\n-86\n-11\n-93\n-99\n-21\n-2\n-108\n-6\n0\n-113\n-116\n-127\n-42\n-131\n-124\n-24\n-56\n-63\n-130\n-118\n-52\n-139\n-43\n-90\n-123\n-7\n-93\n-117\n-34\n-59\n-140\n-103\n-52\n-115\n-83\n-42\n-92\n-48\n-82\n-104\n-38\n-2\n-28\n-150\n-39\n-30\n-71\n-146\n-55\n-114\n-141\n-158\n-55\n-21\n-121\n-142\n-137\n-119\n-99\n-113\n-99\n-33\n-99\n-20\n-129\n-83\n-64\n-179\n-182\n-43\n-86\n-50\n-135\n-186\n-68\n-100\n-181\n-22\n-106\n-178\n-157\n-46\n-41\n-80\n-166\n-77\n-81\n-144\n-132\n-81\n-11\n-38\n-57\n-69\n-13\n-79\n-146\n-1\n-165\n-52\n-134\n-86\n-160\n-97\n-220\n-92\n-200\n-145\n-175\n-138\n-205\n-127\n-165\n-155\n-211\n-134\n-31\n-118\n-190\n-40\n-182\n-96\n-134\n-93\n-84\n-76\n-34\n-33\n-203\n-16\n-245\n-167\n-102\n-5\n-44\n-239\n-127\n-255\n-116\n-61\n-140\n-238\n-69\n-254\n-203\n-178\n-229\n-250\n-120\n-109\n-153\n-108\n-137\n-247\n2\n-151\n-270\n-164\n-62\n-186\n-272\n-190\n-180\n-70\n-179\n-38\n-208\n-215\n-151\n-156\n-62\n-57\n-275\n-182\n-169\n-264\n-70\n-279\n-55\n-287\n-57\n-3\n-67\n-155\n-213\n-17\n2\n-200\n-291\n-179\n-175\n-73\n-257\n-47\n-118\n-206\n-93\n-293\n-199\n-102\n-118\n-188\n-66\n-288\n-21\n-204\n-80\n-237\n-175\n-297\n-235\n-168\n-262\n2\n-162\n-95\n1\n-286\n-318\n-9\n-213\n-159\n-127\n-175\n-266\n-240\n-268\n-245\n-196\n-281\n-86\n-202\n-127\n-144\n-157\n-333\n-122\n-230\n-182\n-38\n-296\n-12\n-224\n-123\n-40\n-6\n-324\n-135\n-289\n-85\n-179\n-37\n-58\n-125\n-228\n-124\n-250\n-73\n-35\n-286\n-267\n-257\n-348\n-83\n-3\n-98\n-99\n-273\n-118\n-310\n-23\n-299\n-96\n-51\n-273\n-79\n-112\n-355\n-48\n-219\n-10\n-103\n-18\n-201\n-108\n-34\n-362\n-165\n-359\n-347\n-157\n-148\n-20\n-344\n-66\n-337\n-387\n-62\n-125\n-4\n-355\n-322\n-263\n-381\n-108\n-25\n-262\n-425\n-100\n-54\n-315\n-221\n-268\n-211\n-321\n-89\n-124\n-297\n-22\n-162\n-117\n-430\n-152\n-373\n-256\n-37\n-61\n-59\n-436\n-377\n-346\n-245\n-167\n-451\n-392\n-382\n-248\n-254\n-382\n-249\n-267\n-216\n-205\n-310\n-326\n-144\n-107\n-65\n-382\n-79\n-401\n-370\n-221\n-283\n-269\n-64\n-207\n-262\n-181\n-146\n-52\n-169\n-147\n-225\n-179\n-215\n-116\n-115\n-37\n-227\n-250\n-228\n-132\n-414\n-425\n-230\n-224\n-319\n-42\n-353\n-285\n-38\n-145\n-263\n-25\n-142\n-296\n-267\n-43\n-315\n-352\n-105\n-275\n-354\n-66\n-414\n-464\n-215\n-107\n-267\n-394\n-10\n-27\n-315\n-286\n-113\n-454\n-400\n-468\n-245\n-18\n-427\n-479\n-281\n-43\n-29\n-15\n-371\n-127\n-371\n-251\n-343\n-267\n-355\n-271\n-68\n-454\n-532\n-264\n-513\n-170\n-484\n-85\n-329\n-389\n-317\n-382\n-535\n-169\n-395\n-53\n-429\n-394\n-465\n-250\n-419\n-434\n-84\n-130\n-229\n-496\n-336\n-388\n-412\n-123\n-502\n-205\n-367\n-224\n-40\n-551\n-99\n-394\n-321\n-515\n-260\n-410\n-518\n-22\n-23\n-259\n-397\n-306\n-199\n-157\n-49\n-298\n-176\n-564\n-271\n-6\n-297\n-514\n-432\n-455\n-192\n-95\n-447\n-237\n-571\n-543\n-229\n-405\n-282\n-235\n-380\n-25\n-603\n-335\n-94\n-533\n-463\n-396\n-421\n-393\n-588\n-376\n-152\n-328\n-460\n-90\n-315\n-533\n-207\n-590\n-100\n-588\n-574\n-259\n-183\n-522\n-424\n-272\n-341\n-443\n-217\n-143\n-26\n-196\n-632\n-520\n-606\n-277\n-176\n-547\n-564\n-444\n-228\n-223\n-115\n-200\n-616\n-576\n-398\n-157\n-78\n-586\n-12\n-650\n-239\n-152\n-20\n-366\n-100\n-478\n-666\n-247\n-105\n-230\n-218\n-48\n-238\n0\n-387\n-660\n-542\n-189\n-339\n-577\n-527\n-273\n-565\n-230\n-578\n-147\n-106\n-373\n-513\n-8\n-465\n-66\n-408\n-351\n-357\n-119\n-251\n-626\n-81\n-575\n-542\n-193\n-219\n-189\n-635\n-77\n-517\n-608\n-309\n-716\n-712\n-287\n-67\n-312\n-334\n-584\n-687\n-488\n-612\n-42\n-180\n-726\n-235\n-606\n-538\n-470\n-477\n-504\n-278\n-24\n-435\n-610\n-540\n-646\n-503\n-151\n-350\n-43\n-699\n-459\n-516\n-424\n-343\n-297\n-460\n-592\n-30\n-614\n-125\n-425\n-180\n-73\n-550\n-361\n-390\n-380\n-518\n-418\n-305\n-326\n-84\n-675\n-320\n-557\n-486\n-457\n-414\n-69\n-228\n-683\n-610\n-188\n-608\n-480\n-225\n-186\n-374\n-256\n-672\n-145\n-323\n-453\n-252\n-214\n-600\n-49\n-652\n-593\n-93\n-42\n-101\n-600\n-422\n-146\n-191\n-474\n-725\n-568\n-572\n-498\n-506\n-702\n-120\n-210\n-340\n-482\n-210\n-666\n-520\n-647\n-219\n-435\n-455\n-814\n-304\n-610\n-224\n-95\n-425\n-456\n-761\n-339\n-256\n-793\n-49\n-317\n-274\n-374\n-620\n-730\n-130\n-128\n-420\n-315\n-47\n-92\n-467\n-269\n-563\n-495\n-501\n-32\n-755\n-774\n-154\n1\n-685\n-657\n-38\n-727\n-428\n-293\n-68\n-203\n-850\n-775\n-545\n-740\n-683\n-728\n-502\n-520\n-44\n-53\n-826\n-555\n-539\n-291\n-435\n-673\n-865\n-114\n-467\n-679\n-598\n-611\n-566\n-606\n-320\n-124\n-430\n-240\n-85\n-549\n-847\n-481\n-444\n-792\n-695\n-405\n-427\n-292\n-533\n-91\n-5\n-546\n-181\n-156\n-488\n-29\n-17\n-572\n-510\n-663\n-321\n-177\n-516\n-85\n-829\n-109\n-236\n-876\n-141\n-427\n-180\n-576\n-45\n-178\n-6\n-236\n-381\n-638\n-144\n-391\n-739\n-43\n-898\n-896\n-395\n-280\n-712\n-127\n-823\n-130\n-783\n-324\n-29\n-136\n-941\n-816\n-712\n-120\n-639\n-209\n-522\n-618\n-205\n-557\n-153\n-451\n-280\n-214\n-683\n-134\n-329\n-403\n-156\n-645\n-194\n-811\n-377\n-161\n-620\n-920\n-225\n-632\n-543\n-658\n-864\n-137\n-928\n-616\n-728\n-145\n-182\n-879\n-595\n-598\n-409\n-934\n-23\n-58\n-301\n-427\n-599\n-562\n-373\n-656\n-360\n-783\n-68\n-228\n-712\n-912\n-260\n-490\n-588\n-481\n-610\n-615\n-180\n-914\n-960\n-462\n-522\n-782\n-617\n-687\n-477\n-934\n-54\n-201\n-279\n-101\n-27\n-759\n-407\n-187\n-202\n-715\n-488\n-206\n-802\n-737\n-18\n-364\n-325\n-155\n-573\n-536\n-769\n-747\n-669\n-856\n-521\n-24\n-921\n-394\n-726\n-251\n-5\n-533\n-923\n-752\n-28\n-775\n-100\n-801\n-22\n-723\n-383\n-952\n-355\n-1058\n-975\n-975\n-706\n-843\n-75\n-124\n-150\n-98\n-1019\n-195\n-342\n-915","parent":{"$":0,"Item":"61c4050b-83dd-4a8e-aafd-f64fc2ae4954"},"predecessors":[],"id":{"$":0,"Item":"9650c84b-d384-4bbf-b43c-0e997fb616e8"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Day 5 code","content":"|]\n\nlet testInput = [| 0 ; 3 ; 0 ; 1 ; -3 |]\n\nlet getInstr (steps: int []) pp =\n    let instr   = steps.[pp]\n    steps.[pp] <- instr + 1\n    instr\n\nlet solve get (stepsI: int []) =\n    let steps           = Array.copy stepsI \n    let mutable pp      = 0\n    let mutable counter = 0\n    \n    while pp < steps.Length do\n        let instr = get steps pp\n        pp       <- pp + instr\n        counter  <- counter + 1\n    counter, steps\n    \nsolve getInstr testInput\n|> printfn \"Puzzle 5.1 = %A\"\n\nsolve getInstr steps\n|> fst\n|> printfn \"Puzzle 5.1 = %A\"\n\nlet getInstr2 (steps: int []) pp =\n    let instr   = steps.[pp]\n    steps.[pp] <- instr + if instr >= 3 then -1 else +1\n    instr\n\nsolve getInstr2 testInput\n|> printfn \"Puzzle 5.2 = %A\"\n\nsolve getInstr2 steps\n|> fst\n|> printfn \"Puzzle 5.2 = %A\"","parent":{"$":0,"Item":"ebc10936-8796-43e0-b809-8f6b539b31a2"},"predecessors":[{"$":0,"Item":"61c4050b-83dd-4a8e-aafd-f64fc2ae4954"},{"$":0,"Item":"9650c84b-d384-4bbf-b43c-0e997fb616e8"}],"id":{"$":0,"Item":"d0577089-2f95-4c4f-ab4d-8940a394ea5b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Day 6","content":"let input = \n    \"10\t3\t15\t10\t5\t15\t5\t15\t9\t2\t5\t8\t5\t2\t3\t6\".Split '\\t'\n    |> Array.map System.Int32.Parse\n    \nlet test = [| 0; 2; 7; 0 |]\n\nlet step (input: int []) =\n    let copy = Array.copy input\n    input \n    |> Array.mapi  (fun  i  v  -> i,  v)\n    |> Array.maxBy (fun (i, v) -> v, -i)\n    |> fun (p, m) ->\n          copy.[p] <- 0\n          for i in 1..m do\n              copy.[(p + i) % copy.Length] <- copy.[(p + i) % copy.Length] + 1\n    copy\n\nopen Useful\n\n#define WEBSHARPER\n\nlet rec solutionR input history = \n    let next = step input\n    let pos  = List.tryFindIndex ((=)next) (input::history) \n    pos\n    |> Option.map(fun n -> history.Length + 1, n + 1)\n    |> Option.defaultWith (fun () -> solutionR next (input::history))\n\nlet solutionNR inputP = // Javascript cannot handle tail recursion\n    let mutable input   = input\n    let mutable history = []\n    let mutable result  = None\n    while result = None do\n        let next = step input\n        let pos  = List.tryFindIndex ((=)next) (input::history)\n        result  <- pos |> Option.map(fun n -> history.Length + 1, n + 1)\n        input   <- next\n        history <- input::history\n    result.Value\n\nsolutionNR input  \n|> printfn \"Puzzle 6 = %A\"\n\n\n","parent":{"$":0,"Item":"ebc10936-8796-43e0-b809-8f6b539b31a2"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"7791cff0-6654-4b0e-b75c-a4bb7ddca919"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Day 7","content":"let input = \"\"\"\nllyhqfe (21)\nvpbdpfm (74) -> ndegtj, wnwxs\ndosteiu (262) -> vliyv, rfxmk, nulxd, tckql\nleqnli (222) -> wuttw, nckca\ncgztcyz (59) -> zbtmpkc, lleaucw, zxvjkqv, tqjyoj\ndqfti (67)\nvsjhe (34) -> zpbbgqh, menyi, ksasli, uahdbi, ccfiz, kdwmlx\nntzuhe (98)\nmpjrzt (53)\ndnzll (23)\nensyb (18) -> usvzfi, uxxtnll, phrkfo, vntjo\nairqzst (39)\nhfzvg (26)\nwpojcme (79)\nxggisxm (37)\njkqcelt (35)\napjsu (299) -> rgylin, yrmfcs\nodoni (18)\ngzatvf (27)\nazkpaf (81)\ndnyaj (76)\nchfcnsc (70)\nwjdkcjo (29) -> jdntuc, htaxf, edpqtnn\nbejkc (194) -> lqjnh, xkfwmh\nlfapaod (97)\neidqfh (24)\nhaeyms (23) -> akxrge, qgqrmeu, nsnhdll, ydyvay\nialdd (67)\notqufza (116) -> dvasofv, mxdxz\njbopt (91)\nmkxsdn (46)\nvkcim (63)\nypokgio (14)\nwiihwvv (55) -> mivrqpc, hdqgdm, muulq, tveyfha\nrvdldy (47)\nxzsfek (87)\nshkfwm (26) -> yjpzyzx, vdnvw, nsbyncu, wpafb\njdryrup (43)\nzqxhle (53)\nxaaqdv (21) -> kxkwc, mpwnd\nlfmlqs (79)\nmcctaf (37)\nqewiy (18)\nlfzvi (240) -> gxmqlu, sfteyu\nzbtmpkc (94)\njaathmh (33)\nsjwxyqb (55)\nwxvsp (187) -> umiohmp, zeauj\nopghigg (97) -> dletgs, bcgqdc\nkabjov (239) -> eulcspz, nxttce\njivdw (14)\nnckca (6)\nnfeok (203) -> apqan, ywtywz, inoyp\nejyegf (71)\nccmfbok (82) -> jbopt, cteuws, rrsxb, atfjks\nqizkjh (350) -> mxsacj, liiwwfa\ntdfirdf (62)\njwboky (54)\nksnnnc (638) -> iuuzow, eiyvtz, dlxcy, ltfbsgc\nmhbiyxk (15396) -> ehpfjr, zqgeod, hiccoc\nbzenp (37)\nuymhfo (37) -> wiihwvv, jgpsybl, zpxuxph\nvewathl (261) -> bzbxoa, ntzbt, jsizfuj, ikrlxqw\nbvqhn (82)\njqtxjrm (1199) -> aqkclfk, eipaxu, hzvctd, zpohg\nkfuwkh (52)\naamghal (79)\njqywsxa (74)\nehpfjr (42) -> sdxwhvp, itdxbrj, cgztcyz, awylric\ngxmyk (166)\nbeknji (29)\nahvdop (50)\nfpuhllh (8)\ncadtows (49)\nshbrz (874) -> hcywj, pkgyjn, hwxxvlb\ntebvlpn (106) -> kfuwkh, nkuhc\njexcm (33)\ngwplv (33)\nnsckvp (49)\nghaxmrh (10881) -> hhosv, ximzx, ztphu\ngkwamq (54)\nvonve (204) -> scxkq, ubsbx\nhmlil (63)\nrpmzw (97)\nfzkqz (75) -> xxyjm, yjqgw, ejyegf\ndfwamci (36)\nbzbxoa (42)\nqlmbqwi (58)\nivygtzl (1708) -> vjfsl, xfvhi, sbhfnav\nvliyv (20)\nmecsrr (81)\nuskdpcu (388) -> nktkgz, xcuud\nvwktc (60)\nfkpjukc (42)\nnsnhdll (70)\ndpgggti (8)\nnxmxgax (70)\nvwntogi (64)\njshekxk (42)\nncxhv (184) -> ddxiiha, hcvuc, tebvlpn, kkjen, wjkalv\nurpzfa (58)\nocrgjl (2738) -> qogmb, qxirdyg, aovhss\ngtxvgr (58)\npsqgnhx (20)\nvkoor (69)\nmzpeoz (50)\nsbebrkf (12)\nzupsoqc (20)\neiyvtz (65) -> modakko, mlydcn\njdvuj (8)\nbytizsx (61)\ndhamym (17)\nzldebh (76)\nesmltj (21)\ntihzzf (701) -> wyeoaxt, hrkhlaq, vyccl, jezmn, nmmrik\nrmriv (27)\nbyiqom (88)\nmnkamc (1717) -> idhjov, pyurvrc, ahpitb\nfvtofr (44) -> jexcm, jokgw, slmnzei\nppkpq (41)\nkxkwc (57)\nepnvhbn (21)\ntusmlk (295) -> ialdd, kipiwwk\nlwqscns (14) -> zgyryw, oiooued\nzbmsz (35)\nczmmh (44)\nfmwid (1567) -> dhbxpw, xkzrkzh, wxvsp, zqyrggw\nsviwi (15)\nnodqkan (89)\nqddbmn (72)\nkiphte (353) -> kfiggar, rncuf\njyajecr (14)\nclqwflm (17)\nkkjen (36) -> rftaqhw, hxtejel\niokwnq (25)\nyelgho (38) -> uiagqs, dzrflyr, tdfirdf\nrgocso (41)\nmdsywgy (70)\nknhvwhl (298)\nzpxuxph (399)\ndhbxpw (19) -> itfnye, yghucrl, ekvkidl\nrxeqfsj (24)\nsjzapjt (85) -> opndzmu, ilexb, tqddro\nnbybi (7) -> vwntogi, mhvzqc\nbnkbyp (73) -> hagkc, arfsqdz, wbzmjq, eisjz\njezmn (40) -> nsmlghl, lakhmm\niwlxpz (18)\nvjfsl (87) -> gccvp, wkble, ilshxl, jqywsxa\nztphu (983) -> picliob, wcblyq, ollvgn\neuwfw (12)\nrccvm (363) -> mutyu, kqltwau\nhifms (54)\nbyldgs (79)\nforycux (37)\nxwwjzx (39)\nqvqzuic (6)\nuylrp (7179) -> apqwz, nsqaxp, yffumkx\njblzpyq (45)\npeexz (96)\nldcaht (98)\nwwggl (157) -> ssxpawm, brjzpkm, woionr\nyyhkwha (179) -> yiehfd, jkqcelt, fuvikt\nrjtdc (44)\nwnwxs (83)\nmsigvaq (96)\nojrggba (69)\npvctv (3341) -> gkwamq, sattu\nctrdahm (24)\nxfvhi (283) -> zkphtd, qmncedz, lsdkm, iokwnq\ngkrtbv (30)\naovhss (185) -> wevhizp, lmnews\ntfpbait (45)\nmkeen (102) -> jttgtsg, phkcge, zxyrq, telnuq\nefbrhl (31)\nwjkalv (54) -> eloku, xwwjzx, etyja, vghvcv\nndois (317) -> csuoxe, jwboky\nvfpwu (712) -> tusmlk, vewathl, jxfbflh, lcefyg, bnkbyp\nzdkgm (13) -> xpkyf, eaqhut\nrhpxizt (449) -> lcnqmai, cpjkn, ccfbpoc\ndmhfz (66) -> ojrui, bkuazfi, yedrd\nbpbwn (97)\ncdglv (1515) -> pbimnll, rcyjnsi, sfnsx, hfdoqqt\nkfcaozk (27)\nlqjnh (38)\nqhjui (47)\nntzbt (42)\natfjks (91)\nkfiggar (24)\nqeoyu (42) -> liukun, tdvorom, knhvwhl, ombds\ntlnuq (76)\nzpedug (76)\narrok (230) -> ypokgio, qonkb\nwvvmksv (21)\nscxkq (33)\niuuzow (117) -> unlwjj, ayfcyul\nbkuazfi (55)\nhrkhlaq (66) -> mwavu, jbtqs\nnbtsze (80)\ndarmn (96)\nkaugsh (378) -> fhzkakn, epdzg, ogsxfk, rzoojpm, dabvuui\nelhxdco (220) -> wmmrhf, tcxkqku\nmgnux (46)\nyzhwurz (136) -> pksyw, osrkwa\nmuulq (86)\nayfcyul (43)\nuryery (39)\nxipivez (33)\nubsbx (33)\ntcxkqku (21)\ndhqjni (17)\nnokkziw (73)\nyzjiby (79) -> numbey, jqtxjrm, ybkdekt, ciwpis, smkqg\nybjghed (91)\naxleb (81)\njfoztzy (37)\nrjoszhu (92)\nvimazqc (93)\nsvhcnju (24)\nmwssex (55)\nwfmmajk (177) -> kfcaozk, pmfbr\nhxjopp (228) -> nsckvp, cadtows\nbieswf (51)\ndabvuui (38) -> nxmxgax, xmtosc, chfcnsc\napqan (38)\nlivac (240)\nkcotwhf (1006) -> jbztwms, pfpmube, bgeec, hhawhzk\nmxdxz (44)\nhhosv (40) -> klnemf, vrzsj, bacazl, gzepcax, onqop, afkeosv, zvlafea\neytppcy (309) -> ltifq, ehxjsgn\nkyzjusc (37)\ngmsmnlz (36)\nmncyztp (1990) -> fsmzfjp, kndrzyc, svvirl\nbnkfzle (261) -> bvqhn, edihrrv\njakfuqo (317) -> sxfxnp, tdrdp\nuxqiqg (95) -> xwyggz, oxtvu, zwtaqj, cxvse\ntftwygl (29)\nytaus (47)\nuxxtnll (81)\nyghucrl (66)\ntnxoqxw (93)\nemkyoy (354) -> rddeecm, dugvnav\nhmorsv (64)\njwidjq (217) -> qfyor, bpsyylv\nkeily (231) -> ueywo, xlpqnhm\numiohmp (15)\nkiuayw (24)\nenuzo (63)\nnoejr (83)\ntveyfha (86)\nohmvcr (98)\nxfzxw (67)\nmodakko (69)\ncwemvgf (85) -> iebsger, mtoqh, ciabx, puzwwgx\nwmmrhf (21)\nvxghl (48) -> umgqr, cbvwcv\ncnvghq (33) -> byiqom, ehljn\niemkgdl (79)\ngpucfv (270) -> bscob, leyohju\nmlydcn (69)\ngsgexgb (90) -> cwemvgf, cukbzsw, iaiqz, gveadp, rccvm\niybrmf (27)\nfrruz (7530) -> pkrxt, ifwkgxo, abpry, dydso, fjjuj, sgfbfq\nxxvlxs (37)\nuqttm (33)\neryxwj (90) -> vxtwg, bmtjkw\nbsdxw (29)\nffxkad (91)\nciwpis (1215) -> elhxdco, ccmod, etuteik, jaxkva\nzzxzeuo (62)\nqycoh (66)\nsuprw (34) -> vpbdpfm, kacamw, dwdczlx, mrqaryt, rjnzfa\nefpvvp (7686) -> mncyztp, tleviy, uuftjqx, vsjhe, mmutg, wzvjkiu\nbpsyylv (17)\nthmnm (80)\nrvpbx (256) -> zwxlf, ojrggba\nndegtj (83)\nksasli (331) -> cyxtnfe, xrtkqi\nvyfbsgv (81) -> rwxfhk, kihifp, ndois, kupmpp, eytppcy, bnkfzle, fycnyn\nkjyufi (37)\nykxkv (299) -> ijzgy, dsbxavd\nwnfcsap (32)\nicoti (69)\nakowch (67)\nxlpqnhm (59)\nyzrfzv (73)\njmmbca (91)\nmfacoz (23)\nbcgqdc (77)\nohbfa (79)\nnumbey (1861) -> lwqscns, arlrk, klqvgm\nkfgyus (42)\ndlfay (16) -> zksnaz, miocbjk\ndwdczlx (162) -> cmdcov, pbhsevc\nliiwwfa (22)\nikrlxqw (42)\nfwbang (99684) -> lvxnl, aspplbw, uylrp, yzjiby\nryzfgj (44) -> lrbozkj, mpjrzt\nzrjtxfa (9314) -> iixjr, vfpwu, ivygtzl, vgwfukr\nmkxatmb (91)\nzxmsme (66) -> lgjbhwy, jugycbw, dnzll\nhxtejel (87)\nrsblo (385)\nrqbgxlt (24)\nrbbhhe (91)\nkcbag (36)\nfdorzyx (49)\nlcnqmai (12)\ndvpmg (1474) -> uagszs, otqufza, mjmpkq\nlakhmm (99)\nzxyrq (18)\nfthgkl (55) -> ekuibos, zmtszz, peexz\nonqop (60) -> bnryi, kjyufi, kyzjusc, elukq\ntismupk (86)\nhhrqbn (75)\ncycky (75)\nxksjes (103)\nufhjnc (106) -> rbbhhe, ybjghed\naqkclfk (88) -> nodqkan, tahov\nfuehgn (175) -> dnliq, dhqjni, ruszodn, cjagg\nafkeosv (181) -> qfwtxzq, aowuj, trkvrk\nbrdkwc (45)\nyedrd (55)\nwyeoaxt (104) -> inlzx, akowch\nowfrl (1516) -> rsblo, hfytix, ggwwhvf, ykxkv\ngosjs (24)\nmxsacj (22)\nosrkwa (32)\ndrffb (15)\nzsucroj (76)\nermgcbt (78)\njpjehc (37)\nvdnvw (58)\nholcy (66) -> frruz, hbzxaji, mhbiyxk, zrjtxfa, efpvvp, acmrndk, trrkrqa\ngjbijgl (64)\nlphqgek (21) -> qdpnoic, qvjiwvb, qxoly\nuhsdpj (72) -> rslnx, bmaoav\nakxrge (70)\nyerckb (255) -> dpgggti, ssysjwe\neipaxu (150) -> qlmbqwi, fsuglk\npbhsevc (39)\npfmordc (36)\nrdjfp (1393) -> dmhfz, wfmmajk, utoogeb\ntpbbd (91)\ndexwo (223) -> fqjdoe, ovpyq\nhwinqpr (27)\nmqgmc (150) -> vkoor, hvdwvo\nqrhweil (99)\nkrdsv (24)\ndydso (1002) -> evbilqr, glbaxl, yzhwurz, usubx, uxxyr, gremk\nwowirye (47)\neaqhut (70)\nilshxl (74)\nyqsfolo (11) -> vrdrc, utqxez\nqniem (85) -> qdnuduv, zsseyik, xxardqs, xafip, uhsdpj, xxehapc, pmwosk\nojbyg (21)\nvkwcj (96)\nrtvpznv (257) -> emxviup, dfwamci, pfmordc, ikcjmxi\nabpry (1005) -> uxqiqg, adxplm, xlbjv\nnhtetdw (29)\nzstbuv (60)\nzmtszz (96)\nnfccf (26) -> zpqpd, skbxo, hzkvyoj, fhivbs\nkrkeek (52)\nowgbqb (30)\ntekug (77)\njaxkva (138) -> zzxzeuo, npxeql\nhqqxg (43)\nungfmbw (61)\nedpqtnn (96)\nydyvay (70)\nniopwq (42)\njgpsybl (317) -> ppkpq, fezoee\noyypq (142) -> iwxgwc, qyovvxb\ninlzx (67)\nedihrrv (82)\nqsloy (44)\nyffumkx (9) -> jakfuqo, ouxsgm, keily, pshyy\nfhivbs (92)\nfkprhv (31)\nrhgyz (38)\neiyxgk (76)\npzemz (76)\nlcefyg (353) -> twvjddq, rhgyz\nvrpyfgm (88)\nhfytix (81) -> cjctf, fckcu, ztcqm, pzemz\nvoiqnou (147) -> czmmh, rjtdc\nozwdh (96)\nekhsrgq (25)\nxmtosc (70)\nyfrewb (77)\nqfyor (17)\nijuod (93) -> ldcaht, ruuhrmf, dfbabey, bbdfr\npknpuej (91) -> livac, vxghl, qcccxc, mxprsl\ngwvsbo (76)\nfqjdoe (39)\ngqahoa (57)\nvykav (89) -> dfhtf, yopex, ypzxdhs\npicliob (97) -> bzenp, jfoztzy\nfhzkakn (107) -> wowirye, aseilg, jmutqq\numgqr (96)\nqmlguo (96)\ngosak (27)\nnvatz (63)\nzsgnve (39)\nfyvjfxi (58)\noxtvu (76)\nhoewyjx (47)\nqykdedu (63)\ntocrk (88) -> nzyls, qlgljuh\nssnoqt (24)\nmhvzqc (64)\narfsqdz (89)\nvrzsj (127) -> tetfdv, ornacig, yrdbx\ntszune (40)\njcuhfsd (80) -> sordz, zmfhyr\ndqaov (96)\njeafpic (32)\ntdvorom (246) -> hfzvg, dapey\ndldcoc (149) -> gwvsbo, eadjn\nngxtfx (91)\noiooued (60)\nnmhmw (979) -> krdsv, kiuayw, rovftl\nyqmbbyr (24)\nzvlafea (140) -> wtjoxu, dxszgsr\nuiagqs (62)\nlhpjahj (86)\nuagszs (36) -> cflribm, dsukkg\numqlwls (202)\npazby (45)\nmqayze (55)\nnzeqmqi (12216) -> nmhmw, pknpuej, rfkvap\nhfdoqqt (128) -> sevcqp, bieswf\nejmfnnu (43)\nhupmm (76)\nwnahs (18)\noomve (87)\nhdfsofm (75)\nqonkb (14)\ncnlny (278)\nogsxfk (140) -> iybrmf, xixiloi, hwinqpr, jdmrbxc\nnafdo (23)\njsizfuj (42)\nmwavu (86)\nciabx (96)\nljwcd (16) -> nokkziw, cjgpfb, yzrfzv\netyja (39)\nhcrzxz (78)\nxwyyfr (256) -> jyajecr, jivdw\nlrbozkj (53)\noibnbf (15)\nbbdfr (98)\nzwzgp (14)\nsvvirl (62)\ntlkrx (23)\nkndrzyc (62)\neuenhl (53)\nipvrlll (86)\nggwwhvf (160) -> hhrqbn, zvazn, hdfsofm\nsofrg (281)\njyovf (29)\nagobkww (69)\ngzepcax (50) -> wpojcme, pprspr\ncxvse (76)\nrftaqhw (87)\nyzbmyaw (86)\njjbmtij (54)\nwhuozum (35) -> suftfkn, gtxvgr, igxdio\njxfbflh (229) -> xkyocjn, ahvdop, ewlsf, jejwwxj\nwoionr (15)\npkgyjn (76) -> urpzfa, fyvjfxi\npwydnik (63)\nchhli (46)\ngdvcou (189) -> jdglmn, mgnux\ncbvwcv (96)\ngtiqar (29)\ntxcwm (29)\nfvojv (116) -> rycpngd, hifms\ndzxjy (96)\nniznnko (44)\njmutqq (47)\nsevcqp (51)\npmfbr (27)\nshoxg (7)\nltfbsgc (109) -> rvdldy, qhjui\nltifq (58)\njxzyg (37)\njttgtsg (18)\nzwtaqj (76)\nmwussz (143) -> etotvx, lbmvl, xlavrvm, rmriv\nzwlok (143) -> zvtgd, shoxg\nhcywj (102) -> brdkwc, tfpbait\nkbuslbp (81)\nsmunvi (172) -> zqxhle, euenhl\nqlgljuh (26)\ngwcqtcr (73)\nkacamw (170) -> bexrple, wetutqh\ndvkbqm (20)\neaerpmi (1342) -> rjoszhu, migwxez, izydgv\nealilsq (50)\neisjz (89)\nrihil (12)\nysabu (24)\nombds (178) -> wlrihpy, vwktc\nsueftvh (81)\nmrqaryt (80) -> thmnm, kligtj\nxkyocjn (50)\nprywl (43)\nfonky (47)\nbhddwe (64)\nmtoqh (96)\npksyw (32)\njndnfa (45)\nguqul (222) -> oonfc, irpjsbf\nnkuhc (52)\napqwz (934) -> gjvcdp, fnuzrye, zwlok\nojrui (55)\ntckql (20)\numsilqj (32)\nxswwe (212) -> ffxkad, ngxtfx\nhwtztim (187) -> idaqt, jshekxk\nnuzxo (83)\nitfnye (66)\nqcedbm (2484) -> bkipqaq, xmcqygt, fvtofr, zjksxbk\njutbah (55)\nscntyh (5)\nliukun (70) -> oftcgd, eiyxgk, sqbfin\nvqxwlkh (8119) -> kcotwhf, ksnnnc, shbrz, jtxdihn, yixpr\nywqtog (136) -> epelgzz, lpvwee\noftcgd (76)\nrdzvcb (184) -> clqwflm, dhamym, qkmkjm\ntqjyoj (94)\npprdw (42) -> tpbbd, mkxatmb\nbgmypwk (22)\nhznriv (96)\ntleviy (973) -> rtvpznv, gbpxwcx, kiphte\ncsuoxe (54)\npqqcnkr (39)\nhcqrrju (100) -> xfzxw, zwyhf\namccpoz (254) -> zsaen, jfkvg\nwbzmjq (89)\nxpkyf (70)\nhnofc (85)\ndsukkg (84)\nqfifp (6)\nqmncedz (25)\ndyrik (37)\niaiqz (445) -> sgjywom, alwbi\nxpjzc (86) -> qrhweil, vsgqkho\nagagr (81)\nfpkktd (25)\nmjmpkq (44) -> nbtsze, hwlgay\nkwhtsv (26)\nawljibm (5)\nhssykro (81)\nvyccl (80) -> aamghal, tkwmbxl\nnelgvnr (2052) -> jwidjq, mwussz, nkuwwiy, opghigg\nzbhioc (20)\nzqgeod (1323) -> sbnod, rtxzoap, zdkgm\nrgqjtw (243)\nvaxouij (343)\njsrpud (57)\nwetutqh (35)\nlsdkm (25)\nsdttg (27)\narlrk (40) -> xlsmzu, hoewyjx\nybkdekt (1234) -> vaxouij, fthgkl, kabjov\nsebno (279) -> qfifp, ghxvqb, qvqzuic, wfazzy\nkeidsd (73) -> hqqxg, ejmfnnu, prywl\nuevcnw (39)\nzvazn (75)\nxdjola (63)\nmiocbjk (75)\nghxvqb (6)\nywtywz (38)\nvtpoo (89) -> vskibye, nelgvnr, qcedbm, owfrl, vyfbsgv\njlfukd (57) -> tnxoqxw, vimazqc\nvkxyhk (41)\ndlxcy (203)\nkosbvn (19)\nwfazzy (6)\nuufonho (46)\nkdwmlx (357)\nlokmiua (2132) -> hdrab, eftrvo, hbnnhyi, avnxndg, tihzzf, nbvtfz, qniem\ndugvnav (46)\nxxardqs (216) -> llyhqfe, ojbyg\nwkble (74)\nlpvwee (67)\npkrxt (1524) -> drwpdaj, ojcinc, hqetmky\nzjksxbk (143)\niebsger (96)\nofwijoe (60)\nqyovvxb (41)\nigxdio (58)\nxkzrkzh (148) -> nafdo, tlkrx, gclbhxw\nruszodn (17)\ndnliq (17)\nqcccxc (114) -> ibiuha, byykf\nbscob (28)\nmivrqpc (86)\nyiehfd (35)\nhbnnhyi (1055) -> ptnjpp, hqcxvkr, aqlvute, yqsfolo\njpexkf (86)\nhagkc (89)\nhlscl (214) -> jblzpyq, jndnfa, twvfw, pazby\nirrca (56)\nsgjywom (12)\nepdzg (248)\nyixpr (1141) -> pjlhta, xksjes, icfxlu\nyjtsmy (85)\ninwmb (53046) -> ghaxmrh, vqxwlkh, nzeqmqi, lokmiua, znypga, vtpoo\netuteik (262)\nwbtqez (87)\nlmnews (26)\nzoovdc (75)\nsmkqg (44) -> vyzukfk, nfeok, apjsu, vbjlbhq, wjdkcjo, ztstgc, olvxzb\ntelnuq (18)\njdmrbxc (27)\nrrsxb (91)\ntetfdv (27)\ncpjkn (12)\ngveadp (429) -> zbhioc, psqgnhx\nzxvjkqv (94)\nmmvszx (12)\nxkfwmh (38)\nvyzukfk (255) -> efbrhl, tqdfypr\ngbpxwcx (77) -> azkpaf, axleb, ngwafk, sueftvh\nblcnplx (32)\ntrkvrk (9)\nnxttce (52)\nrzoojpm (234) -> kbguoiu, yvjjec\nidhjov (49) -> mcctaf, jpjehc\nctnucjw (105) -> ohmvcr, ntzuhe\ntdrdp (16)\nqkmkjm (17)\nbacazl (82) -> enuzo, hmlil\nlgjbhwy (23)\netotvx (27)\npfkbcg (228) -> xkvtxav, oibnbf\nfjlqp (30)\nnsbyncu (58)\nxnackkp (33)\nsxfxnp (16)\nhhawhzk (89) -> dserbhu, ckfagrp\ndsbxavd (43)\nmtbszl (12)\nbkipqaq (71) -> ctrdahm, sptjz, svhcnju\nsndkiv (73)\nidaqt (42)\nsxcfr (98) -> ungfmbw, ynjccf, bytizsx\ngtutcoq (154) -> zqmizps, vxdcv, nmshjlp\nefxxl (69)\nnpxeql (62)\nljelubc (437) -> gwxgtm, umfqiru\nhzbtbe (46)\nbjvncf (49)\nhwxxvlb (48) -> qddbmn, vomiow\nsfteyu (19)\nsbhfnav (255) -> jeafpic, ywecj, wnfcsap, cvgzkp\nbmaoav (93)\nfnuzrye (125) -> vlqcuq, jdvuj, mykvbt, fpuhllh\nvsgqkho (99)\nvkbgz (63)\nrcyjnsi (206) -> rihil, usfvqn\nhdqgdm (86)\nunaqbx (23)\numyrtu (33)\nsordz (47)\nbyykf (63)\nqggexrc (33)\nrovftl (24)\nqdnuduv (120) -> icoti, efxxl\nqogmb (81) -> rnyqcj, hcrzxz\ndfbabey (98)\nvdmkp (38)\nkacpu (90) -> hrbfs, vdmkp\njcegjy (92) -> xoaxcg, mecsrr\nxrtkqi (13)\ncosllh (38) -> hzfwp, gjbijgl\njfkvg (15)\nifwkgxo (1752) -> pbrcoyl, ryzfgj, luswq\ngrcsr (64)\ndzrflyr (62)\nhjtwqe (748) -> mkeen, zowbv, lphqgek, jcuhfsd, qymfgaf\nyjqgw (71)\nidiorl (24)\nusvzfi (81)\nacmrndk (13437) -> cdglv, gsgexgb, fmwid\nvijilqr (271)\ndxszgsr (34)\nehljn (88)\nyutfxcu (72) -> wobno, mwmfw\nngwafk (81)\neijlg (51) -> dzxjy, msigvaq\npkchh (24)\nizydgv (56) -> odoni, wnahs\nwobno (93)\nidfxtqr (96)\nhqetmky (127) -> gwplv, umyrtu, uqttm\nfvjrau (166) -> qsloy, niznnko\nehxjsgn (58)\nhqcxvkr (37) -> oeyrk, ipvrlll\nvaztjkc (75)\nynnfzdz (54)\nvrdrc (99)\nhdrtnjm (273) -> drffb, sviwi\nywecj (32)\niixjr (99) -> hlscl, xswwe, gtutcoq, qizkjh, nfccf, rvpbx, extmwcb\nfuvikt (35)\nkipiwwk (67)\nlakzkpk (84) -> rpmzw, lfapaod\nextmwcb (142) -> vkcim, ihramd, kwkdq, hjwjw\npmwosk (118) -> leefit, mdsywgy\nruuhrmf (98)\ntqdfypr (31)\nitdxbrj (366) -> fjebkm, mfacoz, unaqbx\nkfgmuj (54) -> ljelubc, jlewu, rhpxizt, pjujpa, ijuod, xauyij, bbrdet\njtxdihn (45) -> sofrg, vgdtk, sxcfr, rmivzpg, gdvcou\nyzulmo (33)\nuuamcdc (1954) -> qycoh, jhbov\nochjr (68) -> xhujxe, fonky, olyohzo\nnbvtfz (807) -> hwtztim, yerckb, nyszg, vijilqr\nimtvzmm (40)\ntshcqcu (33)\novsgve (83)\nueywo (59)\ngxmqlu (19)\ntahov (89)\nelukq (37)\nzadsb (87)\nbgeec (53) -> tftwygl, txcwm\nyjpzyzx (58)\nxlbjv (288) -> jxzyg, dyrik, cdanu\nzsaen (15)\nqywtwbt (124) -> esmltj, qsppfv\ndwbirs (5)\noonfc (16)\npyurvrc (49) -> xwidhe, xxvlxs\nzksnaz (75)\nxhujxe (47)\nwctphrv (19)\notadcxu (2028) -> bsdxw, beknji\nhzkvyoj (92)\nzeauj (15)\nzayxe (2822) -> ochjr, cnvghq, whuozum\naqlvute (27) -> absogx, jmmbca\nilexb (72)\nvrdtrmn (69)\ndfhtf (79)\nsbnod (153)\nlwyirb (77)\nhwlgay (80)\nsfnapsi (55)\ncflribm (84)\ncjgpfb (73)\nmenyi (185) -> lhpjahj, yzbmyaw\nubkmjag (78)\nfycnyn (313) -> lwuvg, irrca\nrzixiwv (10)\nqtvcuqk (85)\nalwbi (12)\nsqbfin (76)\nhcvuc (78) -> yzulmo, xnackkp, qggexrc, wjdhaf\nccmod (13) -> ovsgve, noejr, nuzxo\nrslnx (93)\nopndzmu (72)\nmxprsl (84) -> uivazm, ennkek, krkeek\nzowbv (28) -> sndkiv, gwcqtcr\npjujpa (433) -> rgyaijv, kwhtsv\nrnyqcj (78)\nzwxlf (69)\nccfiz (231) -> pwydnik, vkbgz\nzqyrggw (61) -> qqbgbeo, ubkmjag\npuzwwgx (96)\nxwidhe (37)\nasmikyo (24)\nhdrab (1083) -> umqlwls, tuldcdj, keidsd, wwggl\nximzx (146) -> ywqtog, bejkc, vonve, wmdgia, ggeae\nhzfwp (64)\nwmdgia (14) -> bhddwe, zrzgp, hmorsv, grcsr\npfpmube (73) -> wctphrv, kosbvn\neadjn (76)\ntxplq (24)\nqsppfv (21)\nqxoly (51)\nsardhwu (77) -> iemkgdl, byldgs\nvlqcuq (8)\neloku (39)\nypzxdhs (79)\nfsmzfjp (62)\nzqmizps (80)\nqqpnt (1108) -> hxjopp, gpucfv, vykav\naowuj (9)\nxlsmzu (47)\njokgw (33)\nepelgzz (67)\ncjctf (76)\nqgqrmeu (70)\neulcspz (52)\nsattu (54)\nvgdtk (101) -> ggffqux, jlinuge, hvinb\nbrjzpkm (15)\nyvlwtb (114) -> wbtqez, zadsb\nssysjwe (8)\nptnjpp (135) -> forycux, xggisxm\nadxplm (295) -> nfxyjl, lksgoz\nqvjiwvb (51)\nlleaucw (94)\nabsogx (91)\nzflsryn (239) -> fkprhv, blloue\ninoyp (38)\nluswq (102) -> yhlyk, mmvszx, euwfw, sbebrkf\nrncuf (24)\njdntuc (96)\ngremk (86) -> gqahoa, jsrpud\nmutyu (53)\nyhlyk (12)\newlsf (50)\nxixiloi (27)\nwoiwqf (5)\nfckcu (76)\nddxiiha (16) -> bpbwn, uuxhyt\nnmmrik (73) -> jutbah, sjwxyqb, mqayze\nssxpawm (15)\nrksykyt (77) -> ohbfa, lfmlqs\nzwyhf (67)\njhbov (66)\ntqddro (72)\naafpxpx (30)\nzsseyik (248) -> awljibm, woiwqf\nvxdcv (80)\novpyq (39)\nznypga (14031) -> emkyoy, uskdpcu, ccmfbok\ngwxgtm (24)\nztstgc (125) -> jqwbc, darmn\nusubx (100) -> mzpeoz, ealilsq\nklqvgm (56) -> zsgnve, pqqcnkr\nuuxhyt (97)\nyjxneui (76)\nawylric (393) -> wvvmksv, epnvhbn\nwtjoxu (34)\nztcqm (76)\nwjdhaf (33)\nhrase (25)\nllcpsj (178) -> mwssex, sfnapsi\nhrbfs (38)\nvomiow (72)\nuumrue (29)\nxxyjm (71)\nyrdbx (27)\ndserbhu (11)\ntrrkrqa (48) -> awytebt, ocrgjl, zayxe, pvctv, sdovaq, kfgmuj\nxoaxcg (81)\nsdxwhvp (192) -> agagr, hssykro, kbuslbp\nbeqez (142) -> mtbszl, dytsvc\nkihifp (117) -> tekug, lsxwznl, lwyirb, yfrewb\nfwlyuh (70) -> zbmsz, btldlkh\ncvgzkp (32)\nmigwxez (72) -> rzixiwv, bwekmvc\njqwbc (96)\nihramd (63)\nbwekmvc (10)\noeyrk (86)\nccfbpoc (12)\nbexrple (35)\nrtxzoap (153)\nbvwnlaw (88)\npbimnll (136) -> pkbitw, ytaus\nzciuy (63)\nzvtgd (7)\nuuftjqx (1414) -> guqul, jcegjy, fvjrau\nqymfgaf (66) -> gzatvf, sdttg, gosak, pcacjm\nesbnpk (43)\nekuibos (96)\nazyccec (67)\nvghvcv (39)\nicfxlu (31) -> asmikyo, gosjs, fafrerl\ncmdcov (39)\nrjnzfa (192) -> eidqfh, yqmbbyr\nqxirdyg (121) -> mwhopi, jyovf, nhtetdw, tmvjt\nwlrihpy (60)\nnyszg (95) -> bvwnlaw, vrpyfgm\nhiccoc (1118) -> osbsdhc, dlfay, fsomlm, cosllh\nixiqnn (138) -> vthnh, cycky\nuahdbi (313) -> bgmypwk, rzxyny\nahpitb (25) -> yyoptv, qihhif\nzrzgp (64)\nxxehapc (120) -> vrdtrmn, agobkww\nkwkdq (63)\nprhgge (49)\nornacig (27)\nwuttw (6)\nsjbalvv (186) -> uufonho, chhli\nxauyij (427) -> uumrue, gtiqar\nthahonu (208) -> eacnma, fpkktd\nvgwfukr (1921) -> hcqrrju, ckqwb, leqnli, xavfse\npshyy (97) -> qykdedu, zciuy, nvatz, xdjola\ntkwmbxl (79)\nphkcge (18)\nszrnpdw (27)\nfafrerl (24)\naryqw (118) -> ysabu, pkchh\ntwvfw (45)\nyopex (79)\nsptjz (24)\nmwmfw (93)\nsuftfkn (58)\nfjjuj (1782) -> fwlyuh, tocrk, eryxwj\njbztwms (111)\nollvgn (15) -> ermgcbt, kjikhxm\npcacjm (27)\nnldrlb (55)\nyyoptv (49)\nqfwtxzq (9)\nxavfse (42) -> hznriv, vkwcj\npbrcoyl (40) -> nldrlb, wnhseb\ndytsvc (12)\nwpafb (58)\naspplbw (4922) -> eaerpmi, hjtwqe, fikvmjg, kaugsh\nmpwnd (57)\nxmcqygt (65) -> uryery, tlkive\nwevkksz (49)\nikcjmxi (36)\nojcinc (106) -> fjlqp, owgbqb, aafpxpx, gkrtbv\njbtqs (86)\nlksgoz (52)\ntntqpl (202) -> jdryrup, esbnpk\nzpbbgqh (53) -> zpedug, hupmm, yjxneui, zldebh\nrgylin (9)\njdglmn (46)\npkbitw (47)\nrfxmk (20)\nmykvbt (8)\ntwvjddq (38)\nslmnzei (33)\nzpqpd (92)\nlvxnl (3990) -> qeoyu, uymhfo, suprw, ncxhv, drrbwlp, kzwamsk\nfikvmjg (70) -> arrok, thahonu, pfkbcg, yutfxcu, shkfwm, clsve\nekvkidl (66)\niwxgwc (41)\ncbwsr (55)\nkqltwau (53)\njlewu (320) -> zphlpeu, kcxfwz, cbwsr\nbnryi (37)\ndletgs (77)\njlinuge (60)\nennkek (52)\nrzxyny (22)\nuivazm (52)\nhgoesez (214) -> umsilqj, blcnplx\nxkvtxav (15)\nclsve (138) -> ofwijoe, zstbuv\nleefit (70)\nymwqj (301)\nklnemf (76) -> xipivez, tshcqcu, jaathmh, vpzylgj\nqdpnoic (51)\nfsuglk (58)\ndvasofv (44)\ncjagg (17)\nkcxfwz (55)\nkjikhxm (78)\nnulxd (20)\nzgyryw (60)\nnktkgz (29)\npprspr (79)\nwzvjkiu (2006) -> yjtsmy, gjpjta\nusfvqn (12)\nutoogeb (183) -> idiorl, txplq\ngclbhxw (23)\nfsomlm (74) -> hzbtbe, mkxsdn\npxjgtg (219) -> uevcnw, airqzst\nnfxyjl (52)\nhtaxf (96)\nouxsgm (241) -> ynnfzdz, jjbmtij\ncdanu (37)\nzpohg (230) -> qewiy, iwlxpz\nnmshjlp (80)\nuxxyr (26) -> oomve, xzsfek\nwcblyq (171)\nqqbgbeo (78)\nibiuha (63)\nippnuw (342)\njusoe (27)\neftrvo (919) -> rgqjtw, fuehgn, eijlg, jlfukd\nrgyaijv (26)\nfezoee (41)\nzmfhyr (47)\nmxltn (14)\nrfkvap (655) -> zxmsme, nbybi, xaaqdv\numfqiru (24)\nsyeyppr (20)\ntuldcdj (152) -> ekhsrgq, hrase\nskbxo (92)\nlwuvg (56)\nhzvctd (256) -> dwbirs, scntyh\ncteuws (91)\ngjpjta (85)\nijzgy (43)\nrddeecm (46)\nhvinb (60)\ngsrui (49)\nvxtwg (25)\nvthnh (75)\nolyohzo (47)\nbtldlkh (35)\nlbmvl (27)\ngjvcdp (23) -> azyccec, dqfti\nspnzn (70) -> ixiqnn, llcpsj, ufhjnc, fzkqz, mqgmc, tntqpl, yvlwtb\nfjebkm (23)\nkupmpp (41) -> qmlguo, dqaov, ozwdh, idfxtqr\nawytebt (2553) -> oyypq, pprdw, fvojv, yelgho\nrycpngd (54)\nvpzylgj (33)\nosbsdhc (166)\nbdplsy (20)\nwnhseb (55)\nemxviup (36)\nazqje (72) -> holcy, fwbang, inwmb\nblloue (31)\ngccvp (74)\nsfnsx (83) -> prhgge, bjvncf, wevkksz\nnylej (42)\nzkphtd (25)\ndrwpdaj (58) -> nylej, fkpjukc, niopwq, kfgyus\nolvxzb (89) -> tlnuq, zsucroj, dnyaj\npjlhta (63) -> zupsoqc, dvkbqm\nxafip (176) -> rgocso, vkxyhk\nqihhif (49)\nggffqux (60)\nbbrdet (445) -> bdplsy, syeyppr\nvbjlbhq (219) -> gsrui, fdorzyx\nmwhopi (29)\neacnma (25)\ndrrbwlp (59) -> ljwcd, voiqnou, rdzvcb, sardhwu, rksykyt\ndapey (26)\nrmivzpg (227) -> szrnpdw, jusoe\nckfagrp (11)\nnkuwwiy (79) -> jpexkf, tismupk\njejwwxj (50)\ncukbzsw (441) -> mxltn, zwzgp\neobbt (229) -> rxeqfsj, rqbgxlt, ssnoqt\nggeae (270)\nxdfnmvr (147) -> vaztjkc, zoovdc\nfmcwdv (85)\nyvjjec (7)\nkzwamsk (325) -> sebno, haeyms, hdrtnjm\nhvdwvo (69)\nbmtjkw (25)\nrwxfhk (353) -> gmsmnlz, kcbag\nynjccf (61)\nzxozp (42) -> hnofc, fmcwdv, qtvcuqk\nxcuud (29)\nxwyggz (76)\nglbaxl (120) -> imtvzmm, tszune\nunlwjj (43)\nhjwjw (63)\njugycbw (23)\ncyxtnfe (13)\nphrkfo (81)\nmmutg (1040) -> yyhkwha, xwyyfr, xpjzc, amccpoz\nvntjo (81)\ntlkive (39)\nkbguoiu (7)\nnsqaxp (575) -> kacpu, gxmyk, aryqw, qywtwbt, beqez\ntmvjt (29)\nvskibye (1388) -> sjbalvv, hgoesez, lfzvi, lakzkpk, smunvi, cnlny\nsgfbfq (95) -> eobbt, ymwqj, sjzapjt, dldcoc, dexwo, ctnucjw, zflsryn\naseilg (47)\nhbzxaji (6140) -> otadcxu, dvpmg, qqpnt, mnkamc, spnzn, uuamcdc, rdjfp\nxlavrvm (27)\nwevhizp (26)\nyrmfcs (9)\nnsmlghl (99)\nsdovaq (2558) -> zxozp, pxjgtg, xdfnmvr\nirpjsbf (16)\nevbilqr (200)\navnxndg (865) -> ippnuw, ensyb, dosteiu\nutqxez (99)\nleyohju (28)\nnzyls (26)\nlsxwznl (77)\nzphlpeu (55)\nckqwb (234)\nkligtj (80)\"\"\"\n\nlet test = \"\"\"\npbga (66)\nxhth (57)\nebii (61)\nhavc (66)\nktlj (57)\nfwft (72) -> ktlj, cntj, xhth\nqoyq (66)\npadx (45) -> pbga, havc, qoyq\ntknk (41) -> ugml, padx, fwft\njptl (61)\nugml (68) -> gyxo, ebii, jptl\ngyxo (61)\ncntj (57) \"\"\"\n\nlet parseInput (input:string) =\n    input.Split '\\n'\n    |> Array.map (fun s -> s.Trim())\n    |> Array.filter ((<>) \"\")\n    |> Array.choose (fun s  -> \n        let ss = s.Split([| \"->\" |], System.StringSplitOptions.RemoveEmptyEntries)\n        let children = if ss.Length = 1 then [||] else ss.[1].Split(',') |> Array.map (fun s -> s.Trim())\n        match ss.[0].Trim().Split ' '  with\n        | [| nm; wg |] -> Some (nm, (wg.[1..wg.Length-2] |> System.Int32.Parse, children))\n        | _ -> None\n     )\n    \nlet findRoots (nodes:(string * (int * string [])) []) =\n    nodes\n    |> Seq.filter (fun (nm, _) -> Seq.exists (fun (_,(_, ch)) -> Seq.contains nm ch) nodes |> not)\n\nlet nodes = parseInput input\nlet root  = findRoots nodes |> Seq.head\n\nroot\n|> fst\n|> printfn \"Puzzle 7.1 = %A\"\n\nlet getNodeData =\n    let nodesM =\n        nodes\n        |> Map.ofSeq\n    fun nm -> Map.find nm nodesM\n\nlet rec getWeight nm =\n    let wg, ch = getNodeData nm\n    nm\n   ,wg + if ch.Length = 0 \n         then 0 \n         else ch\n              |> Array.map (getWeight >> snd)\n              |> Array.reduce (+)\n\nlet rec findOutBalance nm =\n    let ch     = getNodeData nm |> snd\n    let chws   = ch   |> Array.map     getWeight\n    let ws     = chws |> Array.countBy snd\n    let oddws  = ws   |> Array.filter (snd >> ((=) 1) ) \n    if  ws.Length    < 2 then None else\n    if  ws.Length    > 2 then failwith \"Oops more than 2 different weights\"\n    if  oddws.Length > 1 then failwith \"Oops more than 1 odd out\"\n    oddws\n    |> Seq.tryHead\n    |> Option.map (fun (v, _) -> \n        let oddnm, totw = Array.find (snd >> ((=) v)) chws\n        findOutBalance oddnm\n        |> Option.defaultWith (fun () ->\n            let normalw = ws |> Array.filter (snd >> ((<>) 1) ) |> Array.head |> fst\n            let weight  = getNodeData oddnm |> fst\n            oddnm, weight + normalw - totw\n        )\n    )\n\nnodes\nroot \n|> fst\n|> findOutBalance\n|> printfn \"Puzzle 7.2 = %A\"\n\n#define WEBSHARPER\n","parent":{"$":0,"Item":"ebc10936-8796-43e0-b809-8f6b539b31a2"},"predecessors":[],"id":{"$":0,"Item":"9ab13c25-ea79-454d-83e3-2287448e8e8b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Day 8","content":"let input = \"\nutc dec -736 if p > -7\ntn inc -876 if qlm == 4\nuz dec 294 if l < 10\na inc -904 if me >= -7\ntn inc 622 if ppl <= 6\nfr dec 17 if ufk > -10\nhkt inc -511 if mdk == 0\nt inc -290 if xxh <= -1\nl dec 727 if ufk < 7\ntn inc -576 if l == -727\nz inc 464 if dea >= -2\nufk inc 755 if utc >= 735\nutc dec -720 if qlm <= 5\na dec -277 if ufk <= 755\nxxh dec -640 if u == 0\nhkt inc 875 if m != -6\nny inc -351 if p >= -4\nl inc 674 if dea > -7\nufk dec -826 if p == 0\nmdk inc 377 if utc == 1456\nppl dec 793 if q <= 4\nz dec 114 if mdk > 368\nny dec -412 if ny >= -353\nutc dec 176 if a != -620\nutc dec -610 if p <= 1\nl inc -541 if xxh <= 635\nl inc 102 if ny < 66\nqlm dec 700 if l >= 43\ndea dec -202 if tn <= 38\na inc 785 if a <= -629\nny inc 414 if fr <= -21\nl inc 250 if hw <= -10\nl inc -516 if l > 41\nutc dec 358 if mdk > 373\np dec -38 if z == 350\nuz dec -71 if a == -627\nt inc -713 if fr > -13\nl inc 242 if tn <= 53\ndea dec 600 if hw <= 8\nhw dec -92 if fr != -19\nhkt dec 67 if l <= -232\nqlm dec 523 if hw == 92\nutc dec -608 if q != -8\nm dec 314 if me < 9\nxxh inc -937 if xxh >= 638\nqlm dec 494 if m <= -313\nfr dec -590 if m <= -306\nutc inc -539 if tn == 46\nhkt dec 831 if p >= 43\ndea inc 510 if a > -627\np inc 319 if m > -305\nm inc 736 if xxh >= -302\nppl inc -712 if mdk == 377\nny inc 21 if p <= 41\nhw inc -569 if hw != 92\nppl inc 150 if dea < -595\nxxh dec -953 if z != 356\nppl inc 578 if qlm <= -1714\nuz dec -733 if p >= 35\nxxh inc 100 if xxh >= 660\nhw dec -491 if ppl < -767\nt dec -64 if z < 347\nme dec 802 if dea > -601\nhkt inc 431 if hkt > 359\nutc inc -600 if q != 0\nu inc -223 if tn < 48\ntn inc 443 if uz <= 513\nl inc -349 if ny == 82\nutc inc -499 if xxh <= 661\na inc 600 if hw >= 578\nz dec -636 if utc > 1099\ntn inc 75 if z == 986\nhkt dec 364 if mdk < 377\nufk inc 249 if fr == 573\nl inc -429 if uz > 507\nhw dec -621 if ppl == -778\nl inc -620 if z != 980\nl inc 319 if tn == 564\nq dec -478 if ny <= 82\nutc dec -169 if uz < 519\nfr inc 124 if dea >= -607\nm dec -674 if p != 28\nm dec 744 if p != 44\nl dec -620 if hw <= 582\nutc dec -950 if p >= 37\nuz dec -122 if xxh < 660\nl inc -563 if z < 996\nhkt inc -514 if m <= 361\nl dec 525 if mdk == 377\nxxh inc -666 if u != -228\na inc 934 if a <= -23\na inc 817 if xxh >= -11\nme inc 450 if tn < 563\nhw inc 475 if xxh < -1\nfr dec 493 if xxh < -8\nuz inc -985 if qlm > -1724\nppl inc 856 if qlm >= -1720\nhw inc -368 if me > -804\nny dec -219 if p != 38\nu inc 1000 if ny > 79\nq dec 551 if hkt == 281\nuz dec 317 if dea >= -600\nuz inc -916 if qlm <= -1726\nhkt dec 915 if mdk != 380\nmdk inc 484 if l == -2392\nxxh inc 326 if dea > -607\nu dec -803 if me > -811\nq dec 689 if tn != 565\nhw dec 908 if p == 38\nz inc -173 if ppl > 72\nz dec 371 if tn < 565\np inc 185 if u > 1571\na inc 490 if mdk != 864\ntn dec -27 if u == 1580\nqlm inc 77 if m > 345\np dec 364 if ufk <= 1836\ndea dec 308 if me == -802\na inc -345 if hw == -218\nny inc 603 if p <= -138\nfr inc -4 if utc > 2217\nme inc 118 if hkt <= -626\nhw inc -590 if z < 443\nme dec 279 if q <= -756\nme inc -50 if dea == -908\nppl inc 708 if u <= 1586\nt inc -429 if mdk >= 854\nm dec -372 if uz > -676\nfr dec -840 if ppl == 787\nqlm dec -442 if tn != 584\nu dec 227 if l == -2402\nm inc 279 if z <= 446\nxxh inc -951 if t > -421\nt dec 530 if xxh != 317\nfr inc -621 if mdk <= 869\na dec 480 if fr < 424\nq inc 988 if l == -2384\nu inc 313 if q < -757\nhw dec 237 if hkt == -634\nmdk dec 945 if t > -969\nme inc 631 if ny >= 679\nny dec -740 if uz == -670\nt inc -310 if utc > 2213\np dec -453 if utc >= 2218\nmdk inc -266 if hw == -1045\na inc -887 if qlm == -1198\nppl dec 521 if t >= -1270\ndea dec -685 if xxh != 310\nl inc -472 if m < 1013\nufk inc -920 if l <= -2860\nu dec -503 if me <= -373\nufk inc 547 if m > 998\nl inc -287 if p <= 309\nqlm dec -173 if q <= -755\nu dec -928 if z > 437\nhw inc 43 if hkt < -626\nutc inc -694 if me == -382\nfr dec -938 if tn > 584\nq inc 9 if mdk == -350\ndea inc 119 if m < 1012\nny dec 210 if ufk <= 1465\nxxh inc 352 if q > -758\ndea inc 483 if hkt >= -639\ntn inc -652 if t >= -1266\nufk inc 674 if ny >= 1207\nppl dec 311 if z >= 442\nqlm inc 655 if m < 1005\nz dec 580 if uz < -661\nutc inc -977 if ppl <= -36\nxxh inc -25 if l == -2864\nme dec 252 if uz > -674\nmdk dec -98 if z <= -129\np inc -276 if utc < 541\nhw dec 796 if xxh <= 649\nq inc -726 if z != -137\nfr dec 433 if ufk <= 2140\nhw inc -701 if z < -131\nhw dec 587 if mdk <= -244\nny dec -734 if mdk <= -249\nqlm dec -311 if utc != 546\nufk dec -405 if q > -1481\np dec 97 if t != -1275\nt dec 597 if qlm >= -49\nufk dec 389 if uz < -660\nl inc 765 if a < 504\nfr dec -948 if tn >= 586\nqlm dec 79 if m > 997\nny inc 764 if p < 225\na dec 419 if m != 1003\nq dec -860 if q != -1475\nfr inc 426 if hw > -3080\nufk inc 0 if ppl != -36\nutc inc 939 if p >= 206\nm inc 830 if xxh < 650\nm inc -511 if hw > -3091\nu inc -720 if qlm > -134\ndea inc -147 if a <= 503\nu inc -322 if tn != 591\nny dec 900 if ny != 2713\nny inc -737 if me == -634\nfr inc -494 if l != -2097\nmdk inc -363 if ny != 1976\nl inc 991 if hkt > -636\nl dec 179 if dea != 232\nq dec -264 if ny != 1977\nl dec -976 if uz > -667\ntn inc 791 if hkt > -637\nppl dec 225 if utc < 1495\nuz dec -527 if m > 1317\na inc -644 if me < -624\nuz inc 160 if q >= -361\nu inc 577 if xxh > 650\nq inc 124 if xxh < 653\nl inc 268 if dea > 222\nhw inc 795 if uz < 10\nuz dec 934 if uz < 26\ntn inc 966 if ufk == 2150\nme dec -71 if p <= 222\nme inc 186 if ppl > -270\nm dec -377 if xxh <= 649\nny dec 275 if mdk > -248\nqlm dec -574 if fr != 1371\nutc dec 78 if xxh > 638\nl inc 494 if u > 3315\ntn dec -595 if qlm > 435\ntn dec 113 if a <= -140\nfr inc -610 if ufk < 2148\nuz inc -791 if u != 3334\nuz inc 356 if t < -1276\nl dec -463 if utc < 1414\ntn inc -266 if a < -137\np inc 747 if utc >= 1402\nz inc -671 if hkt == -634\ntn inc -441 if u != 3324\nfr inc 172 if hkt > -638\ntn dec -558 if qlm < 439\na dec -234 if tn <= 2155\nt inc -325 if l >= 126\nt dec -685 if l > 110\nufk inc -912 if z < -805\nufk dec 0 if fr < 941\nfr dec 276 if a == -142\nxxh inc -972 if p < 967\nufk inc 188 if mdk >= -245\nme inc -255 if t > -583\nqlm inc 451 if uz > -1710\nfr inc -921 if z >= -814\nq inc 272 if uz < -1705\nu dec 216 if p <= 956\na inc 30 if z > -812\ntn dec -202 if dea == 232\nm inc 792 if ny != 1976\nuz dec -867 if z == -809\nppl inc -765 if qlm != 894\nhkt inc 301 if xxh < -322\np dec -839 if dea == 232\nutc dec -920 if m > 1694\na inc -206 if mdk == -252\nny dec -545 if ppl <= -1029\nme dec -860 if q >= 39\nufk inc 644 if tn <= 2359\nhw dec 959 if t == -584\nqlm dec 667 if xxh != -321\nufk inc 598 if a > -323\nppl dec -514 if hw <= -4039\nuz dec 708 if p == 1801\nhw inc -902 if hkt != -333\nqlm dec 249 if tn != 2366\nmdk inc -570 if z > -812\nfr inc -47 if tn > 2350\nme inc -62 if hw != -4037\nqlm dec 796 if dea > 239\nq dec -201 if ppl == -521\nz inc 265 if ufk != 2481\nhw dec 597 if q >= 239\nny dec 417 if uz > -1540\nhkt dec -866 if m <= 1704\nm inc 103 if m == 1699\nufk inc -733 if qlm <= -28\nmdk dec -416 if z > -546\nufk dec 477 if z < -543\nl dec 224 if m < 1799\nq inc 646 if u < 3327\nhkt dec -501 if qlm != -29\nppl inc 321 if p > 1797\na dec 678 if ufk == 1268\nu inc -878 if fr > -302\nt dec 523 if uz != -1552\nmdk dec -490 if fr != -304\np dec -603 if ufk >= 1264\ntn inc -234 if qlm > -33\nmdk dec -51 if q <= 881\na inc 672 if me < 244\nz dec 473 if m != 1797\nmdk dec -727 if utc == 2331\nppl inc -59 if me == 235\na dec -937 if uz <= -1547\nuz dec -352 if m >= 1798\nfr inc 693 if utc < 2333\nt inc 493 if hkt != 526\nhw inc 86 if hkt >= 533\nt dec 49 if ny != 2512\nutc inc 273 if me != 235\nxxh inc -871 if dea == 232\nz dec -707 if dea != 234\nmdk dec 362 if ny > 2528\ntn inc -825 if t <= -658\nuz dec 655 if xxh < -1195\ndea dec 231 if me < 242\nmdk dec -260 if xxh != -1200\nppl dec -842 if mdk != 321\nl inc -957 if qlm == -23\nm dec 393 if ny > 2515\nufk inc -648 if me < 243\ndea inc -251 if fr < 399\na inc 772 if mdk < 323\nhkt inc 997 if fr > 383\nl dec 13 if dea == -240\nhkt dec -935 if tn >= 1291\nuz dec 992 if u < 3324\nhw dec -970 if t <= -655\nm inc 132 if mdk == 321\nhw inc 908 if hkt > 2464\nme inc -975 if l != 119\nny dec -76 if dea >= -251\nppl dec -844 if u >= 3322\nqlm dec 286 if ny >= 2597\nxxh dec 903 if uz != -1843\nu dec 992 if hkt <= 2471\ntn dec -663 if me > -735\nny dec -598 if ppl >= 583\nm inc 84 if mdk != 318\nufk inc -260 if t <= -668\nu dec -443 if fr >= 388\nl dec -116 if hw <= -2670\nm inc 816 if dea < -240\nt inc 319 if mdk != 317\nme inc -681 if z < -301\nm inc 451 if uz != -1845\nt inc 472 if mdk <= 330\nqlm inc -125 if z == -310\nufk inc -419 if p > 2401\nl dec -7 if xxh <= -2096\nm dec 325 if fr < 380\nmdk inc -391 if hkt <= 2465\nxxh inc 491 if z != -315\np inc -832 if utc > 2324\nt dec 304 if a > 2056\nxxh dec 107 if dea < -243\nl inc 220 if hw < -2681\np dec -316 if p > 1565\nmdk inc 333 if utc == 2332\nppl dec 961 if a >= 2055\nfr inc 230 if z <= -310\nhkt dec -715 if fr >= 615\nl inc -466 if p <= 1888\nqlm inc 185 if xxh >= -1725\nu inc -710 if t == -168\nz inc 15 if ppl < -371\nutc inc 422 if hw < -2683\nfr dec 688 if t > -181\nmdk dec 606 if a < 2064\nme dec 323 if z <= -289\nppl dec 150 if uz > -1844\nt inc 617 if q > 879\nhw inc -212 if qlm != -255\na inc 338 if m <= 2901\nutc dec 545 if l < -228\ntn dec 407 if z > -303\nmdk dec 784 if ppl >= -378\nq inc -352 if z == -295\nuz inc -644 if ppl <= -372\nfr dec 209 if dea < -242\ntn dec -605 if p >= 1879\nhkt dec 77 if mdk != -1470\nhw dec -280 if hw < -2676\nufk dec 375 if qlm >= -248\np inc -958 if xxh <= -1710\na inc 653 if z != -295\nutc inc 493 if qlm == -255\nxxh dec -649 if q > 530\nz inc -993 if me != -1749\nt inc 119 if mdk <= -1451\nufk dec 883 if utc <= 2825\nm inc -545 if qlm == -255\ntn inc 626 if dea != -253\ntn dec -111 if p > 923\ntn inc -719 if u <= 2780\nu inc 976 if u != 2767\nz inc -495 if ppl != -368\nz dec 481 if dea != -246\nppl dec 539 if ppl >= -381\nuz dec 213 if uz >= -2504\na inc -9 if tn < 1509\nny dec 719 if u < 3757\nuz inc 718 if hkt <= 3103\nny dec 378 if u >= 3748\nme dec 163 if xxh >= -1076\nt dec -569 if hkt > 3105\nfr inc -280 if a <= 2407\nl dec -908 if q != 527\na inc -13 if me < -1912\ndea dec 584 if mdk <= -1464\nhw inc -988 if l >= 692\ntn dec 847 if mdk < -1451\nhw inc 568 if utc > 2822\nt dec 133 if tn < 659\nz inc 271 if q <= 539\nmdk inc -33 if q <= 545\nl inc 185 if dea >= -259\nxxh inc 36 if xxh != -1064\na dec 70 if xxh >= -1042\nz inc 956 if p > 931\nutc inc -778 if dea != -244\ndea inc -868 if z > -1985\nt dec -872 if u >= 3750\nppl dec 420 if u < 3747\ndea inc 372 if xxh >= -1043\nhkt dec 32 if u != 3759\nt inc 23 if uz == -1985\nny dec 106 if ufk == -683\ndea dec -794 if t == 1441\nhkt dec -233 if t < 1435\nq dec -186 if ufk == -683\nu dec 328 if a >= 2331\nxxh inc -179 if z <= -1991\nutc inc -614 if qlm > -254\nfr dec 136 if m != 2349\nuz inc -942 if uz >= -2000\nme inc 391 if m >= 2340\nl dec -448 if utc > 2054\nme dec -64 if fr > -696\nutc dec -621 if qlm > -256\nz dec -622 if dea == 132\na dec -228 if ny == 1992\nqlm inc 957 if a <= 2563\nt dec 178 if hkt == 3304\nme dec -583 if uz >= -2940\nxxh dec 22 if ny >= 1988\nufk dec 294 if fr <= -690\nl dec 666 if a != 2559\ntn dec 135 if qlm >= 704\nhkt inc 524 if q == 722\nuz inc 448 if dea > 118\nq inc 299 if hkt >= 3832\nu dec 502 if p <= 931\nqlm dec -530 if l > 863\nm dec -677 if m > 2344\nuz inc -254 if qlm < 1236\np inc 164 if tn != 663\nny inc -208 if me >= -874\nhw inc 688 if ny >= 1775\nq dec -90 if ny < 1787\nqlm inc 602 if l <= 874\nxxh inc 442 if uz == -2739\nmdk inc 235 if xxh == -793\na dec -225 if u > 2911\nm dec -706 if hkt <= 3831\na dec 229 if ufk <= -977\nppl dec 256 if xxh == -788\nt inc 1000 if p < 1087\nhw inc -970 if a <= 2564\nhw dec 398 if ny >= 1779\nppl inc 984 if ufk != -968\nutc inc -979 if ufk != -967\nhw dec -383 if utc > 1678\np dec 283 if xxh == -793\nhw inc -434 if ny <= 1786\nu dec -226 if l == 868\nl dec 943 if tn > 675\nxxh inc -64 if p >= 807\nppl inc 577 if fr == -694\ndea inc 629 if ppl > 636\nu dec 113 if ufk != -984\na inc 482 if dea < 760\ndea dec -232 if xxh == -857\nny inc -952 if ufk < -967\nhkt inc 159 if p < 811\nz inc 530 if mdk == -1258\nm dec -745 if dea <= 988\nm inc -554 if mdk >= -1258\nfr inc -798 if xxh >= -864\nq dec -139 if utc > 1690\nm dec 962 if p < 808\na inc -409 if u <= 2809\nu dec -30 if ppl > 643\nuz dec 502 if u < 2834\nl dec -653 if qlm == 1834\nqlm inc 732 if me <= -869\ntn dec 200 if fr >= -1495\nny inc -26 if a <= 2632\nhkt inc -601 if ppl < 656\nt inc -277 if l <= 1521\na inc -86 if xxh < -847\nhkt dec -42 if qlm >= 2566\ndea dec 218 if p >= 807\nufk dec 870 if q > 815\nz inc 141 if z == -1463\nl dec 873 if mdk > -1263\nu dec 897 if ppl <= 653\ndea inc -239 if p < 809\nxxh inc 525 if uz >= -2746\ndea inc 827 if mdk > -1266\ndea dec -988 if ppl != 636\nny dec 330 if m < 3923\nq inc -413 if hw > -2554\nhw inc 983 if mdk < -1250\nmdk dec 932 if hw >= -1573\nfr inc -984 if u >= 1934\nxxh dec -344 if qlm > 2566\np dec 189 if tn != 464\nhw inc -986 if ny < 473\nm dec 233 if z > -1323\nmdk inc -803 if a >= 2542\nu dec -858 if dea > 2570\nme dec 215 if dea >= 2590\nq inc 945 if dea >= 2589\nz inc 55 if ny >= 471\nxxh dec -63 if a <= 2544\nfr dec -864 if ufk != -969\nme dec -330 if me <= -861\nufk inc -96 if dea <= 2586\nfr inc 348 if uz >= -2739\nqlm inc -249 if q <= 805\nqlm dec -752 if uz < -2736\nhkt dec -389 if q < 818\ndea inc -169 if ppl == 646\nxxh inc -689 if z <= -1268\ntn inc 911 if m <= 3697\nppl inc -390 if a != 2551\na inc 87 if ufk != -1074\nz inc 413 if ppl == 262\np inc 476 if mdk < -2052\np dec -570 if z != -1257\nuz inc 266 if hkt <= 3654\nppl inc -29 if ny <= 474\nny inc -154 if ppl <= 264\nufk inc -614 if uz < -2741\ndea dec -627 if xxh == -269\nme inc 553 if p < 1670\nq inc -413 if a > 2636\nq dec 754 if utc == 1688\np dec 857 if m == 3688\ndea dec 883 if ufk >= -1074\nuz inc -485 if l == 647\ndea dec -979 if me <= 15\nhkt dec 738 if l > 642\nxxh inc 298 if tn < 1372\nuz dec 235 if l != 651\nm dec -170 if tn > 1379\nhkt inc 902 if a > 2619\nhkt inc 354 if hw < -1573\nqlm dec 512 if uz != -3462\nu inc -676 if t != 984\na inc 635 if z == -1267\nppl inc -756 if q <= 60\nt inc 662 if mdk == -2061\nqlm dec -900 if p > 807\nz dec 877 if hkt == 4176\na dec -841 if uz > -3466\ndea inc 141 if u != 2115\nq inc 917 if dea != 3270\nppl inc -582 if tn >= 1375\ndea dec -309 if xxh < -271\nutc inc -353 if hw <= -1578\nmdk dec 643 if q != 979\nhw inc -595 if fr != -1254\nxxh inc 736 if ny != 325\nhkt inc -692 if z == -2144\np dec 500 if hw < -2170\nuz dec -168 if ppl >= -1083\nu dec 419 if hw > -2181\nfr inc -653 if u != 1704\nm inc -677 if qlm < 3716\nqlm dec -341 if u >= 1704\nme dec -926 if utc >= 1329\nqlm dec -462 if hw != -2174\nfr dec 604 if hw != -2173\np dec -826 if uz >= -3291\nhkt inc -855 if ny <= 315\nutc dec -647 if dea > 3269\nxxh inc 483 if z < -2143\nl dec 93 if utc >= 1979\ndea inc -680 if fr != -1264\nme inc -293 if ufk != -1063\nuz dec 279 if t == 1636\nxxh inc -145 if u <= 1705\nq inc 269 if a > 4097\nufk dec 734 if l >= 552\nz dec -270 if utc > 1977\ntn inc -154 if t <= 1645\nmdk inc 455 if uz < -3283\ndea inc 350 if utc < 1992\nhw dec -300 if ppl <= -1085\nufk inc 337 if u >= 1699\nppl inc -634 if l != 558\nt dec -583 if xxh == 805\nt dec 384 if dea >= 3620\np dec -873 if m == 3011\nufk inc -710 if uz < -3287\nhw inc -808 if hkt <= 3490\nhw dec -464 if u > 1702\nm dec -102 if mdk > -2256\nfr dec 579 if t > 1829\ndea dec -839 if qlm < 4519\nufk dec -741 if l <= 545\nme inc -520 if z <= -1865\nmdk dec 824 if hkt < 3493\nqlm inc -703 if q <= 1243\nt dec 284 if qlm < 4517\nfr dec -527 if ufk == -2183\nme dec -995 if xxh == 805\nutc inc 498 if hw < -2525\nhw dec -350 if ufk <= -2174\ndea inc 143 if mdk == -3073\nutc dec 812 if l < 552\nufk dec 679 if hkt <= 3490\na inc -464 if ny < 317\nufk inc 116 if hkt > 3483\nhw inc 77 if mdk < -3063\nhkt dec 851 if ny < 329\nuz dec -37 if uz != -3287\nhkt dec 45 if xxh == 805\nuz dec -682 if fr <= -1850\ndea inc 695 if hkt > 2582\np dec 857 if hkt <= 2592\nfr inc 114 if dea < 5309\nq dec -714 if p < 1158\nutc dec 896 if ufk != -2752\nuz dec -937 if ufk < -2741\np inc -807 if tn <= 1232\nufk inc 788 if fr >= -1730\nufk dec 519 if l > 558\nufk dec 142 if tn < 1227\nppl dec -561 if ufk > -2103\ndea dec 463 if fr >= -1728\nm inc 139 if tn != 1218\nfr dec -606 if q >= 1951\nqlm inc 934 if fr >= -1122\na dec -910 if xxh < 815\nhw dec -564 if a <= 5015\nu dec -648 if hw > -1532\nhkt dec 601 if hkt <= 2588\nq dec -480 if hkt < 1997\nuz dec 596 if hkt >= 1983\np dec -971 if u > 2347\nz dec 790 if m == 3252\nfr inc 281 if hw <= -1517\nuz dec 636 if hw == -1516\nl dec -582 if ny > 315\nny inc 202 if dea < 5306\nmdk inc -251 if ppl > -1147\nme dec 826 if p == 1317\nqlm dec -11 if p == 1317\nz inc -166 if a >= 5011\nny inc 455 if l >= 1127\nutc dec -156 if qlm < 4525\nq dec -147 if l <= 1129\nufk inc 36 if ny < 978\nppl dec -871 if uz < -2907\nfr inc 776 if t >= 1548\nqlm inc -510 if u != 2352\nz inc 373 if dea >= 5294\nuz dec -975 if fr <= -59\nfr dec -670 if z < -2459\nutc dec 322 if q != 2428\nl dec 3 if ppl != -282\nuz dec 728 if ny > 971\nny dec -396 if p > 1308\na inc -502 if mdk <= -3067\nny dec -492 if uz <= -2666\nppl inc -720 if t >= 1554\nuz inc -323 if hw != -1533\nppl inc 805 if m >= 3252\np inc 310 if qlm != 4520\nm dec 743 if dea >= 5299\nppl inc 847 if t <= 1546\np dec 89 if u != 2352\na inc 472 if z < -2455\nme dec 301 if utc > 914\nppl inc 740 if q < 2434\nufk inc -633 if l > 1138\nppl inc -51 if hw > -1529\nu dec -714 if fr >= -56\nz dec 510 if me >= 0\nl inc 664 if mdk != -3073\nqlm dec -742 if l < 1142\nny dec -473 if tn == 1225\nfr inc -805 if ufk > -2093\nxxh dec -151 if fr > -74\nhw inc -734 if hw <= -1528\np dec 976 if uz >= -2990\nmdk inc 523 if m == 2509\nu dec -176 if utc < 923\nme inc 766 if hkt != 1987\nppl dec -392 if mdk != -2557\nl inc -756 if u > 2527\nfr inc -990 if xxh > 955\nl inc 901 if ufk > -2100\nxxh dec -856 if ppl >= 137\nhkt dec -989 if t == 1561\np dec 846 if p > 339\nhkt inc -429 if dea != 5302\nu dec 534 if hw <= -1517\nuz dec 178 if xxh > 1803\nz dec 655 if m <= 2516\nxxh inc -340 if ny < 2334\nu inc -545 if dea != 5295\np inc -996 if uz > -3172\ndea dec -140 if hkt != 1984\nq inc -764 if a <= 4985\nz inc 263 if uz == -3167\nl dec -929 if a <= 4985\np inc -214 if uz >= -3170\nuz inc 393 if hw >= -1533\ntn inc -624 if me == -5\nme inc -474 if ufk != -2106\nppl dec 475 if l <= 2214\nqlm inc 417 if u != 1449\np inc -490 if qlm > 5257\na inc 526 if u <= 1452\nny inc -347 if u <= 1454\np dec 397 if uz < -2765\nt dec 548 if u <= 1448\nufk dec 514 if ufk > -2102\nl dec 744 if uz != -2782\nfr dec 810 if ppl == -333\nppl dec -338 if qlm > 5258\nqlm dec 272 if q > 1665\nm dec 521 if ufk >= -2614\nuz dec 558 if me < -477\np inc -632 if m >= 1987\ndea inc -237 if fr != -1864\nmdk dec 3 if utc > 917\nl inc -406 if dea >= 5213\ndea inc -268 if z == -2849\nutc inc 675 if q > 1664\nme dec -905 if p < -3230\nufk inc -799 if u != 1439\nxxh inc 718 if hkt != 1987\ntn inc 156 if qlm >= 4984\np inc -680 if fr == -1866\nppl inc 423 if hkt >= 1980\np inc -759 if ufk != -3405\nme inc 496 if qlm <= 4995\nm dec 111 if mdk != -2545\nu dec 351 if z < -2843\nuz dec -405 if xxh != 1804\nny dec -634 if utc == 1592\nqlm inc 294 if l == 1463\nxxh inc -994 if a <= 5511\na inc 460 if uz == -2927\nt inc -313 if u != 1093\nl inc 254 if hkt > 1978\ndea dec -290 if ppl <= 429\nny inc 190 if z <= -2844\nppl inc -865 if dea == 5220\nz dec 372 if utc <= 1595\nl dec -563 if u < 1104\nz inc -283 if xxh < 821\nq inc 967 if utc == 1595\nq dec -621 if ppl > 433\nl dec -221 if tn > 757\nl dec -935 if a >= 5962\nl inc -62 if l != 3225\nhkt dec -654 if t > 1240\ndea inc 87 if p == -4673\nl dec -166 if u <= 1098\ndea dec 183 if hw != -1529\nq dec 70 if p == -4667\na dec -673 if ny < 2188\nq dec 295 if mdk != -2563\nm dec -26 if a == 6644\nqlm inc 378 if xxh != 816\na dec 174 if l <= 3320\nfr inc 117 if dea >= 5131\nhkt dec -732 if hkt >= 2634\nufk inc -838 if mdk != -2547\nny inc -964 if a >= 6461\nhw dec -264 if a == 6470\nz dec -834 if ufk >= -4251\nl inc -658 if m > 1897\nxxh inc 400 if fr >= -1753\nhw dec 380 if hw <= -1265\nt inc -608 if utc < 1597\nppl dec 352 if a > 6467\nl dec -355 if utc > 1591\nl dec 846 if dea <= 5128\nppl dec 756 if fr < -1746\nutc dec 259 if p == -4673\ntn dec 160 if hw < -1257\nt inc -625 if t != 640\nxxh dec 804 if dea > 5130\nny dec 227 if z <= -2665\nppl dec 306 if uz != -2922\nq dec -671 if hw < -1262\ntn dec 149 if ufk == -4248\np dec -583 if mdk == -2553\nhw inc 312 if uz <= -2919\nhkt inc 111 if tn >= 456\nq dec -23 if uz > -2918\nhw inc -291 if l > 3008\nme inc -744 if utc > 1327\nuz dec 188 if utc >= 1336\nhw dec -575 if z < -2663\nppl dec 977 if ny != 988\nl dec -84 if dea < 5135\np inc 905 if uz == -3115\nm inc 636 if m == 1903\nhkt dec 95 if p < -3178\nu inc 249 if utc > 1331\nuz dec -196 if qlm == 5662\nhkt inc -621 if fr > -1750\nz inc -859 if l < 3093\nl inc -789 if ppl > -1957\nme inc 916 if tn >= 457\nuz dec -115 if xxh != 406\nz dec -353 if z <= -2669\nhw inc -965 if ppl != -1960\nt inc 333 if qlm == 5662\nt dec 860 if z == -2310\np dec -841 if l > 3104\nqlm inc 225 if t == 341\nutc inc -937 if p <= -3185\nqlm inc -191 if xxh < 424\nm dec 607 if q != 2354\nuz inc 807 if p >= -3178\nfr dec -431 if uz == -2804\nppl dec -312 if t <= 341\na dec -764 if mdk >= -2557\nutc dec 505 if a >= 7228\nufk dec -148 if tn != 449\nutc dec -371 if utc != -100\ndea dec -11 if utc < 272\nufk inc 329 if utc != 261\nutc dec -484 if z <= -2312\nm dec 784 if ppl == -1651\nxxh dec 669 if m <= 1147\nxxh inc -798 if me == 178\np dec -832 if ppl == -1651\nufk inc 266 if fr > -1318\na inc -993 if fr >= -1319\nxxh inc 25 if ppl != -1652\nu inc -353 if hw == -1631\np inc -338 if q >= 2340\np dec 517 if utc >= 741\nppl dec -221 if dea > 5137\nhw dec 949 if mdk < -2544\ntn inc 201 if ufk != -3781\nmdk inc 855 if t > 334\nm dec 604 if q <= 2353\nme inc 268 if tn <= 644\ntn inc -372 if m > 540\nl dec 275 if qlm >= 5687\nmdk dec -13 if p == -3199\nz dec -725 if tn > 286\ndea inc -843 if dea == 5142\nhw inc -603 if a >= 6234\nppl inc 850 if tn <= 279\nl inc -601 if uz == -2804\nm inc 10 if z >= -2319\nfr inc -412 if xxh != -351\nme dec 726 if tn >= 277\nny dec -719 if me < -544\nhw dec 413 if q > 2349\na dec -229 if hkt == 2651\nt inc 620 if t != 347\nuz inc -216 if t <= 963\nfr inc 614 if me != -549\nxxh inc 536 if z < -2309\nq inc 974 if me < -548\nq inc -131 if ny == 1711\ntn dec 110 if tn > 274\nl inc 47 if p == -3208\nxxh inc -872 if dea >= 4295\ntn inc -667 if tn <= 169\nq dec 562 if mdk >= -1700\na inc -16 if xxh != -685\nhw dec 649 if xxh == -695\nufk inc 239 if l != 2268\nt dec 935 if ppl <= -576\nm dec 1000 if fr > -1120\nhkt inc -167 if xxh == -695\nny inc 926 if uz > -3027\nm inc -729 if xxh > -693\nm inc -677 if a > 6221\np dec -412 if qlm >= 5691\nm dec -678 if ufk < -3526\nppl inc 206 if z < -2308\nm inc -961 if m != -445\nt inc -989 if mdk > -1701\nppl dec 43 if q <= 1654\nxxh inc -619 if ny == 2637\nppl dec 168 if xxh < -1312\nt inc 191 if xxh > -1320\nme inc 387 if hw >= -3826\np inc 517 if q <= 1648\nq dec 577 if ppl > -589\nu dec -841 if fr <= -1115\ndea dec -791 if p <= -2793\nhkt inc 216 if tn != -500\nuz dec -333 if hkt >= 2490\ndea inc 46 if a > 6217\nmdk inc -168 if fr > -1117\nt inc -606 if fr > -1122\nme inc 662 if hkt != 2491\nuz dec 384 if p > -2806\nuz inc -848 if xxh < -1308\nny inc 617 if tn < -497\nfr dec -359 if utc != 750\nm dec -911 if ufk <= -3530\nppl dec -190 if mdk != -1858\nu dec -400 if t > -1388\nme inc -381 if u == 2235\nhw inc -548 if m == 466\nqlm inc -940 if mdk <= -1860\ndea dec 180 if z <= -2316\nhw inc 17 if tn != -504\nfr dec -769 if me > -277\nppl inc -630 if hkt == 2482\nhw inc 825 if xxh == -1314\nutc dec -38 if hw < -3529\nq dec 851 if uz <= -3918\nme dec -417 if me > -274\nq inc 505 if ny < 3248\nny dec 299 if fr > 9\nutc dec 996 if z == -2317\nz inc 157 if ppl == -395\nmdk inc -11 if mdk == -1866\nt dec -222 if ny <= 2964\nq dec 1000 if u <= 2244\ntn dec -704 if ppl >= -399\nl inc 666 if utc > -212\nq inc 890 if dea >= 4951\ntn inc 255 if xxh > -1324\nme dec -317 if p == -2796\nutc dec 651 if m >= 460\ndea dec -945 if q > 110\nny inc -755 if z > -2169\na inc 1 if utc < -858\nuz dec 840 if utc >= -861\nl dec 131 if ufk != -3542\nhkt inc -442 if u > 2236\nmdk dec -156 if hw == -3531\nufk dec 380 if uz != -4756\nxxh dec 198 if p == -2796\nfr inc -946 if z != -2165\nq dec -736 if dea < 5898\nqlm inc -284 if fr == -934\nz dec 895 if t < -1152\nme dec -370 if l != 2806\na dec -949 if dea >= 5906\nl inc -913 if uz <= -4758\nuz inc 15 if t > -1158\nm inc 535 if xxh > -1516\nme inc -896 if u > 2228\nm inc -821 if fr == -934\nme dec 754 if m <= 189\nxxh inc 685 if p >= -2802\nutc inc 149 if uz == -4744\nufk dec -486 if hw <= -3535\ntn dec 617 if u != 2228\nfr inc -971 if ny < 2191\nl dec 933 if z < -3053\nq dec 269 if qlm > 4467\nme inc 449 if l < 968\nutc inc -359 if l <= 965\ntn inc -465 if p <= -2798\nxxh dec -811 if t <= -1149\nfr dec -106 if m <= 182\nuz inc 603 if p < -2794\nuz inc 310 if z <= -3064\nny inc -764 if hw >= -3538\nmdk dec -843 if ufk < -3416\na inc 49 if tn != -158\ndea inc 129 if ufk >= -3433\nny dec 515 if ny < 1438\nq inc -603 if ufk < -3419\ntn dec 470 if hkt < 2496\nm inc -669 if utc <= -1067\ndea inc 401 if ny >= 912\np inc 129 if tn >= -631\np dec -708 if hw != -3540\ndea inc 932 if mdk == -1024\ntn dec -244 if ufk == -3426\nny dec 632 if utc >= -1075\nny dec -958 if z > -3063\nme dec -67 if hkt == 2490\nfr inc 431 if mdk > -1038\nny dec -435 if z < -3052\nny inc 997 if ny != 1686\ndea inc 397 if hw < -3537\nhw dec 232 if xxh == -16\nq inc 826 if p > -1960\nq inc -807 if z < -3045\nuz dec -645 if a < 6227\nme inc -725 if qlm < 4477\nxxh dec -440 if z == -3055\nmdk inc 647 if m <= -489\nt dec -497 if dea != 6827\nhkt dec -874 if hkt == 2490\"\n\nlet test = \"\nb inc 5 if a > 1\na inc 1 if b < 5\nc dec -10 if a >= 1\nc inc -20 if c == 10\"\n\nopen Useful\n\ntype RegisterId  = RegisterId of string\n\ntype ConditionOp =\n| EQ\n| LT\n| LE\n| GT\n| GE\n| NE\n\ntype InstructionType =\n| Inc\n| Dec\n\ntype Instruction = {\n    instType : InstructionType\n    register : RegisterId\n    value    : int\n    condReg  : RegisterId\n    condOp   : ConditionOp\n    condVal  : int\n}\n\n\nlet (|Inst|_|) s =\n    match s with\n    | \"inc\" -> Some Inc\n    | \"dec\" -> Some Dec\n    | _     -> None\n\nlet (|CondOp|_|) s =\n    match s with\n    | \"==\"  -> Some EQ\n    | \"<\"   -> Some LT\n    | \"<=\"  -> Some LE\n    | \">\"   -> Some GT\n    | \">=\"  -> Some GE\n    | \"!=\"  -> Some NE\n    | _     -> None\n\nlet getInstructions (input:string) = \n    input.Split '\\n'\n    |> Array.filter ((<>) \"\")\n    |> Array.map    (fun s -> \n        match s.Trim().Split ' ' with\n        | [| r ; Inst inst ; Int v ; \"if\" ; cr ; CondOp op ; Int cv |] -> \n            {\n                 instType = inst\n                 register = RegisterId r\n                 value    = v\n                 condReg  = RegisterId cr\n                 condOp   = op\n                 condVal  = cv\n            }\n        | _ -> failwith (sprintf \"Bad instruction: %s\" s)\n    )\n\nlet processInstruction (regs, max) (inst:Instruction) =\n    let getValue reg   = Map.tryFind reg   regs |> Option.defaultValue 0\n    let setValue reg v = Map.add     reg v regs\n    let evaluateCondition reg cop v =\n        let r = getValue reg\n        match cop with\n        | EQ -> r =  v\n        | LT -> r <  v\n        | LE -> r <= v\n        | GT -> r >  v\n        | GE -> r >= v\n        | NE -> r <> v\n    if evaluateCondition inst.condReg inst.condOp inst.condVal then\n        let nv = getValue inst.register + if inst.instType = Dec then - inst.value else inst.value\n        (setValue inst.register nv, if nv > max then nv else max)        \n    else (regs, max)\n\ngetInstructions input\n|> Seq.fold processInstruction (Map.empty, 0)\n|> fun (regs, max) -> Map.toSeq regs |> Seq.maxBy snd, max\n|> printfn \"Puzzle 8 = %A\"    \n\n#define WEBSHARPER\n","parent":{"$":0,"Item":"ebc10936-8796-43e0-b809-8f6b539b31a2"},"predecessors":[{"$":0,"Item":"af2b60c6-a99f-433d-b938-f59fefe66c01"}],"id":{"$":0,"Item":"68e7f307-62ef-4ccc-b8ae-c93d3edd1455"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Day 9","content":"let test = \"\"\"\n<>, empty garbage.\n<random characters>, garbage containing random characters.\n<<<<>, because the extra < are ignored.\n<{!>}>, because the first > is canceled.\n<!!>, because the second ! is canceled, allowing the > to terminate the garbage.\n<!!!>>, because the second ! and the first > are canceled.\n<{o\"i!a,<{i<a>, which ends at the first >.\nHere are some examples of whole streams and the number of groups they contain:\n\n{}, 1 group.\n{{{}}}, 3 groups.\n{{},{}}, also 3 groups.\n{{{},{},{{}}}}, 6 groups.\n{<{},{},{{}}>}, 1 group (which itself contains garbage).\n{<a>,<a>,<a>,<a>}, 1 group.\n{{<a>},{<a>},{<a>},{<a>}}, 5 groups.\n{{<!>},{<!>},{<!>},{<a>}}, 2 groups (since all but the last > are canceled).\nYour goal is to find the total score for all groups in your input. Each group is assigned a score which is one more than the score of the group that immediately contains it. (The outermost group gets a score of 1.)\n\n{}, score of 1.\n{{{}}}, score of 1 + 2 + 3 = 6.\n{{},{}}, score of 1 + 2 + 2 = 5.\n{{{},{},{{}}}}, score of 1 + 2 + 3 + 3 + 3 + 4 = 16.\n{<a>,<a>,<a>,<a>}, score of 1.\n{{<ab>},{<ab>},{<ab>},{<ab>}}, score of 1 + 2 + 2 + 2 + 2 = 9.\n{{<!!>},{<!!>},{<!!>},{<!!>}}, score of 1 + 2 + 2 + 2 + 2 = 9.\n{{<a!>},{<a!>},{<a!>},{<ab>}}, score of 1 + 2 = 3.\"\"\" // \"\n\ntest\n|> printfn \"Puzzle 9.1 = %A\"","parent":{"$":0,"Item":"ebc10936-8796-43e0-b809-8f6b539b31a2"},"predecessors":[],"id":{"$":0,"Item":"0b3e1211-86f8-475f-a78b-32ddf232cbfe"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Garage & other things","content":"#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule Garage =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"5adf83e3-c555-4cd2-ab88-e8af42691daf"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Ping computers","content":"type Computer = {\n    name    : string\n    ip      : string option\n    sshPort : int    option\n    mac     : string option\n    user    : string option\n}\nwith static member New nm = \n      {\n        name    = nm\n        ip      = None\n        sshPort = None\n        mac     = None\n        user    = None\n      }\n     static member New (nm, ip) = \n      {\n        name    = nm\n        ip      = Some ip\n        sshPort = None\n        mac     = None\n        user    = None\n      }\n     static member New (nm, ip, mac) = \n      {\n        name    = nm\n        ip      = Some ip\n        sshPort = None\n        mac     = Some mac\n        user    = None\n      }\n     static member New (nm, ip, port) = \n      {\n        name    = nm\n        ip      = Some ip\n        sshPort = Some port\n        mac     = None\n        user    = None\n      }\n     static member New (nm, ip, port, mac) = \n      {\n        name    = nm\n        ip      = Some ip\n        sshPort = Some port\n        mac     = Some mac\n        user    = None\n      }\n     static member New (nm, ip, port, mac, user) = \n      {\n        name    = nm\n        ip      = Some ip\n        sshPort = Some port\n        mac     = Some mac\n        user    = Some user\n      }\n\nlet computersData =\n    [\n        Computer.New(\"ABEASUS\"       , \"ABEASUS\"      , \"60:57:18:8E:F1:02\") // \"9C:EB:E8:1B:29:35\" wired\n        Computer.New(\"NeoRouter\"     , \"192.168.195.1\")\n        Computer.New(\"Router1\"       , \"192.168.5.1\"  , \"9c:d3:6d:b7:cb:e6\") // WNR1000v3\n        Computer.New(\"Router2\"       , \"192.168.5.3\"  , \"E0:91:F5:DE:F4:EC\") // WNDR3400v1\n        Computer.New(\"Router2\"       , \"192.168.5.40\" , \"E0:91:F5:DE:F4:ED\") // WNDR3400v1 Internet Port\n        Computer.New(\"OOMA\"          , \"192.168.5.2\"  )\n        Computer.New(\"EXSi\"          , \"192.168.5.5\"  )\n        Computer.New(\"Modem\"         , \"192.168.100.1\")\n        Computer.New(\"ABEHOME\"       , \"192.168.5.4\"  )\n        Computer.New(\"ABEHOME\"       , \"ABEHOME\"      )\n        Computer.New(\"AbeRaspi\"      , \"192.168.5.41\"  , 2200, \"80:1F:02:D3:77:3D\", \"pi\")\n        Computer.New(\"AbeRaspiNr\"    , \"192.168.195.42\", 2200, \"b8:27:eb:1a:ad:21\", \"pi\")\n        Computer.New(\"OldHTC\"        , \"192.168.5.39\"  , 2222, \"D8:B3:77:56:42:3E\", \"Abe\")\n        Computer.New(\"AbeWCam\"       , \"192.168.5.127\" )\n        Computer.New(\"JJJGarage\"     , \"192.168.15.242\")\n        Computer.New(\"FILESERVER1\"   , \"FILESERVER1\"   )\n        Computer.New(\"AbeRainMachine\", \"192.168.5.240\" )\n        Computer.New(\"Thermo-Abajo\"  , \"192.168.5.252\" , \"44a7cf5e3548\")\n        Computer.New(\"Thermo-Arriba\" , \"192.168.5.253\" , \"5cdad4fdb7d1\")\n        Computer.New(\"Google DNS\"    , \"8.8.8.8\"       )\n    ]\n\nlet computers         = computersData |> List.map   (fun c -> c.name, c.ip |> Option.defaultValue c.name)\nlet computer        n = computersData |> Seq.tryFind(fun c -> c.name = n                                )\nlet computerIp      n = computer n    |> Option.map (fun c -> c.ip         |> Option.defaultValue c.name)\nlet computerSshPort n = computer n    |> Option.bind(fun c -> c.sshPort                                 )\nlet computerMac     n = computer n    |> Option.bind(fun c -> c.mac                                     )\n\nlet getIpPortUser   c = c.ip.Value, c.sshPort.Value, c.user.Value\n\n#if WEBSHARPER\n#else\nlet OldHtcComputer                       = computer \"OldHTC\"   |> Option.get\nlet AbeRaspi                             = computer \"AbeRaspi\" |> Option.get\nlet OldHtcIp  , OldHtcPort  , OldHtcUser = getIpPortUser OldHtcComputer\nlet AbeRaspiIp, AbeRaspiPort, AbeUser    = getIpPortUser AbeRaspi\n#endif\n\nopen UsefulDotNet\n\n#if WEBSHARPER\n[<WebSharper.JavaScript false >]\n#endif\nlet pingOne c = computers |> List.filter (fst >> ((=) c)) |> pingSeveral \n\n#if WEBSHARPER\n[<WebSharper.JavaScript false >]\n#endif\nlet All    () = computers |> pingSeveral","parent":{"$":0,"Item":"5adf83e3-c555-4cd2-ab88-e8af42691daf"},"predecessors":[{"$":0,"Item":"bc75b72d-7942-4ac8-a71f-fc290321b875"}],"id":{"$":0,"Item":"7bb04b3c-b71e-4827-bd9e-b18fbabc1495"},"expanded":true,"level":0,"levelCode":0,"properties":{"ALL":"All()","open":"open FSSGlobal.UsefulDotNet\nopen FSSGlobal.Garage","action-template":"pingOne \"${parm}\"","LayoutButtons":"ALL\ncomputers","LayoutJS":"( function()\n{\n \"use strict\";\n var Global,FSSGlobal,Useful,Async,KeyVal,String,Option,WebSharper,Obj,ExceptionThrown,ErrOptionIsNone,ErrSimple,Result,ropBuilder,ResultS,Wrap,Builder,Garage,Computer,Layout,SC$1,Concurrency,Seq,Unchecked,Strings,IntelliFactory,Runtime,Utils,Enumerator,Arrays,console,Template,Button,Layout$1,HtmlNode,List,Action,Collections,FSharpMap;\n Global=window;\n FSSGlobal=Global.FSSGlobal=Global.FSSGlobal||{};\n Useful=FSSGlobal.Useful=FSSGlobal.Useful||{};\n Async=Useful.Async=Useful.Async||{};\n KeyVal=Useful.KeyVal=Useful.KeyVal||{};\n String=Useful.String=Useful.String||{};\n Option=Useful.Option=Useful.Option||{};\n WebSharper=Global.WebSharper;\n Obj=WebSharper&&WebSharper.Obj;\n ExceptionThrown=Useful.ExceptionThrown=Useful.ExceptionThrown||{};\n ErrOptionIsNone=Useful.ErrOptionIsNone=Useful.ErrOptionIsNone||{};\n ErrSimple=Useful.ErrSimple=Useful.ErrSimple||{};\n Result=Useful.Result=Useful.Result||{};\n ropBuilder=Result.ropBuilder=Result.ropBuilder||{};\n ResultS=Useful.ResultS=Useful.ResultS||{};\n Wrap=Useful.Wrap=Useful.Wrap||{};\n Builder=Wrap.Builder=Wrap.Builder||{};\n Garage=FSSGlobal.Garage=FSSGlobal.Garage||{};\n Computer=Garage.Computer=Garage.Computer||{};\n Layout=FSSGlobal.Layout=FSSGlobal.Layout||{};\n SC$1=Global[\"StartupCode$Temp_cdizkym5$bf864f3c-1370-42f2-ac8a-565a604892e8 FSSGlobal\"]=Global[\"StartupCode$Temp_cdizkym5$bf864f3c-1370-42f2-ac8a-565a604892e8 FSSGlobal\"]||{};\n Concurrency=WebSharper&&WebSharper.Concurrency;\n Seq=WebSharper&&WebSharper.Seq;\n Unchecked=WebSharper&&WebSharper.Unchecked;\n Strings=WebSharper&&WebSharper.Strings;\n IntelliFactory=Global.IntelliFactory;\n Runtime=IntelliFactory&&IntelliFactory.Runtime;\n Utils=WebSharper&&WebSharper.Utils;\n Enumerator=WebSharper&&WebSharper.Enumerator;\n Arrays=WebSharper&&WebSharper.Arrays;\n console=Global.console;\n Template=FSSGlobal&&FSSGlobal.Template;\n Button=Template&&Template.Button;\n Layout$1=Template&&Template.Layout;\n HtmlNode=FSSGlobal&&FSSGlobal.HtmlNode;\n List=WebSharper&&WebSharper.List;\n Action=Template&&Template.Action;\n Collections=WebSharper&&WebSharper.Collections;\n FSharpMap=Collections&&Collections.FSharpMap;\n Async.sleepThen$1=function(f,milliseconds)\n {\n  var b;\n  b=null;\n  return Concurrency.Delay(function()\n  {\n   return Concurrency.Bind(Concurrency.Sleep(milliseconds),function()\n   {\n    f();\n    return Concurrency.Zero();\n   });\n  });\n };\n Async.bind$1=function(f,va)\n {\n  return Concurrency.Bind(va,f);\n };\n Async.apply$1=function(fAsync,xAsync)\n {\n  var b;\n  b=null;\n  return Concurrency.Delay(function()\n  {\n   return Concurrency.Bind(Concurrency.StartChild(fAsync,null),function(a)\n   {\n    return Concurrency.Bind(Concurrency.StartChild(xAsync,null),function(a$1)\n    {\n     return Concurrency.Bind(a,function(a$2)\n     {\n      return Concurrency.Bind(a$1,function(a$3)\n      {\n       return Concurrency.Return(a$2(a$3));\n      });\n     });\n    });\n   });\n  });\n };\n Async.retn$1=function(x)\n {\n  return Concurrency.Return(x);\n };\n Async.iter$1=function(f,va)\n {\n  var b;\n  b=null;\n  return Concurrency.Delay(function()\n  {\n   return Concurrency.Bind(va,function(a)\n   {\n    f(a);\n    return Concurrency.Zero();\n   });\n  });\n };\n Async.map$1=function(f,va)\n {\n  var b;\n  b=null;\n  return Concurrency.Delay(function()\n  {\n   return Concurrency.Bind(va,function(a)\n   {\n    return Concurrency.Return(f(a));\n   });\n  });\n };\n KeyVal.tryGetValue$1=function(key,dict)\n {\n  return Seq.tryPick(function(kp)\n  {\n   return Unchecked.Equals(kp.K,key)?{\n    $:1,\n    $0:kp.V\n   }:null;\n  },dict);\n };\n String.append$1=function(a,b)\n {\n  return a+b;\n };\n String.trim$1=function(s)\n {\n  return Strings.Trim(s);\n };\n String.splitByChar$1=function(c,s)\n {\n  return Strings.SplitChars(s,[c],0);\n };\n Option.modify$1=function(modifier)\n {\n  var g;\n  function f(o)\n  {\n   return o==null?null:{\n    $:1,\n    $0:modifier(o.$0)\n   };\n  }\n  g=function(a)\n  {\n   return Option.defaultValue$1(Global.id,a);\n  };\n  return function(x)\n  {\n   return g(f(x));\n  };\n };\n Option.apply$1=function(vO,fO)\n {\n  var $1;\n  return vO!=null&&vO.$==1&&(fO!=null&&fO.$==1&&($1=[fO.$0,vO.$0],true))?{\n   $:1,\n   $0:$1[0]($1[1])\n  }:null;\n };\n Option.iterFO$1=function(vO,fO)\n {\n  if(vO!=null&&vO.$==1)\n   if(fO!=null&&fO.$==1)\n    fO.$0(vO.$0);\n };\n Option.iterF$1=function(v,a)\n {\n  if(a!=null&&a.$==1)\n   a.$0(v);\n };\n Option.call$1=function(v,a)\n {\n  return a!=null&&a.$==1?{\n   $:1,\n   $0:a.$0(v)\n  }:null;\n };\n Option.defaultWith$1=function(f,a)\n {\n  return a==null?f():a.$0;\n };\n Option.defaultValue$1=function(v,a)\n {\n  return a==null?v:a.$0;\n };\n ExceptionThrown=Useful.ExceptionThrown=Runtime.Class({\n  toString:function()\n  {\n   return this.FSSGlobal_Useful_ErrMsg$get_ErrMsg();\n  },\n  FSSGlobal_Useful_ErrMsg$get_IsWarning:function()\n  {\n   return false;\n  },\n  FSSGlobal_Useful_ErrMsg$get_ErrMsg:function()\n  {\n   return(function($1)\n   {\n    return function($2)\n    {\n     return $1(Utils.prettyPrint($2));\n    };\n   }(Global.id))(this.exn);\n  }\n },Obj,ExceptionThrown);\n ExceptionThrown.New$1=Runtime.Ctor(function(exn)\n {\n  this.exn=exn;\n },ExceptionThrown);\n ErrOptionIsNone=Useful.ErrOptionIsNone=Runtime.Class({\n  toString:function()\n  {\n   return this.FSSGlobal_Useful_ErrMsg$get_ErrMsg();\n  },\n  FSSGlobal_Useful_ErrMsg$get_IsWarning:function()\n  {\n   return false;\n  },\n  FSSGlobal_Useful_ErrMsg$get_ErrMsg:function()\n  {\n   return\"Option is None\";\n  }\n },Obj,ErrOptionIsNone);\n ErrOptionIsNone.New$1=Runtime.Ctor(function()\n {\n },ErrOptionIsNone);\n ErrSimple=Useful.ErrSimple=Runtime.Class({\n  toString:function()\n  {\n   return this.FSSGlobal_Useful_ErrMsg$get_ErrMsg();\n  },\n  FSSGlobal_Useful_ErrMsg$get_IsWarning:function()\n  {\n   return this.warning;\n  },\n  FSSGlobal_Useful_ErrMsg$get_ErrMsg:function()\n  {\n   return this.msg;\n  }\n },Obj,ErrSimple);\n ErrSimple.New$1=Runtime.Ctor(function(msg,warning)\n {\n  this.msg=msg;\n  this.warning=warning;\n },ErrSimple);\n ropBuilder=Result.ropBuilder=Runtime.Class({\n  For:function(sequence,body)\n  {\n   var $this;\n   $this=this;\n   return this.Using(Enumerator.Get(sequence),function(_enum)\n   {\n    return $this.While(function()\n    {\n     return _enum.MoveNext();\n    },$this.Delay(function()\n    {\n     return body(_enum.Current());\n    }));\n   });\n  },\n  Using:function(disposable,body)\n  {\n   return this.TryFinally(function()\n   {\n    return body(disposable);\n   },function()\n   {\n    if(!Unchecked.Equals(disposable,null))\n     disposable.Dispose();\n   });\n  },\n  TryFinally:function(body,compensation)\n  {\n   try\n   {\n    return this.ReturnFrom(body());\n   }\n   finally\n   {\n    compensation();\n   }\n  },\n  TryWith:function(body,handler)\n  {\n   try\n   {\n    return this.ReturnFrom(body());\n   }\n   catch(e)\n   {\n    return handler(e);\n   }\n  },\n  While:function(guard,body)\n  {\n   var $this;\n   $this=this;\n   return!guard()?this.Zero():this.Bind(body(),function()\n   {\n    return $this.While(guard,body);\n   });\n  },\n  Run:function(f)\n  {\n   return f();\n  },\n  Combine:function(a,b)\n  {\n   return Result.combine$1(a,b);\n  },\n  Delay:Global.id,\n  Zero:function()\n  {\n   return Result.succeed$1();\n  },\n  Bind:function(w,r)\n  {\n   return Result.bind$1(function(v)\n   {\n    return Result.tryCall$1(r,v);\n   },w);\n  },\n  ReturnFrom:Global.id,\n  Return:function(x)\n  {\n   return Result.succeed$1(x);\n  }\n },Obj,ropBuilder);\n ropBuilder.New$1=Runtime.Ctor(function()\n {\n },ropBuilder);\n Result.toResultS$1=function(a)\n {\n  return{\n   $:0,\n   $0:a.$0,\n   $1:Arrays.map(function(m)\n   {\n    return new ErrSimple.New$1(m.FSSGlobal_Useful_ErrMsg$get_ErrMsg(),m.FSSGlobal_Useful_ErrMsg$get_IsWarning());\n   },a.$1)\n  };\n };\n Result.fromResultS$1=function(a)\n {\n  return{\n   $:0,\n   $0:a.$0,\n   $1:Arrays.map(Global.id,a.$1)\n  };\n };\n Result.result2String$1=function(res)\n {\n  return Strings.concat(\"\\n\",[Option.defaultValue$1(\"Failed: \",res.$0)].concat(Result.msgs2String$1(res.$1)));\n };\n Result.countMessages$1=function(ms)\n {\n  var $1,$2,$3,errors,warnings,$4,$5;\n  if(Unchecked.Equals(ms,[]))\n   return\"\";\n  else\n   {\n    errors=Arrays.filter(function(m)\n    {\n     return!m.FSSGlobal_Useful_ErrMsg$get_IsWarning();\n    },ms);\n    warnings=Arrays.filter(function(m)\n    {\n     return m.FSSGlobal_Useful_ErrMsg$get_IsWarning();\n    },ms);\n    $4=Arrays.length(errors);\n    $5=Arrays.length(warnings);\n    switch($4===0?$5===0?0:$5===1?2:5:$4===1?$5===0?1:$5===1?3:($1=[$4,$5],6):$5===0?4:($1=[$4,$5],6))\n    {\n     case 0:\n      $3=function($6)\n      {\n       return function($7)\n       {\n        return $6(Utils.toSafe($7));\n       };\n      }(Global.id);\n      break;\n     case 1:\n      $3=function($6)\n      {\n       return function($7)\n       {\n        return $6(Utils.toSafe($7));\n       };\n      }(Global.id);\n      break;\n     case 2:\n      $3=function($6)\n      {\n       return function($7)\n       {\n        return $6(Utils.toSafe($7));\n       };\n      }(Global.id);\n      break;\n     case 3:\n      $3=function($6)\n      {\n       return function($7)\n       {\n        return $6(\"1 error, 1 warning\\n\"+Utils.toSafe($7));\n       };\n      }(Global.id);\n      break;\n     case 4:\n      $3=((Runtime.Curried3(function($6,$7,$8)\n      {\n       return $6(Global.String($7)+\" errors\\n\"+Utils.toSafe($8));\n      }))(Global.id))($4);\n      break;\n     case 5:\n      $3=((Runtime.Curried3(function($6,$7,$8)\n      {\n       return $6(Global.String($7)+\" warnings\\n\"+Utils.toSafe($8));\n      }))(Global.id))($5);\n      break;\n     case 6:\n      $3=(((Runtime.Curried(function($6,$7,$8,$9)\n      {\n       return $6(Global.String($7)+\" errors, \"+Global.String($8)+\" warnings\\n\"+Utils.toSafe($9));\n      },4))(Global.id))($1[0]))($1[1]);\n      break;\n    }\n    return $3(Result.getMessages$1(ms));\n   }\n };\n Result.getMessages$1=function(ms)\n {\n  return Strings.concat(\"\\n\",Result.msgs2String$1(ms));\n };\n Result.msgs2String$1=function(ms)\n {\n  return Arrays.map(function(m)\n  {\n   return m.FSSGlobal_Useful_ErrMsg$get_ErrMsg();\n  },ms);\n };\n Result.seqCheck$1=function(s)\n {\n  return Seq.exists(function(a)\n  {\n   return Result.Success$1(a).$==1;\n  },s)?Result.failWithMsgs$1(Seq.pick(function(a)\n  {\n   var a$1;\n   a$1=Result.Success$1(a);\n   return a$1.$==1?{\n    $:1,\n    $0:a$1.$0\n   }:null;\n  },s)):Result.succeed$1(Seq.map(function(a)\n  {\n   return a.$0.$0;\n  },s));\n };\n Result.withError$1=function(f,a)\n {\n  var ms;\n  ms=a.$1;\n  return Option.defaultWith$1(function()\n  {\n   return f(ms);\n  },a.$0);\n };\n Result.ifError$1=function(def,a)\n {\n  return Option.defaultValue$1(def,a.$0);\n };\n Result.failIfTrue$1=function(m,v)\n {\n  return v?Result.fail$1(m):Result.succeed$1();\n };\n Result.failIfFalse$1=function(m,v)\n {\n  return v?Result.succeed$1():Result.fail$1(m);\n };\n Result.tryProtection$1=function()\n {\n  return Result.succeed$1();\n };\n Result.toOptionMs$1=function(a)\n {\n  return[a.$0,a.$1];\n };\n Result.toOption$1=function(a)\n {\n  return a.$0;\n };\n Result.fromOption$1=function(m,a)\n {\n  return a!=null&&a.$==1?Result.succeed$1(a.$0):Result.fail$1(m);\n };\n Result.fromChoice$1=function(c)\n {\n  return c.$==1?Result.fail$1(c.$0):Result.succeed$1(c.$0);\n };\n Result.result$1=function()\n {\n  SC$1.$cctor();\n  return SC$1.result;\n };\n Result.tryCall$1=function(f,v)\n {\n  try\n  {\n   return f(v);\n  }\n  catch(e)\n  {\n   return Result.fail$1(Result.failException$1(e));\n  }\n };\n Result.failException$1=function(e)\n {\n  return new ExceptionThrown.New$1(e);\n };\n Result.Success$1=function(a)\n {\n  return a.$0==null?{\n   $:1,\n   $0:a.$1\n  }:{\n   $:0,\n   $0:[a.$0.$0,a.$1]\n  };\n };\n Result.failSimpleWarning$1=function(m)\n {\n  return Result.fail$1(new ErrSimple.New$1(m,true));\n };\n Result.failSimpleError$1=function(m)\n {\n  return Result.fail$1(new ErrSimple.New$1(m,false));\n };\n Result.apply$1=function(a,a$1)\n {\n  var fMs,ms,$1,$2,$3;\n  fMs=a.$1;\n  ms=a$1.$1;\n  $1=a.$0;\n  $2=a$1.$0;\n  return $1!=null&&$1.$==1&&($2!=null&&$2.$==1&&($3=[$1.$0,$2.$0],true))?{\n   $:0,\n   $0:{\n    $:1,\n    $0:$3[0]($3[1])\n   },\n   $1:fMs.concat(ms)\n  }:{\n   $:0,\n   $0:null,\n   $1:fMs.concat(ms)\n  };\n };\n Result.bind$1=function(f,a)\n {\n  var o,ms,m;\n  o=a.$0;\n  ms=a.$1;\n  return o==null?{\n   $:0,\n   $0:null,\n   $1:ms\n  }:(m=f(o.$0),{\n   $:0,\n   $0:m.$0,\n   $1:ms.concat(m.$1)\n  });\n };\n Result.combine$1=function(a,rb)\n {\n  var ms;\n  ms=a.$1;\n  return Option.defaultValue$1({\n   $:0,\n   $0:null,\n   $1:ms\n  },a.$0==null?null:{\n   $:1,\n   $0:Result.mergeMsgs$1(ms,rb())\n  });\n };\n Result.mergeMsgs$1=function(ms,r)\n {\n  var t;\n  t=Result.mapMsgs$1(function(a)\n  {\n   return ms.concat(a);\n  },r);\n  return{\n   $:0,\n   $0:t[0],\n   $1:t[1]\n  };\n };\n Result.getMsgs$1=function(a)\n {\n  return a.$1;\n };\n Result.getOption$1=function(a)\n {\n  return a.$0;\n };\n Result.mapMsgs$1=function(f,a)\n {\n  return[a.$0,f(a.$1)];\n };\n Result.mapMsg$1=function(f,a)\n {\n  return[a.$0,Arrays.map(f,a.$1)];\n };\n Result.mapErr$1=function(f,a)\n {\n  return{\n   $:0,\n   $0:a.$0,\n   $1:Arrays.map(f,a.$1)\n  };\n };\n Result.map$1=function(f,a)\n {\n  var o;\n  return{\n   $:0,\n   $0:(o=a.$0,o==null?null:{\n    $:1,\n    $0:f(o.$0)\n   }),\n   $1:a.$1\n  };\n };\n Result.failWithMsgs$1=function(ms)\n {\n  return{\n   $:0,\n   $0:null,\n   $1:ms\n  };\n };\n Result.fail$1=function(m)\n {\n  return{\n   $:0,\n   $0:null,\n   $1:[m]\n  };\n };\n Result.succeedWithMsgs$1=function(x,ms)\n {\n  return{\n   $:0,\n   $0:{\n    $:1,\n    $0:x\n   },\n   $1:ms\n  };\n };\n Result.succeedWithMsg$1=function(x,m)\n {\n  return{\n   $:0,\n   $0:{\n    $:1,\n    $0:x\n   },\n   $1:[m]\n  };\n };\n Result.succeed$1=function(x)\n {\n  return{\n   $:0,\n   $0:{\n    $:1,\n    $0:x\n   },\n   $1:[]\n  };\n };\n ResultS.toResult$1=function()\n {\n  SC$1.$cctor();\n  return SC$1.toResult;\n };\n ResultS.fromResult$1=function()\n {\n  SC$1.$cctor();\n  return SC$1.fromResult;\n };\n Wrap.StartAsTask$1=function(w,options,cancToken)\n {\n  return Concurrency.StartAsTask(Wrap.getAsyncR$1(w),cancToken);\n };\n Wrap.Start$1=function(w,cancToken)\n {\n  Concurrency.Start(Wrap.getAsync$1(w),cancToken);\n };\n Builder=Wrap.Builder=Runtime.Class({\n  For:function(sequence,body)\n  {\n   var $this;\n   $this=this;\n   return this.Using(Enumerator.Get(sequence),function(_enum)\n   {\n    return $this.While(function()\n    {\n     return _enum.MoveNext();\n    },$this.Delay(function()\n    {\n     return body(_enum.Current());\n    }));\n   });\n  },\n  Using:function(disposable,body)\n  {\n   return this.TryFinally(function()\n   {\n    return body(disposable);\n   },function()\n   {\n    if(!Unchecked.Equals(disposable,null))\n     disposable.Dispose();\n   });\n  },\n  TryFinally:function(body,compensation)\n  {\n   var b;\n   return{\n    $:2,\n    $0:(b=null,Concurrency.Delay(function()\n    {\n     return Concurrency.Bind(Concurrency.Catch(Wrap.toAsyncResult$1(body())),function(a)\n     {\n      var $1,$2;\n      compensation();\n      if(a.$==1)\n       throw a.$0;\n      else\n       $2=a.$0;\n      return Concurrency.Return($2);\n     });\n    }))\n   };\n  },\n  TryWith:function(body,handler)\n  {\n   var b;\n   return{\n    $:2,\n    $0:(b=null,Concurrency.Delay(function()\n    {\n     return Concurrency.Bind(Concurrency.Catch(Wrap.toAsyncResult$1(body())),function(a)\n     {\n      return Concurrency.Return(a.$==1?handler(a.$0):a.$0);\n     });\n    }))\n   };\n  },\n  While:function(guard,body)\n  {\n   return Wrap.whileLoop$1(guard,body);\n  },\n  Combine:function(a,b)\n  {\n   return Wrap.combine$1(Wrap.errOptionIsNone$1(),a,b);\n  },\n  Run:function(f)\n  {\n   return f();\n  },\n  Delay:Global.id,\n  ReturnFrom:Global.id,\n  Return:function(x)\n  {\n   return{\n    $:3,\n    $0:x\n   };\n  },\n  Zero:function()\n  {\n   return{\n    $:3,\n    $0:null\n   };\n  },\n  Bind:function(wrapped,restOfCExpr)\n  {\n   return Wrap.bind$1(restOfCExpr,{\n    $:4,\n    $0:wrapped\n   });\n  },\n  Bind$1:function(wrapped,restOfCExpr)\n  {\n   return Wrap.bind$1(restOfCExpr,{\n    $:0,\n    $0:wrapped\n   });\n  },\n  Bind$2:function(wrapped,restOfCExpr)\n  {\n   return Wrap.bind$1(restOfCExpr,{\n    $:1,\n    $0:wrapped\n   });\n  },\n  Bind$3:function(wrapped,restOfCExpr)\n  {\n   return Wrap.bind$1(restOfCExpr,wrapped);\n  }\n },Obj,Builder);\n Builder.New$1=Runtime.Ctor(function()\n {\n },Builder);\n Wrap.runSynchronouslyS$1=function(count,w)\n {\n  var a;\n  a=Wrap.runSynchronouslyO$1(count,w);\n  return a[0]==null?(function($1)\n  {\n   return function($2)\n   {\n    return $1(\"Failed!\\n\"+Utils.toSafe($2));\n   };\n  }(Global.id))(a[1]):(((Runtime.Curried3(function($1,$2,$3)\n  {\n   return $1(Global.String($2)+\"\\n\"+Utils.toSafe($3));\n  }))(Global.id))(a[0].$0))(a[1]);\n };\n Wrap.runSynchronouslyO$1=function(count,w)\n {\n  return Result.mapMsgs$1(count?Result.countMessages$1:Result.getMessages$1,console.log(\"runSynchronously should not be used in Javascript\"));\n };\n Wrap.getResult$1=function(callback,wb)\n {\n  if(wb.$==4)\n  {\n   if(wb.$0==null)\n    callback(Result.fail$1(Wrap.errOptionIsNone$1()));\n   else\n    callback(Result.succeed$1(wb.$0.$0));\n  }\n  else\n   if(wb.$==0)\n    callback(wb.$0);\n   else\n    if(wb.$==1)\n     Concurrency.StartWithContinuations(wb.$0,function(v)\n     {\n      callback(Result.succeed$1(v));\n     },function(exc)\n     {\n      callback(Result.fail$1(Result.failException$1(exc)));\n     },function(can)\n     {\n      callback(Result.fail$1(Result.failException$1(can)));\n     },null);\n    else\n     if(wb.$==2)\n      Concurrency.StartWithContinuations(wb.$0,callback,function(exc)\n      {\n       callback(Result.fail$1(Result.failException$1(exc)));\n      },function(can)\n      {\n       callback(Result.fail$1(Result.failException$1(can)));\n      },null);\n     else\n      callback(Result.succeed$1(wb.$0));\n };\n Wrap.wrapper$1=function()\n {\n  SC$1.$cctor();\n  return SC$1.wrapper;\n };\n Wrap.wrap$1=function()\n {\n  SC$1.$cctor();\n  return SC$1.wrap;\n };\n Wrap.whileLoop$1=function(pred,body)\n {\n  return pred()?Wrap.bind$1(function()\n  {\n   return Wrap.whileLoop$1(pred,body);\n  },body()):{\n   $:3,\n   $0:null\n  };\n };\n Wrap.combine$1=function(errOptionIsNone,wa,wb)\n {\n  var $1,t,b,b$1;\n  switch(wa.$==4?wa.$0==null?4:0:wa.$==0?wa.$0.$0==null?($1=wa.$0.$1,5):(t=wa.$0.$1,t&&Arrays.length(t)===0?0:($1=wa.$0.$1,1)):wa.$==1?($1=wa.$0,2):wa.$==2?($1=wa.$0,3):0)\n  {\n   case 0:\n    return wb();\n    break;\n   case 1:\n    return Wrap.addMsgs$1(errOptionIsNone,$1,wb());\n    break;\n   case 2:\n    return{\n     $:2,\n     $0:(b=null,Concurrency.Delay(function()\n     {\n      return Concurrency.Bind($1,function()\n      {\n       return Concurrency.Bind(Wrap.toAsyncResult$1(wb()),function(a)\n       {\n        return Concurrency.Return(a);\n       });\n      });\n     }))\n    };\n    break;\n   case 3:\n    return{\n     $:2,\n     $0:(b$1=null,Concurrency.Delay(function()\n     {\n      return Concurrency.Bind($1,function(a)\n      {\n       var a$1,ms;\n       a$1=Result.Success$1(a);\n       return a$1.$==0?(ms=a$1.$0[1],Concurrency.Bind(Wrap.toAsyncResult$1(wb()),function(a$2)\n       {\n        return Concurrency.Return(Result.mergeMsgs$1(ms,a$2));\n       })):Concurrency.Return(Result.failWithMsgs$1(a$1.$0));\n      });\n     }))\n    };\n    break;\n   case 4:\n    return{\n     $:4,\n     $0:null\n    };\n    break;\n   case 5:\n    return{\n     $:0,\n     $0:Result.failWithMsgs$1($1)\n    };\n    break;\n  }\n };\n Wrap.addMsgs$1=function(errOptionIsNone,ms,wb)\n {\n  var $1,b,b$1;\n  if(Unchecked.Equals(ms,[]))\n   return wb;\n  else\n   switch(wb.$==4?wb.$0==null?1:($1=wb.$0.$0,0):wb.$==0?($1=wb.$0,2):wb.$==1?($1=wb.$0,3):wb.$==2?($1=wb.$0,4):($1=wb.$0,0))\n   {\n    case 0:\n     return{\n      $:0,\n      $0:Result.succeedWithMsgs$1($1,ms)\n     };\n     break;\n    case 1:\n     return{\n      $:0,\n      $0:Result.mergeMsgs$1(ms,Result.fail$1(errOptionIsNone))\n     };\n     break;\n    case 2:\n     return{\n      $:0,\n      $0:Result.mergeMsgs$1(ms,$1)\n     };\n     break;\n    case 3:\n     return{\n      $:2,\n      $0:(b=null,Concurrency.Delay(function()\n      {\n       return Concurrency.Bind($1,function(a)\n       {\n        return Concurrency.Return(Result.succeedWithMsgs$1(a,ms));\n       });\n      }))\n     };\n     break;\n    case 4:\n     return{\n      $:2,\n      $0:(b$1=null,Concurrency.Delay(function()\n      {\n       return Concurrency.Bind($1,function(a)\n       {\n        return Concurrency.Return(Result.mergeMsgs$1(ms,a));\n       });\n      }))\n     };\n     break;\n   }\n };\n Wrap.wrapper2Async$1=function(f,a)\n {\n  var $1,wb,ab,b;\n  wb=Wrap.tryCall$1(f,a);\n  switch(wb.$==4?0:wb.$==0?1:wb.$==1?2:wb.$==2?3:0)\n  {\n   case 0:\n    return Wrap.wb2arb$1([],wb);\n    break;\n   case 1:\n    return Wrap.wb2arb$1(wb.$0.$1,wb);\n    break;\n   case 2:\n    ab=wb.$0;\n    b=null;\n    return Concurrency.Delay(function()\n    {\n     return Concurrency.Bind(ab,function(a$1)\n     {\n      return Concurrency.Return(Result.succeed$1(a$1));\n     });\n    });\n    break;\n   case 3:\n    return wb.$0;\n    break;\n  }\n };\n Wrap.start$1=function(printMsg,w)\n {\n  Wrap.startV$1(function(a)\n  {\n   if(a[0]==null)\n    printMsg(\"Failed!\\n\"+a[1]);\n   else\n    printMsg(a[1]);\n  },w);\n };\n Wrap.startV$1=function(processVal,w)\n {\n  var f,f$1,f$2,f$3;\n  function f$4(a)\n  {\n   return Result.mapMsgs$1(Result.getMessages$1,a);\n  }\n  function g(m)\n  {\n   return[null,m];\n  }\n  function g$1(m)\n  {\n   return[null,m];\n  }\n  Concurrency.StartWithContinuations(Wrap.getAsyncR$1(w),function(x)\n  {\n   return processVal(f$4(x));\n  },(f=(f$1=function($1)\n  {\n   return function($2)\n   {\n    return $1(Global.String($2));\n   };\n  }(Global.id),function(x)\n  {\n   return g(f$1(x));\n  }),function(x)\n  {\n   return processVal(f(x));\n  }),(f$2=(f$3=function($1)\n  {\n   return function($2)\n   {\n    return $1(Global.String($2));\n   };\n  }(Global.id),function(x)\n  {\n   return g$1(f$3(x));\n  }),function(x)\n  {\n   return processVal(f$2(x));\n  }),null);\n };\n Wrap.toAsyncWithDefault$1=function(w)\n {\n  return function(w$1)\n  {\n   return Wrap.getAsyncWithDefault$1(w,w$1);\n  };\n };\n Wrap.toAsyncOptionMs$1=function(w)\n {\n  return Async.map$1(Result.toOptionMs$1,Wrap.getAsyncR$1(w));\n };\n Wrap.toAsyncOption$1=function(w)\n {\n  return Async.map$1(Result.toOption$1,Wrap.getAsyncR$1(w));\n };\n Wrap.toAsyncResult$1=function(w)\n {\n  return Wrap.getAsyncR$1(w);\n };\n Wrap.toAsync$1=function(w)\n {\n  return Wrap.getAsync$1(w);\n };\n Wrap.getAsync$1=function(w)\n {\n  return Wrap.getAsyncWithDefault$1(function(ms)\n  {\n   throw Global.Error(Result.getMessages$1(ms));\n  },w);\n };\n Wrap.getAsyncWithDefault$1=function(f,w)\n {\n  return Async.map$1(function(a)\n  {\n   return Result.withError$1(f,a);\n  },Wrap.getAsyncR$1(w));\n };\n Wrap.getAsyncR$1=function(wb)\n {\n  var va,b;\n  return wb.$==3?Concurrency.Return(Result.succeed$1(wb.$0)):wb.$==4?Concurrency.Return(Result.fromOption$1(Wrap.errOptionIsNone$1(),wb.$0)):wb.$==0?Concurrency.Return(wb.$0):wb.$==2?wb.$0:(va=wb.$0,(b=null,Concurrency.Delay(function()\n  {\n   return Concurrency.Bind(va,function(a)\n   {\n    return Concurrency.Return(Result.succeed$1(a));\n   });\n  })));\n };\n Wrap.map$1=function(f)\n {\n  var f$1;\n  f$1=function(x)\n  {\n   return Wrap.Return$1(f(x));\n  };\n  return function(w)\n  {\n   return Wrap.bind$1(f$1,w);\n  };\n };\n Wrap.Return$1=function(a)\n {\n  return{\n   $:3,\n   $0:a\n  };\n };\n Wrap.bind$1=function(f,wa)\n {\n  var $1,a,t,ms,b,b$1;\n  switch(wa.$==4?wa.$0==null?1:($1=wa.$0.$0,0):wa.$==0?(a=Result.Success$1(wa.$0),a.$==1?($1=a.$0,2):(t=a.$0[1],t&&Arrays.length(t)===0?($1=a.$0[0],0):($1=[a.$0[0],a.$0[1]],3))):wa.$==1?($1=wa.$0,4):wa.$==2?($1=wa.$0,5):($1=wa.$0,0))\n  {\n   case 0:\n    return Wrap.tryCall$1(f,$1);\n    break;\n   case 1:\n    return{\n     $:4,\n     $0:null\n    };\n    break;\n   case 2:\n    return{\n     $:0,\n     $0:Result.failWithMsgs$1($1)\n    };\n    break;\n   case 3:\n    ms=$1[1];\n    return function(a$1)\n    {\n     var $2,a$2,t$1,b$2,b$3;\n     switch(a$1.$==4?a$1.$0==null?1:($2=a$1.$0.$0,0):a$1.$==0?(a$2=Result.Success$1(a$1.$0),a$2.$==1?($2=a$2.$0,4):(t$1=a$2.$0[1],t$1&&Arrays.length(t$1)===0?($2=a$2.$0[0],2):($2=[a$2.$0[0],a$2.$0[1]],3))):a$1.$==1?($2=a$1.$0,5):a$1.$==2?($2=a$1.$0,6):($2=a$1.$0,0))\n     {\n      case 0:\n       return{\n        $:0,\n        $0:Result.succeedWithMsgs$1($2,ms)\n       };\n       break;\n      case 1:\n       return{\n        $:0,\n        $0:Result.failWithMsgs$1(ms.concat([Wrap.errOptionIsNone$1()]))\n       };\n       break;\n      case 2:\n       return{\n        $:0,\n        $0:Result.succeedWithMsgs$1($2,ms)\n       };\n       break;\n      case 3:\n       return{\n        $:0,\n        $0:Result.succeedWithMsgs$1($2[0],ms.concat($2[1]))\n       };\n       break;\n      case 4:\n       return{\n        $:0,\n        $0:Result.failWithMsgs$1(ms.concat($2))\n       };\n       break;\n      case 5:\n       return{\n        $:2,\n        $0:(b$2=null,Concurrency.Delay(function()\n        {\n         return Concurrency.Bind($2,function(a$3)\n         {\n          return Concurrency.Return(Result.succeedWithMsgs$1(a$3,ms));\n         });\n        }))\n       };\n       break;\n      case 6:\n       return{\n        $:2,\n        $0:(b$3=null,Concurrency.Delay(function()\n        {\n         return Concurrency.Bind($2,function(a$3)\n         {\n          return Concurrency.Return(Result.mergeMsgs$1(ms,a$3));\n         });\n        }))\n       };\n       break;\n     }\n    }(Wrap.tryCall$1(f,$1[0]));\n    break;\n   case 4:\n    return{\n     $:2,\n     $0:(b=null,Concurrency.Delay(function()\n     {\n      return Concurrency.Bind($1,function(a$1)\n      {\n       return Wrap.wb2arb$1([],Wrap.tryCall$1(f,a$1));\n      });\n     }))\n    };\n    break;\n   case 5:\n    return{\n     $:2,\n     $0:(b$1=null,Concurrency.Delay(function()\n     {\n      return Concurrency.Bind($1,function(a$1)\n      {\n       var a$2,ms$1,b$2;\n       a$2=Result.Success$1(a$1);\n       return a$2.$==1?(ms$1=a$2.$0,b$2=null,Concurrency.Delay(function()\n       {\n        return Concurrency.Return(Result.failWithMsgs$1(ms$1));\n       })):Wrap.wb2arb$1(a$2.$0[1],Wrap.tryCall$1(f,a$2.$0[0]));\n      });\n     }))\n    };\n    break;\n  }\n };\n Wrap.tryCall$1=function(f,a)\n {\n  try\n  {\n   return f(a);\n  }\n  catch(e)\n  {\n   return{\n    $:0,\n    $0:Result.fail$1(Result.failException$1(e))\n   };\n  }\n };\n Wrap.wb2arb$1=function(ms,a)\n {\n  var $1,b,b$1,b$2,b$3,b$4;\n  switch(a.$==2?($1=a.$0,1):a.$==0?($1=a.$0,2):a.$==3?($1=a.$0,3):a.$==4?a.$0==null?4:($1=a.$0.$0,3):($1=a.$0,0))\n  {\n   case 0:\n    b=null;\n    return Concurrency.Delay(function()\n    {\n     return Concurrency.Bind($1,function(a$1)\n     {\n      return Concurrency.Return(Result.succeedWithMsgs$1(a$1,ms));\n     });\n    });\n    break;\n   case 1:\n    b$1=null;\n    return Concurrency.Delay(function()\n    {\n     return Concurrency.Bind($1,function(a$1)\n     {\n      return Concurrency.Return(Result.mergeMsgs$1(ms,a$1));\n     });\n    });\n    break;\n   case 2:\n    b$2=null;\n    return Concurrency.Delay(function()\n    {\n     return Concurrency.Return(Result.mergeMsgs$1(ms,$1));\n    });\n    break;\n   case 3:\n    b$3=null;\n    return Concurrency.Delay(function()\n    {\n     return Concurrency.Return(Result.succeedWithMsgs$1($1,ms));\n    });\n    break;\n   case 4:\n    b$4=null;\n    return Concurrency.Delay(function()\n    {\n     return Concurrency.Return(Result.failWithMsgs$1(ms.concat([Wrap.errOptionIsNone$1()])));\n    });\n    break;\n  }\n };\n Wrap.errOptionIsNone$1=function()\n {\n  SC$1.$cctor();\n  return SC$1.errOptionIsNone;\n };\n Useful.extract$1=function(n,s)\n {\n  var b;\n  return Strings.Substring(s,0,(b=s.length,Unchecked.Compare(n,b)===-1?n:b));\n };\n Computer.New$1=function(nm,ip,port,mac,user)\n {\n  return Computer.New(nm,{\n   $:1,\n   $0:ip\n  },{\n   $:1,\n   $0:port\n  },{\n   $:1,\n   $0:mac\n  },{\n   $:1,\n   $0:user\n  });\n };\n Computer.New$2=function(nm,ip,port,mac)\n {\n  return Computer.New(nm,{\n   $:1,\n   $0:ip\n  },{\n   $:1,\n   $0:port\n  },{\n   $:1,\n   $0:mac\n  },null);\n };\n Computer.New$3=function(nm,ip,port)\n {\n  return Computer.New(nm,{\n   $:1,\n   $0:ip\n  },{\n   $:1,\n   $0:port\n  },null,null);\n };\n Computer.New$4=function(nm,ip,mac)\n {\n  return Computer.New(nm,{\n   $:1,\n   $0:ip\n  },null,{\n   $:1,\n   $0:mac\n  },null);\n };\n Computer.New$5=function(nm,ip)\n {\n  return Computer.New(nm,{\n   $:1,\n   $0:ip\n  },null,null,null);\n };\n Computer.New$6=function(nm)\n {\n  return Computer.New(nm,null,null,null,null);\n };\n Computer.New=function(name,ip,sshPort,mac,user)\n {\n  return{\n   name:name,\n   ip:ip,\n   sshPort:sshPort,\n   mac:mac,\n   user:user\n  };\n };\n Garage.getIpPortUser=function(c)\n {\n  return[c.ip.$0,c.sshPort.$0,c.user.$0];\n };\n Garage.computerMac=function(n)\n {\n  var o;\n  o=Garage.computer(n);\n  return o==null?null:o.$0.mac;\n };\n Garage.computerSshPort=function(n)\n {\n  var o;\n  o=Garage.computer(n);\n  return o==null?null:o.$0.sshPort;\n };\n Garage.computerIp=function(n)\n {\n  var o,c,o$1;\n  o=Garage.computer(n);\n  return o==null?null:{\n   $:1,\n   $0:(c=o.$0,(o$1=c.ip,o$1==null?c.name:o$1.$0))\n  };\n };\n Garage.computer=function(n)\n {\n  return Seq.tryFind(function(c)\n  {\n   return c.name===n;\n  },Garage.computersData());\n };\n Garage.computers=function()\n {\n  SC$1.$cctor();\n  return SC$1.computers;\n };\n Garage.computersData=function()\n {\n  SC$1.$cctor();\n  return SC$1.computersData;\n };\n Layout.getLayout=function(lyt,snp)\n {\n  var f,g;\n  function m(c)\n  {\n   return c===\"computers\"?Seq.sort(Seq.distinct(Seq.map(function(t)\n   {\n    return t[0];\n   },Garage.computers()))):[c];\n  }\n  return Layout.getButtonsLayout((f=function(s)\n  {\n   return Seq.collect(m,s);\n  },(g=Layout.evalFsCodeButtonNoParms(lyt),function(x)\n  {\n   return g(f(x));\n  })),snp);\n };\n Layout.getButtonsLayout=function(f,snp)\n {\n  return Layout.extraButtonsLayout(f(Seq.filter(function(y)\n  {\n   return\"\"!==y;\n  },Seq.map(String.trim,String.splitByChar(\"\\n\",Option.defaultValue(\"\",function(d)\n  {\n   var res;\n   res=null;\n   return d.TryGetValue(\"LayoutButtons\",{\n    get:function()\n    {\n     return res;\n    },\n    set:function(v)\n    {\n     res=v;\n    }\n   })?{\n    $:1,\n    $0:res\n   }:null;\n  }(snp.properties)))))));\n };\n Layout.buttonPwd=function(code,lyt)\n {\n  return Button.New$1(\"Send\").OnClick(Runtime.Curried(Layout.sendPwd,2,[code,lyt])).get_Render();\n };\n Layout.sendPwd=function(code,lyt,el,ev)\n {\n  var a,act,x,o;\n  a=Result.Success(lyt.GetGuiCallAction(\"sendPwd\",\"actEvalFsCode\",[\"Code\",code()]));\n  a.$==1?(function($1)\n  {\n   return function($2)\n   {\n    return $1(Utils.printArray(Utils.prettyPrint,$2));\n   };\n  }(function(s)\n  {\n   console.log(s);\n  }))(a.$0):(act=a.$0[0],x=(o=act.onClick,o==null?null:{\n   $:1,\n   $0:((o.$0(act))(el))(ev)\n  }),Option.defaultWith(function($1)\n  {\n   return function()\n   {\n    return $1(\"OnClick is null\");\n   };\n  }(function(s)\n  {\n   console.log(s);\n  }),x));\n };\n Layout.evalFsCodeButtonNoParms=function(lyt)\n {\n  var f,f$1;\n  function p(y)\n  {\n   return\"\"!==y;\n  }\n  function g(t)\n  {\n   return Layout.evalFsCodeButtons(lyt,t);\n  }\n  f=(f$1=function(s)\n  {\n   return Seq.filter(p,s);\n  },function(x)\n  {\n   return Layout.passNoParms(f$1(x));\n  });\n  return function(x)\n  {\n   return g(f(x));\n  };\n };\n Layout.evalFsCodeButtonNoParm=function(lyt)\n {\n  function g(t,p)\n  {\n   return Layout.evalFsCodeButton(lyt,t,p);\n  }\n  return function(x)\n  {\n   return g.apply(null,Layout.passNoParm(x));\n  };\n };\n Layout.passNoParms=function(txts)\n {\n  return Seq.map(Layout.passNoParm,txts);\n };\n Layout.passNoParm=function(txt)\n {\n  return[txt,[]];\n };\n Layout.runFableFsButton=function(lyt,txt,parms)\n {\n  return lyt.GetCallButton(txt,Layout.actRunFableFs(),parms);\n };\n Layout.evalFsCodeButtons=function(lyt,txts)\n {\n  function m(t,p)\n  {\n   return Layout.evalFsCodeButton(lyt,t,p);\n  }\n  return Seq.map(function($1)\n  {\n   return m($1[0],$1[1]);\n  },txts);\n };\n Layout.evalFsCodeButton=function(lyt,txt,parms)\n {\n  return lyt.GetCallButton(txt,Layout.actEvalFsCode(),parms);\n };\n Layout.extraButtonsLayout=function(buttons)\n {\n  return Layout$1.AddGuids([[\"extrabuttons\",new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.div(List.ofSeq(Seq.delay(function()\n   {\n    return Seq.append([HtmlNode.style(\"text-align: center ; overflow: auto ; \")],Seq.delay(function()\n    {\n     return Seq.append(buttons,Seq.delay(function()\n     {\n      return[HtmlNode.css(\" button.btn { margin: 2px; font-size: small; } \")];\n     }));\n    }));\n   })))\n  })],[\"main_extra\",Template.varVerSplitter(85,\"main_messages\",\"extrabuttons\",50,100)],[\"main\",Template.fixedHorSplitter(true,50,\"menu\",\"main_extra\")]]);\n };\n Layout.layout=function()\n {\n  SC$1.$cctor();\n  return SC$1.layout;\n };\n Layout.set_layout=function($1)\n {\n  SC$1.$cctor();\n  SC$1.layout=$1;\n };\n Layout.doGuiCall=function(name,action,parms)\n {\n  Global.doFSharpStationGuiCall([name,action,parms]);\n };\n Layout.setLayout=function(f)\n {\n  Global.setFSharpStationLayout(f);\n };\n Layout.guiParts=function()\n {\n  SC$1.$cctor();\n  return SC$1.guiParts;\n };\n Layout.dummyAction=function()\n {\n  SC$1.$cctor();\n  return SC$1.dummyAction;\n };\n Layout.Properties=function()\n {\n  SC$1.$cctor();\n  return SC$1.Properties;\n };\n Layout.WSResult=function()\n {\n  SC$1.$cctor();\n  return SC$1.WSResult;\n };\n Layout.FScode=function()\n {\n  SC$1.$cctor();\n  return SC$1.FScode;\n };\n Layout.JavaScript=function()\n {\n  SC$1.$cctor();\n  return SC$1.JavaScript;\n };\n Layout.Parser=function()\n {\n  SC$1.$cctor();\n  return SC$1.Parser;\n };\n Layout.Output=function()\n {\n  SC$1.$cctor();\n  return SC$1.Output;\n };\n Layout.menu=function()\n {\n  SC$1.$cctor();\n  return SC$1.menu;\n };\n Layout.buttons=function()\n {\n  SC$1.$cctor();\n  return SC$1.buttons;\n };\n Layout.code=function()\n {\n  SC$1.$cctor();\n  return SC$1.code;\n };\n Layout.snippets=function()\n {\n  SC$1.$cctor();\n  return SC$1.snippets;\n };\n Layout.titleX=function()\n {\n  SC$1.$cctor();\n  return SC$1.titleX;\n };\n Layout.actFindDefinition=function()\n {\n  SC$1.$cctor();\n  return SC$1.actFindDefinition;\n };\n Layout.actCompileWS=function()\n {\n  SC$1.$cctor();\n  return SC$1.actCompileWS;\n };\n Layout.actParseCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actParseCode;\n };\n Layout.actRunWSIn=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunWSIn;\n };\n Layout.actRunWSHere=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunWSHere;\n };\n Layout.actRunWSNewTab=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunWSNewTab;\n };\n Layout.actRunFable=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunFable;\n };\n Layout.actRunFableFs=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunFableFs;\n };\n Layout.actEvalCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actEvalCode;\n };\n Layout.actEvalFsCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actEvalFsCode;\n };\n Layout.actGetFsCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actGetFsCode;\n };\n Layout.actOutdentSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actOutdentSnippet;\n };\n Layout.actIndentSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actIndentSnippet;\n };\n Layout.actDeleteSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actDeleteSnippet;\n };\n Layout.actAddSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actAddSnippet;\n };\n Layout.actSaveFile=function()\n {\n  SC$1.$cctor();\n  return SC$1.actSaveFile;\n };\n Layout.actLoadFile=function()\n {\n  SC$1.$cctor();\n  return SC$1.actLoadFile;\n };\n SC$1.$cctor=function()\n {\n  SC$1.$cctor=Global.ignore;\n  SC$1.result=new ropBuilder.New$1();\n  SC$1.fromResult=Result.toResultS$1;\n  SC$1.toResult=Result.fromResultS$1;\n  SC$1.errOptionIsNone=new ErrOptionIsNone.New$1();\n  SC$1.wrap=new Builder.New$1();\n  SC$1.wrapper=new Builder.New$1();\n  SC$1.computersData=List.ofArray([Computer.New$4(\"ABEASUS\",\"ABEASUS\",\"60:57:18:8E:F1:02\"),Computer.New$5(\"NeoRouter\",\"192.168.195.1\"),Computer.New$4(\"Router1\",\"192.168.5.1\",\"9c:d3:6d:b7:cb:e6\"),Computer.New$4(\"Router2\",\"192.168.5.3\",\"E0:91:F5:DE:F4:EC\"),Computer.New$4(\"Router2\",\"192.168.5.40\",\"E0:91:F5:DE:F4:ED\"),Computer.New$5(\"OOMA\",\"192.168.5.2\"),Computer.New$5(\"EXSi\",\"192.168.5.5\"),Computer.New$5(\"Modem\",\"192.168.100.1\"),Computer.New$5(\"ABEHOME\",\"192.168.5.4\"),Computer.New$5(\"ABEHOME\",\"ABEHOME\"),Computer.New$1(\"AbeRaspi\",\"192.168.5.41\",2200,\"80:1F:02:D3:77:3D\",\"pi\"),Computer.New$1(\"AbeRaspiNr\",\"192.168.195.42\",2200,\"b8:27:eb:1a:ad:21\",\"pi\"),Computer.New$1(\"OldHTC\",\"192.168.5.39\",2222,\"D8:B3:77:56:42:3E\",\"Abe\"),Computer.New$5(\"AbeWCam\",\"192.168.5.127\"),Computer.New$5(\"JJJGarage\",\"192.168.15.242\"),Computer.New$5(\"FILESERVER1\",\"FILESERVER1\"),Computer.New$5(\"AbeRainMachine\",\"192.168.5.240\"),Computer.New$4(\"Thermo-Abajo\",\"192.168.5.252\",\"44a7cf5e3548\"),Computer.New$4(\"Thermo-Arriba\",\"192.168.5.253\",\"5cdad4fdb7d1\"),Computer.New$5(\"Google DNS\",\"8.8.8.8\")]);\n  SC$1.computers=List.map(function(c)\n  {\n   var o;\n   return[c.name,(o=c.ip,o==null?c.name:o.$0)];\n  },Garage.computersData());\n  SC$1.actLoadFile=\"actLoadFile\";\n  SC$1.actSaveFile=\"actSaveFile\";\n  SC$1.actAddSnippet=\"actAddSnippet\";\n  SC$1.actDeleteSnippet=\"actDeleteSnippet\";\n  SC$1.actIndentSnippet=\"actIndentSnippet\";\n  SC$1.actOutdentSnippet=\"actOutdentSnippet\";\n  SC$1.actGetFsCode=\"actGetFsCode\";\n  SC$1.actEvalFsCode=\"actEvalFsCode\";\n  SC$1.actEvalCode=\"actEvalCode\";\n  SC$1.actRunFableFs=\"actRunFableFs\";\n  SC$1.actRunFable=\"actRunFable\";\n  SC$1.actRunWSNewTab=\"actRunWSNewTab\";\n  SC$1.actRunWSHere=\"actRunWSHere\";\n  SC$1.actRunWSIn=\"actRunWSIn\";\n  SC$1.actParseCode=\"actParseCode\";\n  SC$1.actCompileWS=\"actCompileWS\";\n  SC$1.actFindDefinition=\"actFindDefinition\";\n  SC$1.titleX=\"title\";\n  SC$1.snippets=\"snippets\";\n  SC$1.code=\"code\";\n  SC$1.buttons=\"buttons\";\n  SC$1.menu=\"menu\";\n  SC$1.Output=\"Output\";\n  SC$1.Parser=\"Parser\";\n  SC$1.JavaScript=\"JavaScript\";\n  SC$1.FScode=\"F# code\";\n  SC$1.WSResult=\"WS Result\";\n  SC$1.Properties=\"Properties\";\n  SC$1.dummyAction=Action.New$1(\"dummy\");\n  SC$1.guiParts=new FSharpMap.New(List.ofArray([[Layout.actLoadFile(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actSaveFile(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actAddSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actDeleteSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actIndentSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actOutdentSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actGetFsCode(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actEvalCode(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actRunWSNewTab(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actRunWSHere(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actRunWSIn(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actParseCode(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actCompileWS(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actFindDefinition(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.titleX(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"title\")\n  })],[Layout.snippets(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"snippets\")\n  })],[Layout.code(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"editor\")\n  })],[Layout.buttons(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"buttons\")\n  })],[Layout.menu(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"menu\")\n  })],[Layout.Output(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"Output\")\n  })],[Layout.Parser(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"Parser\")\n  })],[Layout.JavaScript(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"JavaScript\")\n  })],[Layout.FScode(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"F# code\")\n  })],[Layout.WSResult(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"WS Result\")\n  })],[Layout.Properties(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"Properties\")\n  })]]));\n  SC$1.layout=[];\n };\nLayout.setLayout(Layout.getLayout);})()"}},{"name":"Thermostat Message","content":"\ntype ThermostatMessage = THMData of name:string * values:(string * string) []\n\n","parent":{"$":0,"Item":"5adf83e3-c555-4cd2-ab88-e8af42691daf"},"predecessors":[],"id":{"$":0,"Item":"77ddaeb8-a657-4246-8f17-65e10712930f"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Adb Run OpenGarage3","content":"open Useful\nopen UsefulDotNet\nopen Adb\n\nlet Adb_Run_OpenGarage3_Present = true\n\nlet shell    c = Adb.shell    c |> ignore\nlet shellSU  c = Adb.shellSU  c |> ignore\nlet keyevent k = Adb.keyevent k |> ignore\n\ntype PhoneCapabilities = {\n    connect       : unit                      -> unit\n    screenCapture : string                    -> unit\n    unlockScreen  : unit                      -> unit\n    click         : (int * int)               -> unit\n    dragDrop      : (int * int) * (int * int) -> unit\n}\n\nlet mutable currentPhoneN = None\n\nlet messaging = new WSMessagingBroker.FStationMessaging(\"screenCapture\")\n\nlet refreshCapture() = messaging.RunActionCall(\"Refresh\", \"actRunFableFs\", [| |])\n\nlet AbeFi = {\n    connect       = fun () -> currentPhoneN <- Some 2; Adb.connectUSB() |> ignore\n    screenCapture = fun file ->\n        Wrap.wrapper {\n            printfn \"%s\" <| Adb.captureScreen2 file\n            return! refreshCapture()\n        } |> Wrap.runSynchronouslyS false |> ignore\n    unlockScreen  = fun ()     -> keyevent 82 ; keyevent 66\n    click         = fun (x, y) -> shell <| sprintf \"input tap %d %d\" x y\n    dragDrop      = fun _ -> printfn \"not implemented dragDrop\"\n}\n\nlet file = @\".\\website\\screen.png\"\n    \nlet clickHtc (x, y) = \n    [\n        \"sendevent /dev/input/event2 3 48 58 \"\n        \"sendevent /dev/input/event2 3 50 58 \"\n        \"sendevent /dev/input/event2 3 58 58 \"\n        sprintf \"sendevent /dev/input/event2 3 53 %d \" (x * 2)\n        sprintf \"sendevent /dev/input/event2 3 54 %d \"  y\n        \"sendevent /dev/input/event2 0 2 0   \"\n        \"sendevent /dev/input/event2 1 330 1 \"\n        \"sendevent /dev/input/event2 0 0 0   \"\n        \"sendevent /dev/input/event2 3 48 58 \"\n        \"sendevent /dev/input/event2 3 50 58 \"\n        \"sendevent /dev/input/event2 3 58 58 \"\n        sprintf \"sendevent /dev/input/event2 3 53 %d \" (x * 2)\n        sprintf \"sendevent /dev/input/event2 3 54 %d \"  y\n        \"sendevent /dev/input/event2 0 2 0   \"\n        \"sendevent /dev/input/event2 0 0 0   \"\n        \"usleep 50 \"\n        \"sendevent /dev/input/event2 0 2 0   \"\n        \"sendevent /dev/input/event2 1 330 0 \"\n        \"sendevent /dev/input/event2 0 0 0   \"\n        \"usleep 500 \"\n    ] |> String.concat \" ; \"\n    |> shell\n\nlet dragDropHtc ((x1, y1), (x2,y2)) = \n    ((x1, y1), (x2,y2)) |> printfn \"sending swipe at %A\"\n    [\n        \"sendevent /dev/input/event2 3 48 58 \"\n        \"sendevent /dev/input/event2 3 50 58 \"\n        \"sendevent /dev/input/event2 3 58 58 \"\n        sprintf \"sendevent /dev/input/event2 3 53 %d \" (x1 * 2)\n        sprintf \"sendevent /dev/input/event2 3 54 %d \"  y1\n        \"sendevent /dev/input/event2 0 2 0   \"\n        \"sendevent /dev/input/event2 1 330 1 \"\n        \"sendevent /dev/input/event2 0 0 0   \"\n        \"usleep 500 \"\n        \"sendevent /dev/input/event2 3 48 58 \"\n        \"sendevent /dev/input/event2 3 50 58 \"\n        \"sendevent /dev/input/event2 3 58 58 \"\n        sprintf \"sendevent /dev/input/event2 3 53 %d \" (x2 * 2)\n        sprintf \"sendevent /dev/input/event2 3 54 %d \"  y2\n        \"sendevent /dev/input/event2 0 2 0   \"\n        \"sendevent /dev/input/event2 0 0 0   \"\n        \"usleep 50 \"\n        \"sendevent /dev/input/event2 0 2 0   \"\n        \"sendevent /dev/input/event2 1 330 0 \"\n        \"sendevent /dev/input/event2 0 0 0   \"\n        \"usleep 500 \"\n    ] |> String.concat \" ; \"\n    |> shell\n\nlet OldHtc = {\n    connect       = fun () -> currentPhoneN <- Some 1; Adb.connectWifi   OldHtcIp |> ignore\n    screenCapture = fun file ->\n        Wrap.wrapper {\n            Adb.captureScreen \"/data/local/screen.png\" file\n            return! refreshCapture()\n        } |> Wrap.runSynchronouslyS false |> ignore\n    unlockScreen  = fun () -> shell   \"/data/local/unlock.sh\"\n    click         = clickHtc\n    dragDrop      = dragDropHtc\n}\n\nlet Cyanogen = {\n    connect       = fun () -> currentPhoneN <- Some 3; Adb.connectUSB() |> ignore\n    screenCapture = Adb.captureScreen \"/data/local/screen.png\"\n    unlockScreen  = fun () -> shell   \"/data/local/unlock.sh\"\n    click         = clickHtc\n    dragDrop      = dragDropHtc\n}\n\nlet mapPhone f =\n    let map fm =\n        match currentPhoneN with \n        //| Some 1 -> Some OldHtc\n        | Some 2 -> Some AbeFi\n        | Some 3 -> Some Cyanogen\n        | _      -> Some OldHtc\n        |> Option.map fm\n        |> Option.defaultWith (fun () -> eprintfn \"Connect to phone first\")\n    if devices().Split('\\n').Length < 2 then\n        map (fun ph -> ph.connect())\n    map f\n    \nlet shellPh c = \n    if devices().Split('\\n').Length < 2 then\n        mapPhone (fun ph -> ph.connect())\n    shell c\n\nlet click p =\n    async {\n        mapPhone (fun ph -> printfn \"sending click %A\" p ; ph.click p)\n        do! Async.Sleep 1000\n        mapPhone (fun ph -> ph.screenCapture file)\n    } |> Async.RunSynchronously\n\nlet dragDrop p =\n    async {\n        mapPhone (fun ph -> printfn \"sending swipe %A\" p ; ph.dragDrop p)\n        do! Async.Sleep 1000\n        mapPhone (fun ph -> ph.screenCapture file)\n    } |> Async.RunSynchronously\n\n\nopen Useful\nopen UsefulDotNet\n\nlet client passphrase = \n    new Renci.SshNet.PrivateKeyFile(@\"D:\\Abelardo\\Documents\\MobaXterm\\home\\.ssh\\id_rsa\", passphrase)\n    |> getClientRsa OldHtcIp OldHtcPort OldHtcUser\n\nlet mutable OldHtcPassword = None\n\nlet doCmdSsh cmd = \n    if OldHtcPassword = None then printfn \"Passphrase not set\" else\n    doCmd (client OldHtcPassword.Value) cmd\n\n//let activateWifiSSH() = doCmdSsh \"ls -la\\n\"\n//let activateWifiSSH() = doCmdSSH \"su -c /home/local/airAdb.sh\"\nlet activateWifiSSH() = doCmdSsh \"su -c 'setprop service.adb.tcp.port 5555 ; stop adbd ; start adbd'\"\n\n// usage: input [text|keyevent]\n//   input text <string>\n//   input keyevent <event_code>\n// \n// 0 -->  \"KEYCODE_UNKNOWN\" \n// 1 -->  \"KEYCODE_MENU\" \n// 2 -->  \"KEYCODE_SOFT_RIGHT\" \n// 3 -->  \"KEYCODE_HOME\" \n// 4 -->  \"KEYCODE_BACK\" \n// 5 -->  \"KEYCODE_CALL\" \n// 6 -->  \"KEYCODE_ENDCALL\" \n// 7 -->  \"KEYCODE_0\" \n// 8 -->  \"KEYCODE_1\" \n// 9 -->  \"KEYCODE_2\" \n// 10 -->  \"KEYCODE_3\" \n// 11 -->  \"KEYCODE_4\" \n// 12 -->  \"KEYCODE_5\" \n// 13 -->  \"KEYCODE_6\" \n// 14 -->  \"KEYCODE_7\" \n// 15 -->  \"KEYCODE_8\" \n// 16 -->  \"KEYCODE_9\" \n// 17 -->  \"KEYCODE_STAR\" \n// 18 -->  \"KEYCODE_POUND\" \n// 19 -->  \"KEYCODE_DPAD_UP\" \n// 20 -->  \"KEYCODE_DPAD_DOWN\" \n// 21 -->  \"KEYCODE_DPAD_LEFT\" \n// 22 -->  \"KEYCODE_DPAD_RIGHT\" \n// 23 -->  \"KEYCODE_DPAD_CENTER\" \n// 24 -->  \"KEYCODE_VOLUME_UP\" \n// 25 -->  \"KEYCODE_VOLUME_DOWN\" \n// 26 -->  \"KEYCODE_POWER\" \n// 27 -->  \"KEYCODE_CAMERA\" \n// 28 -->  \"KEYCODE_CLEAR\" \n// 29 -->  \"KEYCODE_A\" \n// 30 -->  \"KEYCODE_B\" \n// 31 -->  \"KEYCODE_C\" \n// 32 -->  \"KEYCODE_D\" \n// 33 -->  \"KEYCODE_E\" \n// 34 -->  \"KEYCODE_F\" \n// 35 -->  \"KEYCODE_G\" \n// 36 -->  \"KEYCODE_H\" \n// 37 -->  \"KEYCODE_I\" \n// 38 -->  \"KEYCODE_J\" \n// 39 -->  \"KEYCODE_K\" \n// 40 -->  \"KEYCODE_L\" \n// 41 -->  \"KEYCODE_M\" \n// 42 -->  \"KEYCODE_N\" \n// 43 -->  \"KEYCODE_O\" \n// 44 -->  \"KEYCODE_P\" \n// 45 -->  \"KEYCODE_Q\" \n// 46 -->  \"KEYCODE_R\" \n// 47 -->  \"KEYCODE_S\" \n// 48 -->  \"KEYCODE_T\" \n// 49 -->  \"KEYCODE_U\" \n// 50 -->  \"KEYCODE_V\" \n// 51 -->  \"KEYCODE_W\" \n// 52 -->  \"KEYCODE_X\" \n// 53 -->  \"KEYCODE_Y\" \n// 54 -->  \"KEYCODE_Z\" \n// 55 -->  \"KEYCODE_COMMA\" \n// 56 -->  \"KEYCODE_PERIOD\" \n// 57 -->  \"KEYCODE_ALT_LEFT\" \n// 58 -->  \"KEYCODE_ALT_RIGHT\" \n// 59 -->  \"KEYCODE_SHIFT_LEFT\" \n// 60 -->  \"KEYCODE_SHIFT_RIGHT\" \n// 61 -->  \"KEYCODE_TAB\" \n// 62 -->  \"KEYCODE_SPACE\" \n// 63 -->  \"KEYCODE_SYM\" \n// 64 -->  \"KEYCODE_EXPLORER\" \n// 65 -->  \"KEYCODE_ENVELOPE\" \n// 66 -->  \"KEYCODE_ENTER\" \n// 67 -->  \"KEYCODE_DEL\" \n// 68 -->  \"KEYCODE_GRAVE\" \n// 69 -->  \"KEYCODE_MINUS\" \n// 70 -->  \"KEYCODE_EQUALS\" \n// 71 -->  \"KEYCODE_LEFT_BRACKET\" \n// 72 -->  \"KEYCODE_RIGHT_BRACKET\" \n// 73 -->  \"KEYCODE_BACKSLASH\" \n// 74 -->  \"KEYCODE_SEMICOLON\" \n// 75 -->  \"KEYCODE_APOSTROPHE\" \n// 76 -->  \"KEYCODE_SLASH\" \n// 77 -->  \"KEYCODE_AT\" \n// 78 -->  \"KEYCODE_NUM\" \n// 79 -->  \"KEYCODE_HEADSETHOOK\" \n// 80 -->  \"KEYCODE_FOCUS\" \n// 81 -->  \"KEYCODE_PLUS\" \n// 82 -->  \"KEYCODE_MENU\" \n// 83 -->  \"KEYCODE_NOTIFICATION\" \n// 84 -->  \"KEYCODE_SEARCH\" \n// 85 -->  \"TAG_LAST_KEYCODE\"\n// \n// \n// Image capture mode: adb shell \"am start -a android.media.action.IMAGE_CAPTURE\"\n// Video capture mode: adb shell \"am start -a android.media.action.VIDEO_CAPTURE\"\n// To focus: adb shell \"input keyevent KEYCODE_FOCUS\"\n// To take a photo or start/stop recording: adb shell \"input keyevent KEYCODE_CAMERA\"\n// ","parent":{"$":0,"Item":"5adf83e3-c555-4cd2-ab88-e8af42691daf"},"predecessors":[{"$":0,"Item":"4413b3ee-f968-458d-8a5f-7a7c9281c38f"},{"$":0,"Item":"7bb04b3c-b71e-4827-bd9e-b18fbabc1495"},{"$":0,"Item":"555306ec-f8cc-455f-b01f-9d86fbb2682d"},{"$":0,"Item":"bff6817d-fe67-4777-9a13-50393e8900c4"}],"id":{"$":0,"Item":"e8cbf634-01c4-4231-ab2a-6eec6905ac0c"},"expanded":true,"level":0,"levelCode":0,"properties":{"ls":"shell \"ls -la /data/local/\"","flash On":"shellSU \"'echo 1 > /sys/class/leds/flashlight/brightness'\"","cat":"shellSU \"cat /data/local/unlock.sh\"","CHECK":"checkApp \"OpenGarage3.OpenGarage3\" ","shell":"shell \"service list\" ","Screen off":"keyevent 86\nkeyevent 26","unlock":"shell \"/data/local/unlock.sh\"","Screen lock":"keyevent 86\nkeyevent 26\nkeyevent 26\n","unlockx":"keyevent 86\nkeyevent 26\n\n","Screen unlock":"mapPhone (fun ph -> ph.unlockScreen() )","flash Off":"shellSU \"'echo 0 > /sys/class/leds/flashlight/brightness'\"","checkScreenOn":"shell \"dumpsys input_method | grep ScreenOn\"","BACK":"keyevent 4","HOME":"keyevent 3","MENU":"keyevent 1","open":"open FSSGlobal.UsefulDotNet.Adb\nopen FSSGlobal.Garage","Wifi Keyboard":"FSSGlobal.UsefulDotNet.RunProcess.startProcess (sprintf \"http://%s:7777\" OldHtcIp) \"\"","supplicantWifi":"shellSU \"cat /data/misc/wifi/wpa_supplicant.conf\"","enableWifi":"shellSU \"svc wifi enable\"","Refresh":"let [< Fable.Core.Emit \"Date.now()\" >] now() = 1\nlet screen = Fable.Import.Browser.document.getElementById(\"PhoneScreen\")\nscreen.setAttribute(\"src\", screen.getAttribute(\"src\").Split('=').[0] \n|> sprintf \"%s=%d\" <| now())\n","Camera":"shellPh \"am start -a android.media.action.IMAGE_CAPTURE\"","Capture Screen":"mapPhone (fun ph -> ph.screenCapture file)","run OpenGarage3":"runCheckApp \"OpenGarage3.OpenGarage3\"","LayoutJS":"( function()\n{\n \"use strict\";\n var Global,FSSGlobal,Layout,SC$1,Date,WebSharper,Seq,IntelliFactory,Runtime,Utils,HtmlNode,UI,AttrProxy,Useful,String,Option,Template,Button,Result,console,Layout$1,List,Action,Collections,FSharpMap,Input;\n Global=window;\n FSSGlobal=Global.FSSGlobal=Global.FSSGlobal||{};\n Layout=FSSGlobal.Layout=FSSGlobal.Layout||{};\n SC$1=Global[\"StartupCode$Temp_doqgocts$bf864f3c-1370-42f2-ac8a-565a604892e8 FSSGlobal\"]=Global[\"StartupCode$Temp_doqgocts$bf864f3c-1370-42f2-ac8a-565a604892e8 FSSGlobal\"]||{};\n Date=Global.Date;\n WebSharper=Global.WebSharper;\n Seq=WebSharper&&WebSharper.Seq;\n IntelliFactory=Global.IntelliFactory;\n Runtime=IntelliFactory&&IntelliFactory.Runtime;\n Utils=WebSharper&&WebSharper.Utils;\n HtmlNode=FSSGlobal&&FSSGlobal.HtmlNode;\n UI=WebSharper&&WebSharper.UI;\n AttrProxy=UI&&UI.AttrProxy;\n Useful=FSSGlobal&&FSSGlobal.Useful;\n String=Useful&&Useful.String;\n Option=Useful&&Useful.Option;\n Template=FSSGlobal&&FSSGlobal.Template;\n Button=Template&&Template.Button;\n Result=Useful&&Useful.Result;\n console=Global.console;\n Layout$1=Template&&Template.Layout;\n List=WebSharper&&WebSharper.List;\n Action=Template&&Template.Action;\n Collections=WebSharper&&WebSharper.Collections;\n FSharpMap=Collections&&Collections.FSharpMap;\n Input=Template&&Template.Input;\n Layout.getLayout=function(lyt,snp)\n {\n  function m(a)\n  {\n   var t;\n   return a===\"Image\"?Layout.image((function($1)\n   {\n    return function($2)\n    {\n     return $1(\"/screen.png?time=\"+Global.String($2));\n    };\n   }(Global.id))(Date.now())):a===\"Refresh\"?(t=Layout.passNoParm(\"Refresh\"),Layout.runFableFsButton(lyt,t[0],t[1])):a===\"Passphrase\"?Layout.password().Prefix$1(Layout.buttonPwd(Layout.sendPwdCode,lyt)).get_Render():(Layout.evalFsCodeButtonNoParm(lyt))(a);\n  }\n  return Layout.getButtonsLayout(function(s)\n  {\n   return Seq.map(m,s);\n  },snp);\n };\n Layout.image$18$39=Runtime.Curried3(function($1,em,ev)\n {\n  var $2,$3;\n  ev.preventDefault();\n  return Layout.doGuiCall(\"clickScreen\",Layout.actEvalFsCode(),[\"Code\",($2=[(Layout.dragStartCoords())[0]*em.naturalWidth/em.width>>0,(Layout.dragStartCoords())[1]*em.naturalHeight/em.height>>0],($3=[ev.offsetX*em.naturalWidth/em.width>>0,ev.offsetY*em.naturalHeight/em.height>>0],(function($4)\n  {\n   return function($5)\n   {\n    return $4(\"dragDrop \"+(\"(\"+(\"(\"+Utils.prettyPrint($5[0][0])+\", \"+Utils.prettyPrint($5[0][1])+\")\")+\", \"+(\"(\"+Utils.prettyPrint($5[1][0])+\", \"+Utils.prettyPrint($5[1][1])+\")\")+\")\"));\n   };\n  }(Global.id))([$2,$3])))]);\n });\n Layout.image$17$39=Runtime.Curried3(function($1,$2,ev)\n {\n  return Layout.set_dragStartCoords([ev.offsetX,ev.offsetY]);\n });\n Layout.image$16$39=Runtime.Curried3(function($1,$2,ev)\n {\n  return ev.preventDefault();\n });\n Layout.image$15$39=Runtime.Curried3(function($1,$2,ev)\n {\n  return ev.preventDefault();\n });\n Layout.image$10$40=Runtime.Curried3(function($1,em,ev)\n {\n  var $2,$3;\n  return Layout.doGuiCall(\"clickScreen\",Layout.actEvalFsCode(),[\"Code\",($2=ev.offsetX*em.naturalWidth/em.width>>0,($3=ev.offsetY*em.naturalHeight/em.height>>0,(function($4)\n  {\n   return function($5)\n   {\n    return $4(\"click \"+(\"(\"+Utils.prettyPrint($5[0])+\", \"+Utils.prettyPrint($5[1])+\")\"));\n   };\n  }(Global.id))([$2,$3])))]);\n });\n Layout.image=function(file)\n {\n  function a(em,ev)\n  {\n   var $1,$2;\n   return Layout.doGuiCall(\"clickScreen\",Layout.actEvalFsCode(),[\"Code\",($1=ev.offsetX*em.naturalWidth/em.width>>0,($2=ev.offsetY*em.naturalHeight/em.height>>0,(function($3)\n   {\n    return function($4)\n    {\n     return $3(\"click \"+(\"(\"+Utils.prettyPrint($4[0])+\", \"+Utils.prettyPrint($4[1])+\")\"));\n    };\n   }(Global.id))([$1,$2])))]);\n  }\n  function a$1(a$5,ev)\n  {\n   return ev.preventDefault();\n  }\n  function a$2(a$5,ev)\n  {\n   return ev.preventDefault();\n  }\n  function a$3(a$5,ev)\n  {\n   return Layout.set_dragStartCoords([ev.offsetX,ev.offsetY]);\n  }\n  function a$4(em,ev)\n  {\n   var $1,$2;\n   ev.preventDefault();\n   return Layout.doGuiCall(\"clickScreen\",Layout.actEvalFsCode(),[\"Code\",($1=[(Layout.dragStartCoords())[0]*em.naturalWidth/em.width>>0,(Layout.dragStartCoords())[1]*em.naturalHeight/em.height>>0],($2=[ev.offsetX*em.naturalWidth/em.width>>0,ev.offsetY*em.naturalHeight/em.height>>0],(function($3)\n   {\n    return function($4)\n    {\n     return $3(\"dragDrop \"+(\"(\"+(\"(\"+Utils.prettyPrint($4[0][0])+\", \"+Utils.prettyPrint($4[0][1])+\")\")+\", \"+(\"(\"+Utils.prettyPrint($4[1][0])+\", \"+Utils.prettyPrint($4[1][1])+\")\")+\")\"));\n    };\n   }(Global.id))([$1,$2])))]);\n  }\n  return HtmlNode.img([HtmlNode.src(file),new HtmlNode.HtmlNode({\n   $:8,\n   $0:AttrProxy.HandlerImpl(\"click\",function($1)\n   {\n    return function($2)\n    {\n     return a($1,$2);\n    };\n   })\n  }),new HtmlNode.HtmlNode({\n   $:8,\n   $0:AttrProxy.HandlerImpl(\"dragover\",function($1)\n   {\n    return function($2)\n    {\n     return a$1($1,$2);\n    };\n   })\n  }),new HtmlNode.HtmlNode({\n   $:8,\n   $0:AttrProxy.HandlerImpl(\"drag\",function($1)\n   {\n    return function($2)\n    {\n     return a$2($1,$2);\n    };\n   })\n  }),new HtmlNode.HtmlNode({\n   $:8,\n   $0:AttrProxy.HandlerImpl(\"dragstart\",function($1)\n   {\n    return function($2)\n    {\n     return a$3($1,$2);\n    };\n   })\n  }),new HtmlNode.HtmlNode({\n   $:8,\n   $0:AttrProxy.HandlerImpl(\"drop\",function($1)\n   {\n    return function($2)\n    {\n     return a$4($1,$2);\n    };\n   })\n  }),HtmlNode.Id(\"PhoneScreen\"),HtmlNode.style(\"width: 95%\")]);\n };\n Layout.dragStartCoords=function()\n {\n  SC$1.$cctor();\n  return SC$1.dragStartCoords;\n };\n Layout.set_dragStartCoords=function($1)\n {\n  SC$1.$cctor();\n  SC$1.dragStartCoords=$1;\n };\n Layout.sendPwdCode=function()\n {\n  return(function($1)\n  {\n   return function($2)\n   {\n    return $1(\"FSSGlobal.Garage.OldHtcPassword <- Some \"+Utils.prettyPrint($2));\n   };\n  }(Global.id))(Layout.password().get_Var().Get());\n };\n Layout.password=function()\n {\n  SC$1.$cctor();\n  return SC$1.password;\n };\n Layout.getButtonsLayout=function(f,snp)\n {\n  return Layout.extraButtonsLayout(f(Seq.filter(function(y)\n  {\n   return\"\"!==y;\n  },Seq.map(String.trim,String.splitByChar(\"\\n\",Option.defaultValue(\"\",function(d)\n  {\n   var res;\n   res=null;\n   return d.TryGetValue(\"LayoutButtons\",{\n    get:function()\n    {\n     return res;\n    },\n    set:function(v)\n    {\n     res=v;\n    }\n   })?{\n    $:1,\n    $0:res\n   }:null;\n  }(snp.properties)))))));\n };\n Layout.buttonPwd=function(code,lyt)\n {\n  return Button.New$1(\"Send\").OnClick(Runtime.Curried(Layout.sendPwd,2,[code,lyt])).get_Render();\n };\n Layout.sendPwd=function(code,lyt,el,ev)\n {\n  var a,act,x,o;\n  a=Result.Success(lyt.GetGuiCallAction(\"sendPwd\",\"actEvalFsCode\",[\"Code\",code()]));\n  a.$==1?(function($1)\n  {\n   return function($2)\n   {\n    return $1(Utils.printArray(Utils.prettyPrint,$2));\n   };\n  }(function(s)\n  {\n   console.log(s);\n  }))(a.$0):(act=a.$0[0],x=(o=act.onClick,o==null?null:{\n   $:1,\n   $0:((o.$0(act))(el))(ev)\n  }),Option.defaultWith(function($1)\n  {\n   return function()\n   {\n    return $1(\"OnClick is null\");\n   };\n  }(function(s)\n  {\n   console.log(s);\n  }),x));\n };\n Layout.evalFsCodeButtonNoParms=function(lyt)\n {\n  var f,f$1;\n  function p(y)\n  {\n   return\"\"!==y;\n  }\n  function g(t)\n  {\n   return Layout.evalFsCodeButtons(lyt,t);\n  }\n  f=(f$1=function(s)\n  {\n   return Seq.filter(p,s);\n  },function(x)\n  {\n   return Layout.passNoParms(f$1(x));\n  });\n  return function(x)\n  {\n   return g(f(x));\n  };\n };\n Layout.evalFsCodeButtonNoParm=function(lyt)\n {\n  function g(t,p)\n  {\n   return Layout.evalFsCodeButton(lyt,t,p);\n  }\n  return function(x)\n  {\n   return g.apply(null,Layout.passNoParm(x));\n  };\n };\n Layout.passNoParms=function(txts)\n {\n  return Seq.map(Layout.passNoParm,txts);\n };\n Layout.passNoParm=function(txt)\n {\n  return[txt,[]];\n };\n Layout.runFableFsButton=function(lyt,txt,parms)\n {\n  return lyt.GetCallButton(txt,Layout.actRunFableFs(),parms);\n };\n Layout.evalFsCodeButtons=function(lyt,txts)\n {\n  function m(t,p)\n  {\n   return Layout.evalFsCodeButton(lyt,t,p);\n  }\n  return Seq.map(function($1)\n  {\n   return m($1[0],$1[1]);\n  },txts);\n };\n Layout.evalFsCodeButton=function(lyt,txt,parms)\n {\n  return lyt.GetCallButton(txt,Layout.actEvalFsCode(),parms);\n };\n Layout.extraButtonsLayout=function(buttons)\n {\n  return Layout$1.AddGuids([[\"extrabuttons\",new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.div(List.ofSeq(Seq.delay(function()\n   {\n    return Seq.append([HtmlNode.style(\"text-align: center ; overflow: auto ; \")],Seq.delay(function()\n    {\n     return Seq.append(buttons,Seq.delay(function()\n     {\n      return[HtmlNode.css(\" button.btn { margin: 2px; font-size: small; } \")];\n     }));\n    }));\n   })))\n  })],[\"main_extra\",Template.varVerSplitter(85,\"main_messages\",\"extrabuttons\",50,100)],[\"main\",Template.fixedHorSplitter(true,50,\"menu\",\"main_extra\")]]);\n };\n Layout.layout=function()\n {\n  SC$1.$cctor();\n  return SC$1.layout;\n };\n Layout.set_layout=function($1)\n {\n  SC$1.$cctor();\n  SC$1.layout=$1;\n };\n Layout.doGuiCall=function(name,action,parms)\n {\n  Global.doFSharpStationGuiCall([name,action,parms]);\n };\n Layout.setLayout=function(f)\n {\n  Global.setFSharpStationLayout(f);\n };\n Layout.guiParts=function()\n {\n  SC$1.$cctor();\n  return SC$1.guiParts;\n };\n Layout.dummyAction=function()\n {\n  SC$1.$cctor();\n  return SC$1.dummyAction;\n };\n Layout.Properties=function()\n {\n  SC$1.$cctor();\n  return SC$1.Properties;\n };\n Layout.WSResult=function()\n {\n  SC$1.$cctor();\n  return SC$1.WSResult;\n };\n Layout.FScode=function()\n {\n  SC$1.$cctor();\n  return SC$1.FScode;\n };\n Layout.JavaScript=function()\n {\n  SC$1.$cctor();\n  return SC$1.JavaScript;\n };\n Layout.Parser=function()\n {\n  SC$1.$cctor();\n  return SC$1.Parser;\n };\n Layout.Output=function()\n {\n  SC$1.$cctor();\n  return SC$1.Output;\n };\n Layout.menu=function()\n {\n  SC$1.$cctor();\n  return SC$1.menu;\n };\n Layout.buttons=function()\n {\n  SC$1.$cctor();\n  return SC$1.buttons;\n };\n Layout.code=function()\n {\n  SC$1.$cctor();\n  return SC$1.code;\n };\n Layout.snippets=function()\n {\n  SC$1.$cctor();\n  return SC$1.snippets;\n };\n Layout.titleX=function()\n {\n  SC$1.$cctor();\n  return SC$1.titleX;\n };\n Layout.actFindDefinition=function()\n {\n  SC$1.$cctor();\n  return SC$1.actFindDefinition;\n };\n Layout.actCompileWS=function()\n {\n  SC$1.$cctor();\n  return SC$1.actCompileWS;\n };\n Layout.actParseCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actParseCode;\n };\n Layout.actRunWSIn=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunWSIn;\n };\n Layout.actRunWSHere=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunWSHere;\n };\n Layout.actRunWSNewTab=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunWSNewTab;\n };\n Layout.actRunFable=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunFable;\n };\n Layout.actRunFableFs=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunFableFs;\n };\n Layout.actEvalCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actEvalCode;\n };\n Layout.actEvalFsCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actEvalFsCode;\n };\n Layout.actGetFsCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actGetFsCode;\n };\n Layout.actOutdentSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actOutdentSnippet;\n };\n Layout.actIndentSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actIndentSnippet;\n };\n Layout.actDeleteSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actDeleteSnippet;\n };\n Layout.actAddSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actAddSnippet;\n };\n Layout.actSaveFile=function()\n {\n  SC$1.$cctor();\n  return SC$1.actSaveFile;\n };\n Layout.actLoadFile=function()\n {\n  SC$1.$cctor();\n  return SC$1.actLoadFile;\n };\n SC$1.$cctor=function()\n {\n  SC$1.$cctor=Global.ignore;\n  SC$1.actLoadFile=\"actLoadFile\";\n  SC$1.actSaveFile=\"actSaveFile\";\n  SC$1.actAddSnippet=\"actAddSnippet\";\n  SC$1.actDeleteSnippet=\"actDeleteSnippet\";\n  SC$1.actIndentSnippet=\"actIndentSnippet\";\n  SC$1.actOutdentSnippet=\"actOutdentSnippet\";\n  SC$1.actGetFsCode=\"actGetFsCode\";\n  SC$1.actEvalFsCode=\"actEvalFsCode\";\n  SC$1.actEvalCode=\"actEvalCode\";\n  SC$1.actRunFableFs=\"actRunFableFs\";\n  SC$1.actRunFable=\"actRunFable\";\n  SC$1.actRunWSNewTab=\"actRunWSNewTab\";\n  SC$1.actRunWSHere=\"actRunWSHere\";\n  SC$1.actRunWSIn=\"actRunWSIn\";\n  SC$1.actParseCode=\"actParseCode\";\n  SC$1.actCompileWS=\"actCompileWS\";\n  SC$1.actFindDefinition=\"actFindDefinition\";\n  SC$1.titleX=\"title\";\n  SC$1.snippets=\"snippets\";\n  SC$1.code=\"code\";\n  SC$1.buttons=\"buttons\";\n  SC$1.menu=\"menu\";\n  SC$1.Output=\"Output\";\n  SC$1.Parser=\"Parser\";\n  SC$1.JavaScript=\"JavaScript\";\n  SC$1.FScode=\"F# code\";\n  SC$1.WSResult=\"WS Result\";\n  SC$1.Properties=\"Properties\";\n  SC$1.dummyAction=Action.New$1(\"dummy\");\n  SC$1.guiParts=new FSharpMap.New(List.ofArray([[Layout.actLoadFile(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actSaveFile(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actAddSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actDeleteSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actIndentSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actOutdentSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actGetFsCode(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actEvalCode(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actRunWSNewTab(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actRunWSHere(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actRunWSIn(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actParseCode(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actCompileWS(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actFindDefinition(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.titleX(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"title\")\n  })],[Layout.snippets(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"snippets\")\n  })],[Layout.code(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"editor\")\n  })],[Layout.buttons(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"buttons\")\n  })],[Layout.menu(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"menu\")\n  })],[Layout.Output(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"Output\")\n  })],[Layout.Parser(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"Parser\")\n  })],[Layout.JavaScript(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"JavaScript\")\n  })],[Layout.FScode(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"F# code\")\n  })],[Layout.WSResult(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"WS Result\")\n  })],[Layout.Properties(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"Properties\")\n  })]]));\n  SC$1.layout=[];\n  SC$1.password=Input.New$2(\"\").Placeholder(\"Enter Passhrase\").Type(\"Password\");\n  SC$1.dragStartCoords=[0,0];\n };\nLayout.setLayout(Layout.getLayout);})()","LayoutButtons":"Capture Screen\nRefresh\nImage\nCamera\nMENU\nHOME\nBACK\nPassphrase\nactivateWifiSSH\nrun OpenGarage3\nCHECK\nversion\ndevices\nkillServer\nconnectUSB\nAbeFi.connect    \nOldHtc.connect   \nactivateWifi     \n\nls               \ncat              \nshell            \nflash On         \nflash Off        \ncheckScreenOn    \nenableWifi\nsupplicantWifi\nunlock\nactivateWifi\nreboot\n             \nScreen lock  \nScreen unlock\nScreen off\nWifi Keyboard\nreboot\nrebootByCmd\n"}},{"name":"AbeRaspi","content":"open Useful\nopen UsefulDotNet\n\nlet client pwd = getClient AbeRaspiIp AbeRaspiPort AbeUser pwd\n\nlet mutable AbeRaspiPassword = None\n\nlet doCmdF f cmd = \n    if AbeRaspiPassword = None then printfn \"Password not set\" else\n    doCmdF (client AbeRaspiPassword.Value) f cmd\n    \nlet doCmd cmd = doCmdF id cmd\n\n","parent":{"$":0,"Item":"5adf83e3-c555-4cd2-ab88-e8af42691daf"},"predecessors":[{"$":0,"Item":"7bb04b3c-b71e-4827-bd9e-b18fbabc1495"},{"$":0,"Item":"555306ec-f8cc-455f-b01f-9d86fbb2682d"}],"id":{"$":0,"Item":"f4439890-9c51-46b1-94a8-72e35aaf98d1"},"expanded":true,"level":0,"levelCode":0,"properties":{"cat":"doCmd \"cat /etc/rc.local\" ","ls -la":"doCmd \"ls -la IoT\"","activateDoor":"doCmd \"sudo /home/pi/IoT/garageDoorPress.sh\" ","open":"open FSSGlobal.Garage","disconnect":"client.Disconnect()","action-template":"doCmd \"${parm}\"","COMMAND":"doCmd \"source .bashrc ; source .profile ; env\"","LayoutJS":"( function()\n{\n \"use strict\";\n var Global,FSSGlobal,Layout,SC$1,WebSharper,List,Seq,Utils,Useful,String,Option,Template,Button,IntelliFactory,Runtime,Result,console,Layout$1,HtmlNode,Action,Collections,FSharpMap,Input;\n Global=window;\n FSSGlobal=Global.FSSGlobal=Global.FSSGlobal||{};\n Layout=FSSGlobal.Layout=FSSGlobal.Layout||{};\n SC$1=Global[\"StartupCode$Temp_vptg0lb4$bf864f3c-1370-42f2-ac8a-565a604892e8 FSSGlobal\"]=Global[\"StartupCode$Temp_vptg0lb4$bf864f3c-1370-42f2-ac8a-565a604892e8 FSSGlobal\"]||{};\n WebSharper=Global.WebSharper;\n List=WebSharper&&WebSharper.List;\n Seq=WebSharper&&WebSharper.Seq;\n Utils=WebSharper&&WebSharper.Utils;\n Useful=FSSGlobal&&FSSGlobal.Useful;\n String=Useful&&Useful.String;\n Option=Useful&&Useful.Option;\n Template=FSSGlobal&&FSSGlobal.Template;\n Button=Template&&Template.Button;\n IntelliFactory=Global.IntelliFactory;\n Runtime=IntelliFactory&&IntelliFactory.Runtime;\n Result=Useful&&Useful.Result;\n console=Global.console;\n Layout$1=Template&&Template.Layout;\n HtmlNode=FSSGlobal&&FSSGlobal.HtmlNode;\n Action=Template&&Template.Action;\n Collections=WebSharper&&WebSharper.Collections;\n FSharpMap=Collections&&Collections.FSharpMap;\n Input=Template&&Template.Input;\n Layout.getLayout=function(lyt,snp)\n {\n  var f,g,s;\n  return Layout.getButtonsLayout((f=Layout.evalFsCodeButtonNoParms(lyt),(g=(s=List.ofArray([Layout.password().Prefix$1(Layout.buttonPwd(Layout.sendPwdCode,lyt)).get_Render()]),function(s$1)\n  {\n   return Seq.append(s,s$1);\n  }),function(x)\n  {\n   return g(f(x));\n  })),snp);\n };\n Layout.sendPwdCode=function()\n {\n  return(function($1)\n  {\n   return function($2)\n   {\n    return $1(\"FSSGlobal.Garage.AbeRaspiPassword <- Some \"+Utils.prettyPrint($2));\n   };\n  }(Global.id))(Layout.password().get_Var().Get());\n };\n Layout.password=function()\n {\n  SC$1.$cctor();\n  return SC$1.password;\n };\n Layout.getButtonsLayout=function(f,snp)\n {\n  return Layout.extraButtonsLayout(f(Seq.filter(function(y)\n  {\n   return\"\"!==y;\n  },Seq.map(String.trim,String.splitByChar(\"\\n\",Option.defaultValue(\"\",function(d)\n  {\n   var res;\n   res=null;\n   return d.TryGetValue(\"LayoutButtons\",{\n    get:function()\n    {\n     return res;\n    },\n    set:function(v)\n    {\n     res=v;\n    }\n   })?{\n    $:1,\n    $0:res\n   }:null;\n  }(snp.properties)))))));\n };\n Layout.buttonPwd=function(code,lyt)\n {\n  return Button.New$1(\"Send\").OnClick(Runtime.Curried(Layout.sendPwd,2,[code,lyt])).get_Render();\n };\n Layout.sendPwd=function(code,lyt,el,ev)\n {\n  var a,act,x,o;\n  a=Result.Success(lyt.GetGuiCallAction(\"sendPwd\",\"actEvalFsCode\",[\"Code\",code()]));\n  a.$==1?(function($1)\n  {\n   return function($2)\n   {\n    return $1(Utils.printArray(Utils.prettyPrint,$2));\n   };\n  }(function(s)\n  {\n   console.log(s);\n  }))(a.$0):(act=a.$0[0],x=(o=act.onClick,o==null?null:{\n   $:1,\n   $0:((o.$0(act))(el))(ev)\n  }),Option.defaultWith(function($1)\n  {\n   return function()\n   {\n    return $1(\"OnClick is null\");\n   };\n  }(function(s)\n  {\n   console.log(s);\n  }),x));\n };\n Layout.evalFsCodeButtonNoParms=function(lyt)\n {\n  var f,f$1;\n  function p(y)\n  {\n   return\"\"!==y;\n  }\n  function g(t)\n  {\n   return Layout.evalFsCodeButtons(lyt,t);\n  }\n  f=(f$1=function(s)\n  {\n   return Seq.filter(p,s);\n  },function(x)\n  {\n   return Layout.passNoParms(f$1(x));\n  });\n  return function(x)\n  {\n   return g(f(x));\n  };\n };\n Layout.evalFsCodeButtonNoParm=function(lyt)\n {\n  function g(t,p)\n  {\n   return Layout.evalFsCodeButton(lyt,t,p);\n  }\n  return function(x)\n  {\n   return g.apply(null,Layout.passNoParm(x));\n  };\n };\n Layout.passNoParms=function(txts)\n {\n  return Seq.map(Layout.passNoParm,txts);\n };\n Layout.passNoParm=function(txt)\n {\n  return[txt,[]];\n };\n Layout.runFableFsButton=function(lyt,txt,parms)\n {\n  return lyt.GetCallButton(txt,Layout.actRunFableFs(),parms);\n };\n Layout.evalFsCodeButtons=function(lyt,txts)\n {\n  function m(t,p)\n  {\n   return Layout.evalFsCodeButton(lyt,t,p);\n  }\n  return Seq.map(function($1)\n  {\n   return m($1[0],$1[1]);\n  },txts);\n };\n Layout.evalFsCodeButton=function(lyt,txt,parms)\n {\n  return lyt.GetCallButton(txt,Layout.actEvalFsCode(),parms);\n };\n Layout.extraButtonsLayout=function(buttons)\n {\n  return Layout$1.AddGuids([[\"extrabuttons\",new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.div(List.ofSeq(Seq.delay(function()\n   {\n    return Seq.append([HtmlNode.style(\"text-align: center ; overflow: auto ; \")],Seq.delay(function()\n    {\n     return Seq.append(buttons,Seq.delay(function()\n     {\n      return[HtmlNode.css(\" button.btn { margin: 2px; font-size: small; } \")];\n     }));\n    }));\n   })))\n  })],[\"main_extra\",Template.varVerSplitter(85,\"main_messages\",\"extrabuttons\",50,100)],[\"main\",Template.fixedHorSplitter(true,50,\"menu\",\"main_extra\")]]);\n };\n Layout.layout=function()\n {\n  SC$1.$cctor();\n  return SC$1.layout;\n };\n Layout.set_layout=function($1)\n {\n  SC$1.$cctor();\n  SC$1.layout=$1;\n };\n Layout.doGuiCall=function(name,action,parms)\n {\n  Global.doFSharpStationGuiCall([name,action,parms]);\n };\n Layout.setLayout=function(f)\n {\n  Global.setFSharpStationLayout(f);\n };\n Layout.guiParts=function()\n {\n  SC$1.$cctor();\n  return SC$1.guiParts;\n };\n Layout.dummyAction=function()\n {\n  SC$1.$cctor();\n  return SC$1.dummyAction;\n };\n Layout.Properties=function()\n {\n  SC$1.$cctor();\n  return SC$1.Properties;\n };\n Layout.WSResult=function()\n {\n  SC$1.$cctor();\n  return SC$1.WSResult;\n };\n Layout.FScode=function()\n {\n  SC$1.$cctor();\n  return SC$1.FScode;\n };\n Layout.JavaScript=function()\n {\n  SC$1.$cctor();\n  return SC$1.JavaScript;\n };\n Layout.Parser=function()\n {\n  SC$1.$cctor();\n  return SC$1.Parser;\n };\n Layout.Output=function()\n {\n  SC$1.$cctor();\n  return SC$1.Output;\n };\n Layout.menu=function()\n {\n  SC$1.$cctor();\n  return SC$1.menu;\n };\n Layout.buttons=function()\n {\n  SC$1.$cctor();\n  return SC$1.buttons;\n };\n Layout.code=function()\n {\n  SC$1.$cctor();\n  return SC$1.code;\n };\n Layout.snippets=function()\n {\n  SC$1.$cctor();\n  return SC$1.snippets;\n };\n Layout.titleX=function()\n {\n  SC$1.$cctor();\n  return SC$1.titleX;\n };\n Layout.actFindDefinition=function()\n {\n  SC$1.$cctor();\n  return SC$1.actFindDefinition;\n };\n Layout.actCompileWS=function()\n {\n  SC$1.$cctor();\n  return SC$1.actCompileWS;\n };\n Layout.actParseCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actParseCode;\n };\n Layout.actRunWSIn=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunWSIn;\n };\n Layout.actRunWSHere=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunWSHere;\n };\n Layout.actRunWSNewTab=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunWSNewTab;\n };\n Layout.actRunFable=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunFable;\n };\n Layout.actRunFableFs=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunFableFs;\n };\n Layout.actEvalCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actEvalCode;\n };\n Layout.actEvalFsCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actEvalFsCode;\n };\n Layout.actGetFsCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actGetFsCode;\n };\n Layout.actOutdentSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actOutdentSnippet;\n };\n Layout.actIndentSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actIndentSnippet;\n };\n Layout.actDeleteSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actDeleteSnippet;\n };\n Layout.actAddSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actAddSnippet;\n };\n Layout.actSaveFile=function()\n {\n  SC$1.$cctor();\n  return SC$1.actSaveFile;\n };\n Layout.actLoadFile=function()\n {\n  SC$1.$cctor();\n  return SC$1.actLoadFile;\n };\n SC$1.$cctor=function()\n {\n  SC$1.$cctor=Global.ignore;\n  SC$1.actLoadFile=\"actLoadFile\";\n  SC$1.actSaveFile=\"actSaveFile\";\n  SC$1.actAddSnippet=\"actAddSnippet\";\n  SC$1.actDeleteSnippet=\"actDeleteSnippet\";\n  SC$1.actIndentSnippet=\"actIndentSnippet\";\n  SC$1.actOutdentSnippet=\"actOutdentSnippet\";\n  SC$1.actGetFsCode=\"actGetFsCode\";\n  SC$1.actEvalFsCode=\"actEvalFsCode\";\n  SC$1.actEvalCode=\"actEvalCode\";\n  SC$1.actRunFableFs=\"actRunFableFs\";\n  SC$1.actRunFable=\"actRunFable\";\n  SC$1.actRunWSNewTab=\"actRunWSNewTab\";\n  SC$1.actRunWSHere=\"actRunWSHere\";\n  SC$1.actRunWSIn=\"actRunWSIn\";\n  SC$1.actParseCode=\"actParseCode\";\n  SC$1.actCompileWS=\"actCompileWS\";\n  SC$1.actFindDefinition=\"actFindDefinition\";\n  SC$1.titleX=\"title\";\n  SC$1.snippets=\"snippets\";\n  SC$1.code=\"code\";\n  SC$1.buttons=\"buttons\";\n  SC$1.menu=\"menu\";\n  SC$1.Output=\"Output\";\n  SC$1.Parser=\"Parser\";\n  SC$1.JavaScript=\"JavaScript\";\n  SC$1.FScode=\"F# code\";\n  SC$1.WSResult=\"WS Result\";\n  SC$1.Properties=\"Properties\";\n  SC$1.dummyAction=Action.New$1(\"dummy\");\n  SC$1.guiParts=new FSharpMap.New(List.ofArray([[Layout.actLoadFile(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actSaveFile(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actAddSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actDeleteSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actIndentSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actOutdentSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actGetFsCode(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actEvalCode(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actRunWSNewTab(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actRunWSHere(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actRunWSIn(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actParseCode(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actCompileWS(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actFindDefinition(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.titleX(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"title\")\n  })],[Layout.snippets(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"snippets\")\n  })],[Layout.code(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"editor\")\n  })],[Layout.buttons(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"buttons\")\n  })],[Layout.menu(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"menu\")\n  })],[Layout.Output(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"Output\")\n  })],[Layout.Parser(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"Parser\")\n  })],[Layout.JavaScript(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"JavaScript\")\n  })],[Layout.FScode(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"F# code\")\n  })],[Layout.WSResult(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"WS Result\")\n  })],[Layout.Properties(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"Properties\")\n  })]]));\n  SC$1.layout=[];\n  SC$1.password=Input.New$2(\"\").Placeholder(\"Enter Password\").Type(\"password\");\n };\nLayout.setLayout(Layout.getLayout);})()","Garage State":"doCmdF (function | \"\" -> \"Closed\" | _  -> \"OPEN\"\n        >> sprintf \"Garage is %s\")\n  \"ps -ax | grep garageDoorFlash.sh | grep -v grep\"","LayoutButtons":"Garage State\nactivateDoor\ncat\nls -la\npwd\n/sbin/ifconfig\n/sbin/iwconfig\nwpa_passphrase ABEWNETG24 password\nsudo cat /etc/wpa_supplicant/wpa_supplicant.conf\nsudo reboot\ndisconnect\nCOMMAND\nenv"}},{"name":"Thermostats","content":"#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n//#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.DesignTime.dll\"\nopen System.Net\nopen System.IO\nopen FSharp.Data.HttpRequestHeaders\nopen FSharp.Data.JsonExtensions\nopen FSharp.Data\nopen Useful\nopen WSMessagingBroker\n\nlet ThermoAbajoIp  = computer \"Thermo-Abajo\"  |> Option.get |> fun c -> c.ip.Value\nlet ThermoArribaIp = computer \"Thermo-Arriba\" |> Option.get |> fun c -> c.ip.Value\n\ntype Tstat = JsonProvider<\"\"\"{\"temp\":74.00,\"tmode\":1,\"fmode\":0,\"override\":1,\"hold\":1,\"t_heat\":73.00,\"tstate\":0,\"fstate\":0,\"time\":{\"day\":1,\"hour\":14,\"minute\":13},\"t_type_post\":0}\"\"\">\n\nlet messaging = new WSMessagingClient(\"Thermostats\")\nprintfn \"%A\" messaging.EndPoint\n\nlet thermostats =\n    [ \"Arriba\", ThermoArribaIp\n      \"Abajo\" , ThermoAbajoIp\n    ]\n\nlet makeUri ip cmd = sprintf \"http://%s/%s\" ip cmd\n\nlet rec json2props cmd (json: JsonValue) =\n    json.Properties\n    |> Array.collect (fun (p, v) ->\n        let cmd2 = cmd + \"/\" + p\n        if v.Properties.Length > 0 \n        then json2props cmd2 v\n        else [| cmd2, v.ToString() |]\n     )\n     \nlet forThermostat tname = \n    thermostats\n    |> Seq.filter (fun (n, _) -> n = tname || tname = \"*\")\n\nlet queryThermoStat cmd tname =\n    forThermostat tname\n    |> Seq.map    (fun (n,ip) -> \n         makeUri ip cmd\n         |> Tstat.AsyncLoad \n         |> Async.map (fun m -> \n             json2props cmd m.JsonValue\n             |> fun data -> THMData(n, data)\n             |> mapPrint\n             |> messaging.SendAndForget (Address \"ThermostatsSite\") \n             |> Wrap.RunSynchronously \n         )\n       )\n    |> Async.Parallel\n    |> Async.RunSynchronously\n    |> ignore\n\nlet postThermostat cmd body tname =\n    forThermostat tname\n    |> Seq.iter (fun (n, ip) ->\n        Http.RequestString( makeUri ip cmd\n                          , headers = [ ContentType HttpContentTypes.Json ]\n                          , body    = TextRequest body\n                          )\n        |> printfn \"%s\"\n        queryThermoStat cmd n       \n    )\n    \nlet postTstat parm value tname =\n    sprintf \"{%A:%s}\" parm value\n    |> postThermostat \"tstat\"      <| tname\n\nlet setCurrentTime () =\n    System.DateTime.Now\n    |> (fun now -> sprintf \"{ %A: %d, %A: %d }\" \"hour\" now.Hour \"minute\" now.Minute)\n    |> postThermostat \"tstat/time\" <| \"*\"\n\nlet setTmode mode = postTstat \"tmode\" mode \"*\"\nlet setFmode mode = postTstat \"fmode\" mode \"*\"\n    \n    ","parent":{"$":0,"Item":"5adf83e3-c555-4cd2-ab88-e8af42691daf"},"predecessors":[{"$":0,"Item":"e665bede-c870-4041-b7ed-8be419c52a83"},{"$":0,"Item":"77ddaeb8-a657-4246-8f17-65e10712930f"},{"$":0,"Item":"7a655466-e218-4121-a7b6-f9c70a922e07"},{"$":0,"Item":"7bb04b3c-b71e-4827-bd9e-b18fbabc1495"}],"id":{"$":0,"Item":"27bcf9a6-29e7-4f07-81a0-61704feaa012"},"expanded":true,"level":0,"levelCode":0,"properties":{"Abajo(tstat/tstate)":"0","Abajo(sys/network/ipgw)":"\"192.168.5.1\"","Abajo(sys/network/rssi)":"-59","Abajo(sys/network/ssid)":"\"ABEWNETG\"","Arriba(tstat/fmode)":"0","Arriba(tstat/fstate)":"0","Arriba(tstat/t_cool)":"74.00","Arriba(tstat/t_heat)":"73.00","Arriba(tstat/time/minute)":"18","Arriba(tstat/tmode)":"2","Abajo(sys/network/ip)":"0","Arriba(tstat/time/hour)":"6","Arriba(tstat/tstate)":"0","Arriba(tstat/time/day)":"6","Abajo(tstat/model/model)":"\"CT50 V1.94\"","open":"open FSSGlobal.Garage","Arriba(tstat/model/model)":"\"CT30 V1.94\"","update Times":"setCurrentTime()","Abajo(tstat/t_type_post)":"0","Arriba(sys/wlan_fw_version)":"\"v10.105576\"","Abajo(sys/fw_version)":"\"1.04.84\"","LayoutButtons":"sys\nsys/network\nsys/name\ntstat\nThermostat\nmode:Cool\nmode:Heat\nmode:Off\nfan:On\nfan:Off\nfan:Cycle\ntstat/model\ntstat/version\nupdate Times\nWeather","LayoutJS":"( function()\n{\n \"use strict\";\n var Global,FSSGlobal,Layout,ThermostatData,SC$1,Temp_iuwoy4gg_JsonDecoder,IntelliFactory,Runtime,WebSharper,Utils,console,Useful,Wrap,Dict,Arrays,Seq,Option,HtmlNode,UI,Var,Collections,FSharpMap,Concurrency,Val,Template,Input,Button,AttrProxy,AttrModule,Layout$1,Slice,View,Unchecked,Map,String,Result,List,JSON,Action,WSMessagingBroker,WSMessagingClient,ClientSideJson,Provider,MessageGeneric,System,Guid;\n Global=window;\n FSSGlobal=Global.FSSGlobal=Global.FSSGlobal||{};\n Layout=FSSGlobal.Layout=FSSGlobal.Layout||{};\n ThermostatData=Layout.ThermostatData=Layout.ThermostatData||{};\n SC$1=Global[\"StartupCode$Temp_iuwoy4gg$bf864f3c-1370-42f2-ac8a-565a604892e8 FSSGlobal\"]=Global[\"StartupCode$Temp_iuwoy4gg$bf864f3c-1370-42f2-ac8a-565a604892e8 FSSGlobal\"]||{};\n Temp_iuwoy4gg_JsonDecoder=Global.Temp_iuwoy4gg_JsonDecoder=Global.Temp_iuwoy4gg_JsonDecoder||{};\n IntelliFactory=Global.IntelliFactory;\n Runtime=IntelliFactory&&IntelliFactory.Runtime;\n WebSharper=Global.WebSharper;\n Utils=WebSharper&&WebSharper.Utils;\n console=Global.console;\n Useful=FSSGlobal&&FSSGlobal.Useful;\n Wrap=Useful&&Useful.Wrap;\n Dict=Useful&&Useful.Dict;\n Arrays=WebSharper&&WebSharper.Arrays;\n Seq=WebSharper&&WebSharper.Seq;\n Option=Useful&&Useful.Option;\n HtmlNode=FSSGlobal&&FSSGlobal.HtmlNode;\n UI=WebSharper&&WebSharper.UI;\n Var=UI&&UI.Var;\n Collections=WebSharper&&WebSharper.Collections;\n FSharpMap=Collections&&Collections.FSharpMap;\n Concurrency=WebSharper&&WebSharper.Concurrency;\n Val=HtmlNode&&HtmlNode.Val;\n Template=FSSGlobal&&FSSGlobal.Template;\n Input=Template&&Template.Input;\n Button=Template&&Template.Button;\n AttrProxy=UI&&UI.AttrProxy;\n AttrModule=UI&&UI.AttrModule;\n Layout$1=Template&&Template.Layout;\n Slice=WebSharper&&WebSharper.Slice;\n View=UI&&UI.View;\n Unchecked=WebSharper&&WebSharper.Unchecked;\n Map=Collections&&Collections.Map;\n String=Useful&&Useful.String;\n Result=Useful&&Useful.Result;\n List=WebSharper&&WebSharper.List;\n JSON=Global.JSON;\n Action=Template&&Template.Action;\n WSMessagingBroker=FSSGlobal&&FSSGlobal.WSMessagingBroker;\n WSMessagingClient=WSMessagingBroker&&WSMessagingBroker.WSMessagingClient;\n ClientSideJson=WebSharper&&WebSharper.ClientSideJson;\n Provider=ClientSideJson&&ClientSideJson.Provider;\n MessageGeneric=WSMessagingBroker&&WSMessagingBroker.MessageGeneric;\n System=Global.System;\n Guid=System&&System.Guid;\n ThermostatData.New=function(name,data)\n {\n  return{\n   name:name,\n   data:data\n  };\n };\n Layout.processData=function(a)\n {\n  var name,data,b;\n  name=a.$0;\n  data=a.$1;\n  (((Runtime.Curried3(function($1,$2,$3)\n  {\n   return $1(\"Thermostats: \"+Utils.prettyPrint($2)+\" \"+Utils.printArray(function($4)\n   {\n    return\"(\"+Utils.prettyPrint($4[0])+\", \"+Utils.prettyPrint($4[1])+\")\";\n   },$3));\n  }))(function(s)\n  {\n   console.log(s);\n  }))(name))(data);\n  b=Wrap.wrap();\n  return b.Run(b.Delay(function()\n  {\n   function a$1(cmd,dat)\n   {\n    var key,o,o$1;\n    key=(((Runtime.Curried3(function($1,$2,$3)\n    {\n     return $1(Utils.toSafe($2)+\"(\"+Utils.toSafe($3)+\")\");\n    }))(Global.id))(name))(cmd);\n    o=Layout.getThermostat(name);\n    o==null?void 0:Layout.setData(cmd,dat,o.$0);\n    o$1=Layout.currentSnpO();\n    o$1==null?void 0:Dict.add(key,dat,o$1.$0.properties);\n   }\n   Arrays.iter(function($1)\n   {\n    return a$1($1[0],$1[1]);\n   },data);\n   return b.Return(\"got it!\");\n  }));\n };\n Layout.getLayout=function(lyt,snp)\n {\n  function m(a)\n  {\n   var t;\n   return a===\"Thermostat\"?Layout.ThermostatHtmls():a===\"Weather\"?Layout.weather(snp):a===\"Refresh\"?(t=Layout.passNoParm(\"Refresh\"),Layout.runFableFsButton(lyt,t[0],t[1])):(Layout.evalFsCodeButtonNoParm(lyt))(a);\n  }\n  Layout.readThermostatsProperties(snp);\n  return Layout.getButtonsLayout(function(s)\n  {\n   return Seq.map(m,s);\n  },snp);\n };\n Layout.readThermostatsProperties=function(snp)\n {\n  Layout.set_currentSnpO({\n   $:1,\n   $0:snp\n  });\n  Seq.iter(function(t)\n  {\n   Layout.readProperties(snp,t);\n  },Layout.Thermostats());\n };\n Layout.weather=function(snp)\n {\n  var cityId,openWeatherId;\n  cityId=Option.defaultValue(\"4711801\",function(d)\n  {\n   var res;\n   res=null;\n   return d.TryGetValue(\"CityId\",{\n    get:function()\n    {\n     return res;\n    },\n    set:function(v)\n    {\n     res=v;\n    }\n   })?{\n    $:1,\n    $0:res\n   }:null;\n  }(snp.properties));\n  openWeatherId=Option.defaultValue(\"1b76ef58915a2c784ce5dcb7899b81f2\",function(d)\n  {\n   var res;\n   res=null;\n   return d.TryGetValue(\"OpenWeatherId\",{\n    get:function()\n    {\n     return res;\n    },\n    set:function(v)\n    {\n     res=v;\n    }\n   })?{\n    $:1,\n    $0:res\n   }:null;\n  }(snp.properties));\n  return HtmlNode.div([HtmlNode.div([HtmlNode.style(\"height: 1em\")]),HtmlNode.div([HtmlNode.Id(\"openweathermap-widget\")]),HtmlNode.script([HtmlNode.src(\"//openweathermap.org/themes/openweathermap/assets/vendor/owm/js/d3.min.js\")]),HtmlNode.script([HtmlNode.htmlText((((Runtime.Curried3(function($1,$2,$3)\n  {\n   return $1(\"window.myWidgetParam = [{id: 15,cityid: '\"+Utils.toSafe($2)+\"',appid: '\"+Utils.toSafe($3)+\"',units: 'imperial',containerid: 'openweathermap-widget',  }];\");\n  }))(Global.id))(cityId))(openWeatherId))]),HtmlNode.script([HtmlNode.src(\"//openweathermap.org/themes/openweathermap/assets/vendor/owm/js/weather-widget-generator.js\")])]);\n };\n Layout.ThermostatHtmls=function()\n {\n  SC$1.$cctor();\n  return SC$1.ThermostatHtmls;\n };\n Layout.getThermostat=function(nm)\n {\n  return Arrays.tryFind(function(t)\n  {\n   return t.name===nm;\n  },Layout.Thermostats());\n };\n Layout.Thermostats=function()\n {\n  SC$1.$cctor();\n  return SC$1.Thermostats;\n };\n Layout.currentSnpO=function()\n {\n  SC$1.$cctor();\n  return SC$1.currentSnpO;\n };\n Layout.set_currentSnpO=function($1)\n {\n  SC$1.$cctor();\n  SC$1.currentSnpO=$1;\n };\n Layout.deactivated=function()\n {\n  SC$1.$cctor();\n  return SC$1.deactivated;\n };\n Layout.tempText=function()\n {\n  SC$1.$cctor();\n  return SC$1.tempText;\n };\n Layout.temperature=function()\n {\n  SC$1.$cctor();\n  return SC$1.temperature;\n };\n Layout.message=function()\n {\n  SC$1.$cctor();\n  return SC$1.message;\n };\n Layout.readProperties=function(snp,therm)\n {\n  Seq.iter(function(k)\n  {\n   var a;\n   a=Useful.REGEX(\"(.+)\\\\((.+)\\\\)\",\"\",k);\n   a!=null&&a.$==1?Arrays.get(a.$0,1)===therm.name?Layout.setData(Arrays.get(a.$0,2),snp.properties.get_Item(k),therm):void 0:void 0;\n  },snp.properties.get_Keys());\n };\n Layout.newThermostat=function(n)\n {\n  return ThermostatData.New(n,Var.Create$1(new FSharpMap.New([])));\n };\n Layout.thermostatDisplay$133$60=Runtime.Curried3(function(therm,e,$1)\n {\n  return Concurrency.Start(Layout.setHold(e.checked,therm),null);\n });\n Layout.thermostatDisplay=function(therm)\n {\n  var temp,x,g,mode,state,fanState,hold,time,set,title,information,settings;\n  function a(e,a$1)\n  {\n   return Concurrency.Start(Layout.setHold(e.checked,therm),null);\n  }\n  temp=(x=Layout.getData(\"tstat/temp\",therm),Val.map((g=function($1)\n  {\n   return function($2)\n   {\n    return $1(Utils.prettyPrint($2)+\"°F\");\n   };\n  }(Global.id),function(x$1)\n  {\n   return g(Global.Number(x$1));\n  }),x));\n  mode=Val.map(function(a$1)\n  {\n   return a$1===\"1\"?\"Heat\":a$1===\"2\"?\"Cool\":\"Off\";\n  },Layout.getData(\"tstat/tmode\",therm));\n  state=Val.map(function(a$1)\n  {\n   return a$1===\"1\"?\"Heating\":a$1===\"2\"?\"Cooling\":\"\";\n  },Layout.getData(\"tstat/tstate\",therm));\n  fanState=Val.map(function(a$1)\n  {\n   return a$1===\"1\"?\"Fan:On\":\"\";\n  },Layout.getData(\"tstat/fstate\",therm));\n  hold=Layout.getData(\"tstat/hold\",therm);\n  time=Val.map3(Runtime.Curried3(Layout.time2Str),Val.map(Global.Number,Layout.getData(\"tstat/time/day\",therm)),Val.map(Global.Number,Layout.getData(\"tstat/time/hour\",therm)),Val.map(Global.Number,Layout.getData(\"tstat/time/minute\",therm)));\n  set=Layout.getSettingVar(therm);\n  title=HtmlNode.div([HtmlNode.h2([HtmlNode.htmlText(therm.name)]),HtmlNode.htmlText(time)]);\n  information=HtmlNode.div([HtmlNode.h3([HtmlNode.htmlText(temp)]),HtmlNode.h4([HtmlNode.div([HtmlNode.htmlText(state)]),HtmlNode.div([HtmlNode.htmlText(fanState)])])]);\n  settings=HtmlNode.div([Input.New$3(set).Prefix$1(Button.New$1(\"Set:\").OnClick(function()\n  {\n   return function()\n   {\n    return Concurrency.Start(Layout.setSetpoint(therm),null);\n   };\n  }).get_Render()).get_Render().Style(\"\"),HtmlNode.label([HtmlNode[\"class\"](\"checkbox-inline\"),HtmlNode.htmlElement(\"input\",[HtmlNode.type(\"checkbox\"),new HtmlNode.HtmlNode({\n   $:8,\n   $0:AttrProxy.HandlerImpl(\"click\",function($1)\n   {\n    return function($2)\n    {\n     return a($1,$2);\n    };\n   })\n  }),new HtmlNode.HtmlNode({\n   $:8,\n   $0:AttrModule.OnAfterRender(function(e)\n   {\n    Val.sink(function(v)\n    {\n     e.checked=v===\"1\";\n    },hold);\n   })\n  }),HtmlNode.style(\"bottom: 0px\")]),HtmlNode.htmlText(\"Hold\")])]);\n  return Layout$1.New$1(Layout$1.AddGuids([[\"title\",new Template.GuiPart({\n   $:1,\n   $0:title\n  })],[\"information\",new Template.GuiPart({\n   $:1,\n   $0:information\n  })],[\"settings\",new Template.GuiPart({\n   $:1,\n   $0:settings\n  })],[\"data\",Template.fixPcVerSplitter(true,50,\"information\",\"settings\")],[\"main\",Template.fixPcHorSplitter(true,25,\"title\",\"data\")]])).get_Render().Style(\"\\n                grid-gap: 0px  ; \\n                margin  : 10px ; \\n             \").AddClass(Val.map(function($1)\n  {\n   return function($2)\n   {\n    return $1(\"shadow panel thermostat Mode\"+Utils.toSafe($2));\n   };\n  }(Global.id),mode));\n };\n Layout.setHold=function(v,therm)\n {\n  var b;\n  b=null;\n  return Concurrency.Delay(function()\n  {\n   var parm;\n   parm=\"hold\";\n   Layout.setData(parm,v?\"1\":\"0\",therm);\n   Layout.postTstat(parm,v?\"1\":\"0\",therm);\n   return Concurrency.Zero();\n  });\n };\n Layout.setSetpoint=function(therm)\n {\n  var b;\n  b=null;\n  return Concurrency.Delay(function()\n  {\n   return Concurrency.Bind(Val.getAsync(Layout.getSettingParm(therm)),function(a)\n   {\n    var parm;\n    return a!=null&&a.$==1?(parm=a.$0,Concurrency.Bind(Val.getAsync(Layout.getData(parm,therm)),function(a$1)\n    {\n     Layout.postTstat(Slice.string(parm,{\n      $:1,\n      $0:\"tstat/\".length\n     },null),a$1,therm);\n     return Concurrency.Zero();\n    })):Concurrency.Zero();\n   });\n  });\n };\n Layout.postTstat=function(parm,value,therm)\n {\n  var b;\n  Concurrency.Start((b=null,Concurrency.Delay(function()\n  {\n   Global.doFSharpStationGuiCall([\"setTstatParameter\",Layout.actEvalFsCode(),[\"Code\",((((Runtime.Curried(function($1,$2,$3,$4)\n   {\n    return $1(\"postTstat \"+Utils.prettyPrint($2)+\" \"+Utils.prettyPrint($3)+\" \"+Utils.prettyPrint($4)+\" \");\n   },4))(Global.id))(parm))(value))(therm.name)]]);\n   return Concurrency.Zero();\n  })),null);\n  Global.alert((((Runtime.Curried3(function($1,$2,$3)\n  {\n   return $1(\"setting \"+Utils.toSafe($2)+\" = \"+Utils.prettyPrint($3));\n  }))(Global.id))(parm))(value));\n };\n Layout.getSettingVar=function(therm)\n {\n  var view,contentVar,changingIRefO,contentVarChanged,refVarChanged;\n  function f(parmO)\n  {\n   var a,o,g;\n   a=(o=parmO==null?null:{\n    $:1,\n    $0:Layout.getIRef(parmO.$0,therm)\n   },o==null?null:{\n    $:1,\n    $0:Var.Lens(o.$0,(g=function($1)\n    {\n     return function($2)\n     {\n      return $1(Utils.prettyPrint($2));\n     };\n    }(Global.id),function(x)\n    {\n     return g(Global.Number(x));\n    }),function(_old,newV)\n    {\n     return newV;\n    })\n   });\n   return Option.defaultValue(Layout.missingIRef(),a);\n  }\n  view=Val.toView(Val.fixit(Layout.getSettingParm(therm)));\n  contentVar=Var.Create$1(null);\n  changingIRefO=[null];\n  contentVarChanged=[0];\n  refVarChanged=[0];\n  View.Sink(function()\n  {\n   var o,r;\n   o=changingIRefO[0];\n   o==null?void 0:(r=o.$0,contentVarChanged[0]>refVarChanged[0]?refVarChanged[0]=contentVarChanged[0]:!Unchecked.Equals(r.Get(),contentVar.Get())?(refVarChanged[0]=refVarChanged[0]+1,r.Set(contentVar.Get())):void 0);\n  },contentVar.get_View());\n  View.Sink(function()\n  {\n   var o,r;\n   o=changingIRefO[0];\n   o==null?void 0:(r=o.$0,refVarChanged[0]>contentVarChanged[0]?contentVarChanged[0]=refVarChanged[0]:!Unchecked.Equals(r.Get(),contentVar.Get())?(contentVarChanged[0]=contentVarChanged[0]+10,contentVar.Set(r.Get())):void 0);\n  },View.Bind(function(cur)\n  {\n   var r;\n   r=f(cur);\n   changingIRefO[0]={\n    $:1,\n    $0:r\n   };\n   refVarChanged[0]=contentVarChanged[0]+100;\n   contentVar.Set(r.Get());\n   return r.get_View();\n  },view));\n  return contentVar;\n };\n Layout.getIRef=function(key,therm)\n {\n  var a,o;\n  a=(o=Map.TryFind(key,therm.data.Get()),o==null?null:{\n   $:1,\n   $0:o.$0\n  });\n  return Option.defaultValue(Layout.missingIRef(),a);\n };\n Layout.missingIRef=function()\n {\n  SC$1.$cctor();\n  return SC$1.missingIRef;\n };\n Layout.getSettingParm=function(therm)\n {\n  var b;\n  b=Val.valFlow();\n  return b.Delay(function()\n  {\n   return b.Bind$2(Layout.getMode(therm),function(a)\n   {\n    return b.Return(a===\"1\"?{\n     $:1,\n     $0:\"tstat/t_heat\"\n    }:a===\"2\"?{\n     $:1,\n     $0:\"tstat/t_cool\"\n    }:null);\n   });\n  });\n };\n Layout.getMode=function(therm)\n {\n  var b;\n  b=Val.valFlow();\n  return b.Delay(function()\n  {\n   return b.ReturnFrom(Layout.getData(\"tstat/tmode\",therm));\n  });\n };\n Layout.setData=function(k,v,therm)\n {\n  var m;\n  m=Map.TryFind(k,therm.data.Get());\n  m!=null&&m.$==1?m.$0.Set(v):therm.data.Set(therm.data.Get().Add(k,Var.Create$1(v)));\n };\n Layout.getData=function(key,therm)\n {\n  var b;\n  b=Val.valFlow();\n  return b.Delay(function()\n  {\n   return b.Bind$1(therm.data,function(a)\n   {\n    var dataO;\n    dataO=Map.TryFind(key,a);\n    return dataO!=null&&dataO.$==1?b.Bind$1(dataO.$0,function(a$1)\n    {\n     return b.Return(a$1);\n    }):b.Return(\"\");\n   });\n  });\n };\n Layout.time2Str=function(day,hour,minute)\n {\n  return((((Runtime.Curried(function($1,$2,$3,$4)\n  {\n   return $1(Utils.toSafe($2)+\", \"+Utils.padNumLeft(Global.String($3),2)+\":\"+Utils.padNumLeft(Global.String($4),2));\n  },4))(Global.id))(day===0?\"Mon\":day===1?\"Tue\":day===2?\"Wed\":day===3?\"Thu\":day===4?\"Fri\":day===5?\"Sat\":day===6?\"Sun\":\"---\"))(hour))(minute);\n };\n Layout.messaging=function()\n {\n  SC$1.$cctor();\n  return SC$1.messaging;\n };\n Layout.getButtonsLayout=function(f,snp)\n {\n  return Layout.extraButtonsLayout(f(Seq.filter(function(y)\n  {\n   return\"\"!==y;\n  },Seq.map(String.trim,String.splitByChar(\"\\n\",Option.defaultValue(\"\",function(d)\n  {\n   var res;\n   res=null;\n   return d.TryGetValue(\"LayoutButtons\",{\n    get:function()\n    {\n     return res;\n    },\n    set:function(v)\n    {\n     res=v;\n    }\n   })?{\n    $:1,\n    $0:res\n   }:null;\n  }(snp.properties)))))));\n };\n Layout.buttonPwd=function(code,lyt)\n {\n  return Button.New$1(\"Send\").OnClick(Runtime.Curried(Layout.sendPwd,2,[code,lyt])).get_Render();\n };\n Layout.sendPwd=function(code,lyt,el,ev)\n {\n  var a,act,x,o;\n  a=Result.Success(lyt.GetGuiCallAction(\"sendPwd\",\"actEvalFsCode\",[\"Code\",code()]));\n  a.$==1?(function($1)\n  {\n   return function($2)\n   {\n    return $1(Utils.printArray(Utils.prettyPrint,$2));\n   };\n  }(function(s)\n  {\n   console.log(s);\n  }))(a.$0):(act=a.$0[0],x=(o=act.onClick,o==null?null:{\n   $:1,\n   $0:((o.$0(act))(el))(ev)\n  }),Option.defaultWith(function($1)\n  {\n   return function()\n   {\n    return $1(\"OnClick is null\");\n   };\n  }(function(s)\n  {\n   console.log(s);\n  }),x));\n };\n Layout.evalFsCodeButtonNoParms=function(lyt)\n {\n  var f,f$1;\n  function p(y)\n  {\n   return\"\"!==y;\n  }\n  function g(t)\n  {\n   return Layout.evalFsCodeButtons(lyt,t);\n  }\n  f=(f$1=function(s)\n  {\n   return Seq.filter(p,s);\n  },function(x)\n  {\n   return Layout.passNoParms(f$1(x));\n  });\n  return function(x)\n  {\n   return g(f(x));\n  };\n };\n Layout.evalFsCodeButtonNoParm=function(lyt)\n {\n  function g(t,p)\n  {\n   return Layout.evalFsCodeButton(lyt,t,p);\n  }\n  return function(x)\n  {\n   return g.apply(null,Layout.passNoParm(x));\n  };\n };\n Layout.passNoParms=function(txts)\n {\n  return Seq.map(Layout.passNoParm,txts);\n };\n Layout.passNoParm=function(txt)\n {\n  return[txt,[]];\n };\n Layout.runFableFsButton=function(lyt,txt,parms)\n {\n  return lyt.GetCallButton(txt,Layout.actRunFableFs(),parms);\n };\n Layout.evalFsCodeButtons=function(lyt,txts)\n {\n  function m(t,p)\n  {\n   return Layout.evalFsCodeButton(lyt,t,p);\n  }\n  return Seq.map(function($1)\n  {\n   return m($1[0],$1[1]);\n  },txts);\n };\n Layout.evalFsCodeButton=function(lyt,txt,parms)\n {\n  return lyt.GetCallButton(txt,Layout.actEvalFsCode(),parms);\n };\n Layout.extraButtonsLayout=function(buttons)\n {\n  return Layout$1.AddGuids([[\"extrabuttons\",new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.div(List.ofSeq(Seq.delay(function()\n   {\n    return Seq.append([HtmlNode.style(\"text-align: center ; overflow: auto ; \")],Seq.delay(function()\n    {\n     return Seq.append(buttons,Seq.delay(function()\n     {\n      return[HtmlNode.css(\" button.btn { margin: 2px; font-size: small; } \")];\n     }));\n    }));\n   })))\n  })],[\"main_extra\",Template.varVerSplitter(85,\"main_messages\",\"extrabuttons\",50,100)],[\"main\",Template.fixedHorSplitter(true,50,\"menu\",\"main_extra\")]]);\n };\n Layout.layout=function()\n {\n  SC$1.$cctor();\n  return SC$1.layout;\n };\n Layout.set_layout=function($1)\n {\n  SC$1.$cctor();\n  SC$1.layout=$1;\n };\n Layout.doGuiCall=function(name,action,parms)\n {\n  Global.doFSharpStationGuiCall([name,action,parms]);\n };\n Layout.setLayout=function(f)\n {\n  Global.setFSharpStationLayout(f);\n };\n Layout.guiParts=function()\n {\n  SC$1.$cctor();\n  return SC$1.guiParts;\n };\n Layout.dummyAction=function()\n {\n  SC$1.$cctor();\n  return SC$1.dummyAction;\n };\n Layout.Properties=function()\n {\n  SC$1.$cctor();\n  return SC$1.Properties;\n };\n Layout.WSResult=function()\n {\n  SC$1.$cctor();\n  return SC$1.WSResult;\n };\n Layout.FScode=function()\n {\n  SC$1.$cctor();\n  return SC$1.FScode;\n };\n Layout.JavaScript=function()\n {\n  SC$1.$cctor();\n  return SC$1.JavaScript;\n };\n Layout.Parser=function()\n {\n  SC$1.$cctor();\n  return SC$1.Parser;\n };\n Layout.Output=function()\n {\n  SC$1.$cctor();\n  return SC$1.Output;\n };\n Layout.menu=function()\n {\n  SC$1.$cctor();\n  return SC$1.menu;\n };\n Layout.buttons=function()\n {\n  SC$1.$cctor();\n  return SC$1.buttons;\n };\n Layout.code=function()\n {\n  SC$1.$cctor();\n  return SC$1.code;\n };\n Layout.snippets=function()\n {\n  SC$1.$cctor();\n  return SC$1.snippets;\n };\n Layout.titleX=function()\n {\n  SC$1.$cctor();\n  return SC$1.titleX;\n };\n Layout.actFindDefinition=function()\n {\n  SC$1.$cctor();\n  return SC$1.actFindDefinition;\n };\n Layout.actCompileWS=function()\n {\n  SC$1.$cctor();\n  return SC$1.actCompileWS;\n };\n Layout.actParseCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actParseCode;\n };\n Layout.actRunWSIn=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunWSIn;\n };\n Layout.actRunWSHere=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunWSHere;\n };\n Layout.actRunWSNewTab=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunWSNewTab;\n };\n Layout.actRunFable=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunFable;\n };\n Layout.actRunFableFs=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunFableFs;\n };\n Layout.actEvalCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actEvalCode;\n };\n Layout.actEvalFsCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actEvalFsCode;\n };\n Layout.actGetFsCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actGetFsCode;\n };\n Layout.actOutdentSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actOutdentSnippet;\n };\n Layout.actIndentSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actIndentSnippet;\n };\n Layout.actDeleteSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actDeleteSnippet;\n };\n Layout.actAddSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actAddSnippet;\n };\n Layout.actSaveFile=function()\n {\n  SC$1.$cctor();\n  return SC$1.actSaveFile;\n };\n Layout.actLoadFile=function()\n {\n  SC$1.$cctor();\n  return SC$1.actLoadFile;\n };\n SC$1.$cctor=function()\n {\n  var x,_this,f,g,dst,p;\n  SC$1.$cctor=Global.ignore;\n  function f$1(a)\n  {\n   return(Temp_iuwoy4gg_JsonDecoder.j())(JSON.parse(a));\n  }\n  SC$1.actLoadFile=\"actLoadFile\";\n  SC$1.actSaveFile=\"actSaveFile\";\n  SC$1.actAddSnippet=\"actAddSnippet\";\n  SC$1.actDeleteSnippet=\"actDeleteSnippet\";\n  SC$1.actIndentSnippet=\"actIndentSnippet\";\n  SC$1.actOutdentSnippet=\"actOutdentSnippet\";\n  SC$1.actGetFsCode=\"actGetFsCode\";\n  SC$1.actEvalFsCode=\"actEvalFsCode\";\n  SC$1.actEvalCode=\"actEvalCode\";\n  SC$1.actRunFableFs=\"actRunFableFs\";\n  SC$1.actRunFable=\"actRunFable\";\n  SC$1.actRunWSNewTab=\"actRunWSNewTab\";\n  SC$1.actRunWSHere=\"actRunWSHere\";\n  SC$1.actRunWSIn=\"actRunWSIn\";\n  SC$1.actParseCode=\"actParseCode\";\n  SC$1.actCompileWS=\"actCompileWS\";\n  SC$1.actFindDefinition=\"actFindDefinition\";\n  SC$1.titleX=\"title\";\n  SC$1.snippets=\"snippets\";\n  SC$1.code=\"code\";\n  SC$1.buttons=\"buttons\";\n  SC$1.menu=\"menu\";\n  SC$1.Output=\"Output\";\n  SC$1.Parser=\"Parser\";\n  SC$1.JavaScript=\"JavaScript\";\n  SC$1.FScode=\"F# code\";\n  SC$1.WSResult=\"WS Result\";\n  SC$1.Properties=\"Properties\";\n  SC$1.dummyAction=Action.New$1(\"dummy\");\n  SC$1.guiParts=new FSharpMap.New(List.ofArray([[Layout.actLoadFile(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actSaveFile(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actAddSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actDeleteSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actIndentSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actOutdentSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actGetFsCode(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actEvalCode(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actRunWSNewTab(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actRunWSHere(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actRunWSIn(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actParseCode(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actCompileWS(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actFindDefinition(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.titleX(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"title\")\n  })],[Layout.snippets(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"snippets\")\n  })],[Layout.code(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"editor\")\n  })],[Layout.buttons(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"buttons\")\n  })],[Layout.menu(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"menu\")\n  })],[Layout.Output(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"Output\")\n  })],[Layout.Parser(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"Parser\")\n  })],[Layout.JavaScript(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"JavaScript\")\n  })],[Layout.FScode(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"F# code\")\n  })],[Layout.WSResult(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"WS Result\")\n  })],[Layout.Properties(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"Properties\")\n  })]]));\n  SC$1.layout=[];\n  SC$1.messaging=new WSMessagingClient.New(\"ThermostatsSite\",null,null);\n  Global.iwasherebefore=Layout.messaging();\n  SC$1.missingIRef=Var.Lens(Var.Create$1(\"\"),function()\n  {\n   return\"\";\n  },function()\n  {\n   return\"\";\n  });\n  SC$1.message=Var.Create$1(\"\");\n  SC$1.temperature=Var.Create$1(0);\n  SC$1.tempText=Val.map(function($1)\n  {\n   return function($2)\n   {\n    return $1(Utils.prettyPrint($2));\n   };\n  }(Global.id),Layout.temperature());\n  SC$1.deactivated=Var.Create$1(\"\");\n  SC$1.currentSnpO=null;\n  SC$1.Thermostats=[Layout.newThermostat(\"Arriba\"),Layout.newThermostat(\"Abajo\")];\n  SC$1.ThermostatHtmls=HtmlNode.div((x=Seq.map(Layout.thermostatDisplay,Layout.Thermostats()),Seq.append(List.ofArray([HtmlNode.htmlText(Layout.message()),HtmlNode.css(\"\\n                      .thermostat {\\n                          text-align      : center     ; \\n                      }\\n                      .thermostat h2, .thermostat h3, .thermostat h4  {\\n                          margin-top      : 3px     ; \\n                          margin-bottom   : 0px     ; \\n                      }\\n                      .thermostat.ModeCool {\\n                          background-color: blue; \\n                          color: white;\\n                      }\\n                      .thermostat.ModeCool button {\\n                          background-color: navy; \\n                          color: white;\\n                      }\\n                      .thermostat.ModeHeat {\\n                          background-color: firebrick; \\n                          color: white;\\n                      }\\n                      .thermostat.ModeHeat button {\\n                          background-color: darkred; \\n                          color: white;\\n                      }\\n                \")]),x)));\n  (function($1)\n  {\n   return $1(\"Thermostats registering\");\n  }(function(s)\n  {\n   console.log(s);\n  }));\n  _this=Layout.messaging();\n  _this.payloadProcessorO={\n   $:1,\n   $0:(f=function(x$1)\n   {\n    return Layout.processData(f$1(x$1));\n   },(g=Wrap.map(function(a)\n   {\n    return JSON.stringify(((Provider.Id())())(a));\n   }),function(x$1)\n   {\n    return g(f(x$1));\n   }))\n  };\n  Wrap.Start(_this.sendAndForget(WSMessagingBroker.msgType(WSMessagingBroker.MessageType.MsgInformation,(dst=WSMessagingBroker.MessageBrokerAddress(),(p=JSON.stringify(((Provider.Id())())(\"Registering Processor\")),MessageGeneric.New(new WSMessagingBroker.Address({\n   $:0,\n   $0:\"\"\n  }),dst,WSMessagingBroker.MessageType.MsgRequest,\"\",Guid.NewGuid(),p,WSMessagingBroker.Replier.NoReply))))),null);\n };\n Temp_iuwoy4gg_JsonDecoder.j=function()\n {\n  return Temp_iuwoy4gg_JsonDecoder._v?Temp_iuwoy4gg_JsonDecoder._v:Temp_iuwoy4gg_JsonDecoder._v=(Provider.DecodeUnion(void 0,\"$\",[[0,[[\"$0\",\"name\",Provider.Id(),0],[\"$1\",\"values\",Provider.DecodeArray(Provider.DecodeTuple([Provider.Id(),Provider.Id()])),0]]]]))();\n };\nLayout.setLayout(Layout.getLayout);})()","action-template":"queryThermoStat \"${parm}\" \"*\"","OpenWeatherId":"1b76ef58915a2c784ce5dcb7899b81f2","CityId":"4711801","Abajo(tstat/temp)":"72.50","Abajo(tstat/tmode)":"2","Abajo(tstat/fmode)":"0","Abajo(tstat/override)":"1","Abajo(tstat/hold)":"0","Abajo(tstat/t_cool)":"72.50","Abajo(tstat/fstate)":"0","Abajo(tstat/time/day)":"6","Abajo(tstat/time/hour)":"6","Abajo(tstat/time/minute)":"17","Arriba(tstat/temp)":"74.00","Arriba(tstat/override)":"0","Arriba(tstat/hold)":"0","Arriba(tstat/t_type_post)":"0","Arriba(sys/uuid)":"\"44a7cf5e3548\"","Arriba(sys/api_version)":"113","Arriba(sys/fw_version)":"\"1.04.84\"","Abajo(sys/uuid)":"\"5cdad4fdb7d1\"","Abajo(sys/api_version)":"113","Abajo(sys/wlan_fw_version)":"\"v10.105576\"","Abajo(sys/network/bssid)":"\"9c:d3:6d:b7:cb:e6\"","Abajo(sys/network/channel)":"4","Abajo(sys/network/security)":"4","Abajo(sys/network/ipaddr)":"\"192.168.5.252\"","Abajo(sys/network/ipmask)":"\"255.255.255.0\"","Abajo(sys/network/ipdns1)":"\"192.168.5.1\"","Abajo(sys/network/ipdns2)":"\"192.168.5.1\"","Arriba(sys/network/ssid)":"\"ABEWNETG\"","Arriba(sys/network/bssid)":"\"9c:d3:6d:b7:cb:e6\"","Arriba(sys/network/channel)":"4","Arriba(sys/network/security)":"4","Arriba(sys/network/ip)":"0","Arriba(sys/network/rssi)":"-69","Arriba(sys/network/ipaddr)":"\"192.168.5.253\"","Arriba(sys/network/ipmask)":"\"255.255.255.0\"","Arriba(sys/network/ipgw)":"\"192.168.5.1\"","Arriba(sys/network/ipdns1)":"\"192.168.5.1\"","Arriba(sys/network/ipdns2)":"\"192.168.5.1\"","Arriba(sys/name/name)":"\"Arriba\"","Abajo(sys/name/name)":"\"Abajo\"","Abajo(tstat/version/version)":"100","Arriba(tstat/version/version)":"100","mode:Heat":"setTmode \"1\"","mode:Cool":"setTmode \"2\"","mode:Off":"setTmode \"0\"","Abajo(tstat/t_heat)":"72.50","fan:On":"setFmode \"1\"","fan:Off":"setFmode \"0\"","fan:Cycle":"setFmode \"2\""}},{"name":"Create Symbolic Links","content":"open UsefulDotNet\n\n//let runAs       cmd         = runProcess3 \"runas.exe\" \"/user:amieres@hotmail.com cmd.exe\"\nlet runCommand  cmd         = RunProcess.runToFinish \"cmd.exe\" <| sprintf \"/C %s\"           cmd\nlet cmd_del     file        = runCommand                       <| sprintf \"del       %A\"    file\nlet cmd_rmdir   dir         = runCommand                       <| sprintf \"rmdir     %A\"    dir\nlet cmd_mklink  link target = runCommand                       <| sprintf \"mklink /D %A %A\" link target\n\n//cmd_del \"C:\\Program Files\\hello.txt\" |> printfn \"%A\"\n\nopen System.IO\n\n//File.Delete \"C:\\Program Files\\hello.txt\"\nlet createDirLinkInD d = \n    try File.Delete      d with _ -> ()\n    try Directory.Delete d with _ -> ()\n    cmd_mklink d (\"D\" + d.[1..])\n    |> printfn \"%A\"\n\ncreateDirLinkInD \"C:\\Program Files\\dotnet\"\ncreateDirLinkInD \"C:\\Program Files\\Git\"\ncreateDirLinkInD \"C:\\Program Files\\Microsoft SQL Server\"\ncreateDirLinkInD \"C:\\Program Files\\Microsoft SDKs\"\ncreateDirLinkInD \"C:\\Program Files\\Java\"\ncreateDirLinkInD \"C:\\Program Files\\RStudio\"\ncreateDirLinkInD \"C:\\Program Files\\R\"\ncreateDirLinkInD \"C:\\Program Files\\Oracle\"\ncreateDirLinkInD \"C:\\Program Files (x86)\\Android\"\n\ncmd_mklink \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\bin\\Compiled\\packages\" \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\"","parent":{"$":0,"Item":"5adf83e3-c555-4cd2-ab88-e8af42691daf"},"predecessors":[{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"}],"id":{"$":0,"Item":"c60a636a-5e8a-49ec-85f9-8f934c8f9b25"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"paket","content":"#define PAKET\nopen UsefulDotNet\n\nlet paket cmd = RunProcess.runToFinish @\"..\\.paket\\paket.exe\" cmd\nlet install() = paket \"install\"\n\n//let SaveDependenciesFile() =\n","parent":{"$":0,"Item":"5adf83e3-c555-4cd2-ab88-e8af42691daf"},"predecessors":[{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"}],"id":{"$":0,"Item":"833fc159-d686-4e6f-a25a-203a96adc537"},"expanded":true,"level":0,"levelCode":0,"properties":{"open":"////-d:PAKET\nopen FSSGlobal.UsefulDotNet\nopen FSSGlobal.Garage\n","LayoutButtons":"install","action-template":"paket \"${parm}\"","LayoutJS":"( function()\n{\n \"use strict\";\n var Global,FSSGlobal,Layout,SC$1,WebSharper,Seq,Useful,String,Option,Template,Button,IntelliFactory,Runtime,Result,Utils,console,Layout$1,HtmlNode,List,Action,Collections,FSharpMap;\n Global=window;\n FSSGlobal=Global.FSSGlobal=Global.FSSGlobal||{};\n Layout=FSSGlobal.Layout=FSSGlobal.Layout||{};\n SC$1=Global[\"StartupCode$Temp_d5z5ibbj$bf864f3c-1370-42f2-ac8a-565a604892e8 FSSGlobal\"]=Global[\"StartupCode$Temp_d5z5ibbj$bf864f3c-1370-42f2-ac8a-565a604892e8 FSSGlobal\"]||{};\n WebSharper=Global.WebSharper;\n Seq=WebSharper&&WebSharper.Seq;\n Useful=FSSGlobal&&FSSGlobal.Useful;\n String=Useful&&Useful.String;\n Option=Useful&&Useful.Option;\n Template=FSSGlobal&&FSSGlobal.Template;\n Button=Template&&Template.Button;\n IntelliFactory=Global.IntelliFactory;\n Runtime=IntelliFactory&&IntelliFactory.Runtime;\n Result=Useful&&Useful.Result;\n Utils=WebSharper&&WebSharper.Utils;\n console=Global.console;\n Layout$1=Template&&Template.Layout;\n HtmlNode=FSSGlobal&&FSSGlobal.HtmlNode;\n List=WebSharper&&WebSharper.List;\n Action=Template&&Template.Action;\n Collections=WebSharper&&WebSharper.Collections;\n FSharpMap=Collections&&Collections.FSharpMap;\n Layout.getLayout=function(lyt,snp)\n {\n  return Layout.getButtonsLayout(Layout.evalFsCodeButtonNoParms(lyt),snp);\n };\n Layout.getButtonsLayout=function(f,snp)\n {\n  return Layout.extraButtonsLayout(f(Seq.filter(function(y)\n  {\n   return\"\"!==y;\n  },Seq.map(String.trim,String.splitByChar(\"\\n\",Option.defaultValue(\"\",function(d)\n  {\n   var res;\n   res=null;\n   return d.TryGetValue(\"LayoutButtons\",{\n    get:function()\n    {\n     return res;\n    },\n    set:function(v)\n    {\n     res=v;\n    }\n   })?{\n    $:1,\n    $0:res\n   }:null;\n  }(snp.properties)))))));\n };\n Layout.buttonPwd=function(code,lyt)\n {\n  return Button.New$1(\"Send\").OnClick(Runtime.Curried(Layout.sendPwd,2,[code,lyt])).get_Render();\n };\n Layout.sendPwd=function(code,lyt,el,ev)\n {\n  var a,act,x,o;\n  a=Result.Success(lyt.GetGuiCallAction(\"sendPwd\",\"actEvalFsCode\",[\"Code\",code()]));\n  a.$==1?(function($1)\n  {\n   return function($2)\n   {\n    return $1(Utils.printList(Utils.prettyPrint,$2));\n   };\n  }(function(s)\n  {\n   console.log(s);\n  }))(a.$0):(act=a.$0[0],x=(o=act.onClick,o==null?null:{\n   $:1,\n   $0:((o.$0(act))(el))(ev)\n  }),Option.defaultWith(function($1)\n  {\n   return function()\n   {\n    return $1(\"OnClick is null\");\n   };\n  }(function(s)\n  {\n   console.log(s);\n  }),x));\n };\n Layout.evalFsCodeButtonNoParms=function(lyt)\n {\n  var f,f$1;\n  function p(y)\n  {\n   return\"\"!==y;\n  }\n  function g(t)\n  {\n   return Layout.evalFsCodeButtons(lyt,t);\n  }\n  f=(f$1=function(s)\n  {\n   return Seq.filter(p,s);\n  },function(x)\n  {\n   return Layout.passNoParms(f$1(x));\n  });\n  return function(x)\n  {\n   return g(f(x));\n  };\n };\n Layout.evalFsCodeButtonNoParm=function(lyt)\n {\n  function g(t,p)\n  {\n   return Layout.evalFsCodeButton(lyt,t,p);\n  }\n  return function(x)\n  {\n   return g.apply(null,Layout.passNoParm(x));\n  };\n };\n Layout.passNoParms=function(txts)\n {\n  return Seq.map(Layout.passNoParm,txts);\n };\n Layout.passNoParm=function(txt)\n {\n  return[txt,[]];\n };\n Layout.runFableFsButton=function(lyt,txt,parms)\n {\n  return lyt.GetCallButton(txt,Layout.actRunFableFs(),parms);\n };\n Layout.evalFsCodeButtons=function(lyt,txts)\n {\n  function m(t,p)\n  {\n   return Layout.evalFsCodeButton(lyt,t,p);\n  }\n  return Seq.map(function($1)\n  {\n   return m($1[0],$1[1]);\n  },txts);\n };\n Layout.evalFsCodeButton=function(lyt,txt,parms)\n {\n  return lyt.GetCallButton(txt,Layout.actEvalFsCode(),parms);\n };\n Layout.extraButtonsLayout=function(buttons)\n {\n  return Layout$1.AddGuids([[\"extrabuttons\",new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.div(List.ofSeq(Seq.delay(function()\n   {\n    return Seq.append([HtmlNode.style(\"text-align: center ; overflow: auto ; \")],Seq.delay(function()\n    {\n     return Seq.append(buttons,Seq.delay(function()\n     {\n      return[HtmlNode.css(\" button.btn { margin: 2px; font-size: small; } \")];\n     }));\n    }));\n   })))\n  })],[\"main_extra\",Template.varVerSplitter(85,\"main_messages\",\"extrabuttons\",50,100)],[\"main\",Template.fixedHorSplitter(true,50,\"menu\",\"main_extra\")]]);\n };\n Layout.layout=function()\n {\n  SC$1.$cctor();\n  return SC$1.layout;\n };\n Layout.set_layout=function($1)\n {\n  SC$1.$cctor();\n  SC$1.layout=$1;\n };\n Layout.doGuiCall=function(name,action,parms)\n {\n  Global.doFSharpStationGuiCall([name,action,parms]);\n };\n Layout.setLayout=function(f)\n {\n  Global.setFSharpStationLayout(f);\n };\n Layout.guiParts=function()\n {\n  SC$1.$cctor();\n  return SC$1.guiParts;\n };\n Layout.dummyAction=function()\n {\n  SC$1.$cctor();\n  return SC$1.dummyAction;\n };\n Layout.Properties=function()\n {\n  SC$1.$cctor();\n  return SC$1.Properties;\n };\n Layout.WSResult=function()\n {\n  SC$1.$cctor();\n  return SC$1.WSResult;\n };\n Layout.FScode=function()\n {\n  SC$1.$cctor();\n  return SC$1.FScode;\n };\n Layout.JavaScript=function()\n {\n  SC$1.$cctor();\n  return SC$1.JavaScript;\n };\n Layout.Parser=function()\n {\n  SC$1.$cctor();\n  return SC$1.Parser;\n };\n Layout.Output=function()\n {\n  SC$1.$cctor();\n  return SC$1.Output;\n };\n Layout.menu=function()\n {\n  SC$1.$cctor();\n  return SC$1.menu;\n };\n Layout.buttons=function()\n {\n  SC$1.$cctor();\n  return SC$1.buttons;\n };\n Layout.code=function()\n {\n  SC$1.$cctor();\n  return SC$1.code;\n };\n Layout.snippets=function()\n {\n  SC$1.$cctor();\n  return SC$1.snippets;\n };\n Layout.titleX=function()\n {\n  SC$1.$cctor();\n  return SC$1.titleX;\n };\n Layout.actFindDefinition=function()\n {\n  SC$1.$cctor();\n  return SC$1.actFindDefinition;\n };\n Layout.actCompileWS=function()\n {\n  SC$1.$cctor();\n  return SC$1.actCompileWS;\n };\n Layout.actParseCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actParseCode;\n };\n Layout.actRunWSIn=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunWSIn;\n };\n Layout.actRunWSHere=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunWSHere;\n };\n Layout.actRunWSNewTab=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunWSNewTab;\n };\n Layout.actRunFable=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunFable;\n };\n Layout.actRunFableFs=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunFableFs;\n };\n Layout.actEvalCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actEvalCode;\n };\n Layout.actEvalFsCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actEvalFsCode;\n };\n Layout.actGetFsCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actGetFsCode;\n };\n Layout.actOutdentSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actOutdentSnippet;\n };\n Layout.actIndentSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actIndentSnippet;\n };\n Layout.actDeleteSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actDeleteSnippet;\n };\n Layout.actAddSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actAddSnippet;\n };\n Layout.actSaveFile=function()\n {\n  SC$1.$cctor();\n  return SC$1.actSaveFile;\n };\n Layout.actLoadFile=function()\n {\n  SC$1.$cctor();\n  return SC$1.actLoadFile;\n };\n SC$1.$cctor=function()\n {\n  SC$1.$cctor=Global.ignore;\n  SC$1.actLoadFile=\"actLoadFile\";\n  SC$1.actSaveFile=\"actSaveFile\";\n  SC$1.actAddSnippet=\"actAddSnippet\";\n  SC$1.actDeleteSnippet=\"actDeleteSnippet\";\n  SC$1.actIndentSnippet=\"actIndentSnippet\";\n  SC$1.actOutdentSnippet=\"actOutdentSnippet\";\n  SC$1.actGetFsCode=\"actGetFsCode\";\n  SC$1.actEvalFsCode=\"actEvalFsCode\";\n  SC$1.actEvalCode=\"actEvalCode\";\n  SC$1.actRunFableFs=\"actRunFableFs\";\n  SC$1.actRunFable=\"actRunFable\";\n  SC$1.actRunWSNewTab=\"actRunWSNewTab\";\n  SC$1.actRunWSHere=\"actRunWSHere\";\n  SC$1.actRunWSIn=\"actRunWSIn\";\n  SC$1.actParseCode=\"actParseCode\";\n  SC$1.actCompileWS=\"actCompileWS\";\n  SC$1.actFindDefinition=\"actFindDefinition\";\n  SC$1.titleX=\"title\";\n  SC$1.snippets=\"snippets\";\n  SC$1.code=\"code\";\n  SC$1.buttons=\"buttons\";\n  SC$1.menu=\"menu\";\n  SC$1.Output=\"Output\";\n  SC$1.Parser=\"Parser\";\n  SC$1.JavaScript=\"JavaScript\";\n  SC$1.FScode=\"F# code\";\n  SC$1.WSResult=\"WS Result\";\n  SC$1.Properties=\"Properties\";\n  SC$1.dummyAction=Action.New$1(\"dummy\");\n  SC$1.guiParts=new FSharpMap.New(List.ofArray([[Layout.actLoadFile(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actSaveFile(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actAddSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actDeleteSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actIndentSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actOutdentSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actGetFsCode(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actEvalCode(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actRunWSNewTab(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actRunWSHere(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actRunWSIn(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actParseCode(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actCompileWS(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actFindDefinition(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.titleX(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"title\")\n  })],[Layout.snippets(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"snippets\")\n  })],[Layout.code(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"editor\")\n  })],[Layout.buttons(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"buttons\")\n  })],[Layout.menu(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"menu\")\n  })],[Layout.Output(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"Output\")\n  })],[Layout.Parser(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"Parser\")\n  })],[Layout.JavaScript(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"JavaScript\")\n  })],[Layout.FScode(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"F# code\")\n  })],[Layout.WSResult(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"WS Result\")\n  })],[Layout.Properties(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"Properties\")\n  })]]));\n  SC$1.layout=[];\n };\nLayout.setLayout(Layout.getLayout);})()"}},{"name":"CalculationModel","content":"#if WEBSHARPER\n[< JavaScript >]\n#endif\nmodule CalculationModel =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"86382469-687d-4914-94b9-4067d8c5c7e7"},"expanded":false,"level":0,"levelCode":0,"properties":{}},{"name":"CalculationModel","content":"open System\nopen Useful\n\nmodule CalculationModel =\n    open Useful\n    \n    type DimType =\n        | DtDataType\n        | DtTime\n        | DtVersion\n        | DtTCalc\n        | DtCalc\n        | DtMeasure\n        | DtOther\n    \n    type CubeType =\n        | CtOther\n        | CtCalc\n        | CtFreeze\n    \n    type AttType =\n        | AtString\n        | AtNumber\n    \n    type ElmType =\n        | EtString\n        | EtNumber\n    \n    type ModId = ModId of Guid\n    type AttId = AttId of Guid\n    type ElmId = ElmId of Guid\n    type CubId = CubId of Guid\n    type DimId = DimId of Guid\n    type CalId = CalId of Guid\n    type ForId = ForId of Guid\n    type RulId = RulId of Guid\n    \n    type Attribute = {\n        attId          : AttId\n        attName        : string\n        attType        : AttType\n        attTableNum    : int\n    }\n    \n    type Element = {\n        elmId          : ElmId\n        elmDim         : DimId\n        elmType        : ElmType\n        elmName        : string\n        elmDescription : string\n        elmAttributes  : Map<AttId, string> \n        elmParents     : ElmId     []\n    } \n    \n    type Dimension = {\n        dimId               : DimId\n        dimName             : string\n        dimPrefix           : string\n        dimType             : DimType\n        defaultElm          : ElmId     option\n        mutable dimElements : Element   []\n        dimAttributes       : Attribute []\n        isCalcDim           : bool\n    }\n    \n    type Operator = \n        | OpAdd      \n        | OpSubtract \n        | OpMultiply \n        | OpDivide   \n        | OpEQ    \n        | OpNE\n        | OpGT       \n        | OpGE       \n        | OpLT       \n        | OpLE       \n        | OpAnd      \n        | OpOr           \n    \n    type Function = Function\n    \n    type ElmReference =\n        | ElemFixed   of DimId * ElmId\n        | ElemDynamic of DimId * ExpressionText\n            \n    and  ExpressionText =\n        | ExtNA\n        | ExtStet\n        | ExtSlice      of Slice\n        | ExtString     of string\n        | ExtDimElement of DimId\n        | ExtDimName    of DimId\n        | ExtFunction   of Function * ExpressionAny []\n        | ExtIf         of ExpressionNumber * ExpressionText   * ExpressionText\n        | ExtSubSt      of ExpressionText   * ExpressionNumber * ExpressionNumber\n    \n    and  ExpressionNumber =\n        | ExnNA\n        | ExnStet\n        | ExnSlice      of Slice\n        | ExnNumber     of float\n        | ExnOperationN of Operator         * ExpressionNumber * ExpressionNumber\n        | ExnOperationT of Operator         * ExpressionText   * ExpressionText\n        | ExnOperationI of Operator         * ExpressionAny    * ExpressionAny\n        | ExnFunction   of Function         * ExpressionAny []\n        | ExnIf         of ExpressionNumber * ExpressionNumber * ExpressionNumber\n        | ExnMax        of ExpressionNumber * ExpressionNumber\n        | ExnMin        of ExpressionNumber * ExpressionNumber\n        | ExnDeIsChild  of ExpressionText   * ExpressionText   * ExpressionText  \n        \n    and ExpressionAny =    \n        | ExiNA\n        | ExiStet\n        | ExiSlice      of Slice\n        | ExNumeric     of ExpressionNumber\n        | ExText        of ExpressionText\n        | ExiIf         of ExpressionNumber * ExpressionAny * ExpressionAny\n        \n    and  Slice = {\n        sliDims     : Map<DimId, ElmReference>   \n        calculation : CalId option\n        cube        : CubId option\n    } \n    \n    type ForType = \n        | ForBase\n        | ForConsolidated\n        | ForAll\n    \n    type Formula = {\n        forId          : ForId\n        forDestination : ElmReference list\n        forDescription : string\n        forText        : string\n        forExpression  : ExpressionAny\n        forType        : ForType\n        forOrder       : string\n    }\n    \n    [<NoComparison ; NoEquality>]\n    type Calculation = {\n        calId          : CalId\n        calName        : string\n        calDescription : string\n        calOrder       : string\n        format         : string\n        isText         : bool\n        isInput        : bool\n        isBalance      : bool\n        calDims        : Set<DimId>\n        calFormulas    : Formula []\n        cube           : CubId   option\n        properties     : System.Collections.Generic.Dictionary<string, string>\n    } \n    \n    type RuleKey = \n        | RuleKey     of RulId\n        | CalcRuleKey of CalId\n        | FormulaKey  of ForId\n        | ForTextKey  of ForId\n        | ActualRuleKey \n        | InputRuleKey\n        | ConsolidatedRuleKey\n    \n    type Cube = {\n        cubId          : CubId\n        cubName        : string\n        cubRules       : Map<RuleKey, Rule option>\n        cubDims        : DimId []\n        measureDim     : DimId option\n        cubType        : CubeType\n    }\n    \n    and  Rule = {\n        rulId          : RulId\n        rulSourceId    : IComparable\n        rulDescription : string\n        rulDestination : ElmReference list\n        rulExpression  : ExpressionAny\n        rulType        : ForType\n        rulOrder       : string\n    }\n    \n    [<NoComparison ; NoEquality>]\n    type Model = {\n        modId           : ModId\n        server          : string\n        actualElem      : string\n        modDims         : Dimension   []\n        modCubes        : Cube        []\n        modCalculations : Calculation []\n    } \n    \n    let Xmodel = \n      {\n        modId           = ModId <| Guid.NewGuid()\n        server          = @\"local\\Budget\"\n        actualElem      = \"Actual\"\n        modDims         = [||]\n        modCubes        = [||]\n        modCalculations = [||]\n      }\n        \n    let Map_adds kvs map = Seq.append (map |> Map.toSeq) kvs |> Map\n    let calcSlice calc : Slice = \n             {\n                 sliDims       = Map.empty\n                 calculation   = Some calc.calId\n                 cube          = None\n             }\n        \n    type HelperTypeN = HelperTypeN with\n        static member (&%>)  (HelperTypeN, a :     bool             ) : ExpressionNumber = ExnNumber <| if    a then 1.0 else 0.0\n        static member (&%>)  (HelperTypeN, a :     int              ) : ExpressionNumber = ExnNumber <| float a\n        static member (&%>)  (HelperTypeN, a :     float            ) : ExpressionNumber = ExnNumber          a\n        static member (&%>)  (HelperTypeN, a :     Slice            ) : ExpressionNumber = ExnSlice           a\n        static member (&%>)  (HelperTypeN, a :     Calculation      ) : ExpressionNumber = ExnSlice  <| calcSlice a\n        static member (&%>)  (HelperTypeN, a :     ExpressionNumber ) : ExpressionNumber =                    a\n        \n    let inline toExpN v : ExpressionNumber = HelperTypeN &%>  v\n    \n    type HelperTypeT = HelperTypeT with\n        static member (&&>)  (HelperTypeT, a :     string           ) : ExpressionText   = ExtString          a \n        static member (&&>)  (HelperTypeT, a :     Dimension        ) : ExpressionText   = ExtDimName         a.dimId \n        static member (&&>)  (HelperTypeT, a :     Slice            ) : ExpressionText   = ExtSlice           a\n        static member (&&>)  (HelperTypeT, a :     Calculation      ) : ExpressionText   = ExtSlice  <| calcSlice a\n        static member (&&>)  (HelperTypeT, a :     ExpressionText   ) : ExpressionText   =                    a\n    \n    let inline toExpT  v : ExpressionText = HelperTypeT &&>  v\n    \n    type HelperTypeA = HelperTypeA with\n        static member (&>>)  (HelperTypeA, a :     ExpressionNumber) : ExpressionAny = ExNumeric          a \n        static member (&>>)  (HelperTypeA, a :     ExpressionText  ) : ExpressionAny = ExText             a\n        static member (&>>)  (HelperTypeA, a :     Slice           ) : ExpressionAny = ExiSlice           a\n        static member (&>>)  (HelperTypeA, a :     Calculation     ) : ExpressionAny = ExiSlice <| calcSlice a\n        static member (&>>)  (HelperTypeA, a :     bool            ) : ExpressionAny = toExpN             a |> ExNumeric\n        static member (&>>)  (HelperTypeA, a :     int             ) : ExpressionAny = toExpN             a |> ExNumeric\n        static member (&>>)  (HelperTypeA, a :     float           ) : ExpressionAny = toExpN             a |> ExNumeric\n        static member (&>>)  (HelperTypeA, a :     string          ) : ExpressionAny = toExpT             a |> ExText\n        static member (&>>)  (HelperTypeA, a :     ExpressionAny   ) : ExpressionAny =                    a\n    \n    let inline toExpA  v : ExpressionAny = HelperTypeA &>>  v\n\n    type Message =\n        | DimensionNotFound      of DimId\n        | DimensionHasNoElements of string\n        | ElementNotFound        of string * ElmId\n        | CubeNotFound           of CubId\n        | CubeHasNoMeasureDim    of string\n        | CalculationNotFound    of CalId\n        | CalculationHasNoCube   of string\n        interface ErrMsg with\n            member this.ErrMsg   : string = sprintf \"%A\" this\n            member this.IsWarning: bool   = false\n        override this.ToString() = (this :> ErrMsg).ErrMsg\n\n    let fromOptF f = Result.fromOptionW (fun () -> errSimple <| f())\n    let fromOptS s = Result.fromOption  (          errSimple <| s  )\n\n    module internal Model0 =\n        let getCubeO    cubId mdl = mdl.modCubes        |> Seq.tryFind (fun cub -> cub.cubId   =  cubId)\n        let getDimO       dId mdl = mdl.modDims         |> Seq.tryFind (fun d   ->   d.dimId   =    dId)\n        let getDimR       dId mdl = getDimO  dId mdl |> Result.fromOption (DimensionNotFound   dId)\n\n    module Element  =\n        let newElement name = \n          {\n            elmId          = ElmId <| Guid.NewGuid()\n            elmDim         = DimId <| Guid.NewGuid()\n            elmType        = EtString\n            elmName        = name\n            elmDescription = name\n            elmAttributes  = Map.empty\n            elmParents     = [||]\n          }\n\n    module ElmReference =\n        let dimId elr =\n            match elr with\n            | ElemFixed  (id, _)\n            | ElemDynamic(id, _) -> id\n\n    module Slice =\n        let newSlice ds = {\n                 sliDims       = ds |> Seq.map (fun dr -> ElmReference.dimId dr, dr) |> Map \n                 calculation   = None\n                 cube          = None\n        }\n        let forAll = {\n                 sliDims       = Map.empty\n                 calculation   = None\n                 cube          = None\n        }\n        let addRef elr slc = { slc with sliDims = slc.sliDims |> Map.add (ElmReference.dimId elr) elr }\n   \n    module Dimension =\n        let getElementO      eId dim = dim.dimElements |> Seq.tryFind (fun e -> e.elmId = eId)    \n        let getElementR      eId dim = getElementO eId dim |> Result.fromOption (ElementNotFound(dim.dimName, eId))\n        let newDimension name isCalcDim =\n              {\n                dimId          = DimId <| Guid.NewGuid()\n                dimName        = name\n                dimPrefix      = \"\"\n                dimType        = DtOther\n                defaultElm     = None\n                dimElements    = [|  |]\n                dimAttributes  = [|  |]      \n                isCalcDim      = isCalcDim\n              }\n        let newDimensionNonCalc name  = newDimension name false\n        let newDimensionCalc    name  = newDimension name true \n        let inline getElmReference it dim =\n            match toExpT it with \n            | ExtString s1 -> let s2 = s1.Replace(\"_\", \" \")\n                              let elm =\n                                 dim.dimElements                                 \n                                 |> Seq.tryFind (fun e -> e.elmName = s2)\n                                 |> Option.defaultWith (fun () -> \n                                     let newE = Element.newElement s2\n                                     dim.dimElements <- Array.append dim.dimElements [| newE |]\n                                     newE\n                                 )\n                              ElemFixed  (dim.dimId, elm.elmId) \n            | exp          -> ElemDynamic(dim.dimId, exp      )  \n//        member inline this.Item (it) = getElmReference it this\n        //member inline this.__     it     = this.Item it\n        //member inline this.M      it     = this.Item it\n        //member inline this.E      it     = this.Item it\n        //member inline this.I      it     = this.Item it\n        let prefix  pr   dim  = { dim with dimPrefix = pr   }\n        let dType   dt   dim  = { dim with dimType   = dt   }\n        let setName name dim  = { dim with dimName   = name }\n\n    type Dimension with\n        member inline this.Item (it) = Dimension.getElmReference it this\n\n\n    module Cube =\n        let slice cub : Slice = \n             {\n                 sliDims       = Map.empty\n                 calculation   = None\n                 cube          = Some cub.cubId\n             }\n        let containsDim dimId         cub = cub.cubDims |> Seq.contains dimId\n        let isCalcCube                cub = cub.cubType = CtCalc    \n        let newCube name dims mDimO cType = \n                {\n                  cubId      = CubId <| Guid.NewGuid()\n                  cubName    = name\n                  cubDims    = dims\n                  cubRules   = Map.empty\n                  measureDim = mDimO\n                  cubType    = cType\n                }\n        let newCubeCalc name dims mDimO = newCube name  dims mDimO CtCalc \n        let newCubeDims name dims mDimO = newCube name (dims |> Seq.map (fun d -> d.dimId) |> Seq.toArray) mDimO CtOther\n        let addRule     key rule  cub   = { cub with cubRules =                                              Map.add key rule         cub.cubRules }\n        let addRules        rules cub   = { cub with cubRules = rules |> Seq.fold (fun rulesN (key, rule) -> Map.add key rule rulesN) cub.cubRules }\n        //member inline this.Calc ()    = { this with cubType = CtCalc } \n        let forElr (es: ElmReference list) cub = { slice cub with sliDims = Map_adds (List.map (fun (e:ElmReference) -> ElmReference.dimId e, e) es) (slice cub).sliDims } \n        let dims            model cub   = model.modDims |> Array.filter(fun d -> cub.cubDims |> Array.exists ((=) d.dimId) )\n        let measureDimO     model cub   = cub.measureDim    |> Option.bind (swap Model0.getDimO model)\n        let measureDimR     model cub   = cub.measureDim         |> Result.fromOption (CubeHasNoMeasureDim cub.cubName) |> Result.bind (swap Model0.getDimR model)\n        let measureDimNameR model cub   = measureDimR model cub  |> Result.map (fun dim -> dim.dimName)\n        \n    module Calculation =\n        let slice calc = calcSlice calc\n        let calcType calc = if calc.isInput then \"INPUT\" else \"CALC\"    \n        let newInput (name: string) dims  =\n             {\n                calId          = CalId <| Guid.NewGuid()\n                calName        = name.Replace(\"_\", \" \").Trim()\n                calDescription = \"\"\n                calOrder       = \"\"\n                format         = \"#,##0.00\"\n                isText         = false\n                isInput        = true\n                isBalance      = false\n                calDims        = dims |> Seq.map (fun d -> d.dimId) |> Set \n                calFormulas    = [||]\n                cube           = None\n                properties     = System.Collections.Generic.Dictionary<string, string>()\n             }\n        let newCalc    name dims      = { newInput name dims     with isInput     = false }\n        let setName    name      calc = { calc                   with calName     = name  }\n        let setOrder   order     calc = { calc                   with calOrder    = order }\n        let addFormula frml      calc = { calc                   with calFormulas = Array.append calc.calFormulas [| frml |] }\n        let forSlice (es: ElmReference list) calc = { slice calc with sliDims = Map_adds (List.map (fun e -> ElmReference.dimId e, e) es) (slice calc).sliDims } \n        let addFormulas fs calc = if Seq.isEmpty fs then calc else { calc with calFormulas = fs |> Seq.toArray |> Array.append calc.calFormulas } \n        let withCube (model: Model) calc f = calc.cube |> Option.bind (swap Model0.getCubeO model) |> Option.bind f\n        let getElemRefO(model: Model) calc =\n            calc.cube \n            |> Option.bind (swap Model0.getCubeO model)\n            |> Option.bind (fun cub ->  cub.measureDim) \n            |> Option.bind (swap Model0.getDimO  model)\n            |> Option.map  (Dimension.getElmReference calc.calName)\n        let cubeR           c = c.cube          |> fromOptF (fun () -> sprintf \"Calculation '%s' has no cube\" c.calName)\n        let getElemRefR   m c = getElemRefO m c |> fromOptF (fun () -> sprintf \"Calcuation '%s' has no ElemRef\" c.calName) \n\n        \n    module Model =\n        let addCalcs     cs   mdl = { mdl with modCalculations = cs |> Seq.toArray |> Array.append mdl.modCalculations }\n        let addDims      ds   mdl = { mdl with modDims         = ds |> Seq.toArray |> Array.append mdl.modDims         }\n        let addCubes     cs   mdl = { mdl with modCubes        = cs |> Seq.toArray |> Array.append mdl.modCubes        }\n        let addForms     fs   mdl = { mdl with modCalculations = mdl.modCalculations |> Array.map (fun cal -> fs |> Seq.filter (fst >> (=) cal.calId) |> Seq.map snd |> Calculation.addFormulas <| cal) }\n        let addCalc      calc mdl = { mdl with modCalculations = Array.append mdl.modCalculations [| calc |] }\n        let addDim       dim  mdl = { mdl with modDims         = Array.append mdl.modDims         [| dim  |] }\n        let addCube      cube mdl = { mdl with modCubes        = Array.append mdl.modCubes        [| cube |] }\n        let addForm  cid frm  mdl = { mdl with modCalculations = mdl.modCalculations |> Array.map (fun cal -> if cal.calId = cid then Calculation.addFormula frm cal else cal) }\n        let getDimO               = Model0.getDimO\n        let getDimR               = Model0.getDimR\n        let getCalcO      cId mdl = mdl.modCalculations |> Seq.tryFind (fun c   ->   c.calId   =    cId)\n        let getCubeO              = Model0.getCubeO\n        let getCalcR      cId mdl = getCalcO cId mdl |> Result.fromOption (CalculationNotFound cId)\n        let getCubeR      cId mdl = getCubeO cId mdl |> Result.fromOption (CubeNotFound        cId)\n        let pickCubeO      ct mdl = mdl.modCubes        |> Seq.tryPick (fun c   ->   if c.cubType = ct then Some c else None)\n        let pickDimO       dt mdl = mdl.modDims         |> Seq.tryPick (fun d   ->   if d.dimType = dt then Some d else None)\n        let pickCalcO      cn mdl = mdl.modCalculations |> Seq.tryPick (fun c   ->   if c.calName = cn then Some c else None)\n        let freezeCubeO       mdl = pickCubeO CtFreeze   mdl\n        let tCalcDimO         mdl = pickDimO  DtTCalc    mdl \n        let dataTypeDimO      mdl = pickDimO  DtDataType mdl\n        let timeDimO          mdl = pickDimO  DtTime     mdl\n        let versionDimO       mdl = pickDimO  DtVersion  mdl\n        let isActualCalcO     mdl = pickCalcO \"IsActual\" mdl \n        let getCalcCube dims  mdl = \n            mdl.modCubes \n            |> Seq.filter  Cube.isCalcCube\n            |> Seq.tryFind (fun cub -> \n                cub.cubDims \n                |> Seq.filter (fun d -> Some d <> cub.measureDim) \n                |> Set = dims )\n        let setCube cubeN model = { model with modCubes = model.modCubes |> Array.map (fun cub -> if cub.cubId = cubeN.cubId then cubeN else cub ) }\n        let withDimsO mdl cube f =\n            let (<*>)   = Option.apply\n            let dimMeaO = cube.measureDim |> Option.bind (swap getDimO mdl) \n            Some f <*> dimMeaO <*> dataTypeDimO mdl <*> versionDimO mdl <*> timeDimO mdl |> Option.join\n        let withDims mdl cube f = withDimsO mdl cube (fun a b c d -> f a b c d |> Some)\n        let dimCombinations model =\n            model.modCalculations\n            |>  Seq.map (fun c -> c.calDims)\n            |>  Seq.distinct \n        let cubePrefix    = \"Z\"\n        let measurePrefix = \"M\"\n        let orderedDims dimIds model =\n                model.modDims \n                |>  Seq.filter (fun d -> dimIds |> Seq.exists ((=) d.dimId) ) \n        let autoName dimIds model =\n            let nameBase =\n                model\n                |> orderedDims dimIds\n                |> Seq.map (fun d -> d.dimPrefix)\n                |>  String.concat \"\"\n            let similar =\n                model.modCubes\n                |> Seq.choose (fun c -> \n                    match cubePrefix + nameBase with\n                    | n when c.cubName          = n -> Some -1\n                    | n when c.cubName.StartsWith n -> c.cubName.[nameBase.Length + 1..] |> parseInt\n                    | _                             -> None\n                ) \n            nameBase\n          + if similar |> Seq.isEmpty then \"\" else similar |> Seq.max |> ((+) 1) |> sprintf \"%d\"\n    \n        let dimIds           model = model.modDims |> Array.map (fun d -> d.dimId)\n        let fixForDimensions model =\n            //this.modCubes        <- this.modCubes        |>> fun cub -> { cub with cubDims = cub.cubDims |> Array.filter (fun d -> Seq.exists ((=) d) this.DimIds) }\n            let calcs = model.modCalculations |> Array.map (fun cal -> { cal with calDims = cal.calDims |> Set.filter   (fun d -> Seq.exists ((=) d) (dimIds model)) } )\n            { model with modCalculations = calcs }\n        let newCalcCube dimIds model =\n            let name = autoName dimIds model\n            let mDim = Dimension.newDimensionCalc <| measurePrefix + name\n            let orderedDimIds = \n                model\n                |> orderedDims dimIds\n                |> Seq.append <| [ mDim ]\n                |> Seq.map (fun d -> d.dimId)\n                |> Seq.toArray\n            let dims  = Array.append model.modDims  [| mDim                                                                 |]\n            let cubes = Array.append model.modCubes [| Cube.newCubeCalc (cubePrefix + name) orderedDimIds (Some mDim.dimId) |]\n            { model with modDims = dims ; modCubes = cubes }\n        let fixCalcsAndCubes model =\n            let calNoCube = model.modCalculations |> Array.filter (fun c -> c.cube |> Option.bind (swap getCubeO model) |> Option.isNone)\n            if Seq.isEmpty calNoCube then model else\n                let modelN =\n                    calNoCube\n                    |> Seq.map      (fun c -> c.calDims)\n                    |> Seq.distinct\n                    |> Seq.filter   ((swap getCalcCube  model) >> Option.isNone)\n                    |> Seq.fold      (swap newCalcCube) model\n                let calcs =\n                    modelN.modCalculations\n                    |> Array.map (fun oldC ->\n                            calNoCube \n                            |> Seq.tryFind (fun newC -> newC.calId = oldC.calId)\n                            |> Option.map  (fun newC -> { newC with Calculation.cube = (getCalcCube newC.calDims modelN) |> Option.map (fun cub -> cub.cubId) } )\n                            |> Option.defaultValue oldC\n                      )\n                { modelN with modCalculations = calcs }\n        let prepareModel model =\n            model\n            |> fixForDimensions \n            |> fixCalcsAndCubes\n        let addRules rules model =\n            rules\n            |> Seq.groupBy (fun (cubId, _, _) -> cubId)\n            |> Seq.fold (fun mdl (cubId, rules) ->\n                getCubeO cubId mdl\n                |> Option.map(fun cube ->\n                    rules \n                    |> Seq.map (fun (_, key, rule) -> key, rule)\n                    |> Cube.addRules <| cube\n                    |> swap setCube mdl\n                )\n                |> Option.defaultValue mdl\n            ) model\n            \n    \n    module Formula =\n        let inline newFormula dest exp  typ =\n              {\n                  forId          = ForId <| Guid.NewGuid()\n                  forDestination = dest\n                  forDescription = \"\"\n                  forText        = \"\"\n                  forExpression  = toExpA exp\n                  forType        = typ\n                  forOrder       = \"\"\n              }\n        let inline newBase    expr      = newFormula []   expr ForBase         |> Calculation.addFormula\n        let inline newBaseFor expr dest = newFormula dest expr ForBase         |> Calculation.addFormula\n        let inline newCons    expr      = newFormula []   expr ForConsolidated |> Calculation.addFormula\n        let inline newConsFor expr dest = newFormula dest expr ForConsolidated |> Calculation.addFormula\n        let inline newAll     expr      = newFormula []   expr ForAll          |> Calculation.addFormula\n        let inline newAllFor  expr dest = newFormula dest expr ForAll          |> Calculation.addFormula\n        let        conso      frm       = { frm with forType  = ForConsolidated }\n        let        setText    txt  frm  = { frm with forText  = txt             }\n        let        setOrder   ord  frm  = { frm with forOrder = ord             }\n        let getDimDest dim frm = \n            frm.forDestination \n            |> swap Seq.tryPick <| fun er -> if ElmReference.dimId er = dim.dimId then Some er else None\n        \n\n    module Rule =\n        let inline newRule     dest exp typ order =\n              {\n                  rulId          = RulId <| Guid.NewGuid()\n                  rulDestination = dest\n                  rulDescription = \"\"\n                  rulExpression  = toExpA exp\n                  rulType        = typ\n                  rulOrder       = order\n                  rulSourceId    = None\n              }\n        let inline newRuleDest dest exp typ = newRule (dest.sliDims |> Map.toList |> List.map snd) exp typ\n        let conso rul = { rul with rulType = ForConsolidated }    \n    ","parent":{"$":0,"Item":"86382469-687d-4914-94b9-4067d8c5c7e7"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"af2b60c6-a99f-433d-b938-f59fefe66c01"},{"$":0,"Item":"657c8f34-c917-4659-825d-c9ead206efcf"}],"id":{"$":0,"Item":"58a9fc2a-df09-42ef-ba7a-54e780167009"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"MonadicModel","content":"\nlet cons head tail = head :: tail\n\ntype ModelM<'T> = ModelM of (CalculationModel.Model -> Result<'T>)\nmodule ModelM =\n    open CalculationModel\n    let model                     = ModelM Result.succeed\n    let getDimO               dId = ModelM(fun m -> Model.getDimO               dId   m |> fromOptF (fun () -> sprintf \"Dimension %A not found\"    dId) )\n    let getDimR               dId = ModelM(fun m -> Model.getDimR               dId   m ) \n    let getCalcO              cId = ModelM(fun m -> Model.getCalcO              cId   m |> fromOptF (fun () -> sprintf \"Calculation %A not found\"  cId) )\n    let getCubeO              cId = ModelM(fun m -> Model.getCubeO              cId   m |> fromOptF (fun () -> sprintf \"Cube %A not found\"         cId) )\n    let getCalcR              cId = ModelM(fun m -> Model.getCalcR              cId   m ) \n    let getCubeR              cId = ModelM(fun m -> Model.getCubeR              cId   m ) \n    let pickCubeO              ct = ModelM(fun m -> Model.pickCubeO              ct   m |> fromOptF (fun () -> sprintf \"Cube type %A not found\"      ct ) )\n    let pickDimO               dt = ModelM(fun m -> Model.pickDimO               dt   m |> fromOptF (fun () -> sprintf \"Dimension type %A not found\" dt ) )\n    let pickCalcO              cn = ModelM(fun m -> Model.pickCalcO              cn   m |> fromOptF (fun () -> sprintf \"Calculation '%s' not found\"  cn ) )\n    let freezeCubeO               = ModelM(fun m -> Model.freezeCubeO                 m |> fromOptS \"Model has no Freeze cube\"                  )\n    let tCalcDimO                 = ModelM(fun m -> Model.tCalcDimO                   m |> fromOptS \"Model has no TCalc dimension\"              )\n    let dataTypeDimO              = ModelM(fun m -> Model.dataTypeDimO                m |> fromOptS \"Model has no DataType dimension\"           )\n    let timeDimO                  = ModelM(fun m -> Model.timeDimO                    m |> fromOptS \"Model has no time    dimension\"            )\n    let versionDimO               = ModelM(fun m -> Model.versionDimO                 m |> fromOptS \"Model has no version dimension\"            )\n    let isActualCalcO             = ModelM(fun m -> Model.isActualCalcO               m |> fromOptS \"'isActual' calculation not found\"          )\n    let getCalcCube         dims  = ModelM(fun m -> Model.getCalcCube         dims    m |> Result.succeed)\n    let setCube           cubeN   = ModelM(fun m -> Model.setCube           cubeN     m |> Result.succeed) \n    let dimCombinations           = ModelM(fun m -> Model.dimCombinations             m |> Result.succeed) \n    let orderedDims        dimIds = ModelM(fun m -> Model.orderedDims          dimIds m |> Result.succeed) \n    let autoName           dimIds = ModelM(fun m -> Model.autoName             dimIds m |> Result.succeed) \n    let dimIds                    = ModelM(fun m -> Model.dimIds                      m |> Result.succeed) \n    let fixForDimensions          = ModelM(fun m -> Model.fixForDimensions            m |> Result.succeed) \n    let newCalcCube        dimIds = ModelM(fun m -> Model.newCalcCube          dimIds m |> Result.succeed) \n    let fixCalcsAndCubes          = ModelM(fun m -> Model.fixCalcsAndCubes            m |> Result.succeed) \n    let prepareModel              = ModelM(fun m -> Model.prepareModel                m |> Result.succeed) \n    let addRules            rules = ModelM(fun m -> Model.addRules              rules m |> Result.succeed) \n    let modId                     = ModelM(fun m -> m.modId                             |> Result.succeed) \n    let server                    = ModelM(fun m -> m.server                            |> Result.succeed) \n    let actualElem                = ModelM(fun m -> m.actualElem                        |> Result.succeed) \n    let modDims                   = ModelM(fun m -> m.modDims                           |> Result.succeed) \n    let modCubes                  = ModelM(fun m -> m.modCubes                          |> Result.succeed) \n    let modCalculations           = ModelM(fun m -> m.modCalculations                   |> Result.succeed) \n\n    let inline rtn  a                                  = ModelM(fun _ -> Result.succeed a)\n    let inline rtnR a                                  = ModelM(fun _ ->                a)\n    let inline getResult                   (ModelM a)  = ModelM(fun m -> a m |> Result.succeed )\n    let inline bind  (f: 'a -> ModelM<'b>) (ModelM a)  = ModelM(fun m -> a m |> Result.bind (f >> function ModelM b -> b m) )\n    let inline bindR (f: 'a -> ModelM<'b>)         a   = ModelM(fun m -> a   |> Result.bind (f >> function ModelM b -> b m) )\n    let inline map f m                                 = bind (f >> rtn) m\n    let inline apply fX vX                             = fX |> bind  (swap map  vX)\n    let inline combine a b                             = a  |> bind (fun _ -> b)\n    let inline run model                   (ModelM m)  = m model\n    let rec traverseM f list =\n        let (>>=) v f = bind f v\n        let retn      = rtn\n        let initState = retn []\n        let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n        List.foldBack folder list initState \n    let inline sequenceM x = traverseM id x\n\n    type Builder() =\n        member inline this.Return      x                        = rtn x\n        member inline this.ReturnFrom  x                        = x\n        member        this.Bind       (w , r )                  = bind  r w\n        member        this.Bind       (w , r )                  = bindR r w\n        member inline this.Zero       ()                        = rtn ()\n        member inline this.Delay       f                        = f\n        member inline this.Combine    (a, b)                    = combine a b\n        member inline this.Run         f                        = f()\n        member this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else rtn   ()\n            whileLoop guard body\n        member this.TryWith(body, handler) =\n            try this.ReturnFrom(body())\n            with e -> handler e\n        member this.TryFinally(body, compensation) =\n            try this.ReturnFrom(body())\n            finally compensation()\n        member this.Using(disposable:#System.IDisposable, body) =\n            let body' = fun () -> body disposable\n            this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))              \n\ntype CubeM<'T> = CubeM of (CalculationModel.Model -> CalculationModel.Cube -> Result<'T>)\nmodule CubeM =\n    open CalculationModel\n    let slice                     = CubeM(fun m c -> Cube.slice                       c |> Result.succeed)\n    let containsDim     dimId     = CubeM(fun m c -> Cube.containsDim     dimId       c |> Result.succeed)\n    let isCalcCube                = CubeM(fun m c -> Cube.isCalcCube                  c |> Result.succeed)\n    let addRule         key rule  = CubeM(fun m c -> Cube.addRule         key rule    c |> Result.succeed)\n    let addRules            rules = CubeM(fun m c -> Cube.addRules            rules   c |> Result.succeed)\n    let forElr                 es = CubeM(fun m c -> Cube.forElr                 es   c |> Result.succeed)\n    let dims                      = CubeM(fun m c -> Cube.dims                      m c |> Result.succeed)\n    let measureDimO               = CubeM(fun m c -> Cube.measureDimO               m c |> Result.succeed)\n    let measureDimR               = CubeM(fun m c -> Cube.measureDimR               m c                  )\n    let measureDimNameR           = CubeM(fun m c -> Cube.measureDimNameR           m c                  )\n    let cubId                     = CubeM(fun m c -> c.cubId                            |> Result.succeed)\n    let cubName                   = CubeM(fun m c -> c.cubName                          |> Result.succeed)\n    let cubRules                  = CubeM(fun m c -> c.cubRules                         |> Result.succeed)\n    let cubDims                   = CubeM(fun m c -> c.cubDims                          |> Result.succeed)\n    let measureDim                = CubeM(fun m c -> c.measureDim                       |> fromOptF (fun () -> sprintf \"Cube %s has no measureDim\" c.cubName) )\n    let cubType                   = CubeM(fun m c -> c.cubType                          |> Result.succeed)\n\n    let inline rtn                                a  = CubeM(fun _ _ -> Result.succeed a  )\n    let inline rtnR                               a  = CubeM(fun _ _ ->                a  )\n    let inline rtnM                       (ModelM a) = CubeM(fun m _ ->                a m)\n    let inline getResult                  (CubeM  a) = CubeM(fun m c -> a m c |> Result.succeed)\n    let inline bind  (f: 'a -> CubeM<'b>) (CubeM  a) = CubeM(fun m c -> a m c |> Result.bind (f >> function CubeM b -> b m c) )\n    let inline bindM (f: 'a -> CubeM<'b>) (ModelM a) = CubeM(fun m c -> a m   |> Result.bind (f >> function CubeM b -> b m c) )\n    let inline bindR (f: 'a -> CubeM<'b>)         a  = CubeM(fun m c -> a     |> Result.bind (f >> function CubeM b -> b m c) )\n    let inline map f m                               = bind (f >> rtn) m\n    let inline combine a b                           = a |> bind (fun _ -> b)\n    let inline run model cube             (CubeM  m) = m model cube\n    let inline runM      cube             (CubeM  m) = ModelM(fun mdl -> m mdl cube)\n    let rec traverseM f list =\n        let (>>=) v f = bind f v\n        let retn      = rtn\n        let initState = retn []\n        let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n        List.foldBack folder list initState \n    let inline sequenceM x = traverseM id x\n\n    type Builder() =\n        member inline this.Return      x                        = rtn      x\n        member inline this.ReturnFrom  x                        =          x\n        member        this.Bind       (w , r )                  = bind  r  w\n        member        this.Bind       (w , r )                  = bindM r  w\n        member        this.Bind       (w , r )                  = bindR r  w\n        member inline this.Zero       ()                        = rtn ()\n        member inline this.Delay       f                        = f\n        member inline this.Combine    (a, b)                    = combine a b\n        member inline this.Run         f                        = f()\n        member this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else rtn   ()\n            whileLoop guard body\n        member this.TryWith(body, handler) =\n            try body()\n            with e -> handler e\n        member this.TryFinally(body, compensation) =\n            try body()\n            finally compensation()\n        member this.Using(disposable:#System.IDisposable, body) =\n            let body' = fun () -> body disposable\n            this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))              \n\ntype DimensionM<'T> = DimensionM of (CalculationModel.Model -> CalculationModel.Dimension -> Result<'T>)\nmodule DimensionM =\n    open CalculationModel\n    let        getElementO     eId  = DimensionM(fun m d -> Dimension.getElementO      eId d |> Result.succeed)\n    let        getElementR     eId  = DimensionM(fun m d -> Dimension.getElementR      eId d                  )\n    let inline getElmReference it   = DimensionM(fun m d -> Dimension.getElmReference   it d |> Result.succeed)\n    let        prefix          pr   = DimensionM(fun m d -> Dimension.prefix          pr   d |> Result.succeed)\n    let        dType           dt   = DimensionM(fun m d -> Dimension.dType           dt   d |> Result.succeed)\n    let        setName         name = DimensionM(fun m d -> Dimension.setName         name d |> Result.succeed)\n    let        dimId                = DimensionM(fun m d -> d.dimId                          |> Result.succeed)\n    let        dimName              = DimensionM(fun m d -> d.dimName                        |> Result.succeed)\n    let        dimPrefix            = DimensionM(fun m d -> d.dimPrefix                      |> Result.succeed)\n    let        dimType              = DimensionM(fun m d -> d.dimType                        |> Result.succeed)\n    let        defaultElm           = DimensionM(fun m d -> d.defaultElm                     |> Result.succeed)\n    let        dimElements          = DimensionM(fun m d -> d.dimElements                    |> Result.succeed)\n    let        dimAttributes        = DimensionM(fun m d -> d.dimAttributes                  |> Result.succeed)\n    let        isCalcDim            = DimensionM(fun m d -> d.isCalcDim                      |> Result.succeed)\n\n    let inline rtn  a                                          = DimensionM(fun _ _ -> Result.succeed a)\n    let inline rtnR a                                          = DimensionM(fun _ _ ->                a)\n    let inline getResult                       (DimensionM  a) = DimensionM(fun m c -> a m c |> Result.succeed)\n    let inline bind  (f: 'a -> DimensionM<'b>) (DimensionM  a) = DimensionM(fun m c -> a m c |> Result.bind (f >> function DimensionM b -> b m c) )\n    let inline bindM (f: 'a -> DimensionM<'b>) (ModelM      a) = DimensionM(fun m c -> a m   |> Result.bind (f >> function DimensionM b -> b m c) )\n    let inline bindR (f: 'a -> DimensionM<'b>)              a  = DimensionM(fun m c -> a     |> Result.bind (f >> function DimensionM b -> b m c) )\n    let inline map f m                                         = bind (f >> rtn) m\n    let inline combine a b                                     = a |> bind (fun _ -> b)\n    let inline run model dim                  (DimensionM  m) = m model dim\n    let inline runM      dim                  (DimensionM  m) = ModelM(fun mdl -> m mdl dim)\n    let rec traverseM f list =\n        let (>>=) v f = bind f v\n        let retn      = rtn\n        let initState = retn []\n        let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n        List.foldBack folder list initState \n    let inline sequenceM x = traverseM id x\n\n    type Builder() =\n        member inline this.Return      x                        = rtn      x\n        member inline this.ReturnFrom  x                        =          x\n        member        this.Bind       (w , r )                  = bind  r  w\n        member        this.Bind       (w , r )                  = bindM r  w\n        member        this.Bind       (w , r )                  = bindR r  w\n        member inline this.Zero       ()                        = rtn ()\n        member inline this.Delay       f                        = f\n        member inline this.Combine    (a, b)                    = combine a b\n        member inline this.Run         f                        = f()\n        member this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else rtn   ()\n            whileLoop guard body\n        member this.TryWith(body, handler) =\n            try body()\n            with e -> handler e\n        member inline this.TryFinally(body, compensation) =\n            try body()\n            finally compensation()\n        member this.Using(disposable:#System.IDisposable, body) =\n            let body' = fun () -> body disposable\n            this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))              \n\ntype CalculationM<'T> = CalculationM of (CalculationModel.Model -> CalculationModel.Calculation -> Result<'T>)\nmodule CalculationM =\n    open CalculationModel\n    let slice             = CalculationM(fun m c -> Calculation.slice            c |> Result.succeed)\n    let calcType          = CalculationM(fun m c -> Calculation.calcType         c |> Result.succeed)\n    let setName    name   = CalculationM(fun m c -> Calculation.setName    name  c |> Result.succeed)\n    let setOrder   order  = CalculationM(fun m c -> Calculation.setOrder   order c |> Result.succeed)\n    let addFormula frml   = CalculationM(fun m c -> Calculation.addFormula frml  c |> Result.succeed)\n    let forSlice    es    = CalculationM(fun m c -> Calculation.forSlice    es   c |> Result.succeed)\n    let addFormulas fs    = CalculationM(fun m c -> Calculation.addFormulas fs   c |> Result.succeed)\n    let getElemRefR       = CalculationM(fun m c -> Calculation.getElemRefR    m c                  )\n    let calId             = CalculationM(fun m c -> c.calId                        |> Result.succeed)\n    let calName           = CalculationM(fun m c -> c.calName                      |> Result.succeed)\n    let calDescription    = CalculationM(fun m c -> c.calDescription               |> Result.succeed)\n    let calOrder          = CalculationM(fun m c -> c.calOrder                     |> Result.succeed)\n    let format            = CalculationM(fun m c -> c.format                       |> Result.succeed)\n    let isText            = CalculationM(fun m c -> c.isText                       |> Result.succeed)\n    let isInput           = CalculationM(fun m c -> c.isInput                      |> Result.succeed)\n    let isBalance         = CalculationM(fun m c -> c.isBalance                    |> Result.succeed)\n    let calDims           = CalculationM(fun m c -> c.calDims                      |> Result.succeed)\n    let calFormulas       = CalculationM(fun m c -> c.calFormulas                  |> Result.succeed)\n    let cube              = CalculationM(fun m c -> Calculation.cubeR            c                  )\n    let properties        = CalculationM(fun m c -> c.properties                   |> Result.succeed)\n\n    let inline rtn  a                                              = CalculationM(fun _ _ -> Result.succeed a)\n    let inline rtnR a                                              = CalculationM(fun _ _ ->                a)\n    let inline getResult                         (CalculationM  a) = CalculationM(fun m c -> a m c   |> Result.succeed )\n    let inline bind  (f: 'a -> CalculationM<'b>) (CalculationM  a) = CalculationM(fun m c -> a m c   |> Result.bind (f >> function CalculationM b -> b m c) )\n    let inline bindM (f: 'a -> CalculationM<'b>) (ModelM        a) = CalculationM(fun m c -> a m     |> Result.bind (f >> function CalculationM b -> b m c) )\n    let inline bindC (f: 'a -> CalculationM<'b>) (CubeM         a) = CalculationM(fun m c -> Calculation.cubeR c |> Result.bind (swap Model.getCubeR m) |> Result.bind (a m) |> Result.bind (f >> function CalculationM b -> b m c) )\n    let inline bindR (f: 'a -> CalculationM<'b>) (a: Result<_>   ) = CalculationM(fun m c -> a       |> Result.bind (f >> function CalculationM b -> b m c) )\n    let inline map f m                                             = bind (f >> rtn) m\n    let inline combine a b                                         = a |> bind (fun _ -> b)\n    let inline run  model calc                   (CalculationM  m) =                   m model calc\n    let inline runM       calc                   (CalculationM  m) = ModelM(fun mdl -> m mdl   calc)\n    let rec traverseM f list =\n        let (>>=) v f = bind f v\n        let retn      = rtn\n        let initState = retn []\n        let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n        List.foldBack folder list initState \n    let inline sequenceM x = traverseM id x\n\n    type Builder() =\n        member inline this.Return      x                        = rtn      x\n        member inline this.ReturnFrom  x                        =          x\n        member        this.Bind       (w , r )                  = bind  r  w\n        member        this.Bind       (w , r )                  = bindC r  w\n        member        this.Bind       (w , r )                  = bindM r  w\n        member        this.Bind       (w , r )                  = bindR r  w\n        member inline this.Zero       ()                        = rtn ()\n        member inline this.Delay       f                        = f\n        member inline this.Combine    (a, b)                    = combine a b\n        member inline this.Run         f                        = f()\n        member this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else rtn   ()\n            whileLoop guard body\n        member this.TryWith(body, handler) =\n            try body()\n            with e -> handler e\n        member this.TryFinally(body, compensation) =\n            try body()\n            finally compensation()\n        member this.Using(disposable:#System.IDisposable, body) =\n            let body' = fun () -> body disposable\n            this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))              \n\nlet calculationM  = CalculationM.Builder()\nlet dimensionM    = DimensionM.Builder()\nlet cubeM         = CubeM.Builder()\nlet modelM        = ModelM.Builder()","parent":{"$":0,"Item":"86382469-687d-4914-94b9-4067d8c5c7e7"},"predecessors":[{"$":0,"Item":"58a9fc2a-df09-42ef-ba7a-54e780167009"}],"id":{"$":0,"Item":"90cfafb9-9397-4dda-940b-8e33c4412d1c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"InitModel","content":"module InitModel =\n    open CalculationModel\n\n    let mutable initModel =\n      {\n        modId           = ModId <| Guid.NewGuid()\n        server          = @\"LOCAL\\CipherSpace\"\n        actualElem      = \"Actual\"\n        modCubes        = [| |]\n        modDims         = [| |]\n        modCalculations = [| |]\n      }\n      \n    let mutable dims         = []\n    let mutable calcs        = []\n    let mutable forms        = []\n    let mutable cubes        = []\n    let mutable rules        = []\n\n    let setInitModel model   = initModel <- model\n                               dims      <- []\n                               calcs     <- []\n                               forms     <- []\n                               cubes     <- []\n                               rules     <- []\n    let addDim  dim          = dims      <-  dim              :: dims\n                               dim\n    let addCalc calc         = calcs     <-  calc             :: calcs\n                               calc\n    let addFrm  calc frm     = forms     <- (calc.calId, frm) :: forms\n    let addCube cube         = cubes     <-  cube             :: cubes\n                               cube\n    let addRule rule         = rules     <-  rule             :: rules\n    let getDimId d = d.dimId\n\n    let newDim name typ pre  = Dimension.newDimensionNonCalc name |> Dimension.dType typ |> Dimension.prefix pre                   |> addDim\n    let newCalc typ name ord ds = typ name ds |> Calculation.setOrder ord                                                          |> addCalc\n    let newCube name typ dims mdim = Cube.newCube name (dims |> Seq.map getDimId |> Seq.toArray) (mdim |> Option.map getDimId) typ |> addCube\n    let inline newForm c t exp dest ord txt = Formula.newFormula dest exp t |> Formula.setText txt |> Formula.setOrder ord         |> addFrm c\n    let inline newRule cube dest exp typ order =  (cube, Rule.newRule dest exp typ order) |> addRule\n\n    let addDims ()           = initModel |> Model.addDims  (List.rev dims ) |> setInitModel\n    let addCalcs()           = initModel |> Model.addCalcs (List.rev calcs) |> setInitModel\n    let addFrms ()           = initModel |> Model.addForms (List.rev forms) |> setInitModel\n    let addCubes()           = initModel |> Model.addCubes (List.rev cubes) |> setInitModel\n    let addRules()           = initModel |> Model.addRules (List.rev rules  |> List.map (fun (cube, rule) -> cube.cubId, RuleKey rule.rulId, Some rule)) |> setInitModel\n\n\n","parent":{"$":0,"Item":"86382469-687d-4914-94b9-4067d8c5c7e7"},"predecessors":[{"$":0,"Item":"58a9fc2a-df09-42ef-ba7a-54e780167009"}],"id":{"$":0,"Item":"06aa50e4-05e5-4862-a528-57cdef08acfc"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CalculationSyntax","content":"#nowarn \"86\"\nmodule CalculationSyntax = \n    open CalculationModel\n\n    //let And = (&&)\n\n    let inline ( +   ) x y = ExnOperationN (OpAdd     , toExpN    x      , toExpN    y)\n    let inline ( -   ) x y = ExnOperationN (OpSubtract, toExpN    x      , toExpN    y)\n    let inline ( *   ) x y = ExnOperationN (OpMultiply, toExpN    x      , toExpN    y)\n    let inline ( /   ) x y = ExnOperationN (OpDivide  , toExpN    x      , toExpN    y)\n    let inline ( =   ) x y = ExnOperationN (OpEQ      , toExpN    x      , toExpN    y)\n    let inline ( <>  ) x y = ExnOperationN (OpNE      , toExpN    x      , toExpN    y)\n    let inline ( >   ) x y = ExnOperationN (OpGT      , toExpN    x      , toExpN    y)\n    let inline ( >=  ) x y = ExnOperationN (OpGE      , toExpN    x      , toExpN    y)\n    let inline ( <   ) x y = ExnOperationN (OpLT      , toExpN    x      , toExpN    y)\n    let inline ( <=  ) x y = ExnOperationN (OpLE      , toExpN    x      , toExpN    y)\n    let inline ( &&  ) x y = ExnOperationN (OpAnd     , toExpN    x      , toExpN    y)\n    let inline ( ||  ) x y = ExnOperationN (OpOr      , toExpN    x      , toExpN    y)\n     \n    let inline ( &=  ) x y = ExnOperationT (OpEQ      , toExpT    x      , toExpT    y)\n    let inline ( &<> ) x y = ExnOperationT (OpNE      , toExpT    x      , toExpT    y)\n    let inline ( &>  ) x y = ExnOperationT (OpGT      , toExpT    x      , toExpT    y)\n    let inline ( &>= ) x y = ExnOperationT (OpGE      , toExpT    x      , toExpT    y)\n    let inline ( &<  ) x y = ExnOperationT (OpLT      , toExpT    x      , toExpT    y)\n    let inline ( &<= ) x y = ExnOperationT (OpLE      , toExpT    x      , toExpT    y)\n     \n    let inline ( ?   ) (d:Dimension) e = d |> Dimension.getElmReference ( toExpT e )\n    let inline ( !   ) (d:Dimension)   = ExtDimElement d.dimId\n    \n    \n    let inline IF          (cond, thenR , elseR) = ExnIf       (toExpN cond, toExpN thenR , toExpN elseR)\n    let inline MAX         (v1  , v2           ) = ExnMax      (toExpN v1  , toExpN v2                  )\n    let inline MIN         (v1  , v2           ) = ExnMin      (toExpN v1  , toExpN v2                  )\n    let inline DE_ISCHILD  (dim , parent, child) = ExnDeIsChild(toExpT dim , toExpT parent, toExpT child)\n    \n    let inline IFt  (cond, thenR, elseR) = ExtIf   (toExpN cond, toExpT thenR, toExpT elseR)\n    let inline IFa  (cond, thenR, elseR) = ExiIf   (toExpN cond, toExpA thenR, toExpA elseR)\n    let inline SUBST(txt , from , len  ) = ExtSubSt(toExpT txt , toExpN from , toExpN len  )\n    \n    let forAll = {\n                 sliDims       = Map.empty\n                 calculation   = None\n                 cube          = None\n    }\n    \n    let inline toForm0 e = Formula.newFormula [] (toExpA e) ForBase\n    //let inline addFormula  (c:Calculation) f dest forT = c.Add({ f with forDestination = dest ; forType = forT })\n    //let inline addFormulaE (c:Calculation) e           = addFormula c (toForm0 e)\n    //let inline toRule0 e = Rule.New([], toExpA e, ForBase)\n    //let inline addRule     (c:Cube       ) r dest rulT = c.AddRule (RuleKey r.rulId) (Some { r with rulDestination = dest ; rulType = rulT })\n    //let inline addRuleE    (c:Cube       ) e           = addRule c (toRule0 e)\n    //\n   //\n    let Calc  = Calculation.newCalc\n    let Input = Calculation.newInput\n    let NA    = ExnNA\n    \n    module DE =\n        let inline ISCHILD  (dim , parent, child) = ExnDeIsChild(toExpT dim , toExpT parent, toExpT child)\n\n    type Calculation with\n        member calc.For ls = Calculation.forSlice ls calc\n        \n        ","parent":{"$":0,"Item":"86382469-687d-4914-94b9-4067d8c5c7e7"},"predecessors":[{"$":0,"Item":"06aa50e4-05e5-4862-a528-57cdef08acfc"},{"$":0,"Item":"58a9fc2a-df09-42ef-ba7a-54e780167009"}],"id":{"$":0,"Item":"4f4d9d79-09fe-4df1-8af2-0ba6a4fffa2c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Formula & Calculation Rules","content":"//open Useful\n\nmodule CalcRules =\n    let (==)  = (=)\n    let (&&=) = (&&)\n    let (&)   = (+)\n    open CalculationModel\n    open CalculationSyntax\n    open Useful\n    \n    let noneToFalseC              = CubeM .getResult    >> CubeM .map  (Result.ifError      false                              )\n    let noneToFalseM              = ModelM.getResult    >> ModelM.map  (Result.ifError      false                              )\n    let versionRef     (s:string) = ModelM.versionDimO  |> ModelM.map  (fun versionDim  ->  versionDim?(s)                     )\n    let dataTypeRef    (s:string) = ModelM.dataTypeDimO |> ModelM.map  (fun dataTypeDim ->  dataTypeDim?(s)                    )\n    let getSlice       refM       = refM                |> CubeM.bindM (fun ref         ->  CubeM.forElr [ ref ]               )\n    let containsDTDim             = ModelM.dataTypeDimO |> CubeM.bindM (fun dataTypeDim ->  CubeM.containsDim dataTypeDim.dimId) |> noneToFalseC\n    let containsVersionDim        = ModelM.versionDimO  |> CubeM.bindM (fun versionDim  ->  CubeM.containsDim versionDim .dimId) |> noneToFalseC\n    let containsTimeDim           = ModelM.timeDimO     |> CubeM.bindM (fun timeDim     ->  CubeM.containsDim timeDim    .dimId) |> noneToFalseC\n    let versionDimSl   (s:string) = versionRef     s    |> getSlice\n    let calculatedValue           = dataTypeRef \"Calculated Value\"\n    let manualAdjustment          = dataTypeRef \"Manual Adjustment\"\n    let frozenValue               = dataTypeRef \"Frozen Value\"\n    let value                     = dataTypeRef \"Value\"\n    let formulaElem               = dataTypeRef \"Formula\"\n    let actualElemRef             = ModelM.actualElem |> ModelM.bind versionRef\n    let valueCalc                 = calculationM {\n        let! calName = CalculationM.calName\n        let! meaDim  = CubeM.measureDimR\n        let! value   = value\n        let! slice   = CubeM.forElr [ value ; meaDim?(calName) ]\n        return slice\n    }\n    let tCalcCalcName             = calculationM {\n        let! calName  = CalculationM.calName\n        let! tCalcDim = ModelM.tCalcDimO\n        return tCalcDim?(calName)\n    }\n    let actualElemSl                            = ModelM.actualElem |> CubeM .bindM versionDimSl\n    let exitWhen                              v = if v then Result.fail (errSimple \"false\") else Result.succeed()\n    let cubeActualRule                          = actualElemRef |> ModelM.map (fun actualElem  -> Rule.newRule [ actualElem  ]  ExtStet        ForBase \"B\" )\n    let cubeFormulaRuleO  txt                   = formulaElem   |> ModelM.map (fun formulaElem -> Rule.newRule [ formulaElem ] (ExtString txt) ForBase \"G1\")\n    let cubeInputRuleO                          = cubeFormulaRuleO \"<Input>\"\n    let cubeConsolidationRuleO                  = cubeFormulaRuleO \"<Consolidation>\"\n    let getDimDest                    dimM  frm = dimM |> ModelM.bind (swap Formula.getDimDest frm >> fromOptS \"No getDimDest\" >> ModelM.rtnR)\n    let isFormulaText                       frm = getDimDest ModelM.dataTypeDimO frm |> ModelM.apply (ModelM.map (==) formulaElem  ) |> noneToFalseM \n    let isActual                            frm = getDimDest ModelM.versionDimO  frm |> ModelM.apply (ModelM.map (==) actualElemRef) |> noneToFalseM \n    let containsDimDest               dimM  frm = getDimDest dimM frm |> ModelM.map (fun _ -> true)                                  |> noneToFalseM\n    let dontUseCalculatedValue              frm = containsDimDest ModelM.dataTypeDimO frm\n    let addCalculatedValueF                 frm = calculationM {\n        let! dontUseCalculatedValue = dontUseCalculatedValue frm\n        if dontUseCalculatedValue then return id else\n        let! calculatedValue        = calculatedValue\n        return cons calculatedValue \n    }\n    let formulaRule                         frm = calculationM {\n        let! calcRef             = CalculationM.getElemRefR\n        let! addCalculatedValueF = addCalculatedValueF frm\n        let  dest                = calcRef :: frm.forDestination |> addCalculatedValueF\n        let! isFormulaText       = isFormulaText frm\n        let! isActual            = isActual frm\n        let! calOrder            = CalculationM.calOrder\n        let  order               = (if isFormulaText then \"E\" elif isActual then \"A\" else \"M\") & calOrder & frm.forOrder\n        return Rule.newRule dest frm.forExpression frm.forType order \n    }\n    let formulaTextRule frm = calculationM {\n        let! containsDTDim   = containsDTDim\n        do!  exitWhen     (not containsDTDim)\n        let! containsDTDest  = containsDimDest ModelM.dataTypeDimO frm\n        do!  exitWhen          containsDTDest\n        let! formulaRef      = formulaElem\n        let! calcRef         = CalculationM.getElemRefR\n        let! calOrder        = CalculationM.calOrder\n        let  order           = \"F\" & calOrder & frm.forOrder\n        return Rule.newRule (formulaRef :: calcRef :: frm.forDestination) (ExtString frm.forText) frm.forType order\n    }\n    let actualValueRule = calculationM {\n        let! isActualCalcR      = ModelM.isActualCalcO |> ModelM.getResult\n        if   Result.isError isActualCalcR then return id else\n        let! isActualCalc       = isActualCalcR\n        let! containsVersionDim = containsVersionDim\n        let! containsTimeDim    = containsTimeDim\n        let  useActual          = containsVersionDim &&= containsTimeDim\n        if   not useActual        then return id else\n        let! actualElemSl       = actualElemSl\n        return fun body -> IFa(isActualCalc = 1, actualElemSl, body)\n    }\n    let frozenBodyRule = calculationM {\n        let! freezeCubeR        = ModelM.freezeCubeO   |> ModelM.getResult\n        if Result.isError freezeCubeR then  return id else\n        let! freezeCube         = freezeCubeR\n        let! tCalcCalcName      = tCalcCalcName\n        let! frozenValue        = getSlice frozenValue     \n        return fun body -> IFa(Cube.forElr[tCalcCalcName] freezeCube = 1, frozenValue, body)\n    }\n    let calculationRule = calculationM {\n        let! containsDTDim      = containsDTDim\n        do!  exitWhen        (not containsDTDim)\n        let! isInput            = CalculationM.isInput\n        let! isText             = CalculationM.isText\n        let! calOrder           = CalculationM.calOrder\n        let! calName            = CalculationM.calName\n        let! calculatedValue    = getSlice calculatedValue \n        let! manualAdjustment   = getSlice manualAdjustment\n        let  body1              = if    isInput then ExiStet else \n                                     if isText  then IFa(manualAdjustment &= ExtNA, calculatedValue, manualAdjustment) \n                                                else calculatedValue + manualAdjustment |> ExNumeric\n        let! frozenBodyRule     = frozenBodyRule\n        let! actualValueRule    = actualValueRule\n        let  body2              = body1 |> frozenBodyRule |> actualValueRule\n        //do!  exitWhen  (body2 == ExiStet)\n        let! valueCalc          = valueCalc \n        return Rule.newRule (valueCalc.sliDims |> Map.toList |> List.map snd) body2 ForBase (\"N\" & calOrder)\n    }\n    let formulaRules frm = calculationM {\n        let! cubId        = CubeM.cubId\n        let! formRule     = formulaRule     frm |> CalculationM.getResult\n        let! formTextRule = formulaTextRule frm |> CalculationM.getResult\n        return [   cubId, (FormulaKey frm.forId), formRule     |> Result.toOption\n                   cubId, (ForTextKey frm.forId), formTextRule |> Result.toOption\n               ]\n     }\n    let calcRules = calculationM {\n        let! cubId        = CubeM.cubId\n        let! calId        = CalculationM.calId\n        let! calFormulas  = CalculationM.calFormulas\n        let! rule         = calculationRule |> CalculationM.getResult\n        let! ruless       = calFormulas     |> Seq.map formulaRules |> Seq.toList |> CalculationM.sequenceM\n        let  rules        = ruless          |> List.collect id\n        return (cubId, CalcRuleKey calId, rule |> Result.toOption) :: rules\n    }\n    let cubeRules = cubeM {\n        let! cubId        = CubeM.cubId\n        let! actualRule   = cubeActualRule          |> ModelM.getResult\n        let! inputRule    = cubeInputRuleO          |> ModelM.getResult\n        let! consolRule   = cubeConsolidationRuleO  |> ModelM.getResult\n        return [   cubId, ActualRuleKey      , actualRule |> Result.toOption\n                   cubId, InputRuleKey       , inputRule  |> Result.toOption\n                   cubId, ConsolidatedRuleKey, consolRule |> Result.toOption\n               ]\n    }\n    let modelRulesM = modelM {\n        let! model           = ModelM.model\n        let! modCubes        = ModelM.modCubes\n        let! modCalculations = ModelM.modCalculations\n        let  allCubeRules    = modCubes |> Seq.filter Cube.isCalcCube |> Seq.choose (fun cub -> CubeM.run        model cub cubeRules |> Result.toOption) |> Seq.collect id\n        let  allCalcRules    = modCalculations                        |> Seq.choose (fun cal -> CalculationM.run model cal calcRules |> Result.toOption) |> Seq.collect id\n        return Seq.append allCubeRules allCalcRules\n    }\n    let modelRules model = ModelM.run model modelRulesM\n    let addModelRules model =\n        let res = \n            model \n            |> modelRules \n            |> Result.map (swap Model.addRules model) \n        Result.getMsgs res\n        |> Seq.iter (printfn \"%A\")\n        res |> Result.ifError model\n    \n    ","parent":{"$":0,"Item":"86382469-687d-4914-94b9-4067d8c5c7e7"},"predecessors":[{"$":0,"Item":"90cfafb9-9397-4dda-940b-8e33c4412d1c"},{"$":0,"Item":"4f4d9d79-09fe-4df1-8af2-0ba6a4fffa2c"}],"id":{"$":0,"Item":"3425a36b-08fa-4a1e-8284-3785e56f8b06"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"RuleText","content":"module RuleText =\n    open CalculationModel\n    open Useful\n    \n    let opRuleText isText op =\n            match isText, op with\n            | _    , OpAdd      -> \"+\"\n            | _    , OpSubtract -> \"-\"\n            | _    , OpMultiply -> \"*\"\n            | _    , OpDivide   -> \"/\"\n            | _    , OpAnd      -> \"and\"\n            | _    , OpOr       -> \"or\"   \n            | false, OpEQ       -> \"=\"\n            | false, OpNE       -> \"<>\"\n            | false, OpGT       -> \">\"\n            | false, OpGE       -> \">=\"\n            | false, OpLT       -> \"<\"\n            | false, OpLE       -> \"<=\"\n            | true , OpEQ       -> \"@=\"\n            | true , OpNE       -> \"@<>\"\n            | true , OpGT       -> \"@>\"\n            | true , OpGE       -> \"@>=\"\n            | true , OpLT       -> \"@<\"\n            | true , OpLE       -> \"@<=\"\n    \n    let elemRuleText elem = sprintf \"'%s'\" elem.elmName       \n    let elementTextR dId eId = modelM {\n        let! dim  = ModelM.getDimR dId \n        let! elem = Dimension.getElementR eId dim\n        return elemRuleText elem\n    }    \n    let firstElement = dimensionM {\n        let! dimElements = DimensionM.dimElements\n        let! dimName     = DimensionM.dimName\n        let! first       = dimElements |> Seq.tryHead |> fromOptF (fun () -> sprintf \"Dimension %s Has No Elements\" dimName)\n        return first\n    }\n    let defaultE = DimensionM.defaultElm |> DimensionM.bind (Option.map DimensionM.getElementR >> Option.defaultValue firstElement)\n    let defaultElementTextR = dimensionM {\n        let! defaultElm = DimensionM.defaultElm |> DimensionM.bind (Option.map DimensionM.getElementR >> Option.defaultValue firstElement)\n        return elemRuleText defaultElm\n    }\n    let allFixedRefs (refs:Map<DimId,ElmReference>) =\n        refs \n        |> Seq.map (fun x -> x.Value)\n        |> Seq.exists (\n            function\n            | ElemFixed   _                \n            | ElemDynamic(_, ExtString(_)) -> false\n            | _                            -> true\n        )\n        |> not\n    \n    let fixedText dim txt = sprintf \"%s: %s\" dim.dimName txt\n    \n    let rec elrRuleTextR elr : CubeM<string> = cubeM {\n        match elr with\n        | ElemFixed   ( dId, eId) -> return! elementTextR dId eId |> CubeM.rtnM\n        | ElemDynamic (_dId, exT) -> return! extRuleTextR exT\n      }\n    and fixedTextR elr : CubeM<string> = cubeM {\n        let! dim = ModelM.getDimR (ElmReference.dimId elr)\n        let! txt = elrRuleTextR elr\n        return fixedText dim txt                                                            \n      }\n    and calcRuleTextRefR  : CalculationM<string> = calculationM {\n        let! meaDimName = CubeM.measureDimNameR\n        let! calName    = CalculationM.calName\n        return sprintf \"%s: '%s'\" meaDimName calName\n      }\n    and localSlcRuleTextR (refs:Map<DimId,ElmReference>) : CubeM<string> = cubeM {\n        return! refs\n                |> Seq.map  (fun x -> fixedTextR x.Value)\n                |> Seq.toList\n                |> CubeM.sequenceM\n                |> CubeM.map (String.concat \", \")\n                |> CubeM.map (sprintf \"[%s]\")\n      }\n    and dimParameterText thisDims dimId : CubeM<string> = cubeM {\n        let! dim = ModelM.getDimR dimId\n        if   Seq.exists ((=) dimId) thisDims\n        then return \"!\" + dim.dimName\n        else let!   res = defaultElementTextR |> DimensionM.runM dim\n             return res\n      }\n    and dbCallRuleText (refs:Map<DimId,ElmReference>) thatCubId : CubeM<string> = cubeM {\n        let! thisDims = CubeM.cubDims\n        let! thatCube = ModelM.getCubeR thatCubId\n        let! texts    = thatCube.cubDims\n                        |> Seq.map (fun d ->\n                            refs \n                            |> Map.tryFind d\n                            |> Option.map          elrRuleTextR\n                            |> Option.defaultWith (fun () -> dimParameterText thisDims d)\n                           )\n                        |> Seq.toList\n                        |> CubeM.sequenceM\n        return texts |> String.concat \", \" |> sprintf \"DB('%s', %s)\" thatCube.cubName\n      }\n    and cubeSlcRuleTextR refs slcCubId : CubeM<string> = cubeM {\n        let! thisCubId = CubeM.cubId\n        if   thisCubId = slcCubId && allFixedRefs refs\n        then return! localSlcRuleTextR            refs\n        else return! dbCallRuleText refs slcCubId\n      }\n    and calcSlcRuleTextR refs = calculationM {\n        let! meaDimId = CubeM.measureDim\n        let! calName  = CalculationM.calName\n        let  refsNew  = Map.add meaDimId (ElemDynamic(meaDimId, ExtString calName) ) refs\n        let! cubeId   = CubeM.cubId\n        return refsNew, cubeId\n      }\n    and slcRuleTextR (slc: Slice) : CubeM<string> = cubeM {\n        let refs = slc.sliDims\n        match slc.cube  , slc.calculation with\n        |     Some cubId, None            -> return! cubeSlcRuleTextR     refs cubId\n        |     _         , Some calId      -> let! calc          = ModelM.getCalcR calId\n                                             let! nRefs, cubId  = calcSlcRuleTextR refs |> CalculationM.runM calc\n                                             return! cubeSlcRuleTextR nRefs cubId\n        |     _         , _               -> let! thisCubId = CubeM.cubId\n                                             return! cubeSlcRuleTextR     refs thisCubId\n      }\n    and exnRuleTextR (exn:ExpressionNumber) : CubeM<string> = cubeM {\n        match exn with\n        | ExnNA                     -> return  \"#NA\"\n        | ExnStet                   -> return  \"STET\"\n        | ExnSlice      slc         -> return! slcRuleTextR slc\n        | ExnNumber     fn          -> return  sprintf \"%f\" fn\n        | ExnIf        (cn, th, el) -> let! cond = exnRuleTextR cn\n                                       let! theN = exnRuleTextR th\n                                       let! elsE = exnRuleTextR el\n                                       return  sprintf \"IF(%s, %s, %s)\"   cond theN elsE\n        | ExnOperationN(op, n1, n2) -> let! v1  = exnRuleTextR n1\n                                       let  opt = opRuleText        false  op\n                                       let! v2  = exnRuleTextR n2\n                                       return  sprintf \"(%s) %s (%s)\"           v1 opt v2\n        | ExnOperationT(op, n1, n2) -> let! v1  = extRuleTextR n1 \n                                       let  opt = opRuleText        false  op\n                                       let! v2  = extRuleTextR n2\n                                       return  sprintf \"(%s) %s (%s)\"           v1 opt v2\n        | ExnOperationI(op, n1, n2) -> let! v1  = exaRuleTextR n1\n                                       let  opt = opRuleText        false  op\n                                       let! v2  = exaRuleTextR n2\n                                       return  sprintf \"(%s) %s (%s)\"           v1 opt v2\n        | ExnMax       (    n1, n2) -> let! v1 = exnRuleTextR n1\n                                       let! v2 = exnRuleTextR n2\n                                       return  sprintf \"MAX(%s, %s)\"            v1     v2\n        | ExnMin       (    n1, n2) -> let! v1 = exnRuleTextR n1\n                                       let! v2 = exnRuleTextR n2\n                                       return  sprintf \"MIN(%s, %s)\"            v1     v2\n        | ExnDeIsChild (dn, pn, cn) -> let! dim = extRuleTextR dn\n                                       let! par = extRuleTextR pn\n                                       let! chi = extRuleTextR cn\n                                       return  sprintf \"DE.IsChild(%s, %s, %s)\" dim par chi\n        | ExnFunction  (_func, exs) -> return \"\"\"! exs |> Result.Seq.traverseA (exaRuleTextR model modcub) |> Result.map (String.concat \",\") |> Result.map (sprintf \"Function(%s)\")\"\"\"\n      }\n    and extRuleTextR (ext:ExpressionText) : CubeM<string> = cubeM {\n        match ext with\n        | ExtNA                     -> return      \"#NA\"\n        | ExtStet                   -> return      \"STET\"\n        | ExtSlice      slc         -> return!     slcRuleTextR slc\n        | ExtString     str         -> return      sprintf \"'%s'\" (str.Replace(\"'\", \"''\"))\n        | ExtDimElement dId         -> let! dim   = ModelM.getDimR dId\n                                       let! dimNm = DimensionM.dimName |> DimensionM.runM dim\n                                       return       sprintf \"!%s\"  dimNm\n        | ExtDimName    dId         -> let! dim   = ModelM.getDimR dId\n                                       let! dimNm = DimensionM.dimName |> DimensionM.runM dim\n                                       return       sprintf \"'%s'\" dimNm\n        | ExtIf        (cn, th, el) -> let! cond  = exnRuleTextR cn\n                                       let! theN  = extRuleTextR th\n                                       let! elsE  = extRuleTextR el\n                                       return  sprintf \"IF(%s, %s, %s)\"   cond theN elsE\n        | ExtSubSt     (tx, st, ln) -> let! str   = extRuleTextR tx\n                                       let! start = exnRuleTextR st\n                                       let! len   = exnRuleTextR ln\n                                       return  sprintf \"SUBST(%s, %s, %s)\" str start len\n        | ExtFunction  (_fn, exs)   -> return\"\"\"! exs |> Result.Seq.traverseA (exaRuleTextR model modcub) |> Result.map (String.concat \",\") |> Result.map (sprintf \"Function(%s)\")\"\"\"\n      }\n    and exaRuleTextR (exa:ExpressionAny) : CubeM<string> = cubeM {\n        match exa with\n        | ExiNA                     -> return  \"#NA\"\n        | ExiStet                   -> return  \"STET\"\n        | ExiSlice      slc         -> return! slcRuleTextR slc\n        | ExNumeric     nmb         -> return! exnRuleTextR nmb\n        | ExText        txt         -> return! extRuleTextR txt\n        | ExiIf        (cn, th, el) -> let! cond = exnRuleTextR cn\n                                       let! theN = exaRuleTextR th\n                                       let! elsE = exaRuleTextR el\n                                       return sprintf \"IF(%s, %s, %s)\" cond theN elsE\n      }\n    let destRuleText ref = cubeM{\n        match ref with\n        | ElemFixed   ( dId, eId           ) -> let! dim = ModelM.getDimR dId\n                                                let! elm = elementTextR dId eId\n                                                return  sprintf \"%s: %s\" dim.dimName elm\n        | ElemDynamic ( dId, ExtString(txt)) -> let! dim = ModelM.getDimR dId\n                                                return  sprintf \"%s: %s\" dim.dimName txt                      \n        | ElemDynamic (_dId, exp           ) -> return! extRuleTextR exp\n      }\n      \n    let rulDestinationR rul = cubeM {\n        let! texts = rul.rulDestination |> CubeM.traverseM destRuleText\n        return texts |> String.concat \", \" |> sprintf \"[%s]\"\n     }\n\n","parent":{"$":0,"Item":"86382469-687d-4914-94b9-4067d8c5c7e7"},"predecessors":[{"$":0,"Item":"90cfafb9-9397-4dda-940b-8e33c4412d1c"},{"$":0,"Item":"58a9fc2a-df09-42ef-ba7a-54e780167009"}],"id":{"$":0,"Item":"746803c6-b7b3-4730-a3b6-4e6fd1f1c390"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Alea Interfase","content":"//#I @\"D:\\Program Files (x86)\\Infor\\BI\\OLAP\\bin\"\n//#r @\"Compiled\\Alea\\Interop.MdsAut.dll\"\n#define FSI32BIT\n\n#r \"../packages/FSharp.ComProvider/lib/net40/FSharp.ComProvider.dll\"\n\nopen Useful\n\ntype ErrAlea(errn, msg, warning) =\n    interface ErrMsg with\n        member this.ErrMsg   : string = msg errn\n        member this.IsWarning: bool   = warning\n    override this.ToString() = msg errn\n\nmodule Alea =\n\n    type MdsAut = TypeLib.``Alea Automation Server (Inproc)``.``1.0``\n    let private g  = new MdsAut.GeneralClass        ()\n    let private s  = new MdsAut.ServersClass        ()\n    let private d  = new MdsAut.DimensionsClass     ()\n    let private c  = new MdsAut.TablesClass         ()\n    let private at = new MdsAut.AttributeTablesClass()\n    let private e  = new MdsAut.ElementsClass       ()\n    let private l  = new MdsAut.DataCellsClass      ()\n\n    let res = g.MdsInit 0\n\n    let callR<'T> ef (v: obj) =\n        let err  = g.MdsGetLastError()\n        let errN = unbox<int> err\n        if  errN <> 0 && v = err\n        then Result.fail (ErrAlea(errN, (fun n -> g.MdsError n |> unbox<string> |> sprintf \"Alea %d: %s\" errN |> ef), false))\n        else v |> unbox<'T> |> Result.succeed\n\n    type Server    = Server    of string\n    type Dimension = Dimension of string\n    type Cube      = Cube      of string\n    type Element   = Element   of string\n    type Field     = {\n        fldName        : string\n        fldTable       : int16\n        fldDescription : string\n        fldType        : int16\n        fldLength      : int16\n        fldDecimals    : int16\n    }\n    type Handle    = Handle    of int\n    \n    module private Names =\n        let sname (Server    n    ) = n\n        let dname (Dimension n    ) = n\n        let cname (Cube      n    ) = n\n        let ename (Element   n    ) = n\n        let fname  f                = f.fldName\n    \n    module Server =\n        let address     server = Names.sname server\n        let ef       fn server = (sprintf \"Server.%s %A: %s\" fn server)\n        let connectR    server = s.ServerConnectEx (address server, \"Admin\", \"\") |> callR<bool> (ef \"connectR\"    server)\n        let disconnectR server = s.ServerDisconnect(address server             ) |> callR<bool> (ef \"disconnectR\" server)\n\n    module Element = \n        open Names\n        let name                      elem   = ename elem\n        let ef          fn server dim elem   = (sprintf \"Element.%s %A %A %A: %s\" fn server dim elem)\n        let withR<'T>   fn server dim elem f = f <| sname server <| dname dim <| ename elem |> callR<'T> (ef fn server dim elem)\n        let childrenCountR server dim elem   = withR<int   > \"childrenCountR\" server dim elem  <| fun servAd dimN elemN -> e.ElementChildrenCount(servAd, dimN, elemN) \n        let childrenNameR  server dim elem i = withR<string> \"childrenNameR\"  server dim elem  <| fun servAd dimN elemN -> e.ElementChildrenName (servAd, dimN, elemN, i)\n        let childrenR      server dim elem   = Result.result {\n                                                   let! n     = childrenCountR server dim elem\n                                                   let! elems = seq[ for i in 1..n do\n                                                                        yield childrenNameR server dim elem i\n                                                                ] |> Result.seqCheck\n                                                   return elems |> Seq.map Element |> Seq.toArray\n                                               }\n    module Handle =\n        let int   (Handle n) = n\n        let int16 (Handle n) = int16 n\n        \n    module Dimension = \n        open Names\n        let name         (Dimension n)                         = n\n        let ef          fn server dim                          = (sprintf \"Dimension.%s %A %A: %s\" fn server dim)\n        let withR<'T>   fn server dim f                        = f <| sname server <| dname dim |> callR<'T> (ef fn server dim)\n        let import         server dim          df ef del desc  = withR<bool  > \"import\"         server dim   <| fun servAd dimN -> d.DimensionImport        (servAd, dimN, df, ef, (del:string), (desc:string))\n        let editBeginR     server dim          clear desc      = withR<bool  > \"editBeginR\"     server dim   <| fun servAd dimN -> d.DimensionEditBegin     (servAd, dimN, clear, desc |> Option.defaultValue dimN)\n        let addElementR    server dim eType elem parent weight = withR<bool  > \"addElementR\"    server dim   <| fun servAd dimN -> d.DimensionEditAddElement(servAd, dimN, eType, elem, parent, weight, \"\")\n        let editCommitR    server dim commit                   = withR<bool  > \"editCommitR\"    server dim   <| fun servAd dimN -> d.DimensionEditCommit    (servAd, dimN, commit) \n        let elementsCountR server dim                          = withR<int   > \"elementsCountR\" server dim   <| fun servAd dimN -> e.ElementsCount          (servAd, dimN) \n        let elementsNameR  server dim i                        = withR<string> \"elementsNameR\"  server dim   <| fun servAd dimN -> e.ElementsName           (servAd, dimN, i) \n     \n        let elementsR server dim = Result.result {\n                                       let! n     = elementsCountR server dim\n                                       let! names = seq[ for i in 1..n do\n                                                            yield elementsNameR server dim i\n                                                    ] |> Result.seqCheck\n                                       let  elems = names |> Seq.map Element\n                                       return elems |> Seq.toArray\n                                   }\n        let inputsR  server dim  = Result.result {\n                                       let! n     = elementsCountR server dim\n                                       let! elems = seq [ for i in 1..n do\n                                                            yield\n                                                                Result.result {\n                                                                    let! elemN  = elementsNameR server dim i\n                                                                    let  elem   = Element elemN\n                                                                    let! childN = Element.childrenCountR server dim elem\n                                                                    return \n                                                                        if childN = 0 \n                                                                        then Some elem\n                                                                        else None\n                                                                }\n                                                    ]\n                                                    |> Result.seqCheck\n                                       return elems |> Seq.choose id |> Seq.toArray\n                                   }\n        let attTableDeleteR      server dim nT                  = withR<bool> \"attTableDeleteR\"      server dim <| fun servAd dimN -> at.ATableDelete     (servAd, dimN, nT |> int)\n        let attTableCreateBeginR server dim nT                  = withR<int > \"attTableCreateBeginR\" server dim <|(fun servAd dimN -> at.ATableCreateBegin(servAd, dimN, nT - 1s  )) |> Result.map Handle\n        let fieldAddR            handle fld                     = at.ATableFieldAdd(    Handle.int16 handle, fld.fldName, fld.fldDescription, fld.fldType, fld.fldLength, fld.fldDecimals) |> callR<bool> (sprintf \"Dimension.fieldAddR     %s %s\" fld.fldName) \n        let createCommitR        handle                         = at.ATableCreateCommit(Handle.int16 handle                             ) |> callR<bool> (sprintf \"Dimension.createCommitR %s\")\n\n    module Field =\n        open Names\n        let newField fldName fldTable fldDescription fldType fldLength fldDecimals   = {\n            fldName        = fldName       \n            fldTable       = fldTable      \n            fldDescription = fldDescription\n            fldType        = fldType       \n            fldLength      = fldLength     \n            fldDecimals    = fldDecimals   \n        }\n        let name                       fld        = Names.fname fld\n        let number                     fld        = fld.fldTable\n        let withR<'T>    fn server dim fld ef   f = f <| sname server <| dname dim <| number fld <| fname fld |> callR<'T> (ef fn server dim fld)\n        let ef           fn server dim fld        = sprintf \"Field.%s %A %A %A: %s\"     fn server dim fld\n        let ef2     elem fn server dim fld err    = sprintf \"%s Element: '%s'\"      (ef fn server dim fld err) elem\n        let getInfoDescR    server dim fld        = withR<string> \"getInfoDescR\"    server dim fld  ef        <| fun servAd dimN nS field -> at.ATableFieldGetInfo(    servAd, dimN, nS,              field, 2)\n        let getInfoAtypR    server dim fld        = withR<int16 > \"getInfoAtypR\"    server dim fld  ef        <| fun servAd dimN nS field -> at.ATableFieldGetInfo(    servAd, dimN, nS,              field, 3)\n        let getInfoLengthR  server dim fld        = withR<int16 > \"getInfoLengthR\"  server dim fld  ef        <| fun servAd dimN nS field -> at.ATableFieldGetInfo(    servAd, dimN, nS,              field, 4)\n        let getInfoDecimalR server dim fld        = withR<int16 > \"getInfoDecimalR\" server dim fld  ef        <| fun servAd dimN nS field -> at.ATableFieldGetInfo(    servAd, dimN, nS,              field, 5)\n        let putValueR       server dim fld v elem = withR<bool  > \"putValueR\"       server dim fld (ef2 elem) <| fun servAd dimN nS field -> at.ATableFieldPutValue(v, servAd, dimN, nS |> int, elem, field   )\n\n    module Cube =\n        open Names\n        let name                    cube           = Names.cname cube\n        let ef            fn server cube           = (sprintf \"Cube.%s %A %A: %s\" fn server cube)\n        let withR<'T>     fn server cube f         = f <| sname server <| cname cube |> callR<'T> (ef fn server cube)\n        let create           server cube ds        = withR<bool  > \"create\"           server cube <| fun servAd cubeN -> \n                                                        let dims = ds |> Array.map Dimension.name\n                                                        let dim n = Array.tryItem n dims |> Option.defaultValue null\n                                                        c.TablesAdd(servAd, cubeN, cubeN, dims.[0], dims.[1]\n                                                                  , dim  2, dim  3, dim  4, dim  5\n                                                                  , dim  6, dim  7, dim  8, dim  9\n                                                                  , dim 10, dim 11, dim 12, dim 13\n                                                                  , dim 14, dim 15, dim 16, dim 17\n                                                                  , dim 18, dim 19)\n        let delete           server cube           = withR<bool  > \"delete\"           server cube <| fun servAd cubeN -> c.TableKill(servAd, cubeN)\n        let putRulesForcedR  server cube xml       = withR<bool  > \"putRulesForced\"   server cube <| fun servAd cubeN -> c.TablePutRulesForced(servAd, cubeN, xml)\n        let setMeasure       server cube dim       = withR<bool  > \"setMeasure\"       server cube <| fun servAd cubeN -> c.TableSetMeasureDimension(servAd, cubeN, Dimension.name dim)\n        let dimensionsCountR server cube           = withR<int   > \"dimensionsCountR\" server cube <| fun servAd cubeN -> c.TableDimensionsCount(servAd, cubeN)\n        let exists           server cube           = dimensionsCountR                 server cube |> Result.map ((>) 0) |> Result.ifError false  \n        let dimensionsNameR  server cube i         = withR<string> \"dimensionsNameR\"  server cube <| fun servAd cubeN -> c.TableDimensionsName (servAd, cubeN, i)\n        let putValueExR      server cube v elems   = withR<bool  > \"putValueExR\"      server cube <| fun servAd cubeN -> l.DataPutValueEx (servAd, cubeN, v, elems)\n        let dimensionsR      server cube           = Result.result {\n                                                        let! n    = dimensionsCountR server cube\n                                                        let! dims = seq [\n                                                                         for i in 1..n do \n                                                                             yield (dimensionsNameR server cube i)\n                                                                    ]\n                                                                    |> Result.seqCheck\n                                                        return dims |> Seq.map Dimension |> Seq.toArray\n                                                     } \n        let bulkTransferBeginR  lType              = l.BulkTransferBegin(lType)             |> callR<bool> (sprintf \"Cube.bulkTransferBeginR: %s\")\n        let bulkTransferCommitR lType stop log     = l.BulkTransferCommit(lType, stop, log) |> callR<bool> (sprintf \"Cube.bulkTransferCommitR: %s\")\n","parent":{"$":0,"Item":"86382469-687d-4914-94b9-4067d8c5c7e7"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"19f52d97-7978-4a6e-9fca-fd872eeb5eaf"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"MonadicAlea","content":"module AleaN =\n    open Alea\n    \n    type   ServerN<'T>           = ServerN   of (Server -> Result<'T>)\n    module ServerN =        \n        let address              = ServerN   (Server.address >> Result.succeed)\n        let connectR             = ServerN    Server.connectR\n        let disconnectR          = ServerN    Server.disconnectR\n        \n        let inline rtn a                                   = ServerN(fun _ -> Result.succeed a)\n        let inline rtnR a                                  = ServerN(fun _ ->                a)\n        let inline getResult                   (ServerN a) = ServerN(fun s -> a s |> Result.succeed )\n        let inline bind (f: 'a -> ServerN<'b>) (ServerN a) = ServerN(fun s -> a s |> Result.bind (f >> function ServerN b -> b s) )\n        let inline map f m                                 = bind (f >> rtn) m\n        let inline bindR  f                    (ServerN a) = ServerN(fun s -> a s |> Result.bind f)\n        let inline combine a b                             = a |> bind (fun _ -> b)\n        let inline run server                  (ServerN m) = Result.result {\n            let! r_  = Server.connectR    server\n            let! res = m                  server\n            let! r_  = Server.disconnectR server\n            return res\n        }\n        let rec traverseM f list =\n            let (>>=) v f = bind f v\n            let retn      = rtn\n            let initState = retn []\n            let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n            List.foldBack folder list initState \n        let inline sequenceM x = traverseM id x\n        \n        type Builder() =\n            member inline this.Return      x                        = rtn x\n            member inline this.ReturnFrom  x                        = x\n            member inline this.Bind       (w , r )                  = bind r w\n            member inline this.Bind       (w , r )                  = bind r (rtnR w)\n            member inline this.Zero       ()                        = rtn ()\n            member inline this.Delay       f                        = f\n            member inline this.Combine    (a, b)                    = combine a b\n            member inline this.Run         f                        = f()\n            member this.While(guard, body) =\n                let rec whileLoop guard body =\n                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                    else rtn   ()\n                whileLoop guard body\n            member this.TryWith(body, handler) =\n                try this.ReturnFrom(body())\n                with e -> handler e\n            member this.TryFinally(body, compensation) =\n                try this.ReturnFrom(body())\n                finally compensation()\n            member this.Using(disposable:#System.IDisposable, body) =\n                let body' = fun () -> body disposable\n                this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n            member this.For(sequence:seq<_>, body) =\n                this.Using(sequence.GetEnumerator(),fun enum -> \n                    this.While(enum.MoveNext, \n                        this.Delay(fun () -> body enum.Current)))              \n                        \n                        \n    type   ElementN<'T>          = ElementN   of (Server -> Dimension -> Element-> Result<'T>)\n    module ElementN =         \n        let name                 = ElementN   (fun s d e -> Element.name               e |> Result.succeed)\n        let childrenCountR       = ElementN   (fun s d e -> Element.childrenCountR s d e)\n        let childrenNameR     i  = ElementN   (fun s d e -> Element.childrenNameR  s d e i)\n        let childrenR            = ElementN   (fun s d e -> Element.childrenR      s d e)\n                                              \n    type   HandleN<   'T>                                  = HandleN    of (Handle -> Result<'T>)\n    module HandleN                                         =\n        let inline rtn a                                   = HandleN(fun _ -> Result.succeed a)\n        let inline rtnR a                                  = HandleN(fun _ ->                a)\n        let inline bind (f: 'a -> HandleN<'b>) (HandleN a) = HandleN(fun h -> a h |> Result.bind (f >> function HandleN b -> b h) )\n        let inline map f m                                 = bind (f >> rtn) m\n        let inline combine a b                             = a |> bind (fun _ -> b)\n        let inline run closer handle (HandleN m)           = m handle |> Result.bind (fun _ -> closer handle)\n        let rec traverseM f list =\n            let (>>=) v f = bind f v\n            let retn      = rtn\n            let initState = retn []\n            let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n            List.foldBack folder list initState \n        let inline sequenceM x = traverseM id x\n\n        type Builder() =\n            member inline this.Return      x                        = rtn x\n            member inline this.ReturnFrom  x                        = x\n            member inline this.Bind       (w , r )                  = bind r w\n            member inline this.Bind       (w , r )                  = bind r (rtnR w)\n            member inline this.Zero       ()                        = rtn ()\n            member inline this.Delay       f                        = f\n            member inline this.Combine    (a, b)                    = combine a b\n            member inline this.Run         f                        = f()\n            member this.While(guard, body) =\n                let rec whileLoop guard body =\n                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                    else rtn   ()\n                whileLoop guard body\n            member this.TryWith(body, handler) =\n                try this.ReturnFrom(body())\n                with e -> handler e\n            member this.TryFinally(body, compensation) =\n                try this.ReturnFrom(body())\n                finally compensation()\n            member this.Using(disposable:#System.IDisposable, body) =\n                let body' = fun () -> body disposable\n                this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n            member this.For(sequence:seq<_>, body) =\n                this.Using(sequence.GetEnumerator(),fun enum -> \n                    this.While(enum.MoveNext, \n                        this.Delay(fun () -> body enum.Current)))              \n        \n    type   DimensionN<'T>                           = DimensionN of (Server -> Dimension -> Result<'T>)\n    module DimensionN                               = \n        let name                                    = DimensionN (fun s d -> Dimension.name                   d |> Result.succeed)\n        let import                  df ef del desc  = DimensionN (fun s d -> Dimension.import               s d          df ef del desc )\n        let editBeginR              clear desc      = DimensionN (fun s d -> Dimension.editBeginR           s d          clear desc     )\n        let addElementR    eType elem parent weight = DimensionN (fun s d -> Dimension.addElementR          s d eType elem parent weight)\n        let editCommitR    commit                   = DimensionN (fun s d -> Dimension.editCommitR          s d commit                  )\n        let elementsCountR                          = DimensionN (fun s d -> Dimension.elementsCountR       s d                         )\n        let elementsNameR  i                        = DimensionN (fun s d -> Dimension.elementsNameR        s d i                       )\n        let elementsR                               = DimensionN (fun s d -> Dimension.elementsR            s d                         )\n        let inputsR                                 = DimensionN (fun s d -> Dimension.inputsR              s d                         )\n        let attTableDeleteR          nT             = DimensionN (fun s d -> Dimension.attTableDeleteR      s d nT                      )\n        let attTableCreateBeginR     nT             = DimensionN (fun s d -> Dimension.attTableCreateBeginR s d nT                      )\n        let createCommitR                           =                        Dimension.createCommitR\n        let getInfoDescR                 fld        = DimensionN (fun s d -> Field.getInfoDescR             s d fld                     )\n        let getInfoAtypR                 fld        = DimensionN (fun s d -> Field.getInfoAtypR             s d fld                     )\n        let getInfoLengthR               fld        = DimensionN (fun s d -> Field.getInfoLengthR           s d fld                     )\n        let getInfoDecimalR              fld        = DimensionN (fun s d -> Field.getInfoDecimalR          s d fld                     )\n        let putValueR                    fld v elem = DimensionN (fun s d -> Field.putValueR                s d fld v elem              )\n\n        let  rtn  a                                        = DimensionN(fun _ _ -> Result.succeed a)\n        let  rtnR a                                        = DimensionN(fun _ _ ->                a)\n        let  getResult                      (DimensionN a) = DimensionN(fun s d -> a s d |> Result.succeed )\n        let  bind (f: 'a -> DimensionN<'b>) (DimensionN a) = DimensionN(fun s d -> a s d |> Result.bind (f >> function DimensionN b -> b s d) )\n        let  map f m                                       = bind (f >> rtn) m\n        let  bindR  f                       (DimensionN a) = DimensionN(fun s d -> a s d |> Result.bind f)\n        let  combine a b                                   = a |> bind (fun _ -> b)\n        let  run server dim                 (DimensionN m) = m server dim\n        let  runM dim m                                    = ServerN (fun s -> run s dim m)\n        let rec traverseM f list =\n            let (>>=) v f = bind f v\n            let retn      = rtn\n            let initState = retn []\n            let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n            List.foldBack folder list initState \n        let inline sequenceM x = traverseM id x\n\n        type Builder() =\n            member inline this.Return      x                        = rtn x\n            member inline this.ReturnFrom  x                        = x\n            member inline this.Bind       (w , r )                  = bind r w\n            member inline this.Bind       (w , r )                  = bind r (rtnR w)\n            member inline this.Zero       ()                        = rtn ()\n            member inline this.Delay       f                        = f\n            member inline this.Combine    (a, b)                    = combine a b\n            member inline this.Run         f                        = f()\n            member this.While(guard, body) =\n                let rec whileLoop guard body =\n                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                    else rtn   ()\n                whileLoop guard body\n            member this.TryWith(body, handler) =\n                try this.ReturnFrom(body())\n                with e -> handler e\n            member this.TryFinally(body, compensation) =\n                try this.ReturnFrom(body())\n                finally compensation()\n            member this.Using(disposable:#System.IDisposable, body) =\n                let body' = fun () -> body disposable\n                this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n            member this.For(sequence:seq<_>, body) =\n                this.Using(sequence.GetEnumerator(),fun enum -> \n                    this.While(enum.MoveNext, \n                        this.Delay(fun () -> body enum.Current)))              \n\n    type   FieldN<'T>                           = FieldN of (Server -> Dimension -> Field -> Result<'T>)\n    module FieldN                               = \n        let fieldAddR              = FieldN  (fun s d fld-> HandleN (fun h -> Dimension.fieldAddR h fld ) |> Result.succeed )\n        let getInfoDescR           = FieldN  (fun s d fld-> Field.getInfoDescR             s d fld        )\n        let getInfoAtypR           = FieldN  (fun s d fld-> Field.getInfoAtypR             s d fld        )\n        let getInfoLengthR         = FieldN  (fun s d fld-> Field.getInfoLengthR           s d fld        )\n        let getInfoDecimalR        = FieldN  (fun s d fld-> Field.getInfoDecimalR          s d fld        )\n        let putValueR       v elem = FieldN  (fun s d fld-> Field.putValueR                s d fld v elem )\n\n        let  rtn  a                                = FieldN(fun _ _ _ -> Result.succeed a)\n        let  rtnR a                                = FieldN(fun _ _ _ ->                a)\n        let  getResult                  (FieldN a) = FieldN(fun s d fl -> a s d fl |> Result.succeed )\n        let  bind (f: 'a -> FieldN<'b>) (FieldN a) = FieldN(fun s d fl -> a s d fl |> Result.bind (f >> function FieldN b -> b s d fl) )\n        let  map f m                               = bind (f >> rtn) m\n        let  bindR  f                   (FieldN a) = FieldN(fun s d fl -> a s d fl |> Result.bind f)\n        let  combine a b                           = a |> bind (fun _ -> b)\n        let  run server dim fld         (FieldN m) = m server dim fld\n        let  runD fld m                            = DimensionN (fun s dim -> run s dim fld m)\n\n        type Builder() =\n            member inline this.Return      x                        = rtn x\n            member inline this.ReturnFrom  x                        = x\n            member inline this.Bind       (w , r )                  = bind r w\n            member inline this.Bind       (w , r )                  = bind r (rtnR w)\n            member inline this.Zero       ()                        = rtn ()\n            member inline this.Delay       f                        = f\n            member inline this.Combine    (a, b)                    = combine a b\n            member inline this.Run         f                        = f()\n            member this.While(guard, body) =\n                let rec whileLoop guard body =\n                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                    else rtn   ()\n                whileLoop guard body\n            member this.TryWith(body, handler) =\n                try this.ReturnFrom(body())\n                with e -> handler e\n            member this.TryFinally(body, compensation) =\n                try this.ReturnFrom(body())\n                finally compensation()\n            member this.Using(disposable:#System.IDisposable, body) =\n                let body' = fun () -> body disposable\n                this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n            member this.For(sequence:seq<_>, body) =\n                this.Using(sequence.GetEnumerator(),fun enum -> \n                    this.While(enum.MoveNext, \n                        this.Delay(fun () -> body enum.Current)))              \n\n    type   CubeN<'T>                 = CubeN of (Server -> Cube -> Result<'T>)\n    module CubeN                     = \n        let name                     = CubeN(fun s c -> Cube.name               c |> Result.succeed )  \n        let exists                   = CubeN(fun s c -> Cube.exists           s c |> Result.succeed )  \n        let create           ds      = CubeN(fun s c -> Cube.create           s c ds     )  \n        let delete                   = CubeN(fun s c -> Cube.delete           s c        )  \n        let putRulesForcedR  xml     = CubeN(fun s c -> Cube.putRulesForcedR  s c xml    )  \n        let setMeasure       dim     = CubeN(fun s c -> Cube.setMeasure       s c dim    )  \n        let dimensionsCountR         = CubeN(fun s c -> Cube.dimensionsCountR s c        )  \n        let dimensionsNameR  i       = CubeN(fun s c -> Cube.dimensionsNameR  s c i      )  \n        let putValueExR      v elems = CubeN(fun s c -> Cube.putValueExR      s c v elems)  \n        let dimensionsR              = CubeN(fun s c -> Cube.dimensionsR      s c        )  \n\n        let inline rtn  a                              = CubeN(fun _ _ -> Result.succeed a)\n        let inline rtnR a                              = CubeN(fun _ _ ->                a)\n        let inline getResult                 (CubeN a) = CubeN(fun s d -> a s d |> Result.succeed )\n        let inline bind (f: 'a -> CubeN<'b>) (CubeN a) = CubeN(fun s d -> a s d |> Result.bind (f >> function CubeN b -> b s d) )\n        let inline map f m                             = bind (f >> rtn) m\n        let inline bindR  f                  (CubeN a) = CubeN(fun s d -> a s d |> Result.bind f)\n        let inline combine a b                         = a |> bind (fun _ -> b)\n        let inline run server cube           (CubeN m) = m server cube\n        let inline runM cube m                         = ServerN (fun s -> run s cube m)\n\n        type Builder() =\n            member inline this.Return      x                        = rtn x\n            member inline this.ReturnFrom  x                        = x\n            member inline this.Bind       (w , r )                  = bind r w\n            member inline this.Bind       (w , r )                  = bind r (rtnR w)\n            member inline this.Zero       ()                        = rtn ()\n            member inline this.Delay       f                        = f\n            member inline this.Combine    (a, b)                    = combine a b\n            member inline this.Run         f                        = f()\n            member this.While(guard, body) =\n                let rec whileLoop guard body =\n                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                    else rtn   ()\n                whileLoop guard body\n            member this.TryWith(body, handler) =\n                try this.ReturnFrom(body())\n                with e -> handler e\n            member this.TryFinally(body, compensation) =\n                try this.ReturnFrom(body())\n                finally compensation()\n            member this.Using(disposable:#System.IDisposable, body) =\n                let body' = fun () -> body disposable\n                this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n            member this.For(sequence:seq<_>, body) =\n                this.Using(sequence.GetEnumerator(),fun enum -> \n                    this.While(enum.MoveNext, \n                        this.Delay(fun () -> body enum.Current)))              \n\n\n    let dimensionN = DimensionN.Builder()\n    let cubeN      = CubeN     .Builder()\n    let serverN    = ServerN   .Builder()\n    let fieldN     = FieldN    .Builder()\n    let handleN    = HandleN   .Builder()\n\n","parent":{"$":0,"Item":"86382469-687d-4914-94b9-4067d8c5c7e7"},"predecessors":[{"$":0,"Item":"90cfafb9-9397-4dda-940b-8e33c4412d1c"},{"$":0,"Item":"4137cad8-fd64-426e-98de-16a92a56388d"},{"$":0,"Item":"58a9fc2a-df09-42ef-ba7a-54e780167009"},{"$":0,"Item":"19f52d97-7978-4a6e-9fca-fd872eeb5eaf"}],"id":{"$":0,"Item":"7dd7ed3e-d73a-46e5-b4d3-fc1414536571"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Update Model","content":"\nmodule UpdateModel =\n    open CalculationModel\n    open Alea\n    open AleaN\n\n    let serverOlap         model = Alea.Server model.server\n\n    let calcList model flt =\n        model.modCalculations\n        |> Seq.filter flt\n        |> Seq.map    (fun c -> sprintf \"%s\\t%s\" (if c.isText then \"S\" else \"N\" ) c.calName)\n        |> String.concat \"\\n\"\n\n    let measureFields = [\n            Field.newField \"Type\"          1s \"Type\"       0s  10s 0s \n            Field.newField \"Format_String\" 1s \"Format\"     0s 254s 0s \n    ]\n    \n    let tCalcFields =\n        measureFields @ [\n            Field.newField \"Cube\"          1s \"Cube\"       0s  50s 0s \n            Field.newField \"FreezeCube\"    1s \"FreezeCube\" 0s  50s 0s \n            Field.newField \"User\"          1s \"User\"       0s  50s 0s \n        ]\n        \n    let getFldByDesc d fs = fs |> List.tryFind (fun f -> f.fldDescription = d) |> Result.fromOption (ErrSimple (\"Attribute Field not found\", false))\n\n    let importDimension txt desc = dimensionN {\n        let  temp1   = new UsefulDotNet.TempFileName()\n        System.IO.File.WriteAllText(temp1.Name, txt )\n        let  temp2   = new UsefulDotNet.TempFileName()\n        let! res     = DimensionN.import temp1.Name temp2.Name  \"\\t\"  desc |> DimensionN.getResult\n        do  (temp1 :> IDisposable).Dispose()\n        do  (temp2 :> IDisposable).Dispose()  // Cannot use 'use' or 'use!' because the reader monad does not execute immediately\n        return res\n    }\n    \n    let createAttributeTable atTblN fields = dimensionN {\n        let! _r      = DimensionN.attTableDeleteR      atTblN  |> DimensionN.getResult\n        let! handle  = DimensionN.attTableCreateBeginR atTblN\n        let! handles = fields |> DimensionN.traverseM (fun fld -> FieldN.runD fld FieldN.fieldAddR)\n        let! commit  = handles|> HandleN.sequenceM |> HandleN.run DimensionN.createCommitR handle\n        return commit\n    }\n\n    let createMeasureDimension model cub = dimensionN {\n        let! _r      = importDimension (calcList model (fun c -> c.cube = Some cub.cubId)) (\"Measures for \" + cub.cubName)\n        let! _r      = createAttributeTable 1s measureFields\n        let! fType   = getFldByDesc \"Type\"     measureFields\n        let! fFormat = getFldByDesc \"Format\"   measureFields\n        for c in model.modCalculations |> Seq.filter (fun c -> c.cube = Some cub.cubId) do\n            let typ  = Calculation.calcType c\n            let! _r  = DimensionN.putValueR fType     typ    c.calName\n            let! _r  = DimensionN.putValueR fFormat c.format c.calName\n            ()\n    }\n    \n    let createCube model cub dimOlap = cubeN {\n        let  dims      = Cube.dims model cub\n        let  dimNames  = dims     |> Array.map (fun d -> d.dimName.ToUpper())\n        let  dimsOlap  = dimNames |> Array.map Dimension\n        let! currentDs = CubeN.dimensionsR |> CubeN.getResult\n        let  exists    = currentDs\n                         |> Result.map(\n                             Array.map (fun dimOlap -> (Dimension.name dimOlap).ToUpper() )\n                             >> ((=) dimNames))\n                         |> Result.ifError false\n        if not exists then\n            let! _r    = CubeN.delete |> CubeN.getResult\n            let! _r    = CubeN.create     dimsOlap\n            let! _r    = CubeN.setMeasure dimOlap \n            ()\n    }\n    \n    let createDimensionAndCube model cub = serverN {\n        let!    dimName   = Cube.measureDimNameR model cub\n        let     dim       = Dimension dimName\n        do!     createMeasureDimension model cub     |> DimensionN.runM dim\n        return! createCube             model cub dim |> CubeN     .runM (Alea.Cube cub.cubName)\n    }\n    \n    let createCubes = modelM {\n        let! modCubes = ModelM.modCubes\n        let! model    = ModelM Result.succeed\n        return serverN {\n            for cube in modCubes |> Seq.filter (fun cub -> cub.cubType = CtCalc) do\n                    do! createDimensionAndCube model cube\n        }\n    }\n\n    let createTCalcDimension model = dimensionN {\n        let! _r      = importDimension (calcList model <| fun _ -> true) \"Model Calculations\"\n        let! _r      = createAttributeTable 1s tCalcFields\n        let! fCube   = getFldByDesc \"Cube\"     tCalcFields\n        let! fType   = getFldByDesc \"Type\"     tCalcFields\n        let! fFormat = getFldByDesc \"Format\"   tCalcFields\n        for c in model.modCalculations do\n            let  typ  = Calculation.calcType c\n            let! cube = c.cube |> Option.map (swap Model.getCubeR model) |>  Result.fromOption (ErrSimple(\"Cube not found\", false)) |> Result.join\n            let! _r   = DimensionN.putValueR fCube    cube.cubName c.calName\n            let! _r   = DimensionN.putValueR fType    typ          c.calName\n            let! _r   = DimensionN.putValueR fFormat c.format      c.calName\n            ()\n    }\n    ","parent":{"$":0,"Item":"86382469-687d-4914-94b9-4067d8c5c7e7"},"predecessors":[{"$":0,"Item":"7dd7ed3e-d73a-46e5-b4d3-fc1414536571"},{"$":0,"Item":"e24d6bc0-703c-4f12-aca8-8158af50b7cd"},{"$":0,"Item":"4137cad8-fd64-426e-98de-16a92a56388d"},{"$":0,"Item":"58a9fc2a-df09-42ef-ba7a-54e780167009"}],"id":{"$":0,"Item":"980cbebb-065e-4b10-86c5-87df2fab5cb7"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"WriteRules","content":"module WriteRules =\n    open CalculationModel\n    open AleaN\n\n    let ruleXml (doc:System.Xml.XmlDocument) rule = cubeM {\n        let node    = doc.CreateElement    \"Rule\"  |> doc.FirstChild.AppendChild\n        let cells v = (doc.CreateAttribute \"Cells\" |> node.Attributes.Append).Value <- v\n        do match rule.rulType with\n           | ForBase         -> cells \"Basic\"\n           | ForConsolidated -> cells \"Consolidated\"\n           | ForAll          -> ()           \n        let! dest = RuleText.rulDestinationR rule\n        let! text = RuleText.exaRuleTextR    rule.rulExpression\n        do node.AppendChild(doc.CreateElement \"Target\" ).InnerText <- dest\n        do node.AppendChild(doc.CreateElement \"Formula\").InnerText <- text\n    }\n\n    let writeCubeRule() = cubeM {\n        let doc       = System.Xml.XmlDocument()\n        doc.LoadXml     \"<Alea:Rules xmlns:Alea=\\\"http://www.misag.com\\\" Accelerated=\\\"false\\\" />\"\n        let! rules    = CubeM.cubRules\n        let! addRules = rules \n                        |> Seq.choose (fun rkv -> rkv.Value   ) \n                        |> Seq.sortBy (fun rul -> rul.rulOrder)\n                        |> Seq.map    (ruleXml doc)\n                        |> Seq.toList\n                        |> CubeM.sequenceM \n        let xml = doc.InnerXml.Replace(\"<Rule\"   , \"<Alea:Rule\"   ).Replace(\"</Rule\"   , \"</Alea:Rule\"  )\n                              .Replace(\"<Target\" , \"<Alea:Target\" ).Replace(\"</Target\" , \"</Alea:Target\")\n                              .Replace(\"<Formula\", \"<Alea:Formula\").Replace(\"</Formula\", \"</Alea:Formula\")\n        xml |> printfn \"%s\\n----------------------------------------------------------------------------------------------------------------------------\\n\\n\"\n        let! cubName  = CubeM.cubName\n        return CubeN.putRulesForcedR xml |> CubeN.map ignore |> CubeN.runM (Alea.Cube cubName)\n    }\n    \n    let writeRules = modelM {\n        let!    cubes = ModelM.modCubes\n        return! cubes |> Seq.toList |> ModelM.traverseM (fun cube -> CubeM.runM cube <| writeCubeRule())\n    }\n        \n    open UpdateModel\n    open AleaN\n\n    let updateModel = modelM {\n        let! creates   = createCubes\n        let! model     = ModelM.model\n        let  creaTCalc = createTCalcDimension model |> DimensionN.runM (Alea.Dimension \"TCalc\")\n        let! writes    = writeRules  \n        let! server    = ModelM.server\n        let  actions   = List.append [ creates; creaTCalc] writes |> ServerN.sequenceM\n        let! res       = ServerN.run (Alea.Server server) actions\n        return res\n    }\n\n    let createCubesR model = ModelM.run model updateModel \n\n","parent":{"$":0,"Item":"86382469-687d-4914-94b9-4067d8c5c7e7"},"predecessors":[{"$":0,"Item":"980cbebb-065e-4b10-86c5-87df2fab5cb7"},{"$":0,"Item":"19f52d97-7978-4a6e-9fca-fd872eeb5eaf"},{"$":0,"Item":"746803c6-b7b3-4730-a3b6-4e6fd1f1c390"},{"$":0,"Item":"58a9fc2a-df09-42ef-ba7a-54e780167009"}],"id":{"$":0,"Item":"cd877d32-4cbd-4d2f-9b7b-db85e57ad0f4"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CalculationModelDll","content":"// select the snippets that form the Assembly. The name of this snippet 'CalculationModelDll' will be the name of the Assembly","parent":{"$":0,"Item":"86382469-687d-4914-94b9-4067d8c5c7e7"},"predecessors":[{"$":0,"Item":"3425a36b-08fa-4a1e-8284-3785e56f8b06"},{"$":0,"Item":"7dd7ed3e-d73a-46e5-b4d3-fc1414536571"},{"$":0,"Item":"cd877d32-4cbd-4d2f-9b7b-db85e57ad0f4"},{"$":0,"Item":"06aa50e4-05e5-4862-a528-57cdef08acfc"},{"$":0,"Item":"58a9fc2a-df09-42ef-ba7a-54e780167009"},{"$":0,"Item":"4f4d9d79-09fe-4df1-8af2-0ba6a4fffa2c"},{"$":0,"Item":"746803c6-b7b3-4730-a3b6-4e6fd1f1c390"}],"id":{"$":0,"Item":"8578db18-9dc2-4654-95af-dad8b6bb1547"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"xxxSampleFormulas","content":"#r \"Compiled/CalculationModelDll/CalculationModelDll.dll\"\nopen System\nopen FSSGlobal.CalculationModel\nmodule SampleFormulas =\n    open CalculationModel\n    open InitModel\n    open CalculationSyntax\n    \n    setInitModel {\n        modId           = ModId <| Guid.NewGuid()\n        server          = @\"LOCAL\\CipherSpace\"\n        modCubes        = [| |]\n        modDims         = [| |]\n        modCalculations = [| |]\n    }\n    \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    \n    let TCalc                = newDim \"TCalc\"      DtTCalc    \"\"\n    let DataType             = newDim \"DataType\"   DtDataType \"\"\n    let Version              = newDim \"Version\"    DtVersion  \"\"\n    let Year                 = newDim \"Year\"       DtTime     \"\"\n    let Price                = newDim \"Price\"      DtOther    \"PR\"     \n    let Brand                = newDim \"Brand\"      DtOther    \"BR\"     \n    let Product              = newDim \"Product\"    DtOther    \"PD\"     \n    let Season               = newDim \"Season\"     DtOther    \"SE\"     \n    let CostCenter           = newDim \"CostCenter\" DtOther    \"CC\"     \n    let Account              = newDim \"Account\"    DtOther    \"AC\"     \n     \n    addDims()\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    let comb1                = [ Version; DataType; Price; Brand; Product; Season; CostCenter; Account ]\n  \n    let Sales_by_Brand                           = newCalc Input \"Sales_by_Brand                           \" \"AA\" comb1\n    let FP_vs_MD_Perc                            = newCalc Input \"FP_vs_MD_Perc                            \" \"AB\" comb1\n    let Sales_by_Brand_Price                     = newCalc  Calc \"Sales_by_Brand_Price                     \" \"AC\" comb1\n    let Gross_Perc                               = newCalc Input \"Gross_Perc                               \" \"AD\" comb1\n    let Gross_Sales_by_Brand_Price               = newCalc  Calc \"Gross_Sales_by_Brand_Price               \" \"AE\" comb1\n    let Seasonal_Allocation                      = newCalc Input \"Seasonal_Allocation                      \" \"AF\" comb1\n    let Seasonal_Allocation_2                    = newCalc  Calc \"Seasonal_Allocation_2                    \" \"AG\" comb1\n    let Seasonal_Allocation_Outlet               = newCalc Input \"Seasonal_Allocation_Outlet               \" \"AH\" comb1\n    let Discount                                 = newCalc Input \"Discount                                 \" \"AI\" comb1\n    let Sales_by_Season                          = newCalc  Calc \"Sales_by_Season                          \" \"AJ\" comb1\n    let Net_Sales_by_Season                      = newCalc  Calc \"Net_Sales_by_Season                      \" \"AK\" comb1\n    let Markup                                   = newCalc  Calc \"Markup                                   \" \"AL\" comb1\n    let Seasonal_Cost_Factor                     = newCalc Input \"Seasonal_Cost_Factor                     \" \"AM\" comb1\n    let COGS                                     = newCalc  Calc \"COGS                                     \" \"AN\" comb1\n    let Inventory_Beginning                      = newCalc  Calc \"Inventory_Beginning                      \" \"AO\" comb1\n    let Average_Price                            = newCalc Input \"Average_Price                            \" \"AP\" comb1\n    let Inventory_Beginning_Quantity             = newCalc  Calc \"Inventory_Beginning_Quantity             \" \"AQ\" comb1\n    let Inventory_Transfer_IN                    = newCalc  Calc \"Inventory_Transfer_IN                    \" \"AR\" comb1\n    let Purchases                                = newCalc  Calc \"Purchases                                \" \"AS\" comb1\n    let Inventory_Transfer_OUT                   = newCalc  Calc \"Inventory_Transfer_OUT                   \" \"AT\" comb1\n    let Sell_Through                             = newCalc Input \"Sell_Through                             \" \"AU\" comb1\n    let Purchases_Timing_Perc                    = newCalc Input \"Purchases_Timing_Perc                    \" \"AV\" comb1\n    let Total_Stock                              = newCalc  Calc \"Total_Stock                              \" \"AW\" comb1\n    let Inventory_Ending                         = newCalc  Calc \"Inventory_Ending                         \" \"AX\" comb1\n    let VAT_Rate_Sales_Tax                       = newCalc Input \"VAT_Rate_Sales_Tax                       \" \"AY\" comb1\n    let Selling_Squared_meters                   = newCalc Input \"Selling_Squared_meters                   \" \"AZ\" comb1\n    let Net_Squared_meters                       = newCalc Input \"Net_Squared_meters                       \" \"BA\" comb1\n    let Gross_Squared_Meters                     = newCalc Input \"Gross_Squared_Meters                     \" \"BB\" comb1\n    let CAPEX                                    = newCalc Input \"CAPEX                                    \" \"BC\" comb1\n    let CASHOUT                                  = newCalc Input \"CASHOUT                                  \" \"BD\" comb1\n    let Landed_Factor_Custom_Duties              = newCalc Input \"Landed_Factor_Custom_Duties              \" \"BE\" comb1\n    let Landed_Factor_Insurance                  = newCalc Input \"Landed_Factor_Insurance                  \" \"BF\" comb1\n    let Landed_Factor_Freight                    = newCalc Input \"Landed_Factor_Freight                    \" \"BG\" comb1\n    let Net_Sales_Stockist                       = newCalc Input \"Net_Sales_Stockist                       \" \"BH\" comb1\n    let Net_Sales_Inter_Company                  = newCalc Input \"Net_Sales_Inter_Company                  \" \"BI\" comb1\n    let PercNet_Sales_Full_Price                 = newCalc  Calc \"PercNet_Sales_Full_Price                 \" \"BJ\" comb1\n    let PercNet_Sales_Markdown                   = newCalc  Calc \"PercNet_Sales_Markdown                   \" \"BK\" comb1\n    let PercNet_Sales_Stockist                   = newCalc  Calc \"PercNet_Sales_Stockist                   \" \"BL\" comb1\n    let PercNet_Sales_InterCompany               = newCalc  Calc \"PercNet_Sales_InterCompany               \" \"BM\" comb1\n    let Average_Sales_Price_Full_Price           = newCalc Input \"Average_Sales_Price_Full_Price           \" \"BN\" comb1\n    let Average_Sales_Price_Markdown             = newCalc Input \"Average_Sales_Price_Markdown             \" \"BO\" comb1\n    let Average_Sales_Price_Stockist             = newCalc Input \"Average_Sales_Price_Stockist             \" \"BP\" comb1\n    let Average_Sales_Price_Intercompany         = newCalc Input \"Average_Sales_Price_Intercompany         \" \"BQ\" comb1\n    let Mark_Up_Boutique                         = newCalc  Calc \"Mark_Up_Boutique                         \" \"BR\" comb1\n    let Mark_Up_Outlet                           = newCalc  Calc \"Mark_Up_Outlet                           \" \"BS\" comb1\n    let Custom_Duties_Beginning_Inventory        = newCalc Input \"Custom_Duties_Beginning_Inventory        \" \"BT\" comb1\n    let Freight_Beginning_Inventory              = newCalc Input \"Freight_Beginning_Inventory              \" \"BU\" comb1\n    let Insurance_Beginning_Inventory            = newCalc Input \"Insurance_Beginning_Inventory            \" \"BV\" comb1\n    let Index_Perc                               = newCalc Input \"Index_Perc                               \" \"BW\" comb1\n    let Depreciation_IC_Initial_Provision        = newCalc Input \"Depreciation_IC_Initial_Provision        \" \"BX\" comb1\n    let Depreciation_IC_Final_Provision          = newCalc Input \"Depreciation_IC_Final_Provision          \" \"BY\" comb1\n    let Depreciation_TP_Initial_Provision        = newCalc Input \"Depreciation_TP_Initial_Provision        \" \"BZ\" comb1\n    let Depreciation_TP_Final_Provision          = newCalc Input \"Depreciation_TP_Final_Provision          \" \"BA\" comb1\n    let Depreciation_IC_Initial_Provision_Factor = newCalc  Calc \"Depreciation_IC_Initial_Provision_Factor \" \"BB\" comb1\n    let Depreciation_IC_Final_Provision_Factor   = newCalc  Calc \"Depreciation_IC_Final_Provision_Factor   \" \"BC\" comb1\n    let Depreciation_TP_Initial_Provision_Factor = newCalc  Calc \"Depreciation_TP_Initial_Provision_Factor \" \"BD\" comb1\n    let Depreciation_TP_Final_Provision_Factor   = newCalc  Calc \"Depreciation_TP_Final_Provision_Factor   \" \"BE\" comb1\n    let Depreciation_Beginning                   = newCalc  Calc \"Depreciation_Beginning                   \" \"BF\" comb1\n    let Depreciation_Ending                      = newCalc  Calc \"Depreciation_Ending                      \" \"BG\" comb1\n    let Depreciation_Change                      = newCalc  Calc \"Depreciation_Change                      \" \"BH\" comb1\n    let AMOUNT                                   = newCalc  Calc \"AMOUNT                                   \" \"BI\" comb1\n\n    addCalcs()\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    \n    let Value                    = DataType?Value\n    let For_NoSeasonal           = [ Season?(\"21\")     ; Value ]\n    let For_FallWinterM1         = [ Season?(\"07\")     ; Value ]\n    let For_SeasonCarryOver      = [ Season?(\"19\")     ; Value ]\n    let For_NoSeasonalThirdParty =   Brand?( \"06\") :: For_NoSeasonal\n    \n    let isOutlet                  = SUBST(!CostCenter, 2, 1) &= \"O\"\n    let isThirdParty              = DE_ISCHILD(Product, \"TP\", !Product)\n    let isFallWinterM1            = !Season &= \"07\"\n    let isSeasonCarryOver         = !Season &= \"19\"\n    \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    let inline  newForm a b c d = newForm a b c d \"\" \"\"\n    \n    newForm Sales_by_Brand_Price                     ForBase         <| Sales_by_Brand * FP_vs_MD_Perc                               <| []\n    newForm FP_vs_MD_Perc                            ForBase         <| 1 - FP_vs_MD_Perc.For[ Price?Full_Price ]                    <| [ Price?Mark_Down ; Value ]\n    newForm FP_vs_MD_Perc                            ForBase         <| Sales_by_Brand_Price / Sales_by_Brand                        <| []                                                             \n    newForm Gross_Sales_by_Brand_Price               ForBase         <| Sales_by_Brand_Price / (1 - Gross_Perc)                      <| [] \n    newForm Seasonal_Allocation                      ForBase         <| 1                                                            <| For_NoSeasonalThirdParty\n    newForm Seasonal_Allocation                      ForBase         <| 1 - Seasonal_Allocation.For[ Season?Seasons ]                <| For_SeasonCarryOver     \n    newForm Seasonal_Allocation_2                    ForBase         <| 1                                                            <| For_NoSeasonalThirdParty      \n    newForm Seasonal_Allocation_2                    ForBase         <| 0.5                                                          <| For_FallWinterM1                                                 \n    newForm Seasonal_Allocation_2                    ForBase         <| 0.5                                                          <| For_SeasonCarryOver                                         \n    newForm Seasonal_Allocation_2                    ForBase         <| 0                                                            <| []                                                                                                                           \n    newForm Seasonal_Allocation_2                    ForBase         <| IF(isFallWinterM1 || isSeasonCarryOver, 0.5, 0)              <| []\n    newForm Seasonal_Allocation_Outlet               ForBase         <| 1 - Seasonal_Allocation_Outlet.For[ Season?Seasons2 ]        <| For_NoSeasonal\n    newForm Sales_by_Season                          ForBase         <| Sales_by_Brand_Price    \n                                                                          * IF( isOutlet                                           \n                                                                              , Seasonal_Allocation_Outlet                                           \n                                                                              , IF(!CostCenter &= \"RBUS19\"                                           \n                                                                                || !CostCenter &= \"RBUS20\"                                           \n                                                                                || !CostCenter &= \"RBUS42\"                                           \n                                                                                || !CostCenter &= \"RBUS41\"                                          \n                                                                                  , Seasonal_Allocation_2                                          \n                                                                                  , Seasonal_Allocation                                          \n                                                                              )                                           \n                                                                           )                                                         <| []\n    newForm Discount                                 ForConsolidated <| 1 - Sales_by_Season / Net_Sales_by_Season                    <| []\n    newForm Net_Sales_by_Season                      ForBase         <|  Sales_by_Season / (1 - Discount)                            <| []                                                                  \n    newForm Markup                                   ForBase         <| IF (isOutlet, 1.25, 2.5)                                     <| [ Value ] \n    newForm Markup                                   ForConsolidated <| Net_Sales_by_Season / COGS   * Seasonal_Cost_Factor          <| []\n    newForm COGS                                     ForBase         <| Net_Sales_by_Season / Markup * Seasonal_Cost_Factor          <| []\n    newForm Inventory_Beginning                      ForBase         <| IF( isOutlet                                           \n                                                                          , NA                                          \n                                                                          , COGS \n                                                                            * (Inventory_Transfer_IN.For[ CostCenter?Outlets ]                                          \n                                                                               /  COGS.For[ CostCenter?Boutiques ]                                          \n                                                                               +  COGS.For[ CostCenter?Boutiques ] ) )               <| For_FallWinterM1\n    newForm Inventory_Beginning                      ForBase         <| IF (isOutlet, COGS, COGS / 0.47 * 0.55)                      <| []                                                                                                                                \n    newForm Inventory_Beginning_Quantity             ForBase         <| Inventory_Beginning / (Average_Price * Seasonal_Cost_Factor) <| []\n    newForm Inventory_Transfer_IN                    ForBase         <| COGS                                                         <| [ CostCenter?ROUS08 ]\n    newForm Inventory_Transfer_IN                    ForBase         <| IF( isOutlet, COGS / 0.35, NA)                               <| For_FallWinterM1 \n    newForm Inventory_Transfer_IN                    ForBase         <| IF( isOutlet                                           \n                                                                          , Inventory_Transfer_OUT.For[ CostCenter?Boutiques ]               \n                                                                            * Sales_by_Brand / Sales_by_Brand.For[ CostCenter?Outlets ]               \n                                                                          , NA)                                                                                                       <| []\n    newForm Purchases                                ForBase         <| COGS * Purchases_Timing_Perc / Sell_Through                                                                      <| []\n    newForm Inventory_Transfer_OUT                   ForBase         <| IF( isOutlet, NA, Inventory_Beginning + Purchases - COGS)                                                        <| []\n    newForm Total_Stock                              ForBase         <| Inventory_Beginning + Inventory_Transfer_IN - Inventory_Transfer_OUT + Purchases                                 <| []\n    newForm Inventory_Ending                         ForBase         <| Total_Stock - COGS                                                                                               <| []\n    newForm Mark_Up_Boutique                         ForBase         <| IF(isOutlet, NA    , Markup)                                                                                     <| []\n    newForm Mark_Up_Outlet                           ForBase         <| IF(isOutlet, Markup, NA    )                                                                                     <| []\n    newForm Depreciation_IC_Initial_Provision_Factor ForBase         <| IF(Depreciation_IC_Initial_Provision <= 0, 0, MAX(0, 1 - (1 - Depreciation_IC_Initial_Provision) / Index_Perc) ) <| []\n    newForm Depreciation_IC_Final_Provision_Factor   ForBase         <| IF(Depreciation_IC_Final_Provision   <= 0, 0, MAX(0, 1 - (1 - Depreciation_IC_Final_Provision  ) / Index_Perc) ) <| []\n    newForm Depreciation_TP_Initial_Provision_Factor ForBase         <| IF(Depreciation_TP_Initial_Provision <= 0, 0, MAX(0, 1 - (1 - Depreciation_TP_Initial_Provision) / Index_Perc) ) <| []\n    newForm Depreciation_TP_Final_Provision_Factor   ForBase         <| IF(Depreciation_TP_Final_Provision   <= 0, 0, MAX(0, 1 - (1 - Depreciation_TP_Final_Provision  ) / Index_Perc) ) <| []\n    newForm Depreciation_Beginning                   ForBase         <| IF(isOutlet,              \n                                                                             IF( isThirdParty              \n                                                                              , Depreciation_TP_Initial_Provision_Factor              \n                                                                              , Depreciation_IC_Initial_Provision_Factor)              \n                                                                            * Inventory_Beginning              \n                                                                        , 0)                                                               <| []\n    newForm Depreciation_Ending                      ForBase         <| IF(isOutlet,              \n                                                                            IF( isThirdParty              \n                                                                              , Depreciation_TP_Final_Provision_Factor              \n                                                                              , Depreciation_IC_Final_Provision_Factor)              \n                                                                            * Inventory_Ending              \n                                                                        , 0)                                                               <| []\n    newForm Depreciation_Change                      ForBase         <| Depreciation_Beginning - Depreciation_Ending                       <| []\n    newForm AMOUNT                                   ForBase         <| Net_Sales_by_Season.For[ Price?Full_Price ; Product?All_Products ] <| [ Account?(\"BDG.002.02.FPR\") ; Product   ?ND ]\n    newForm AMOUNT                                   ForBase         <| Net_Sales_by_Season.For[ Price?Mark_Down  ; Product?All_Products ] <| [ Account?(\"BDG.002.02.MKD\") ; Product   ?ND ]\n    newForm AMOUNT                                   ForBase         <| Purchases_Timing_Perc                                              <| [ Account?(\"BDG.005.04\"    ) ; Product   ?ND ]\n    newForm AMOUNT                                   ForBase         <| Markup                                                             <| [ Account?(\"BDG.011.EC\"    ) ; CostCenter?ND ]\n    newForm AMOUNT                                   ForBase         <| IF( isOutlet, NA,  Markup)                                         <| [ Account?(\"BDG.011.W\"     ) ; CostCenter?ND ]\n\n    addFrms()\n    ","parent":{"$":0,"Item":"86382469-687d-4914-94b9-4067d8c5c7e7"},"predecessors":[],"id":{"$":0,"Item":"637217cf-d9b8-4bef-9774-a28412f1e944"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"xxxFormula & Calculation Rules","content":"//open Useful\n\nmodule CalcRules =\n    let eq  = (=)\n    let And = (&&)\n    let (&) = (+)\n    open CalculationModel\n    open CalculationSyntax\n    open Useful\n    \n    let cubeActualRule          versionDim      = Rule.newRule [ versionDim?Actual   ]  ExtStet        ForBase \"B\"\n    let cubeActualRuleO       model             = Model.versionDimO model |> Option.map cubeActualRule\n    let cubeFormulaRule  txt _meaDim dataTypeDim _versionDim _timeDim = Rule.newRule [ dataTypeDim?Formula ] (ExtString txt) ForBase \"G1\"\n    let cubeInputRule                           = cubeFormulaRule \"<Input>\"\n    let cubeConsolidationRule                   = cubeFormulaRule \"<Consolidation>\"\n    let isFormulaText           dataTypeDim frm = Formula.getDimDest dataTypeDim frm |> Option.map (eq dataTypeDim?Formula) |> Option.defaultValue false\n    let isActual                versionDim  frm = Formula.getDimDest versionDim  frm |> Option.map (eq versionDim?Actual  ) |> Option.defaultValue false\n    let formulaRule (model: Model) (calc: Calculation) (cube:Cube) frm =\n        Model.withDimsO model cube <| fun _meaDim dataTypeDim versionDim _timeDim ->\n            Calculation.getElemRefO model calc \n            |> Option.map (fun ref -> \n                ref ::\n                if Cube.containsDim dataTypeDim.dimId cube then\n                    let  dataTypeDest = Formula.getDimDest dataTypeDim frm\n                    if   dataTypeDest.IsNone \n                    then dataTypeDim?Calculated_Value :: frm.forDestination\n                    else frm.forDestination\n                else     frm.forDestination\n            )\n            |> Option.map (fun dest -> Rule.newRule dest frm.forExpression frm.forType ((if isFormulaText dataTypeDim frm then \"E\" elif isActual versionDim frm then  \"A\" else \"M\") & calc.calOrder & frm.forOrder) )\n    let formulaTextRule (model: Model) (calc: Calculation) (cube:Cube) frm =\n        Model.withDimsO model cube <| fun _meaDim dataTypeDim _versionDim _timeDim ->\n            if not <| Cube.containsDim dataTypeDim.dimId cube then None else\n            let dataTypeDest = Formula.getDimDest dataTypeDim frm\n            if  dataTypeDest.IsSome then None else\n            Calculation.getElemRefO model calc\n            |> Option.map (fun ref -> Rule.newRule (dataTypeDim?Formula :: ref :: frm.forDestination) (ExtString frm.forText) frm.forType (\"F\" & calc.calOrder & frm.forOrder) )\n    let calculationRule (model: Model) (cube:Cube) calc =\n        Model.withDimsO model cube <| fun meaDim dataTypeDim versionDim timeDim ->\n            if not <| Cube.containsDim dataTypeDim.dimId cube then None else\n            let tCalcDimO        = Model.tCalcDimO     model\n            let freezeCubeO      = Model.freezeCubeO   model\n            let isActualCalcO    = Model.isActualCalcO model\n            let calculatedValue  = Cube.forElr [ dataTypeDim?Calculated_Value                ] cube\n            let manualAdjustment = Cube.forElr [ dataTypeDim?Manual_Adjustment               ] cube\n            let frozenValue      = Cube.forElr [ dataTypeDim?Frozen_Value                    ] cube\n            let valueCalc        = Cube.forElr [ dataTypeDim?Value ; meaDim?(calc.calName)   ] cube\n            let useActual        = seq { \n                                     yield isActualCalcO.IsSome\n                                     yield Cube.containsDim versionDim.dimId cube\n                                     yield Cube.containsDim timeDim   .dimId cube\n                                   } |> Seq.contains false |> not\n            let body1            = if calc.isInput then \n                                       ExiStet  \n                                   else\n                                       if calc.isText then\n                                           IFa(manualAdjustment &= ExtNA, calculatedValue, manualAdjustment) \n                                       else\n                                           calculatedValue + manualAdjustment |> ExNumeric\n            let body2            = if freezeCubeO.IsSome |> And tCalcDimO.IsSome\n                                   then IFa(Cube.forElr[tCalcDimO.Value?(calc.calName)] freezeCubeO.Value = 1, frozenValue, body1)\n                                   else body1\n            let body3            = if   useActual \n                                   then IFa(isActualCalcO.Value = 1, Cube.forElr [ versionDim?ActualElem ] cube, body2)\n                                   else body2\n            //if eq body3 ExiStet then None else                      \n            Rule.newRule (valueCalc.sliDims |> Map.toList |> List.map snd) body3 ForBase (\"N\" & calc.calOrder)\n            |> Some\n    let formulaRules (model: Model) (calc: Calculation) frm =\n        Calculation.withCube model calc <| fun cube        -> \n            seq {\n                yield cube.cubId, (FormulaKey frm.forId), formulaRule     model calc cube frm\n                yield cube.cubId, (ForTextKey frm.forId), formulaTextRule model calc cube frm\n            }\n            |> Some\n        |> Option.defaultValue Seq.empty\n    let calcRules (model: Model) calc =\n        Calculation.withCube model calc <| fun cube        -> \n            seq {\n                yield cube.cubId, CalcRuleKey calc.calId, calculationRule model cube calc\n                for frm in calc.calFormulas do\n                    yield! formulaRules model calc frm\n            }\n            |> Some\n        |> Option.defaultValue Seq.empty\n    let cubeRules (model: Model) cube =\n        seq {\n            yield cube.cubId, ActualRuleKey      ,                model |>   cubeActualRuleO\n            yield cube.cubId, InputRuleKey       , Model.withDims model cube cubeInputRule\n            yield cube.cubId, ConsolidatedRuleKey, Model.withDims model cube cubeConsolidationRule\n        }\n    let modelRules model =\n        seq {\n            for cube in model.modCubes |> Seq.filter Cube.isCalcCube do yield! cubeRules model cube\n            for calc in model.modCalculations                        do yield! calcRules model calc\n        }        \n    let addModelRules model = model |> Model.addRules (modelRules model)\n    ","parent":{"$":0,"Item":"86382469-687d-4914-94b9-4067d8c5c7e7"},"predecessors":[{"$":0,"Item":"90cfafb9-9397-4dda-940b-8e33c4412d1c"},{"$":0,"Item":"4f4d9d79-09fe-4df1-8af2-0ba6a4fffa2c"}],"id":{"$":0,"Item":"303fbc46-6f96-4fb9-942f-02370a80f627"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"xxxTest","content":"#I @\"D:\\Program Files (x86)\\Infor\\BI\\OLAP\\bin\"\n#r @\"Compiled\\Alea\\Interop.MdsAut.dll\"\n#define FSI32BIT\n\nmodule Test =\n    open CalculationModel\n    open FSSGlobal.Useful\n    \n    \n    let printRules model =\n        model.modCubes\n        |> Seq.collect (fun  cub       -> cub.cubRules |> Seq   .map (fun rkv -> rkv, cub.cubId))\n        |> Seq.choose  (fun (rkv, cid) -> rkv.Value    |> Option.map (fun rul -> rul, cid      ))\n        |> Seq.sortBy  (fst >> (fun r -> r.rulOrder))        \n        |> Seq.map     (fun (rul, cid) -> rul.rulOrder, RuleText.aleaRule model cid rul)\n        |> Seq.iter    (printfn \"%A\")\n    //printRules ()\n\n    \n    //printfn \"%A\" model\n    \n    InitModel.initModel\n    |> Model.prepareModel \n    |> CalcRules.addModelRules\n    |> printRules\n    //|> WriteRules.createCubesR\n    //|> Result.getMsgs |> Seq.iter (printfn \"%A\")\n    ","parent":{"$":0,"Item":"86382469-687d-4914-94b9-4067d8c5c7e7"},"predecessors":[{"$":0,"Item":"637217cf-d9b8-4bef-9774-a28412f1e944"},{"$":0,"Item":"e24d6bc0-703c-4f12-aca8-8158af50b7cd"}],"id":{"$":0,"Item":"7817de82-c2b4-4fa9-b768-6e3251334b5c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Tests","content":"#r @\"..\\packages\\Unquote\\lib\\net45\\Unquote.dll\"\nmodule Tests =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableFSI":"1"}},{"name":"Tap Runner","content":"#r @\"..\\packages\\NUnit\\lib\\nunit.framework.dll\"\n/// Test Anything Protocol (TAP) NUnit runner by Phillip Trelford\nmodule Tap =\n\n    open System\n    open System.Collections\n    open System.Reflection\n    open NUnit.Framework\n    \n    type Args = obj[]\n    type ExpectedResult = obj option\n    type ExpectedException = Type option\n    type Timeout = int option\n    type Test = Test of MethodInfo * Args * ExpectedResult * ExpectedException * Timeout\n    \n    let internal getCustomAttribute<'TAttribute when 'TAttribute :> Attribute> (mi:MethodInfo) = \n       mi.GetCustomAttribute(typeof<'TAttribute>, true) :?> 'TAttribute\n    \n    module internal SourceData =\n    \n       let (|SourceProperty|_|) (name,t:Type) =\n          let pi = t.GetProperty(name)\n          if pi <> null then Some(pi.GetGetMethod()) else None\n    \n       let (|SourceMethod|_|) (name,t:Type) =\n          let mi = t.GetMethod(name)\n          if mi <> null then Some(mi) else None\n    \n       let getSourceData (instance:obj, instanceType) (sourceName,sourceType:Type) =\n          match (sourceName,sourceType) with\n          | SourceProperty mi | SourceMethod mi->\n             let instance = \n                if instanceType <> sourceType \n                then Activator.CreateInstance(sourceType) \n                else instance\n             let result = mi.Invoke(instance, [||]) \n             result :?> IEnumerable\n          | _ -> invalidOp \"Expecting property or method\"\n    \n    module internal ParameterData =\n    \n       open SourceData\n    \n       module internal List =\n          let rec combinations = function\n          | [] -> [[]]\n          | hs :: tss ->\n             [for h in hs do\n                for ts in combinations tss ->\n                   h :: ts]\n    \n       let tryGetCustomAttribute<'TAttribute when 'TAttribute :> Attribute> (pi:ParameterInfo) =\n          match pi.GetCustomAttribute(typeof<'TAttribute>, true) with\n          | :? 'TAttribute as attr -> Some attr\n          | _ -> None\n    \n       let (|Random|_|) = tryGetCustomAttribute<RandomAttribute>\n       let (|Range|_|) = tryGetCustomAttribute<RangeAttribute>\n       let (|Values|_|) = tryGetCustomAttribute<ValuesAttribute>\n       let (|ValueSource|_|) = tryGetCustomAttribute<ValueSourceAttribute>\n    \n       let getParameterData instance (pi:ParameterInfo) =\n          match pi with\n          | Random rand -> [for x in rand.GetData(pi) -> x]\n          | Range range -> [for x in range.GetData(pi) -> x]\n          | Values values -> [for x in values.GetData(pi) -> x]\n          | ValueSource source ->\n             let data = getSourceData instance (source.SourceName, source.SourceType)\n             [for x in data -> x]\n          | _ -> invalidOp \"Expecting values\"\n    \n    module internal TestGeneration =\n    \n       open SourceData\n       open ParameterData\n    \n       let (|Ignore|_|) (mi:MethodInfo) =\n          if getCustomAttribute<IgnoreAttribute>(mi) <> null then Some() else None\n    \n       let (|TestCases|_|) (mi:MethodInfo) =\n          let cases = mi.GetCustomAttributes(typeof<TestCaseAttribute>, true)\n          if cases.Length > 0 then Some(cases |> Seq.cast<TestCaseAttribute>)\n          else None\n    \n       let (|TestCaseSource|_|) (mi:MethodInfo) =\n          let source = getCustomAttribute<TestCaseSourceAttribute>(mi)\n          if source <> null then\n             let sourceType = \n                if source.SourceType <> null then source.SourceType else mi.DeclaringType\n             Some(source.SourceName, sourceType)\n          else None\n    \n       let (|VanillaTest|_|) (mi:MethodInfo) =\n          if getCustomAttribute<TestAttribute>(mi) <> null then Some() else None\n    \n       let tryGetExpectedException (mi:MethodInfo) =\n          let attr = getCustomAttribute<ExpectedExceptionAttribute>(mi)\n          if attr <> null then Some attr.ExpectedException else None\n    \n       let (|Timeout|_|) (mi:MethodInfo) =\n          let attr = getCustomAttribute<TimeoutAttribute>(mi)\n          if attr <> null then Some (attr.Properties.[\"Timeout\"] :?> int) else None\n    \n       let (|MaxTime|_|) (mi:MethodInfo) =\n          let attr = getCustomAttribute<MaxTimeAttribute>(mi)\n          if attr <> null then Some (attr.Properties.[\"MaxTime\"] :?> int) else None\n    \n       let tryGetTimeout = function Timeout ms | MaxTime ms -> Some ms | _ -> None\n      \n       let fromCases (mi:MethodInfo) (cases:TestCaseAttribute seq) =\n          let ex = tryGetExpectedException(mi)\n          let timeout = tryGetTimeout mi\n          [|for case in cases ->\n             let expected = if case.HasExpectedResult then Some case.ExpectedResult else None\n             let ex = if case.ExpectedException <> null then Some(case.ExpectedException) else ex\n             Test(mi, case.Arguments, expected, ex, timeout)\n          |]\n    \n       let fromData instance (mi:MethodInfo) (data:IEnumerable) =\n          let ex = tryGetExpectedException mi\n          let timeout = tryGetTimeout mi\n          [|for item in data ->\n             match item with\n             | :? TestCaseData as case ->\n                let expected = if case.HasExpectedResult then Some(case.Result) else None\n                let ex = if case.ExpectedException <> null then Some(case.ExpectedException) else ex\n                Test(mi, case.Arguments, expected, ex, timeout) \n             | :? (obj[]) as args -> Test(mi, args, None, ex, timeout)\n             | arg -> Test(mi, [|arg|], None, ex, timeout)\n          |]\n    \n       let fromValues instance (mi:MethodInfo) =\n          let ex = tryGetExpectedException mi\n          let timeout = tryGetTimeout mi\n          [| let ps = mi.GetParameters()\n             let argValues = [for pi in ps -> getParameterData instance pi]\n             match List.combinations argValues with\n             | [] -> yield Test(mi, [||], None, ex, timeout)\n             | xs -> yield! [for args in xs -> Test(mi, List.toArray args, None, ex, timeout)]\n          |]\n    \n       let generateTests instance (mi:MethodInfo) =\n          let instance = instance, mi.DeclaringType\n          match mi with\n          | Ignore -> [||]\n          | TestCases cases -> fromCases mi cases\n          | TestCaseSource source -> getSourceData instance source |> fromData instance mi\n          | VanillaTest -> fromValues instance mi\n          | _ -> [||]\n    \n    module internal TestRunner =\n    \n       let runTest instance (Test(mi,args,expected,exType,timeout)) = \n          try\n             let actual = \n                match timeout with\n                | Some ms -> Async.RunSynchronously(async { return mi.Invoke(instance,args) }, ms)\n                | None -> mi.Invoke(instance,args)\n             match expected with\n             | Some expected -> Assert.AreEqual(expected, actual)\n             | None -> ()\n             None\n          with ex ->        \n            match ex.InnerException with\n            | :? SuccessException -> None\n            | ex ->\n                match exType with         \n                | Some t when t = ex.GetType() -> None\n                | _ -> Some ex\n    \n       let color c =\n          let previous = Console.ForegroundColor\n          Console.ForegroundColor <- c\n          { new System.IDisposable with \n             member __.Dispose() = Console.ForegroundColor <- previous\n          }\n    \n       let showResult number (Test(mi,args,_,_,_)) error =\n          let name =\n             mi.Name + \n                if args.Length > 0 then \"(\" + String.Join(\",\", args) + \")\"\n                else \"\"\n          match error with\n          | None ->\n             using (color ConsoleColor.Green) <| fun _ ->\n                printfn \"ok %d - %s\" number name\n          | Some e ->\n             using (color ConsoleColor.Red) <| fun _ ->\n                printfn \"not ok %d - %s\" number name\n                printfn \"  %A\" e\n    \n       let runTests instance (setUp,tearDown) (tests:Test[]) =\n          printfn \"1..%d\" tests.Length\n          tests |> Array.iteri (fun i test ->\n             let result =\n                try setUp (); runTest instance test\n                finally tearDown ()\n             result |> showResult (i+1) test \n          )\n    \n    let Run (testType:Type) =\n       let constr = testType.GetConstructor([||])\n       let instance = if constr <> null then constr.Invoke([||]) else null\n       let methods = testType.GetMethods()\n       let tests = [|for mi in methods do yield! TestGeneration.generateTests instance mi|]\n      \n       let methodsWithAttribute attr =\n          methods |> Array.filter (fun mi -> mi.GetCustomAttribute(attr, true) <> null)\n    \n       let runMethods (methods:MethodInfo[]) = \n          methods |> Array.iter (fun mi -> mi.Invoke(instance,[||]) |> ignore)\n    \n       let setUps = methodsWithAttribute typeof<SetUpAttribute>\n       let tearDowns = methodsWithAttribute typeof<SetUpAttribute>\n       let setUp () = setUps |> runMethods\n       let tearDown () = tearDowns |> runMethods\n    \n       methodsWithAttribute typeof<TestFixtureSetUpAttribute> |> runMethods\n       TestRunner.runTests instance (setUp, tearDown) tests\n       methodsWithAttribute typeof<TestFixtureTearDownAttribute> |> runMethods","parent":{"$":0,"Item":"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"},"predecessors":[],"id":{"$":0,"Item":"2c0233fa-d7dd-4bc9-86fd-9f9da6f5dba3"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Code for Testing","content":"open Useful\nopen NUnit.Framework\nopen Swensen.Unquote\n\nlet out, runStdOut =\n    let stdout = System.Text.StringBuilder()\n    (fun (s:string) -> stdout.Append s |> ignore)\n  , (fun f -> stdout.Clear() |> ignore\n              f()\n              stdout.ToString())\n\ntype Marker = interface end    \n\n","parent":{"$":0,"Item":"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"},"predecessors":[{"$":0,"Item":"2c0233fa-d7dd-4bc9-86fd-9f9da6f5dba3"},{"$":0,"Item":"e24d6bc0-703c-4f12-aca8-8158af50b7cd"}],"id":{"$":0,"Item":"c487f6a1-efbc-4a29-8c60-a9ebc73ae4e3"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"not a test: SSH to android","content":"open Useful\nopen UsefulDotNet\nopen Garage\n\nlet mutable passwordO = Some \"spa3102\"\n\ntype Computer with\n    member this.sshClient    pwd        =\n       getClient    this.ip.Value (Option.defaultValue 22 this.sshPort) this.user.Value pwd\n    member this.sshClientRsa passphrase =\n       new Renci.SshNet.PrivateKeyFile(@\"D:\\Abelardo\\Documents\\MobaXterm\\home\\.ssh\\id_rsa\", passphrase)\n       |> getClientRsa this.ip.Value (Option.defaultValue 22 this.sshPort) this.user.Value\n\n[ doCmd (AbeRaspi      .sshClient    passwordO.Value)\n  doCmd (OldHtcComputer.sshClientRsa passwordO.Value)\n]\n|> Seq.iter (fun f -> f \"ps\")\n","parent":{"$":0,"Item":"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"},"predecessors":[{"$":0,"Item":"7bb04b3c-b71e-4827-bd9e-b18fbabc1495"},{"$":0,"Item":"555306ec-f8cc-455f-b01f-9d86fbb2682d"}],"id":{"$":0,"Item":"51ce1b75-40fe-4bf6-b5df-9eeae87f8506"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"not a test: syntactic issues (not a test)","content":"let name = \"world\"\nlet x = 2.0\nlet sqr x = x * x\nlet a = 3.0\nlet b = 4.0\n\nlet r = sin(x) + cos(x)\nlet c = sqr(a) + sqr(b)\nlet v = abs(r + c)\nprintfn \"Hello %s\"  name.Trim().ToUpper()\n\nlet r = (sin x) + (cos x)\nlet c = (sqr a) + (sqr b)\nlet v = (abs(r + c))\nprintfn \"Hello %s\" (name.Trim().ToUpper())\n\n\n\nlet f () = printf \"1\"; fun () -> printf \"2\"\n\nlet g () = printf \"g\"\n\n//then, rather bizarrely, the following \"two\" programs behave differently:\n\nf ()   (g ())   // evaluates to () printing out \"g12\"\nprintfn \"\"\n(f ()) (g ()) // evaluates to () printing out \"1g2\"\nprintfn \"\"\n\nlet x = \"Hello\"\nlet y = (1,2)\nlet msg = \"\"\n\n//x.Substring y\n//x.Substring 1 2\n\nlet  recipient = \"x\"\ntype Message = Message of string * string\ntype Error   = Error   of string * string\n\nmatch msg with\n| \"Hello\" -> Message(recipient, \"Hi\"     )\n| \"Bye\"   -> Message(recipient, \"So Long\")\n| _       -> Message(recipient, \"\"       )\n\n//match msg with\n//| \"Hello\" -> Some Message(recipient, \"Hi\"     )\n//| \"Bye\"   -> Some Message(recipient, \"So Long\")\n//| _       -> None\n\nmatch msg with\n| \"Hello\" -> Some <| Message(recipient, \"Hi\"     )\n| \"Bye\"   -> Some <| Message(recipient, \"So Long\")\n| _       -> None\n\nmatch msg with\n| \"Hello\" -> Some(Message(recipient, \"Hi\"     ))\n| \"Bye\"   -> Some(Message(recipient, \"So Long\"))\n| _       -> None\n\nmatch msg with\n| \"Hello\" -> Message(recipient, \"Hi\"     ) |> Some\n| \"Bye\"   -> Message(recipient, \"So Long\") |> Some\n| _       ->                                  None\n\n////////////////////////////\n\n//match msg with\n//| \"Hello\" -> Result.Ok    Message(recipient, \"Hi\"     )\n//| \"Bye\"   -> Result.Ok    Message(recipient, \"So Long\")\n//| _       -> Result.Error Error(\"unrecognized message\", msg)\n\nmatch msg with\n| \"Hello\" -> Result.Ok    <| Message(recipient, \"Hi\"     )\n| \"Bye\"   -> Result.Ok    <| Message(recipient, \"So Long\")\n| _       -> Result.Error <| Error(\"unrecognized message\", msg)\n\nmatch msg with\n| \"Hello\" -> Result.Ok   (Message(recipient, \"Hi\"     ))\n| \"Bye\"   -> Result.Ok   (Message(recipient, \"So Long\"))\n| _       -> Result.Error(Error(\"unrecognized message\", msg))\n\nmatch msg with\n| \"Hello\" -> Message(recipient, \"Hi\"     )      |> Result.Ok   \n| \"Bye\"   -> Message(recipient, \"So Long\")      |> Result.Ok   \n| _       -> Error(\"unrecognized message\", msg) |> Result.Error\n\nlet sqr n = n * n\n\n(fun x y -> x + y) (sqr 5)(7)\n|> printfn \"%d\"\n\nsqr (5)\nsqr(5)\n\n(2).ToString()\n|> printfn \"%A\"\n","parent":{"$":0,"Item":"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"},"predecessors":[],"id":{"$":0,"Item":"b2f96f09-6749-4413-8f59-c542268369e2"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Wrap.wrap","content":"let wrapIf () =\n    Wrap.wrap {\n        let a = 1\n        if a = 1 then\n            let r = 3\n            ()\n        ()\n    }\n\nlet asyncIf () =\n    async {\n        let a = 1\n        if a = 1 then\n            let r = 3\n            ()\n        ()\n    }\n\nlet resultIf () =\n    Result.result {\n        let a = 1\n        if a = 1 then\n            let r = 3\n            ()\n        ()\n    }\n\nlet hello i =\n    printoutfn out \"before \"\n    Wrap.wrap {\n        printoutfn out \"wrap \"\n        let! h =  async { printoutfn out \"Hello1 %d\" i } \n        return i + 1\n    }\n\nlet hellllo (i:int) =\n    Wrap.wrap {\n        let! h = Some i\n        return h\n    }\n\nlet helllo i =\n    Wrap.wrap {\n        let h = hello i\n        return! h\n    }\n\nlet helo i =\n    Wrap.wrap {\n        do! Wrap.wrap { return () }\n        return i\n    }\n\nlet whileR() = \n    let mutable i = 0\n    Result.result {\n        let! a = Result.succeed 2\n        while (printoutfn out \"<%d>\" i ; i <= a) do\n            printoutfn out \"%d: \" i\n            let! z = hello i |> Wrap.toAsyncResult |> Async.RunSynchronously\n            i <- z\n            printoutfn out \" z = %d\" z\n    } |> ignore\n\nlet whileW() = \n    let mutable i = 0\n    Wrap.wrap {\n        let! aR = async { return Result.succeed 2 }\n        let! a = aR\n        while (printoutfn out \"<%d>\" i ; i <= a) do\n            printoutfn out \"%d: \" i\n            let! z = hello i\n            i <- z\n            printoutfn out \" z = %d\" z\n        return! WSome   ()\n    } |> Wrap.RunSynchronously\n\nlet whileWW() =\n    let mutable i = 0\n    let aAR = async { return Result.succeed 2 }\n    aAR |> WAsync |> Wrap.bind (fun aR ->\n        aR |> WResult |> Wrap.bind (fun a ->\n            let pred () = printoutfn out \"<%d>\" i ; i <= a \n            let body = fun () ->\n                printoutfn out \"%d: \" i\n                let zW = hello i\n                zW |> Wrap.bind (fun z ->\n                    i <- z\n                    printoutfn out \" z = %d\" i\n                    WSome   ()\n                )\n            let r = Wrap.whileLoop pred body\n            r\n        )\n    ) |> Wrap.RunSynchronously\n    \nlet helloA i =\n    printoutfn out \"before \"\n    async {\n        printoutfn out \"async \"\n        do! async { printoutfn out \"HelloA %d\" i }\n        return i + 1\n    }\n\nlet whileA() = \n    let mutable i = 0\n    async {\n        let! a = async { return 2 }\n        while (printoutfn out \"<%d>\" i ; i <= a) do\n            printoutfn out \"%d: \" i\n            let! z = hello i |> Wrap.toAsync\n            i <- z\n            printoutfn out \" z = %d\" z\n        ()\n    } |> Async.RunSynchronously\n\nlet forR() = \n    Result.result {\n        let! a = Result.succeed 2\n        for i = 0 to a do\n            printoutfn out \"%d: \" i\n            let! z = hello i |> Wrap.toAsyncResult |> Async.RunSynchronously\n            printoutfn out \" z = %d\" z\n    } |> ignore\n    \nlet forW() = \n    Wrap.wrap {\n        let! aR = async { return Result.succeed 2 }\n        let! a = aR\n        for i = 0 to a do\n            printoutfn out \"%d: \" i\n            let! z = hello i\n            printoutfn out \" z = %d\" z\n        return! WSome   ()\n    } |> Wrap.RunSynchronously\n    \nlet forA() = \n    async {\n        let! a = async { return 2 }\n        for i = 0 to a do\n            printoutfn out \"%d: \" i\n            let! z = hello i |> Wrap.toAsync\n            printoutfn out \" z = %d\" z\n        ()\n    } |> Async.RunSynchronously\n\nopen UsefulDotNet\n\nlet deleteIt() =\n    Wrap.wrap {\n        let file = \"hello.txt\"\n        System.IO.File.WriteAllText(file, \"this is the content\\njaja\")\n        printoutfn out \"before use\"\n        use toErase = new TempFileName(file)\n        printoutfn out \"using\"\n        do! Async.Sleep 5\n        printoutfn out \"still using\"\n        System.IO.File.ReadAllText file |> printoutfn out \"%s\"\n        printoutfn out \"used\"\n    } |> Wrap.RunSynchronously\n\n//runStdOut forR |> printfn \"%s\"\n//runStdOut forW |> printfn \"%s\"\n//runStdOut forA |> printfn \"%s\"\n\n\n//    let [<Test>]``when Divide by zero``() =               let divBy x y = x / y\n//                                                          test <@ divBy 10 0 = 10 @>\n//let [<Test>] formula                             () = test <@ (1+2)/3 = 2 @>\nlet [<Test>] ``whileA  must be diffrt. than \"\"`` () = runStdOut whileA  <>! \"\"     \nlet [<Test>] ``whileR  must be equal to whileA`` () = runStdOut whileR   =! runStdOut whileA     \nlet [<Test>] ``whileWW must be equal to whileA`` () = runStdOut whileWW  =! runStdOut whileA \nlet [<Test>] ``whileW  must be equal to whileA`` () = runStdOut whileW   =! runStdOut whileA \nlet [<Test>] ``forR    must be equal to forA``   () = runStdOut forR     =! runStdOut forA     \nlet [<Test>] ``forW    must be equal to forA``   () = runStdOut forW     =! runStdOut forA\nlet [<Test>] ``using TempFileName``              () = runStdOut deleteIt =! \"before use\\nusing\\nstill using\\nthis is the content\\njaja\\nused\\n\"\n   ","parent":{"$":0,"Item":"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"},"predecessors":[{"$":0,"Item":"4137cad8-fd64-426e-98de-16a92a56388d"},{"$":0,"Item":"c487f6a1-efbc-4a29-8c60-a9ebc73ae4e3"},{"$":0,"Item":"e24d6bc0-703c-4f12-aca8-8158af50b7cd"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"71b30bbf-0f07-4f43-8376-de712a2697bf"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FStationMessaging","content":"open WSMessagingBroker\n\nlet preds() =\n    let messaging = new FStationMessaging(\"FStationMessaging\")\n    let snpPath = \"FSSGlobal/F# Code/Tests/FStationMessaging\"\n\n    Wrap.wrapper {\n        let! preds = messaging.RequestPreds snpPath\n        return preds\n    } |> Wrap.RunSynchronously\n\nlet [<Test>] ``My code must contain myself``() = \n    test <@ preds() |> Seq.exists (fun snp -> snp.content.Contains \"supercalifragilisticexpialidocious, mxyzptlk & rumpelstiltskin are unusual words\") @>\n","parent":{"$":0,"Item":"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"},"predecessors":[{"$":0,"Item":"d9c4540a-85f5-4c62-91be-fcb2d60e9f17"},{"$":0,"Item":"c487f6a1-efbc-4a29-8c60-a9ebc73ae4e3"}],"id":{"$":0,"Item":"e291419f-5cb5-4751-b09b-3ca1e2fcd20d"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"ClientWebSocket .Net","content":"open Useful\nopen WSMessagingBroker\n\nlet out' s = printfn \"%s\" s\n\nlet clientId = \"ClientWebSocket .Net Test\"\nlet messaging = new WSMessagingClient(clientId)\n\nmessaging.ProcessIncoming <| fun msg -> Wrap.wrapper { printoutfn out' \"Message: %A\" msg }\n//messaging.Out <- out\n\nlet GetListeners() = messaging.MBListeners |> Wrap.RunSynchronously\n\nlet GetListeners4Times() =\n    GetListeners() |> printoutfn out \"1: %A\"\n    GetListeners() |> printoutfn out \"2: %A\"\n    GetListeners() |> printoutfn out \"3: %A\"\n    GetListeners() |> printoutfn out \"4: %A\"\n\nlet sendFromBroker() =\n    newMsg MessageBrokerAddress \"This is Information\"\n    |> replier Broker\n    |> msgType MsgFromBroker\n    |> messaging.SendMsg\n    |> Wrap.runSynchronouslyS false\n    |> printoutfn out \"%s\"\n\nlet sendFromBroker4Times() =\n    sendFromBroker()\n    sendFromBroker()\n    sendFromBroker()\n    sendFromBroker()\n\nlet timeouts() = \n    newMsg MessageBrokerAddress \"This should Timeout\"\n    |> replier Receiver\n    |> msgType MsgInformation\n    |> messaging.SendMsg\n    |> Wrap.runSynchronouslyS false\n    |> printoutfn out \"%s\"\n\nlet [<Test>] ``Get Listeners 4 times``           () = test <@ runStdOut(GetListeners4Times)  .Contains \"|]\\n4: [|\"             @>\nlet [<Test>] ``BMOnlyBrokerShouldUse 4 times``   () = test <@ runStdOut(sendFromBroker4Times).Contains \"Failed!\\nBMOnlyBrokerShouldUse\\nFailed!\\nBMOnlyBrokerShouldUse\\nFailed!\\nBMOnlyBrokerShouldUse\\nFailed!\\nBMOnlyBrokerShouldUse\\n\" @>\nlet [<Test>] ``I must be one of the listeners``  () = test <@ GetListeners()           |> Seq.contains clientId                @>\nlet [<Test>] ``Must get a BMOnlyBrokerShouldUse``() = test <@ runStdOut(sendFromBroker)      .Contains \"BMOnlyBrokerShouldUse\" @>\nlet [<Test>] ``Must Timeout``                    () = raises<System.TimeoutException> <@ timeouts()                            @>\n    \n        ","parent":{"$":0,"Item":"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"},"predecessors":[{"$":0,"Item":"e665bede-c870-4041-b7ed-8be419c52a83"},{"$":0,"Item":"c487f6a1-efbc-4a29-8c60-a9ebc73ae4e3"},{"$":0,"Item":"2c0233fa-d7dd-4bc9-86fd-9f9da6f5dba3"}],"id":{"$":0,"Item":"8d27dca0-b87f-43b8-abe4-967e15467df4"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"\nopen canopy\nopen runner\nopen System\n\n//start an instance of the firefox browser\nstart firefox\n\n//this is how you define a test\n\"taking canopy for a spin\" &&& fun _ ->\n    //this is an F# function body, it's whitespace enforced\n\n    //go to url\n    url \"http://lefthandedgoat.github.io/canopy/testpages/\"\n\n    //assert that the element with an id of 'welcome' has\n    //the text 'Welcome'\n    \"#welcome\" == \"Welcome\"\n\n    //assert that the element with an id of 'firstName' has the value 'John'\n    \"#firstName\" == \"John\"\n\n    //change the value of element with\n    //an id of 'firstName' to 'Something Else'\n    \"#firstName\" << \"Something Else\"\n\n    //verify another element's value, click a button,\n    //verify the element is updated\n    \"#button_clicked\" == \"button not clicked\"\n    click \"#button\"\n    \"#button_clicked\" == \"button clicked\"\n\n//run all tests\nrun()\n\nprintfn \"press [enter] to exit\"\nSystem.Console.ReadLine() |> ignore\n\nquit()","parent":{"$":0,"Item":"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"},"predecessors":[],"id":{"$":0,"Item":"fdb52749-398c-402a-8ecb-8137dafa37d2"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Run All Tests","content":"// You can select which test to run just by making them predecessors of this\n\nTap.Run typeof<Marker>.DeclaringType    // run tests in module\n\n","parent":{"$":0,"Item":"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"},"predecessors":[{"$":0,"Item":"71b30bbf-0f07-4f43-8376-de712a2697bf"}],"id":{"$":0,"Item":"3268fd67-3dfe-47c4-afec-0231952e2294"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableFSI":"0"}},{"name":"WebSharper Code","content":"#define WEBSHARPER\n(*\n Code to be Compiled to Javascript and run in the browser\n using `Compile WebSharper` or `Run WebSharper`\n*)\n","parent":{"$":0,"Item":"bf864f3c-1370-42f2-ac8a-565a604892e8"},"predecessors":[{"$":0,"Item":"66ab3e22-f5ed-4e75-966d-28394d24f3d7"}],"id":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"expanded":true,"level":0,"levelCode":0,"properties":{"Theme":"twilight","DisableFSI":"1","NoIndent":"1","DisableFable":"1","Layout":"[[\"main_messages\",{\"GuiSplit\":[true,\"StVariable\",false,18,\"messagesB\",\"snippets_code\",0,75]}]]"}},{"name":"paket dependencies","content":"source https://www.nuget.org/api/v2\nframework: net461\n\nnuget FSharp.Compiler.Tools 4.1.23\nnuget FSharp.Compiler.Service 17.0.1\n\nnuget CryptSharpOfficial \nnuget FSharp.Configuration\nnuget FSharp.Core\nnuget FSharp.Data\nnuget FSharp.Data.SqlClient\nnuget HtmlAgilityPack\nnuget Microsoft.Owin\nnuget Microsoft.Owin.Diagnostics\nnuget Microsoft.Owin.FileSystems\nnuget Microsoft.Owin.Host.HttpListener\nnuget Microsoft.Owin.Hosting\nnuget Microsoft.Owin.StaticFiles\nnuget Mono.Cecil 0.10.0-beta6\nnuget Owin\nnuget Owin.Compression 1.0.18\nnuget System.ValueTuple\n//nuget System.IO.Compression 4.3.0-preview1-24530-04\nnuget System.IO.Compression\nnuget WebSharper         \nnuget WebSharper.Compiler\nnuget WebSharper.FSharp\nnuget WebSharper.Owin\nnuget WebSharper.Owin.WebSocket\nnuget WebSharper.UI.Next        \nnuget Newtonsoft.Json\nnuget XPlot.Plotly\nnuget SSH.NET\n\nnuget FSharpPlus 1.0.0-CI00136\n\nnuget FSharp.Quotations.Evaluator\n\nnuget Fable.Core\nnuget Fable.Import.Browser\n\nnuget NUnit 2.6.4\nnuget Unquote\n\nnuget CommonServiceLocator \n\nnuget AWSSDK.Core\nnuget AWSSDK.Lambda\n","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[],"id":{"$":0,"Item":"0a1bc147-ca13-4f2c-9c8b-533b42001d8f"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"1"}},{"name":"HtmlNode","content":"\n[<JavaScript>]\nmodule HtmlNode      =\n","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Val","content":"[<NoComparison>]\ntype Val<'a> =\n    | Constant  of 'a\n    | DynamicV  of Var<'a>\n    | Dynamic   of View<'a>\n  with member this.ValTypeMember = 0\n\nmodule Var =\n    let mutable private counter = 1\n    let freshId () =\n        counter <- counter + 1\n        \"varuid\" + string counter\n            \n    let Make (init: 'T) (view: View<'T>) (set: 'T -> unit) =\n        let id = freshId ()\n        let current = ref init\n        let view = view |> View.Map (fun x -> current := x; x)\n        { new Var<'T>() with\n            member this.View           = view\n            member this.Get         () = !current\n            member this.Set         x  = set x\n            member this.SetFinal    x  = set x\n            member this.UpdateMaybe f  = view |> View.Get (f >> Option.iter set)\n            member this.Update      f  = view |> View.Get (f >>             set)\n            member this.Id             = id\n        }\n    let lensView get update view0 (var: Var<_>) =\n        let id   = freshId()\n        let view = View.Map2 (fun v _ -> get v) var.View view0\n        { new Var<'V>() with\n            member this.Get        () = get (var.Get())\n            member this.Set         v = var.Update(fun t -> update t v)\n            member this.SetFinal    v = this.Set(v)\n            member this.Update      f = var.Update(fun t -> update t (f (get t)))\n            member this.UpdateMaybe f = var.UpdateMaybe(fun t -> Option.map (fun x -> update t x) (f (get t)))\n            member this.View          = view\n            member this.Id            = id\n        }\n\nmodule ListModel =\n    let currentLensUpd def curr upd (model:ListModel<_,_>) = \n        curr \n        |> Var.lensView (Option.bind (model.TryFindByKey) >> Option.defaultValue def) \n                        (fun kO v -> kO |> Option.iter (upd v) ; kO)\n                        model.View\n    let currentLensUpd' def curr upd (model:ListModel<_,_>) = \n        let view = curr |> View.Map2 (fun _mdl kO -> kO |> Option.bind model.TryFindByKey |> Option.defaultValue def) model.View\n        Var.Make def view upd\n    let currentLens def curr (model:ListModel<_,_>) = \n        model \n        |> currentLensUpd' def curr (fun v -> model.UpdateBy (fun _ -> model.TryFindByKey (model.Key v) |> Option.map (fun _ -> v) ) <| model.Key v)\n    \nmodule Val =\n    let swap = Useful.swap\n    \n    let mapV : ('a -> 'b) -> Val<'a> -> Val<'b> =\n        fun    f             va      ->\n            match va with\n            | Constant  a -> f a                   |> Constant\n            | Dynamic  wa -> wa      |> View.Map f |> Dynamic \n            | DynamicV va -> va.View |> View.Map f |> Dynamic \n\n    let iterV : ('a -> unit) -> Val<'a> -> unit = //f v = toView v |> View.Get f\n        fun     f               va      ->\n            match va with\n            | Constant  a ->          f  a                  \n            | Dynamic  wa -> View.Get f wa \n            | DynamicV va ->          f va.Value \n\n    let toView v =\n        match v with\n        | Constant  a -> View.Const a\n        | Dynamic  wa -> wa\n        | DynamicV va -> va.View\n\n    let getAsync v =\n        match v with\n        | Constant  a -> async.Return   a\n        | Dynamic  wa -> View.GetAsync wa\n        | DynamicV va -> async.Return  va.Value\n\n    let bindV : ('a -> Val<'b>) -> Val<'a> -> Val<'b> =\n        fun     f                  v       -> \n            match v with\n            | Constant  a -> f a\n            | Dynamic  wa -> wa      |> View.Bind (f >> toView) |> Dynamic \n            | DynamicV va -> va.View |> View.Bind (f >> toView) |> Dynamic \n\n    let inline map2V (f_a_b_c: 'a->'b->'c) : Val<'a>->Val<'b>->Val<'c> =\n        let inline    f_aVbVc   a =  mapV  (f_a_b_c   a)\n        let inline    fVb_aVc  vb = (swap   f_aVbVc) vb\n        let inline    fVbVaVc  vb =  bindV (fVb_aVc  vb)\n        let inline    fVaVbVc  va = (swap   fVbVaVc) va\n        fVaVbVc\n\n    let inline map3V f3 v1 v2 v3    = map2V f3 v1 v2    |> map2V (|>) v3\n    let inline map4V f3 v1 v2 v3 v4 = map3V f3 v1 v2 v3 |> map2V (|>) v4\n    \n    let tagDoc: ('a -> Doc) -> Val<'a> -> Doc =\n        fun     tag            va      ->\n            match va with\n            | Constant  a -> tag   a\n            | Dynamic  wa -> wa      |> View.Map tag |> Doc.EmbedView\n            | DynamicV va -> va.View |> View.Map tag |> Doc.EmbedView\n\n    let tagElt: ('a -> Elt) -> Val<'a> -> Doc =\n        fun     tag            va     ->\n            match va with\n            | Constant  a -> tag   a :> Doc\n            | Dynamic  wa -> wa      |> View.Map tag |> Doc.EmbedView\n            | DynamicV va -> va.View |> View.Map tag |> Doc.EmbedView\n\n    let attrVO att       vao     =\n            match vao with\n            | Constant (Some a)-> Attr.Create      att   a\n            | Constant  None   -> Attr.DynamicPred att  (View.Const false              ) (View.Const                      \"\"         )\n            | Dynamic       wa -> Attr.DynamicPred att  (View.Map Option.isSome wa     ) (View.Map   (Option.defaultValue \"\") wa     )\n            | DynamicV      va -> Attr.DynamicPred att  (View.Map Option.isSome va.View) (View.Map   (Option.defaultValue \"\") va.View)\n\n    let attrV att       va      =\n            match va with\n            | Constant  a -> Attr.Create  att   a\n            | Dynamic  wa -> Attr.Dynamic att  wa\n            | DynamicV va -> Attr.Dynamic att  va.View    \n\n    type HelperType = HelperType with\n        static member (&>) (HelperType, a :     string option   ) = Constant  a\n        static member (&>) (HelperType, a :     string          ) = Constant  a\n        static member (&>) (HelperType, a :     bool            ) = Constant  a\n        static member (&>) (HelperType, a :     int             ) = Constant  a\n        static member (&>) (HelperType, a :     float           ) = Constant  a\n        static member (&>) (HelperType, a :     Doc             ) = Constant  a\n        static member (&>) (HelperType, va: Val<string option>  ) =          va\n        static member (&>) (HelperType, va: Val<string       >  ) =          va\n        static member (&>) (HelperType, va: Val<bool         >  ) =          va\n        static member (&>) (HelperType, va: Val<int          >  ) =          va\n        static member (&>) (HelperType, va: Val<float        >  ) =          va\n        static member (&>) (HelperType, va: Val<Doc          >  ) =          va\n        static member (&>) (HelperType, va: Val<_            >  ) =          va\n        static member (&>) (HelperType, vr: Var<_            >  ) = DynamicV vr\n        static member (&>) (HelperType, vw: View<_           >  ) = Dynamic  vw\n\n(*    [< Inline @\"(\n            typeof($v) == 'function' ? {$:2, $0:$v} // View\n            :   typeof($v) == 'object'\n                      ? typeof($v.$) != 'undefined' // Val\n                            ? $v \n                            : typeof($v.Id) == 'number' || typeof($v.i) == 'number' || typeof($v.RView == 'function')// Var\n                                 ? {$:1, $0:$v}\n                                 : typeof($v.docNode) != 'undefined'\n                                     ? {$:0, $0:$v} // Doc\n                                     : {$:2, $0:$v} // View?\n                      : {$:0, $0:$v}) // other\n                                     \" >]\n    let fixit0 v = Constant v\n    let fixit2 v = let result = fixit0 v\n                   result\n                   \n    [< Direct \"FSSGlobal.HtmlNode.Val.fixit2($v)\" >]\n    //[< Inline >]\n    let inline fixit v = HelperType &> v\n*)\n    let toVal (o: obj) =\n        match o with\n        | :?      string   as t   -> Val.Constant t \n        | :?      int      as t   -> Val.Constant t |> As<Val<string>> \n        | :?      bool     as t   -> Val.Constant t |> As<Val<string>>  \n        | :?      Doc      as t   -> Val.Constant t |> As<Val<string>>  \n        | :? Val< string>  as v   ->              v        \n        | :? Var< string>  as v   -> Val.DynamicV v        \n        | v when JS.In \"RSet\" v   -> Val.DynamicV (As<Var< string>> v)\n        | :? Function      as vw  -> Val.Dynamic  (As<View<string>> vw)        \n        | _ when o?get_ValTypeMember() = 0 -> o |> As<Val<string>> \n        | _                       -> failwith <| sprintf \"Could not convert %A\" o\n\n    [< Direct \"$_f($v)\" >]\n    let inline fixitF _f v = HelperType &> v\n    let inline fixit    v = fixitF toVal v\n\n    let [<Inline>] inline bindIRefO0 (f: 'a->Var< 'b> option) (view: View<'a>) = \n        let contentVar                          = Var.Create None\n        let changingIRefO : Var< 'b> option ref = ref        None\n        let contentVarChanged                   = ref 0L\n        let refVarChanged                       = ref 0L\n    \n        contentVar.View \n        |> View.Sink (fun _ ->            \n            match !changingIRefO, contentVar.Value with\n            | Some(r), Some(v) ->\n                if  !contentVarChanged  > !refVarChanged   then refVarChanged := !contentVarChanged\n                elif r.Value           <> v                then refVarChanged := !refVarChanged       + 1L ; r.Value         <-  v\n            | None, Some(_)    -> contentVar.Value <- None\n            | _   , None       -> ()\n         )\n    \n        view |> View.Bind (fun cur ->\n            let rO            = f cur\n            changingIRefO    := rO\n            refVarChanged    := !contentVarChanged + 100L\n            contentVar.Value <- rO |> Option.map (fun r -> r.Value)\n            rO |> Option.map (fun r -> r.View) |> Option.defaultWith (fun () -> View.Const Unchecked.defaultof<_>)\n        ) |> View.Sink (fun _ -> \n            !changingIRefO \n            |> Option.iter (fun r -> \n                if  !refVarChanged  > !contentVarChanged then contentVarChanged := !refVarChanged\n                elif Some r.Value  <>  contentVar.Value  then contentVarChanged := !contentVarChanged + 10L; contentVar.Value  <- Some r.Value\n            )\n        )\n        contentVar\n        \n    let [<Inline>] inline bindIRef0 (f: 'a->Var< 'b>) (view: View<'a>) = \n        let contentVar = Var.Create Unchecked.defaultof<'b>\n        let changingIRefO : Var< 'b> option ref = ref None\n        let contentVarChanged = ref 0L\n        let refVarChanged     = ref 0L\n    \n        contentVar.View \n        |> View.Sink (fun _ -> \n            !changingIRefO \n            |> Option.iter (fun r -> \n                if  !contentVarChanged  > !refVarChanged   then refVarChanged := !contentVarChanged\n                elif r.Value           <> contentVar.Value then refVarChanged := !refVarChanged       + 1L ; r.Value         <-  contentVar.Value\n               )\n           )\n    \n        view |> View.Bind (fun cur ->\n            let r = f cur\n            changingIRefO    := Some r\n            refVarChanged    := !contentVarChanged + 100L\n            contentVar.Value <- r.Value\n            r.View\n        ) |> View.Sink (fun _ -> \n            !changingIRefO \n            |> Option.iter (fun r -> \n                if  !refVarChanged  > !contentVarChanged then contentVarChanged := !refVarChanged\n                elif r.Value       <> contentVar.Value   then contentVarChanged := !contentVarChanged + 10L; contentVar.Value  <-  r.Value\n               )\n            )\n        contentVar\n        \n    let inline toDoc         v           = toView            (fixit v ) |> Doc.EmbedView\n    let [<Inline>] inline bindIRef  f  v           = bindIRef0  f (fixit v   |> toView)\n    let [<Inline>] inline bindIRefO f  v           = bindIRefO0 f (fixit v   |> toView)\n    let inline iter       f  v           = iterV           f (fixit v )\n    let inline bind       f  v           = bindV           f (fixit v )\n    let inline map        f  v           = mapV            f (fixit v )\n    let inline map2       f  v1 v2       = map2V           f (fixit v1) (fixit v2)\n    let inline map3       f  v1 v2 v3    = map3V           f (fixit v1) (fixit v2) (fixit v3)\n    let inline map4       f  v1 v2 v3 v4 = map4V           f (fixit v1) (fixit v2) (fixit v3) (fixit v4)\n\n    let inline apply      va vf          = bindV(fun f-> mapV f va) vf\n  \n    let inline iter2      f  v1 v2       = map2            f v1 v2       |> iterV id\n    let inline iter3      f  v1 v2 v3    = map3            f v1 v2 v3    |> iterV id\n    let inline iter4      f  v1 v2 v3 v4 = map4            f v1 v2 v3 v4 |> iterV id\n  \n    let inline mapAsync   f  v           = View.MapAsync   f (fixit v |> toView) |> Dynamic\n    let inline sink       f  v           = View.Sink       f (fixit v |> toView) \n    let inline mapCached  f  v           = View.MapCached  f (      v |> toView) |> Dynamic\n\n    let [<Inline>] inline consistent   (vl:Val<_>)  = \n        let prior      = ref <| Var.Create Unchecked.defaultof<_>\n        let setPrior v = if (!prior).Value <> v then (!prior).Value <- v \n        let vw         = toView vl\n        View.Sink setPrior vw\n        !prior :> Var< _> |> DynamicV\n\n    type valBuilder() =\n        member inline this.Return     (x)                            = Constant x\n        member inline this.ReturnFrom (x)                            = x\n        member        this.Bind       (w:Val<'a> , r: 'a -> Val<'b>) = bind r w\n        member        this.Bind       (w:Var<'a> , r: 'a -> Val<'b>) = bind r w\n        member        this.Bind       (w:View<'a>, r: 'a -> Val<'b>) = bind r w\n        member inline this.Zero       ()                             = Constant ()\n        member inline this.Delay      (f)                            = f()\n    \n    let valFlow = valBuilder()\n","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"657c8f34-c917-4659-825d-c9ead206efcf"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"0f5719f0-e95e-498d-ab88-f89ff1440e32"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"HtmlNode","content":"[<NoComparison ; NoEquality>]\ntype HtmlNode =\n    | HtmlElement    of name: string * children: HtmlNode seq\n    | HtmlElementF   of func:(Attr seq -> Doc seq -> Doc) * children: HtmlNode seq\n    | HtmlElementV   of Val<HtmlNode>\n    | HtmlAttribute  of name: string * value:    Val<string>\n    | HtmlAttributeO of name: string * value:    Val<string option>\n    | HtmlText       of Val<string>\n    | HtmlEmpty\n    | SomeDoc        of Doc\n    | SomeAttr       of Attr\n    \nlet addClassX    (classes:string) (add:string) = classes.Split ' ' |> Set.ofSeq |> Set.union  (Set.ofSeq <| add.Split ' ') |> String.concat \" \"\n//let removeClass (classes:string) (rem:string) = classes.Split ' ' |> Set.ofSeq |> Set.remove               rem            |> String.concat \" \"\n\n//let callAddClassX = addClassX \"a\" \"b\" // so that WebSharper.Collections.js is included\n\nlet inline chooseAttr node = \n    match node with\n    | HtmlAttribute (name, value   ) when name <> \"class\" && name <> \"style\" \n                                     -> Some <| Val.attrV    name value\n    | HtmlAttributeO(name, valueO  ) when name <> \"class\" && name <> \"style\" \n                                     -> Some <| Val.attrVO   name valueO\n    | SomeAttr             attr      -> Some <| attr\n    | _                              -> None\n\nlet chooseThisAttr this node =\n    match node with\n    | HtmlAttribute (att, value) when att = this -> Some value\n    | _                                          -> None\n\nlet concat s a b = a + s + b\nlet groupAttr name sep children = \n    children \n    |> Seq.choose (chooseThisAttr name)\n    |> (fun ss -> if ss |> Seq.isEmpty \n                  then None \n                  else ss |> Seq.reduce (Val.map2 <| concat sep ) |> Val.attrV name |> Some)\n\nlet inline getAttrsFromSeq children =\n    children \n    |> Seq.choose chooseAttr\n    |> Seq.append (List.choose id [ children |> groupAttr \"class\" \" \" ; children |> groupAttr \"style\" \"; \" ])\n\nlet rec chooseNode node =\n    match node with\n    | HtmlElement (name, children) -> Some <| (Doc.Element name (getAttrsFromSeq children) (children |> Seq.choose chooseNode) :> Doc)\n    | HtmlElementF(func, children) -> Some <| (func             (getAttrsFromSeq children) (children |> Seq.choose chooseNode)       )\n    | HtmlElementV vnode           -> Some <| (vnode |> Val.toView |> Doc.BindView (chooseNode >> Option.defaultValue Doc.Empty))\n    | HtmlText     vtext           -> Some <| Val.tagDoc WebSharper.UI.Html.text vtext\n    | SomeDoc      doc             -> Some <| doc\n    | _                            -> None\n\nlet getAttrChildren attr =\n    Seq.tryPick (function \n                | HtmlAttribute(a, v) when a = attr -> Some v \n                | _                                 -> None)\n    >> Option.defaultValue (Constant \"\")\n\nlet rec mapHtmlElement (f:string -> seq<HtmlNode> -> string * HtmlNode seq) (element:HtmlNode) :HtmlNode =\n    match element with\n    | HtmlElement (name, children) -> f name  children                    |> HtmlElement\n    | HtmlElementV vnode           -> vnode |> Val.map (mapHtmlElement f) |> HtmlElementV\n    | _                            -> element\n\n//let getAttr attr element =\n//    match element with\n//    | HtmlElement(_, children) -> children\n//    | _                        -> seq []\n//    |> getAttrChildren attr\n//\n//let getClass = getAttr \"class\"\n//let getStyle = getAttr \"style\"\n\n//let replaceAttribute att (children: HtmlNode seq) newVal =\n//    HtmlAttribute(att, newVal)\n//    :: (children\n//        |> Seq.filter (function HtmlAttribute(old, _) when old = att -> false | _ -> true)\n//        |> Seq.toList\n//       )\n//\n//let replaceAtt att node newVal = mapHtmlElement (fun n ch -> n, replaceAttribute att ch newVal |> Seq.ofList) node\n\nlet inline htmlElement    name ch = HtmlElement   (name, ch           )\nlet inline htmlElementF   func ch = HtmlElementF  (func, ch           )\nlet inline htmlAttribute  name v  = HtmlAttribute (name, Val.fixit v  )\nlet inline htmlAttributeO name v  = HtmlAttributeO(name, Val.fixit v  )\nlet inline htmlText       txt     = HtmlText      (      Val.fixit txt)\nlet inline str            txt     = HtmlText      (      Val.fixit txt)\nlet inline someElt        elt     = SomeDoc       (elt :> Doc         )    \n  \nlet inline addChildren    add (h:HtmlNode) = h |> mapHtmlElement (fun n ch -> n, Seq.append ch   add)\nlet inline insertChildren add (h:HtmlNode) = h |> mapHtmlElement (fun n ch -> n, Seq.append add  ch )\nlet inline addClass       c    h           = h |> addChildren [ htmlAttribute  \"class\" c ] \nlet inline addClassIf     c v              = addClass <| Val.map (fun b -> if b then c else \"\") (Val.fixit v)\n\nlet out (ps:HtmlNode list) =\n    match ps with\n    | [ ]            -> [ ]\n    | [h]            -> [h]\n    | h :: p :: tail -> addChildren [h] p :: tail\n    \nlet rec indent2Level lvl chn  (ps:HtmlNode list) =\n    match ps with\n    | l when l.Length < lvl -> chn :: l\n    | _                     -> indent2Level lvl chn <| out ps        \n\ntype HtmlNode with\n    member inline this.toDoc = \n        match this with\n        | HtmlAttribute _\n        | HtmlEmpty       -> Doc.Empty\n        | _               -> chooseNode this |> Option.defaultValue Doc.Empty\n    // member inline   this.Class          clas = Val.fixit clas |> replaceAtt \"class\" this\n    member          this.AddChildren    add  = this |> addChildren    add\n    member          this.InsertChildren add  = this |> insertChildren add\n    member inline   this.AddClass       c    = this |> addClass       c\n    static member ( - ) (ps:HtmlNode list, chn : HtmlNode) : HtmlNode list = \n        match ps with \n        | h :: tail -> h.AddChildren [chn] :: tail\n        | []        -> []        \n    static member ( --- ) (ps:HtmlNode list, chn) : HtmlNode list = \n        match ps with \n        | [ ]            -> [ ]\n        | [h]            -> [ h.AddChildren [                 chn ] ]\n        | h :: p :: tail ->   p.AddChildren [ h.AddChildren [ chn ] ] :: tail\n    static member ( +  ) (ps:HtmlNode list, r:HtmlNode) : (HtmlNode list) =   r :: ps\n    static member ( --                   ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level  2 chn ps\n    static member ( ----                 ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level  3 chn ps    \n    static member ( ------               ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level  4 chn ps    \n    static member ( --------             ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level  5 chn ps    \n    static member ( ----------           ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level  6 chn ps    \n    static member ( ------------         ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level  7 chn ps    \n    static member ( --------------       ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level  8 chn ps    \n    static member ( ----------------     ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level  9 chn ps    \n    static member ( ------------------   ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level 10 chn ps    \n    static member ( -------------------- ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level 11 chn ps    \n\nlet rec finishO (ps:HtmlNode list) =\n    match ps with\n    | [ ]               -> None\n    | [h]               -> Some h\n    | _h :: _p :: _tail -> finishO <| out ps        \n\nlet endHtmlIndent ps = finishO ps |> Option.defaultWith (fun () -> htmlText \"Malformed HTMLNode\")\nlet ( !! ) (p:HtmlNode seq -> HtmlNode) l = [ p l ]\n\nlet renderDoc = chooseNode >> Option.defaultValue Doc.Empty\n    ","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"0f5719f0-e95e-498d-ab88-f89ff1440e32"}],"id":{"$":0,"Item":"d9124644-0af6-4a7f-a711-ef76ca77f0de"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"HTML Elements & Attributes","content":"let inline atr att v = Val.attrV  att (Val.fixit v)\nlet inline tag tag v = Val.tagDoc tag (Val.fixit v)\n\nlet inline _class       v = atr \"class\"       v\nlet inline _type        v = atr \"type\"        v\nlet inline _style       v = atr \"style\"       v\nlet inline _placeholder v = atr \"placeholder\" v\nlet inline textV        v = tag  Html.text    v\n\nlet inline a           ch = htmlElement   \"a\"           ch\nlet inline p           ch = htmlElement   \"p\"           ch\nlet inline ul          ch = htmlElement   \"ul\"          ch\nlet inline li          ch = htmlElement   \"li\"          ch\nlet inline br          ch = htmlElement   \"br\"          ch\nlet inline hr          ch = htmlElement   \"hr\"          ch\nlet inline h1          ch = htmlElement   \"h1\"          ch\nlet inline h2          ch = htmlElement   \"h2\"          ch\nlet inline h3          ch = htmlElement   \"h3\"          ch\nlet inline h4          ch = htmlElement   \"h4\"          ch\nlet inline h5          ch = htmlElement   \"h5\"          ch\nlet inline h6          ch = htmlElement   \"h6\"          ch\nlet inline div         ch = htmlElement   \"div\"         ch\nlet inline img         ch = htmlElement   \"img\"         ch\nlet inline span        ch = htmlElement   \"span\"        ch\nlet inline form        ch = htmlElement   \"form\"        ch\nlet inline table       ch = htmlElement   \"table\"       ch\nlet inline thead       ch = htmlElement   \"thead\"       ch\nlet inline th          ch = htmlElement   \"th\"          ch\nlet inline tr          ch = htmlElement   \"tr\"          ch\nlet inline td          ch = htmlElement   \"td\"          ch\nlet inline tbody       ch = htmlElement   \"tbody\"       ch\nlet inline label       ch = htmlElement   \"label\"       ch\nlet inline button      ch = htmlElement   \"button\"      ch\nlet inline script      sc = htmlElement   \"script\"      sc\nlet inline styleH      st = htmlElement   \"style\"       st\nlet inline fieldset    ch = htmlElement   \"fieldset\"    ch\nlet inline link        sc = htmlElement   \"link\"        sc\nlet inline iframe      at = htmlElement   \"iframe\"      at\nlet inline body        ch = htmlElement   \"body\"        ch\nlet inline section     ch = htmlElement   \"section\"     ch\nlet inline strong      at = htmlElement   \"strong\"      at\n\n\nlet inline target      v  = htmlAttribute  \"target\"      v\nlet inline href        v  = htmlAttribute  \"href\"        v\nlet inline hrefO       vO = htmlAttributeO \"href\"        vO\nlet inline rel         v  = htmlAttribute  \"rel\"         v\nlet inline charset     v  = htmlAttribute  \"charset\"     v\nlet inline src         v  = htmlAttribute  \"src\"         v\nlet inline ``class``   v  = htmlAttribute  \"class\"       v\nlet inline ``type``    v  = htmlAttribute  \"type\"        v\nlet inline width       v  = htmlAttribute  \"width\"       v\nlet inline title       v  = htmlAttribute  \"title\"       v\nlet inline Id          v  = htmlAttribute  \"id\"          v\nlet inline frameborder v  = htmlAttribute  \"frameborder\" v\nlet inline spellcheck  v  = htmlAttribute  \"spellcheck\"  v\nlet inline draggable   v  = htmlAttribute  \"draggable\"   v\nlet inline style       v  = htmlAttribute  \"style\"       v\nlet inline placeholder v  = htmlAttribute  \"placeholder\" v\n\nlet inline style1    n v  = style <| Val.map ((+) (n + \":\")) v\n\ntype HtmlNode with\n    member inline   this.Style          sty  = this.AddChildren([ style sty ])\n\nlet inline css         v  = styleH [ htmlText v ] \n\nlet inline classIf cls v = ``class`` <| Val.map (fun b -> if b then cls else \"\") (Val.fixit v)\n\n//let inline ``xclass`` v  = \n//    match Val.fixit v with\n//    | Constant c  -> Attr.Class        c       \n//    | Dynamic  cw -> Attr.DynamicClass \"class_for_view_not_implemented\" cw      ((<>)\"\")\n//    | DynamicV cv -> Attr.DynamicClass cv.Value                         cv.View ((<>)\"\")\n//    |> SomeAttr\n\nlet style2pairs (ss:string) : (string * string) [] =\n    ss.Split(';') \n    |> Array.map   (fun s -> s.Split(':') ) \n    |> Array.filter(fun d -> d.Length = 2 )\n    |> Array.map   (fun d -> d.[0].Trim(), d.[1].Trim() )\n\nlet string2Styles = style2pairs >> Array.map (fun (n, v) -> Attr.Style n v |> SomeAttr)\n\n//let composeDoc elt dtl dtlVal = dtlVal |> Val.toView |> Doc.BindView (Seq.append dtl >> elt >> renderDoc) |> SomeDoc\n\nlet inline bindHElem hElemF v  = Val.map hElemF  (Val.fixit v) |> HtmlElementV\n\nlet createIFrame f =\n    let cover = Var.Create true\n    div [ style           \"position: relative; overflow: hidden; height: 100%; width: 100%;\" \n          iframe \n            [ style       \"position: absolute; width:100%; height:100%;\"\n              frameborder \"0\"\n              SomeAttr <| on.afterRender f\n              SomeAttr <| on.mouseLeave (fun _ _ -> cover.Value <- true)\n            ]\n          div \n            [ style       \"position: absolute;\"\n              classIf     \"iframe-cover\" (Val.map id cover)               \n              SomeAttr <| on.mouseEnter (fun _ _ -> Input.Mouse.MousePressed \n                                                    |> View.Get (fun pressed -> if not pressed then cover.Value <- false))\n            ]          \n          styleH [ htmlText \".iframe-cover { top:0; left:0; right:0; bottom:0; background: blue; opacity: 0.04; z-index: 2; }\" ]\n        ]\n\n[< Inline \"\"\"(!$v)\"\"\">]\nlet isUndefined v = v.GetType() = v.GetType()\n\nlet  findRootElement (e:Dom.Element) =\n    if isUndefined e.GetRootNode then JS.Document.Body\n    else\n        let root = e.GetRootNode()\n        if isUndefined root?body \n        then root.FirstChild :?> Dom.Element\n        else root?body  |> unbox<Dom.Element>\n","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"d9124644-0af6-4a7f-a711-ef76ca77f0de"}],"id":{"$":0,"Item":"c3755c07-1385-495d-bad7-a5b0fa54ac9b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"storeVar","content":"[< Inline >]\nlet inline storeVar<'T> storeName (var:Var<_>) =\n    JS.Window.LocalStorage.GetItem storeName |> fun v -> if v <> null then           var.Value <- Json.Deserialize<'T> v\n    Val.sink (fun v -> JS.Window.LocalStorage.SetItem (storeName, Json.Serialize v)) var\n\n","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"0f5719f0-e95e-498d-ab88-f89ff1440e32"}],"id":{"$":0,"Item":"336d6f19-0c57-4af9-8716-1b3fbf6b112c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"LoadFiles","content":"module LoadFiles =\n\n    [< Inline \"CIPHERSpaceLoadFiles($_files, $_cb)\" >]\n    let LoadFilesCb (_files: string []) (_cb: unit -> unit) : unit = X<_>\n    \n    let createScript fn =\n        let fileRef = JS.Document.CreateElement(\"script\")\n        fileRef.SetAttribute(\"type\", \"text/javascript\"  )\n        fileRef.SetAttribute(\"src\" , fn                 )\n        fileRef\n    \n    let createCss fn =\n        let fileRef = JS.Document.CreateElement(\"link\")\n        fileRef.SetAttribute(\"rel\" , \"stylesheet\"     )\n        fileRef.SetAttribute(\"type\", \"text/css\"       )\n        fileRef.SetAttribute(\"href\", fn               )\n        fileRef\n    \n    let createHtml fn =\n        let fileRef = JS.Document.CreateElement(\"link\")\n        fileRef.SetAttribute(\"rel\" , \"import\"         )\n        fileRef.SetAttribute(\"type\", \"text/html\"      )\n        fileRef.SetAttribute(\"href\", fn               )\n        fileRef\n    \n    [< Inline \"\"\"(!$v)\"\"\">]\n    let isUndefined v = v.GetType() = v.GetType()\n    \n    let LoadFile(file: string) =\n        let (|EndsWith|_|) s (fn:string) = if fn.EndsWith s then Some() else None\n        match file with\n        | EndsWith \".js\"   ()\n        | EndsWith \".fsx\"  ()\n        | EndsWith \".fs\"   () when isUndefined <| JS.Document.QuerySelector(\"script[src='\" + file + \"']\") ->\n                                createScript file |> Some\n        | EndsWith \".css\"  ()-> createCss    file |> Some\n        | EndsWith \".html\" ()-> createHtml   file |> Some\n        | _                  -> None\n        |> Option.map         (fun ref -> \n            Async.FromContinuations <| \n                fun (cont, econt, _ccont) -> \n                    try \n                        ref?onload <- cont\n                        JS.Document.Head.AppendChild ref |> ignore\n                    with e -> econt e\n        )\n        |> Option.defaultWith (fun ()  -> async { return () })\n    \n    let LoadFilesAsync(files: string []) =\n        async {\n            for file in files do\n                do! LoadFile file\n        }\n    \n    let LoadFilesAsyncOld (files: string []) =\n        Async.FromContinuations <| \n            fun (cont, econt, _ccont) -> \n                try \n                    LoadFilesCb files cont\n                with e -> econt e\n    \n    ","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"02d3bc50-4aa0-41ce-a37e-5b90a943481f"}],"id":{"$":0,"Item":"1f1aa135-fd74-42cc-b9a5-87f380c113a9"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"open HtmlNode","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"c3755c07-1385-495d-bad7-a5b0fa54ac9b"}],"id":{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Template","content":"[<JavaScript>]\nmodule Template      =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"11ecbe45-3d0c-4121-a8fd-7c126b96f4a3"}],"id":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableWebSharper":"1"}},{"name":"","content":"let container content = div <| [ ``class`` \"container\" ] @ content","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"8fb54777-3046-4aae-9282-33401a45c280"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Bootstrap","content":"type Bootstrap() =\n    member this.Render =\n        div [\n          script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js' type='text/javascript\"    ; ``type`` \"text/javascript\" ; charset \"UTF-8\"      ]\n          script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"   ; ``type`` \"text/javascript\" ; charset \"UTF-8\"      ]\n          link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" ; ``type`` \"text/css\"        ; rel     \"stylesheet\" ]\n          link   [ href \"/EPFileX/css/main.css\"                                                ; ``type`` \"text/css\"        ; rel     \"stylesheet\" ]\n         ]\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"40614ad6-3f81-468b-a4ff-034124b82ae1"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Button","content":"[<NoComparison ; NoEquality>]\ntype Button = {\n    _class  : Val<string>\n    _type   : Val<string>\n    style   : Val<string>\n    text    : Val<string>\n    onClick : Dom.Element -> Dom.MouseEvent -> unit\n    disabled: Val<bool>\n    id      : string\n} with\n  static member inline New txt = \n      { _class   = Val.fixit \"btn\" \n        _type    = Val.fixit \"button\" \n        style    = Val.fixit \"\"\n        text     = Val.fixit txt\n        onClick  = fun _ _ -> ()\n        disabled = Val.fixit false\n        id       = \"\"\n      }\n  member        this.Render     =         \n    button [ ``type``  <| this._type\n             ``class`` <| this._class\n             Id        <| this.id  \n             style     <| this.style\n             SomeAttr  <| attr.disabledDynPred (View.Const \"\") (this.disabled |> Val.toView)\n             SomeAttr  <| on.click <@ this.onClick @>\n             HtmlText  <| this.text \n           ] \n    |> renderDoc |> SomeDoc\n  member inline this.Id          id   = { this with id       = id             }\n  member inline this.Class       clas = { this with _class   = Val.fixit clas }\n  member inline this.Type        typ  = { this with _type    = Val.fixit typ  }\n  member inline this.Style       sty  = { this with style    = Val.fixit sty  }\n  member inline this.Text        txt  = { this with text     = Val.fixit txt  }\n  member inline this.Disabled    dis  = { this with disabled = Val.fixit dis  }\n  member inline this.OnClick     f    = { this with onClick  = f              }","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Input","content":"[<NoComparison ; NoEquality>]\ntype Input = {\n    _type       : Val<string>\n    _class      : Val<string>\n    style       : Val<string>\n    placeholder : Val<string>\n    id          : string\n    var         : Var<string>\n    prefix      : HtmlNode\n    suffix      : HtmlNode\n    content     : Attr seq\n    prefixAdded : bool\n    suffixAdded : bool\n    disabled    : Val<bool>\n} with\n  static member  New(var) = { _class      = Val.fixit \"form-control\" \n                              _type       = Val.fixit \"text\" \n                              style       = Val.fixit \"\" \n                              placeholder = Val.fixit \"Enter text:\"\n                              id          = \"\"\n                              content     = []\n                              prefix      = HtmlEmpty\n                              prefixAdded = false\n                              suffix      = HtmlEmpty\n                              suffixAdded = false\n                              var         = var   \n                              disabled    = Val.fixit false\n                            }\n  member        this.Render    =         \n    let groupClass det = match det with HtmlText _  -> \"input-group-addon\" | _ -> \"input-group-btn\"\n    div [\n        if this.prefixAdded || this.suffixAdded then\n            yield ``class`` \"input-group\"\n        if this.prefixAdded then\n            yield  span     [ ``class`` <| groupClass this.prefix \n                              this.prefix       ]\n        yield Doc.Input ([_type            this._type\n                          _class           this._class\n                          _style           this.style\n                          attr.id          this.id  \n                          attr.disabledDynPred (View.Const \"\") (this.disabled |> Val.toView)\n                          _placeholder     this.placeholder ] |> Seq.append this.content)\n                          this.var\n              :> Doc |> SomeDoc\n        if this.suffixAdded then\n            yield  span     [ ``class`` <| groupClass this.suffix \n                              this.suffix       ]\n      ]\n  member inline this.Class       clas = { this with _class      = Val.fixit clas                  }\n  member inline this.Type        typ  = { this with _type       = Val.fixit typ                   }\n  member inline this.Style       sty  = { this with style       = Val.fixit sty                   }\n  member inline this.Placeholder plc  = { this with placeholder = Val.fixit plc                   }\n  member inline this.Id          id   = { this with id          =       id                        }\n  member inline this.Content     c    = { this with content     =       c                         }\n  member inline this.Prefix      p    = { this with prefix      =       p    ; prefixAdded = true }\n  member inline this.Prefix      p    = this.Prefix(htmlText p)\n  member inline this.Suffix      s    = { this with suffix      =       s    ; suffixAdded = true }\n  member inline this.SetVar      v    = { this with var         = v                               }\n  member inline this.Disabled    dis  = { this with disabled    = Val.fixit dis                   }\n  member inline this.Var              = this.var\n  static member  New(v:string)              = Input.New(Var.Create v)\n  static member  New(v:Var<string option>) = Input.New(Var.Lens v (Option.defaultValue \"\") (fun sO s -> sO |> Option.map (fun _ -> s) )).Disabled(v |> Val.map Option.isNone)\n  ","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Hoverable","content":"[<NoComparison ; NoEquality>]\ntype Hoverable = {\n    hover      : Var<bool>\n} with\n  static member  New   = \n    let hover      = Var.Create false\n    { \n        hover      = hover     \n    }\n  member inline this.Content    (c: HtmlNode seq) = \n    [ classIf \"hovering\" this.hover\n      SomeAttr <| on.mouseEnter (fun _ _ -> this.hover.Value <- true )\n      SomeAttr <| on.mouseLeave (fun _ _ -> this.hover.Value <- false)\n    ] \n    |> Seq.append  c\n    |> div\n  member inline this.Content    (c:HtmlNode) = \n      c.AddChildren \n          [ classIf \"hovering\" this.hover\n            SomeAttr <| on.mouseEnter (fun _ _ -> this.hover.Value <- true )\n            SomeAttr <| on.mouseLeave (fun _ _ -> this.hover.Value <- false)\n          ] \n  static member  Demo  = Hoverable.New.Content(div [ style \"flex-flow: column;\" ])\n  \nlet hoverable (c:HtmlNode) = Hoverable.New.Content c\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Panel","content":"[<NoComparison ; NoEquality>]\ntype Panel = {\n    _class   : Val<string>\n    _style   : Val<string>\n    title    : Val<string>\n    header   : HtmlNode seq\n    content  : HtmlNode seq\n    disabled : Val<bool>\n} with\n  static member  New   = { _class   = Val.fixit <| \"panel panel-default shadow\"\n                           _style   = Val.fixit <| \"text-align:center\" \n                           title    = Val.fixit <| \"Panel\"        \n                           header   =          [ htmlText \"Some text\"    ] \n                           content  =          [ htmlText \"Some Content\" ] \n                           disabled = Val.fixit <| Var.Create false\n                         }\n  member        this.Render          =  \n    fieldset [ SomeAttr <| attr.disabledDynPred (View.Const \"\")  (this.disabled |> Val.toView)\n               div [ ``class`` this._class\n                     div (Seq.append\n                              [ ``class`` \"panel-heading\"\n                                label [ ``class``  \"panel-title text-center\" ; htmlText this.title ]\n                              ]\n                              this.header)\n\n                     div (Seq.append\n                              [ ``class`` \"panel-body\"\n                                style     this._style \n                              ]\n                              this.content)\n                   ] \n             ]\n  member inline this.Class       clas = { this with _class   = Val.fixit clas }\n  member inline this.Style       sty  = { this with _style   = Val.fixit sty  }\n  member inline this.Title       txt  = { this with title    = Val.fixit txt  }\n  member inline this.Header      h    = { this with header   =       h        }\n  member inline this.Content     c    = { this with content  =       c        }\n  member inline this.Disabled    dis  = { this with disabled =       dis      }\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"}],"id":{"$":0,"Item":"0a11766b-f227-4b38-88a3-919d964387bf"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"TextArea","content":"[<NoComparison ; NoEquality>]\ntype TextArea = {\n    _class      : Val<string>\n    placeholder : Val<string>\n    title       : Val<string>\n    spellcheck  : Val<bool>\n    id          : string\n    var         : Var<string>\n    disabled    : Val<bool>\n} with\n  static member  New(var) = { _class      = Val.fixit \"form-control\"\n                              placeholder = Val.fixit \"Enter text:\"\n                              title       = Val.fixit \"\"\n                              spellcheck  = Val.fixit false\n                              id          = \"\"\n                              var         = var \n                              disabled    = Val.fixit false\n                            }\n  member        this.RenderWith  more  =    \n    htmlElementF (fun att _ch -> Doc.InputArea att this.var :> Doc)\n        ([ \n          ``class``           this._class\n          Id                  this.id  \n          spellcheck       <| Val.map (fun spl -> if spl then \"true\" else \"false\") this.spellcheck\n          title               this.title\n          style               \"height: 100%;  width: 100%; box-sizing: border-box; \"\n          placeholder         this.placeholder \n          SomeAttr         <| attr.disabledDynPred (View.Const \"\") (this.disabled |> Val.toView)\n        ] @ more)\n    |> Seq.singleton \n    //|> Seq.append [ style \"height: 100%;  width: 100%; box-sizing: border-box; \" ] \n    |> div\n  member        this.Render           = this.RenderWith []    \n  member inline this.Class       clas = { this with _class      = Val.fixit clas }\n  member inline this.Placeholder plc  = { this with placeholder = Val.fixit plc  }\n  member inline this.Title       ttl  = { this with title       = Val.fixit ttl  }\n  member inline this.Spellcheck  spl  = { this with spellcheck  = spl            }\n  member inline this.Id          id   = { this with id          = id             }\n  member inline this.SetVar      v    = { this with var         = v              }\n  member inline this.Disabled    dis  = { this with disabled    = Val.fixit dis  }\n  member inline this.Var              = this.var\n  static member  New(v:string)              = TextArea.New(Var.Create v)\n  static member  New(v:Var<string option>) = TextArea.New(Var.Lens v (Option.defaultValue \"\") (fun sO s -> sO |> Option.map (fun _ -> s) )).Disabled(v |> Val.map Option.isNone)\n  ","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"codeMirrorIncludes","content":"let codeMirrorIncludes =\n   [| \"/EPFileX/codemirror/scripts/codemirror/codemirror.js\"             \n      \"/EPFileX/codemirror/scripts/intellisense.js\"                      \n      \"/EPFileX/codemirror/scripts/codemirror/codemirror-intellisense.js\"\n      \"/EPFileX/codemirror/scripts/codemirror/codemirror-compiler.js\"    \n      \"/EPFileX/codemirror/scripts/codemirror/mode/none.js\"            \n      \"/EPFileX/codemirror/scripts/codemirror/mode/fsharp.js\"            \n      \"/EPFileX/codemirror/scripts/codemirror/mode/css.js\"            \n      \"/EPFileX/codemirror/scripts/codemirror/mode/javascript.js\"            \n      \"/EPFileX/codemirror/scripts/codemirror/mode/markdown.js\"            \n      \"/EPFileX/codemirror/scripts/addon/search/searchcursor.js\"          \n      \"/EPFileX/codemirror/scripts/addon/search/search.js\"          \n      \"/EPFileX/codemirror/scripts/addon/search/jump-to-line.js\"          \n      \"/EPFileX/codemirror/scripts/addon/dialog/dialog.js\"          \n      \"/EPFileX/codemirror/scripts/addon/edit/matchbrackets.js\"          \n      \"/EPFileX/codemirror/scripts/addon/selection/active-line.js\"       \n      \"/EPFileX/codemirror/scripts/addon/display/fullscreen.js\"          \n      \"/EPFileX/codemirror/scripts/addon/hint/show-hint.js\"          \n      \"/EPFileX/codemirror/scripts/addon/lint/lint.js\"          \n   |]","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"4180353c-9dc5-438d-862d-851539b02075"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CodeMirror","content":"type CodeMirrorPos = { line: int ; ch  : int }\nlet inline cmPos(l, c) = { line = l ; ch  = c }\n\ntype CodeMirrorEditor() =\n    let _a = 1\n  with\n    [< Inline \"CodeMirror($_elt, {\n\t    theme        : 'rubyblue'\n\t  , lineNumbers  : true\n\t  , matchBrackets: true\n      , gutters      : ['CodeMirror-lint-markers']\n      , extraKeys    : {\n\t\t    Tab  : function (cm) { cm.replaceSelection('    ', 'end'); }\n\t\t  , 'F11': function (cm) { cm.setOption('fullScreen', !cm.getOption('fullScreen')); }\n        }\n})\"    >]\n//    [< Inline \"setupEditor($_elt)\" >]\n    static member SetupEditor _elt                                    : CodeMirrorEditor = X<_>\n    [< Inline \"$this.getValue()\"              >]      \n    member this.GetValue()                                            : string           = X<_>\n    [< Inline \"$this.setValue($_v)\"           >]      \n    member this.SetValue(_v:string)                                   : unit             = X<_>\n    [< Inline \"$this.refresh()\"               >]      \n    member this.Refresh()                                             : unit             = X<_>\n    [< Inline \"$this.setOption($_o, $_v)\"     >]      \n    member this.SetOption(_o:string, _v:obj)                          : unit             = X<_>\n    [< Inline \"$this.getCursor()\"             >]      \n    member this.GetCursor()                                           : CodeMirrorPos    = X<_>\n    [< Inline \"$this.setCursor($_line, $_col)\">]      \n    member this.SetCursor(_line:int, _col:int)                        : unit             = X<_>\n    [< Inline \"$this.focus()\"                 >]      \n    member this.Focus()                                               : unit             = X<_>\n    [< Inline \"$this.getLine($_l)\"            >]      \n    member this.GetLine(_l:int)                                       : string           = X<_>\n    [< Inline \"$this.getDoc().markText({line:$_fl, ch:$_fc}, {line:$_tl, ch:$_tc}, {className: $_className, title: $_title})\" >]\n    member this.MarkText (_fl:int,_fc:int) (_tl:int,_tc:int) (_className: string) (_title: string): unit       = X<_>\n    [< Inline \"while($this.getAllMarks().length > 0) { $this.getAllMarks()[0].clear() }\" >]\n    member this.RemoveMarks() : unit       = X<_>\n    [< Inline \"$this.getDoc().clearHistory()\" >]\n    member this.ClearHistory()                                        : unit             = X<_>\n    [< Inline \"$this.on($_event, $_f)\"        >]\n    member this.On(_event: string, _f:(CodeMirrorEditor * obj)->unit) : unit             = X<_>\n    [< Inline \"$this.addKeyMap($_keyMap)\"     >]\n    member this.AddKeyMap(_keyMap: obj)                               : unit             = X<_>\n    [< Inline \"$this.getWrapperElement()\"     >]\n    member this.GetWrapperElement()                                   : Dom.Element      = X<_>\n    [< Inline \"$this.replaceSelection($_v, $_s)\">]\n    member this.ReplaceSelection(_v:string, _s:string)                                    = ()\n\n[<NoComparison ; NoEquality>]\ntype CodeMirror = {\n    _class          : Val<string>\n    style           : Val<string>\n    id              : string\n    var             : Var<string>\n    onChange        : (unit             -> unit)\n    onRender        : (CodeMirrorEditor -> unit) option\n    mutable editorO : CodeMirrorEditor option\n    disabled        : Val<bool>\n} with\n\n  static member  New(var) = \n      { _class   = Val.fixit \"\" \n        style    = Val.fixit \"\" \n        id       = \"\"\n        var      = var \n        onChange = ignore\n        onRender = None\n        editorO  = None\n        disabled = Val.fixit false\n      }\n  member        this.Render                 =\n    div [ \n          ``class``            this._class\n          SomeAttr <| attr.id  this.id \n          style \"position: relative; height: 300px\"\n          style                this.style\n          div [\n                style \"height: 100%; width: 100%; position: absolute;\"\n                SomeAttr <| on.afterRender (fun el ->\n                   async {\n                       do! LoadFiles.LoadFilesAsync codeMirrorIncludes\n                       let editor        = CodeMirrorEditor.SetupEditor el\n                       this.editorO     <- Some editor\n                       this.onRender |> Option.iter (fun onrender -> onrender editor)\n                       let editorChanged = ref 0L\n                       let varChanged    = ref 0L\n                       editor.On(\"changes\", fun (_cm, _change) ->\n                           let v = editor.GetValue() \n                           if this.var.Value <> v then editorChanged := !editorChanged + 1L; this.var.Value <- v; this.onChange() \n                       )\n                       this.var.View |> View.Sink (fun _ ->\n                           if  !editorChanged      > !varChanged    then varChanged := !editorChanged\n                           elif editor.GetValue() <> this.var.Value then editor.SetValue this.var.Value ; editor.ClearHistory()\n                       )\n                       this.disabled |> Val.sink (fun dis -> editor.SetOption(\"readOnly\", if dis then \"nocursor\" :> obj else false :> obj) )\n                   } |> Async.Start\n                )    \n              ]\n          link [ href \"/EPFileX/codemirror/content/editor.css\"                   ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/content/codemirror.css\"               ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/display/fullscreen.css\" ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/dialog/dialog.css\"      ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/hint/show-hint.css\"     ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/lint/lint.css\"          ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          css  \".CodeMirror { height: 100% }\"\n     ]\n  member inline this.Class    clas = { this with _class    = Val.fixit clas }\n  member inline this.Id       id   = { this with id        =       id       }\n  member inline this.SetVar   v    = { this with var       = v              }\n  member inline this.Style    sty  = { this with style     = Val.fixit sty  }\n  member inline this.OnChange f    = { this with onChange  = f              }\n  member inline this.OnRender f    = { this with onRender  = Some f         }\n  member inline this.Disabled dis  = { this with disabled  = Val.fixit dis  }\n  member inline this.Var           = this.var\n  static member  New(v:string)             = CodeMirror.New(Var.Create v)\n  static member  New(v:Var<string option>) = CodeMirror.New(Var.Lens v (Option.defaultValue \"\") (fun sO s -> sO |> Option.map (fun _ -> s) )).Disabled(v |> Val.map Option.isNone)\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"1f1aa135-fd74-42cc-b9a5-87f380c113a9"},{"$":0,"Item":"4180353c-9dc5-438d-862d-851539b02075"}],"id":{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CodeMirror Hints","content":"\ntype Hint = {\n    text        : string\n    displayText : string\n    className   : string\n}\n\ntype HintResponse  = {\n    list           : Hint []\n    from           : CodeMirrorPos   \n    ``to``         : CodeMirrorPos   \n}\n\ntype HintFunc      = FuncWithArgs<CodeMirrorEditor * (HintResponse -> unit) * obj,  unit>\n\ntype HintOptions   = {\n    hint           : HintFunc\n    completeSingle : bool   \n    container      : Dom.Element\n}\n\n[< Inline \"($_v.hint.async = 1, $_ed.showHint($_v))\"          >]\nlet showHint_ (_ed:CodeMirrorEditor) _v : unit       = X<_>\nlet showHints (ed:CodeMirrorEditor) getHints completeSingle _ =\n    showHint_ ed\n        {  completeSingle = completeSingle\n           hint           = HintFunc getHints\n           container      = ed.GetWrapperElement() |> findRootElement\n        }\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"id":{"$":0,"Item":"a05dd36e-a15e-4394-8013-128e21e69574"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CodeMirror Lint","content":"type LintResponse  = {\n    message        : string\n    severity       : string\n    from           : CodeMirrorPos   \n    ``to``         : CodeMirrorPos   \n}\n\ntype LintFunc      = FuncWithArgs<string * (LintResponse[] -> unit) * obj * CodeMirrorEditor,  unit>\n\n[< Inline \"($_ed.setOption('lint', { async: 1, getAnnotations: $_f, container: $_elm }))\"          >]\nlet setLint_(_ed:CodeMirrorEditor) (_f:LintFunc) (_elm:Dom.Element)  : unit = X<_>\nlet setLint (ed:CodeMirrorEditor) getAnnotations       = \n    setLint_ ed (LintFunc getAnnotations) (ed.GetWrapperElement() |> findRootElement)\n\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"id":{"$":0,"Item":"18d8153d-422c-42f6-8266-9a9d854bd6a1"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"SplitterBar","content":"[<NoComparison ; NoEquality>]\ntype HtmlMeasure =\n| Percentage of Val<float>\n| Pixel      of Val<float>\n\n[<NoComparison ; NoEquality>]\ntype SplitterBar = {\n    value            : Var<float>\n    min              : Val<float>\n    max              : Val<float>\n    vertical         : Val<bool>\n    node             : HtmlNode\n    children         : HtmlNode seq\n    after            : bool\n    mutable dragging : bool\n    mutable startVer : bool \n    mutable startP   : float \n    mutable start    : float \n    mutable size     : float \n    mutable domElem  : Dom.Element option\n}\nwith\n    static member New(var) = \n        {\n            value    = var\n            min      = Val.fixit   5.0\n            max      = Val.fixit  95.0\n            vertical = Val.fixit  true  \n            node     = div [ ``class`` \"Splitter\" ]\n            children = []\n            after    = true\n            dragging = false\n            startVer = true\n            startP   = 0.0\n            start    = 0.0\n            size     = 0.0\n            domElem  = None\n        }\n    static member New(value)    = SplitterBar.New(Var.Create value)\n    member        this.Var      = this.value\n    member        this.GetValue = this.value |> Val.map2 max this.min |> Val.map2 min this.max\n    member        this.Render   =\n        let mouseCoord (ev: Dom.MouseEvent) = if this.startVer then float ev.ClientX else float ev.ClientY\n        let size () : float =\n            match this.domElem with\n            | None    -> 100.0\n            | Some el -> \n             el.ParentElement.GetBoundingClientRect() \n             |> fun r -> \n                 match this.startVer, this.after with\n                 | true , true  ->  r.Width  \n                 | true , false -> -r.Width \n                 | false, true  ->  r.Height\n                 | false, false -> -r.Height\n        let drag (ev: Dom.Event) =\n            ev :?> Dom.MouseEvent\n            |> mouseCoord\n            |> fun m   -> (m - this.start) * 100.0 / this.size + this.startP\n            |> fun v   -> this.value.Value <- v // ; JS.Inline(\"console.log($0)\", this)\n           \n        let rec finishDragging (_: Dom.Event) =\n            if this.dragging then\n                this.dragging <- false\n                JS.Window.RemoveEventListener(\"mousemove\", drag          , false) \n                JS.Window.RemoveEventListener(\"mouseup\"  , finishDragging, false) \n                //printfn \"mouseup\"\n        let startDragging (_: Dom.Element) (ev: Dom.MouseEvent) =\n            if not this.dragging then\n                Val.map2 (fun startP dirV ->\n                    this.dragging <- true\n                    this.startVer <- dirV\n                    this.startP   <- startP\n                    this.start    <- mouseCoord ev\n                    this.size     <- size()\n                    JS.Window.AddEventListener(\"mousemove\", drag          , false) \n                    JS.Window.AddEventListener(\"mouseup\"  , finishDragging, false) \n                    ev.PreventDefault()\n                ) this.GetValue this.vertical\n                |> Val.iter id\n        this.node\n          .AddChildren(\n          [\n            ``class`` <| Val.map (fun ver -> if ver then \"Vertical\" else \"Horizontal\") this.vertical \n            SomeAttr  <| on.mouseDown startDragging\n            SomeAttr  <| on.afterRender (fun el -> this.domElem <- Some el)\n            css \"\n                .Splitter.Vertical   { cursor: col-resize; background-color: #eef ; width : 5px ; margin-left:-7px; }\n                .Splitter.Horizontal { cursor: row-resize; background-color: #eef ; height: 5px ; margin-top :-7px; }\n            \"\n          ])\n          .AddChildren this.children\n    member inline this.Value       v =   this.value.Value <- v  ; this\n    member inline this.Node     node = { this with node         = node                        }\n    member inline this.Min         v = { this with min          = Val.fixit v                 }\n    member inline this.Max         v = { this with max          = Val.fixit v                 }\n    member inline this.Vertical    v = { this with vertical     = Val.fixit v                 }\n    member inline this.Horizontal  v = { this with vertical     = Val.fixit v |> Val.map not  }\n    member inline this.Vertical   () = { this with vertical     = Val.fixit true              }\n    member inline this.Horizontal () = { this with vertical     = Val.fixit false             }\n    member inline this.Before        = { this with after        =           false             }\n    member inline this.After         = { this with after        =           true              }\n    member inline this.Children   ch = { this with children     = ch                          }\n    ","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"ResizeObserver","content":"[< Inline \"try { return !!(ResizeObserver) } catch(e) { return false }\" >] \nlet implementedResizeObserver() = false\n\n[< Inline \"new ResizeObserver($_f)\" >]\nlet newResizeObserver (_f: unit->unit) = X<_> \n\n[< Inline \"$_ro.observe($_el)\" >]\nlet RObserve _ro (_el:Dom.Element) = X<_> \n\nlet mutable observers : obj list = []\n\nlet domRect2Tuple (r:Dom.DomRect) = (r.Top, r.Left, r.Width, r.Height)\n\nlet [< Inline \"$_el.isConnected\" >] isValidElement (_el:Dom.Element) = true\n\nlet dimsChanged (el:Dom.Element) = \n    let dims = ref <| el.GetBoundingClientRect()\n    fun () ->\n        let ndims = el.GetBoundingClientRect()\n        if domRect2Tuple !dims = domRect2Tuple ndims then false\n        else dims := ndims    ; true\n\nlet addResizeObserver f el =\n    if implementedResizeObserver() then\n        let ro =  newResizeObserver f\n        observers <- ro::observers\n        RObserve ro el\n    else\n        let changed = dimsChanged el\n        async {\n            while isValidElement el do\n                do! Async.Sleep 110\n                if changed() then f()\n        } |> Async.Start\n        ","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"5878287a-a18f-4c71-b086-bd6e146270a1"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableWebSharper":"1"}},{"name":"Grid","content":"[<NoComparison ; NoEquality>]\ntype Area =\n| Auto     of SplitterBar\n| Fixed    of HtmlMeasure\n| Splitter of SplitterBar\n\ntype SectionType =\n| StVariable\n| StFixedPx\n| StFixedPerc\n\nlet setVar (vr:Var<_>) vl = if vr.Value <> vl then vr.Value <- vl \n\n[<NoComparison ; NoEquality>]\ntype Grid = {\n    padding       : float\n    gap           : float\n    content       : (string option * HtmlNode) []\n    cols          : Area []\n    rows          : Area []\n    widthHeight   : Var<float * float>\n    lastSplitter  : (int * bool) option\n}\nwith\n    static member New = {\n       padding       = 9.0\n       gap           = 9.0\n       cols          = [| |]\n       rows          = [| |]\n       content       = [| |]\n       widthHeight   = Var.Create (1000.0, 100.0)\n       lastSplitter  = None\n    }\n    member this.NewSplitter  (f: Var<float>, col) =\n        let spl = SplitterBar.New(f)\n        if col then\n            { this with lastSplitter = Some (this.cols.Length, col) ; cols = Array.append this.cols  [| spl              |> Splitter |] }\n        else \n            { this with lastSplitter = Some (this.rows.Length, col) ; rows = Array.append this.rows  [| spl.Horizontal() |> Splitter |] }\n    member this.NewSplitter        (f: float, col) = this.NewSplitter(Var.Create f, col)\n    member inline this.ColFixedPx   f              = { this with cols    = Array.append this.cols    [| Pixel     (Val.fixit f)              |> Fixed    |] }\n    member inline this.ColFixed     f              = { this with cols    = Array.append this.cols    [| Percentage(Val.fixit f)              |> Fixed    |] }\n    member inline this.ColVariable (s:SplitterBar) = { this with cols    = Array.append this.cols    [| s                                    |> Splitter |] }\n    member inline this.ColVariable (f:float)       = this.NewSplitter(f, true)\n    member inline this.ColVariable (f:Var<float>)  = this.NewSplitter(f, true)\n    member inline this.ColAuto     (f:float)       = { this with cols    = Array.append this.cols    [| SplitterBar.New(     f)              |> Auto     |] }\n    member inline this.RowFixedPx   f              = { this with rows    = Array.append this.rows    [| Pixel     (Val.fixit f)              |> Fixed    |] }\n    member inline this.RowFixed     f              = { this with rows    = Array.append this.rows    [| Percentage(Val.fixit f)              |> Fixed    |] }\n    member inline this.RowVariable (s:SplitterBar) = { this with rows    = Array.append this.rows    [| s                                    |> Splitter |] }\n    member inline this.RowVariable (f:float)       = this.NewSplitter(f, false)\n    member inline this.RowVariable (f:Var<float>)  = this.NewSplitter(f, false)\n    member inline this.RowAuto     (f:float)       = { this with rows    = Array.append this.rows    [| SplitterBar.New(     f).Horizontal() |> Auto     |] }\n    member        this.Content (area, html)        = { this with content = Array.append this.content [| Some area, html                                  |] }\n    member        this.Content        html         = { this with content = Array.append this.content [| None     , html                                  |] }\n    member inline this.Padding      f              = { this with padding = f                                                                                }\n    member inline this.Gap          f              = { this with gap     = f                                                                                }\n    member this.changeSplitter f =\n        this.lastSplitter\n        |> Option.iter (fun (pos, col) ->\n            if col then\n                match this.cols.[pos] with\n                | Splitter spl -> this.cols.[pos] <- Splitter <| f spl \n                | _            -> ()\n            else \n                match this.rows.[pos] with\n                | Splitter spl -> this.rows.[pos] <- Splitter <| f spl \n                | _            -> ()\n        )\n        this\n    member        this.Before                = this.changeSplitter (fun spl -> spl.Before     )\n    member inline this.Max                 v = this.changeSplitter (fun spl -> spl.Max       v)\n    member inline this.Min                 v = this.changeSplitter (fun spl -> spl.Min       v)\n    member inline this.Children           ch = this.changeSplitter (fun spl -> spl.Children ch)\n    member this.style    (areas:Area[]) size =\n        if areas.Length = 0 then Val.Constant \"100%\" else\n        let pcs, pxs = \n            areas \n            |> Seq.fold (fun (pcs, pxs) a ->\n                match a with\n                | Auto             _spl -> (                          pcs,                pxs)          \n                | Splitter          spl -> (Val.map2 (+) spl.GetValue pcs,                pxs) \n                | Fixed (Percentage v)  -> (Val.map2 (+) v            pcs,                pxs)\n                | Fixed (Pixel      v)  -> (                          pcs, Val.map2 (+) v pxs)\n            ) (Val.Constant 0.0, Val.Constant 0.0)\n        let finalPerc = Val.map2 (fun v size -> (size - this.padding * 2. - this.gap * ((float areas.Length) - 1.) - v) / (size - this.padding * 2.)) pxs size\n        let autoPct   = Val.map  ((-) 100.0)  pcs \n        let perc   pc = Val.map2 (fun finalPerc pc -> finalPerc * pc |> max 0.0 |> sprintf \"%f%%\") finalPerc pc\n        let pixel  px = Val.map  (fun           px ->             px |> max 0.0 |> sprintf \"%fpx\")           px\n        areas\n        |> Seq.foldBack (fun a state ->\n            match a with\n            |  Auto             _spl -> perc  autoPct          \n            |  Splitter          spl -> perc  spl.GetValue\n            |  Fixed (Percentage v)  -> perc  v\n            |  Fixed (Pixel      v)  -> pixel v\n            |> Val.map2(fun state v -> v::state) state\n           )  <| (Val.Constant [])\n        |> Val.map (String.concat \" \")\n    member this.styles() =\n        [ style1 \"grid-template-columns\" <| this.style this.cols (Val.map fst this.widthHeight)\n          style1 \"grid-template-rows\"    <| this.style this.rows (Val.map snd this.widthHeight)\n        ]\n    member this.GridTemplate() =\n        [ \n            yield!\n                this.content\n                |> Seq.map (fun (area, html) ->\n                    match area with\n                    | None   -> html\n                    | Some a -> html.AddChildren([ style <| sprintf \"grid-area: %s; dispxlay: grid\" a ])\n                   )\n            yield!\n                this.cols\n                |> Seq.indexed\n                |> Seq.choose (function\n                    |_i, Auto    _spl -> None           \n                    | i, Splitter spl -> Some <| spl.Render.InsertChildren( \n                                            [ style1 \"grid-column\" (string (i + if spl.after then 2 else 1))\n                                              style1 \"grid-row\"    (sprintf \"1 / %d\" (this.rows.Length + 1)) ] ) \n                    |_i, Fixed    _   -> None\n               )\n            yield!\n                this.rows\n                |> Seq.indexed\n                |> Seq.choose (function\n                    |_i, Auto    _spl -> None           \n                    | i, Splitter spl -> Some <| spl.Render.InsertChildren( \n                                            [ style1 \"grid-row\"    (string (i + if spl.after then 2 else 1))\n                                              style1 \"grid-column\" (sprintf \"1 / %d\" (this.cols.Length + 1)) ] ) \n                    |_i, Fixed    _   -> None\n               )\n            yield! this.styles() \n            yield style    <| sprintf \"display: grid; grid-gap: %fpx; padding: %fpx; box-sizing: border-box\" this.gap this.padding \n            yield SomeAttr <| on.afterRender(fun el   -> \n                let setDimensions () =\n                    el.GetBoundingClientRect()\n                    |> fun r -> setVar this.widthHeight (r.Width, r.Height)\n                //async {\n//                    do! Async.Sleep 60\n                do  setDimensions()\n                //} |> Async.Start\n                addResizeObserver setDimensions el\n              ) \n        ]\n    member this.Render =\n        div <| this.GridTemplate()\n    static member inline NewBisect(first, secT, ver, per:Var<float>, ch1, ch2) =\n        let sect, auto, areas = \n            if ver then match secT with\n                        | StVariable  -> fun (g:Grid) -> g.ColVariable per\n                        | StFixedPx   -> fun (g:Grid) -> g.ColFixedPx  per\n                        | StFixedPerc -> fun (g:Grid) -> g.ColFixed    per\n                       ,                (fun (g:Grid) -> g.ColAuto 50.0)\n                       ,                 fun (g:Grid) -> g.Content( style \"grid-template-areas: 'one   two' \" )\n                   else match secT with\n                        | StVariable  -> fun (g:Grid) -> g.RowVariable per\n                        | StFixedPx   -> fun (g:Grid) -> g.RowFixedPx  per\n                        | StFixedPerc -> fun (g:Grid) -> g.RowFixed    per\n                       ,                (fun (g:Grid) -> g.RowAuto 50.0)\n                       ,                 fun (g:Grid) -> g.Content( style \"grid-template-areas: 'one' 'two' \" )\n        Grid.New.Content(\"one\", ch1)\n                .Content(\"two\", ch2).Padding(0.0)\n        |> areas\n        |> (if first then sect >> auto\n                     else auto >> sect)\n        ","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"5878287a-a18f-4c71-b086-bd6e146270a1"},{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"id":{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"TabStrip","content":"let reorderList (ts:'a list) drag drop =\n    if drop < drag then\n       ts.[0       ..drop - 1     ]\n     @    [      ts.[drag]        ]\n     @ ts.[drop    ..drag - 1     ]\n     @ ts.[drag + 1..ts.Length - 1]\n    else\n       ts.[0..drag - 1            ]\n     @ ts.[drag + 1..drop         ]\n     @    [      ts.[drag]        ]\n     @ ts.[drop + 1..ts.Length - 1]\n\nlet reorderArray (ts:'a []) drag drop =\n   (if drop < drag then\n      [|\n       ts.[0       ..drop - 1     ]\n       [|        ts.[drag]       |]\n       ts.[drop    ..drag - 1     ]\n       ts.[drag + 1..ts.Length - 1]\n      |]\n    else\n      [|\n       ts.[0..drag - 1            ]\n       ts.[drag + 1..drop         ]\n       [|        ts.[drag]       |]\n       ts.[drop + 1..ts.Length - 1]\n      |]\n   )|> Array.collect id \n\n\n[< NoComparison >]\ntype TabStrip =\n    { selected  : Var<int>\n      tabs      : Var<(System.Guid * (string * HtmlNode)) []>\n      top       : bool\n      horizontal: bool\n      id        : System.Guid\n    } \n\nlet draggedTab: (TabStrip * int) option ref = ref None\n\nlet uid2s (uid: System.Guid) = \"X\" + uid.ToString().Replace(\"-\", \"\")\n\nlet selectedPanels: Var<Map<System.Guid, System.Guid>> = Var.Create Map.empty \n\nlet setSelectedPanel group panelO = \n    selectedPanels.Value <- \n        match panelO with\n        | Some panel -> selectedPanels.Value.Add    (group, panel)\n        | None       -> selectedPanels.Value.Remove  group\n\nlet mutable TabMoved : ((TabStrip * TabStrip) -> unit) option = None\nlet RaiseTabMoved fromS toS = TabMoved |> Option.iter (fun f -> f (fromS, toS))\n\ntype TabStrip with\n    member this.moveTab from drag drop =\n        let ts = this.tabs.Value\n        let ft = from.tabs.Value\n        let newTabsT =\n            [|\n             ts.[0       ..drop - 1     ]\n             [|        ft.[drag]       |]\n             ts.[drop    ..ts.Length - 1]\n            |]\n            |> Array.collect id\n        let newTabsF =\n            [|\n             ft.[0       ..drag - 1     ]\n             ft.[drag + 1..ft.Length - 1]\n            |]\n            |> Array.collect id\n        from.tabs.Value     <- newTabsF\n        this.tabs.Value     <- newTabsT\n        this.selected.Value <- drop\n        if from.selected.Value >= newTabsF.Length then from.selected.Value <- 0\n        RaiseTabMoved from this\n\n    member this.reorder drop =\n        match !draggedTab with\n        | None                                      -> ()\n        | Some( from, drag) when from.id <> this.id -> this.moveTab from drag drop\n        | Some(_from, drag)                         ->\n        this.tabs.Value     <- reorderArray this.tabs.Value drag drop\n        let sel = this.selected.Value\n        this.selected.Value <- if    sel = drag                then drop\n                               elif (sel < drag && sel < drop)\n                                 || (sel > drag && sel > drop) then sel \n                               elif  sel < drag                then sel + 1\n                               else                                 sel - 1\n                               \n    static member New(tabs)    =\n        { selected   = Var.Create 0\n          tabs       = tabs \n          top        = false \n          horizontal = true\n          id         = System.Guid.NewGuid() \n        } \n    static member New(tabs) = TabStrip.New(tabs |> Seq.map (fun def -> System.Guid.NewGuid(), def) |> Seq.toArray |> Var.Create)\n    member this.Top         = { this with top        = true  }\n    member this.Bottom      = { this with top        = false }\n    member this.SetTop    t = { this with top        = t     }\n    member this.Horizontal  = { this with horizontal = true  }\n    member this.Vertical    = { this with horizontal = false }\n    member this.Selected    = Val.map2 (fun tabs sel -> tabs |> Seq.tryItem sel |> Option.map fst) this.tabs this.selected\n    member this.Select    n = this.selected.Value <- n\n    member this.Select   nm = this.tabs.Value |> Seq.indexed |> Seq.tryPick (fun (i, (_ , (tn, _))) -> if tn = nm then this.selected.Value <- i ; Some true else None) |> Option.defaultValue false\n    member this.Select   gi = this.tabs.Value |> Seq.indexed |> Seq.tryPick (fun (i, (ti, (_ , _))) -> if ti = gi then this.selected.Value <- i ; Some true else None) |> Option.defaultValue false\n    member this.Render      =\n        let strip =\n            this.tabs\n            |> bindHElem (\n                fun tabs ->\n                    div [ yield ``class`` <| sprintf \"tab-strip %s %s\"\n                                                (if this.top        then \"top\"        else \"bottom\"  ) \n                                                (if this.horizontal then \"horizontal\" else \"vertical\")\n                          \n                          for i, (_uid, (txt, _)) in  tabs |> Seq.indexed  do\n                              yield Hoverable.New.Content(\n                                    div [ htmlText txt\n                                          ``class`` <| Val.map (fun sel -> \"tab\" + (if sel = i then \" selected\" else \"\")) this.selected\n                                          draggable \"true\"\n                                          SomeAttr <| on.dragOver(fun _  ev -> ev.PreventDefault()                            )\n                                          SomeAttr <| on.drag    (fun _  _  ->                     draggedTab := Some(this, i))\n                                          SomeAttr <| on.drop    (fun _e ev -> ev.PreventDefault(); ev.StopPropagation() ; this.reorder i )\n                                          SomeAttr <| on.click   (fun _  _  ->                       this.selected.Value <- i ) \n                                        ])\n                        ]\n            )\n        Val.sink (setSelectedPanel this.id) this.Selected  \n        let content = \n            this.tabs\n            |> bindHElem (fun tabs ->\n                div [\n                  yield  ``class`` \"tab-children\"\n                  yield  Id <| uid2s this.id\n                  yield!\n                      tabs\n                      |> Seq.map (fun (uid, (_txt, sub)) -> \n                          sub.AddChildren(\n                            [ style <| Val.map (fun sels -> if sels |> Map.toSeq |> Seq.map snd |> Seq.contains uid then \"\" else \"display : none\") selectedPanels\n                              Id    <| uid2s uid\n                            ]))\n                ] \n             )\n        div [ ``class`` \"tab-panel\"\n              (if     this.top then strip else HtmlEmpty)\n              div [ content ; ``class`` \"tab-content\" ]\n              (if not this.top then strip else HtmlEmpty)\n              SomeAttr <| on.dragOver(fun _  ev -> ev.PreventDefault()                                      )\n              SomeAttr <| on.drop    (fun _e ev -> ev.PreventDefault() ; this.reorder this.tabs.Value.Length)\n              css @\"\n\n.tab-panel {\n overflow  : hidden   ;\n display   : flex     ;\n flex-flow : column   ;\n background: lightgray;\n}\n.tab-content {\n flex      : 1 1     ;\n overflow  : auto    ;\n position  : relative;\n}\n.tab-children {\n height    : 100%    ;\n width     : 100%    ;\n position  : absolute;\n display   : grid    ;\n}\n.tab-strip {\n padding   : 0pt     ;\n flex      : 0 0     ;\n}\n.tab {\n border     : 0.2pt solid transparent;\n padding    : 0pt 4pt;\n display    : inline-block;\n font-family: sans-serif;\n font-weight: 200;\n font-size  : small;\n color      : #666;\n cursor     : pointer;\n}\n.top>.tab {\n border-radius: 2pt 2pt 0pt 0pt;\n border-bottom-width: 0pt;\n vertical-align: bottom;\n}\n.bottom>.tab {\n border-top-width: 0pt;\n border-radius: 0pt 0pt 2pt 2pt;\n vertical-align: top;\n}\n.horizontal>.tab:not(:first-child) {\n border-left-width: 0pt;\n}\n.tab.hovering {\n background: red;\n}\n.tab.selected {\n background: white;\n border-left-width: 0.2pt;\n color: black;\n font-weight: 500;\n border-color: black;\n}\n.horizontal>.tab.selected {\n border-left-width: 0.2pt;\n}\n\"]","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"}],"id":{"$":0,"Item":"cddabd38-7ecb-4692-99bd-13ca70e4232f"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"SplitterNode","content":"#nowarn \"1178\"\ntype SplitterNode = | SplitterNode of Var<SplitterStructure>\nand  SplitterStructure =\n    | SHtmlNode of HtmlNode\n    | STabStrip of TabStrip\n    | Split     of SplitterNode * SplitterNode * (SplitterNode -> SplitterNode -> HtmlNode)\n\nlet rec renderSplitterNode      sn = match sn with SplitterNode chV -> bindHElem (fun ch -> renderSplitterStructure ch) chV \nand     renderSplitterStructure ss =\n        match ss with\n        | SHtmlNode node        -> node\n        | STabStrip strip       -> strip.Render  \n        | Split   (ch1, ch2, f) -> f ch1 ch2\n\nlet renderSplitter (per:float) ver ch1 ch2 = Grid.NewBisect(true, StVariable, ver, Var.Create per, renderSplitterNode ch1, renderSplitterNode ch2).Render\n\ntype SplitterStructure with    \n    static member New(vertical : bool, child1, child2, per) = Split(SplitterNode (Var.Create              child1), SplitterNode (Var.Create              child2), renderSplitter per  vertical)\n    static member New(vertical : bool, child1, child2     ) = Split(SplitterNode (Var.Create              child1), SplitterNode (Var.Create              child2), renderSplitter 50.0 vertical)\n    static member New(vertical : bool, child1, child2, per) = Split(SplitterNode (Var.Create <| SHtmlNode child1), SplitterNode (Var.Create <| SHtmlNode child2), renderSplitter per  vertical)\n    static member New(vertical : bool, child1, child2, per) = Split(SplitterNode (Var.Create <| STabStrip child1), SplitterNode (Var.Create <| STabStrip child2), renderSplitter per  vertical)\n    static member New(ss1, ss2, f                         ) = Split(SplitterNode (Var.Create ss1                ), SplitterNode (Var.Create ss2                ), f                      )\n    static member New(strip                               ) = STabStrip strip\n    static member New(node                                ) = SHtmlNode node\n\ntype SplitterNode with\n    static member New        ss           = SplitterNode <| Var.Create ss\n    static member New       (ss:HtmlNode) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    static member New       (ss:TabStrip) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    member this.Render                    = renderSplitterNode this\n    member this.Var                       = match this with SplitterNode chV -> chV\n    member this.Value                     = this.Var.Value\n    member this.SplitMe(first, ver, node) =\n        this.Var.Value <- if first then SplitterStructure.New(ver, node      , this.Value) \n                                   else SplitterStructure.New(ver, this.Value, node      )\n    member this.SplitMe(first, ver, node:TabStrip) = this.SplitMe(first, ver, STabStrip node      )\n    member this.SplitMe(first, ver, node:HtmlNode) = this.SplitMe(first, ver, SHtmlNode node      )\n    member this.SplitMe(first, ver               ) = this.SplitMe(first, ver, TabStrip.New([||])  )\n    member this.Navigate recFun                    =\n        match this.Value with\n        | SHtmlNode _           \n        | STabStrip _           -> recFun this.Value\n        | Split   (ch1, ch2, f) -> ch1.Navigate recFun || ch2.Navigate recFun\n    member this.SelectTab  (nm: string)            = this.Navigate (function | STabStrip strip -> strip.Select nm | _ -> false) \n    member this.IsEmpty                            =\n        match this.Value with\n        | SHtmlNode HtmlEmpty   -> true\n        | SHtmlNode _           -> false\n        | STabStrip strip       -> strip.tabs.Value.Length = 0\n        | Split   (ch1, ch2, f) -> ch1.IsEmpty && ch2.IsEmpty\n    member this.UnSplitEmpties()                   =\n        if                                    this.IsEmpty then this.Var.Value <- SplitterStructure.New(TabStrip.New([||])) else\n        match this.Value with\n        | Split   (ch1, ch2, f) -> if   ch1.IsEmpty then ch2.UnSplitEmpties() ; this.Var.Value <- ch2.Value \n                                   elif ch2.IsEmpty then ch1.UnSplitEmpties() ; this.Var.Value <- ch1.Value \n                                                    else ch1.UnSplitEmpties()\n                                                         ch2.UnSplitEmpties()\n        | _                     -> ()  \n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"cddabd38-7ecb-4692-99bd-13ca70e4232f"}],"id":{"$":0,"Item":"a48d72fc-5220-4dac-b3b3-98bad48b0561"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"MenuBar","content":"let inline menuEntry content   = li [ content ]\nlet inline refA      cont  t r = a  [ cont ; hrefO r ; target t ] \nlet inline refText   txt  _t r = bindHElem (fun t -> if t = \"\" then HtmlEmpty else refA(htmlText t) t r) txt\nlet inline entryTxt  txt   t r = menuEntry (refText  txt t  r)\n  \nlet inline entries    ch cl    =  ul ch |> addClass cl\nlet inline nav        ch       =  entries ch \"nav navbar-nav\"\nlet inline dropdown   ch       =  entries ch \"dropdown-menu\"\nlet navbar brand center right  =\n    div [ ``class``                     \"navbar navbar-default\"\n          div [ ``class``               \"container-fluid\"\n                div [ ``class``         \"navbar-header\"\n                      div [ ``class``   \"navbar-brand\"\n                            brand\n                          ]\n                    ]\n                div [ ``class``         \"navbar-collapse collapse\"\n                      center\n                      right |> addClass \"navbar-right\"\n                    ]\n              ]\n    ]\n    \n#nowarn \"1178\"    \n\ntype MenuEntry = {\n    text       : Val<string>\n    ref        : Val<string option>\n    active     : Val<bool>\n    disabled   : Val<bool>\n    subMenu    : Menu option\n    toolTip    : string option\n    target     : string option\n    divider    : bool\n    onClick    : (Dom.Element -> Dom.MouseEvent -> unit) option\n} with\n    static member inline New txt = { \n        text      = Val.fixit  txt\n        active    = Val.fixit  false \n        ref       = Val.Constant None\n        toolTip   = None\n        subMenu   = None\n        onClick   = None\n        target    = None\n        divider   = false\n        disabled  = Val.fixit false\n    } \n    static member inline New(txt, ref) = { MenuEntry.New(txt) with ref      = Val.map Some ref }\n    member this.Render           = \n        entryTxt this.text (this.target |> Option.defaultValue \"\") this.ref \n        |> addClassIf \"active\" this.active |> addClassIf \"disabled\" this.disabled\n        |> match this.subMenu with | None  -> id | Some m -> addChildren [ ``class`` \"dropdown\" ; m.Render ]\n        |> match this.onClick with | None  -> id | Some f -> addChildren [ SomeAttr  <| on.click <@ f @>   ; style \"cursor : pointer\" ]\n        |> match this.divider with | false -> id | true   -> addClass    \"divider\"\n    member inline this.Target   t   = { this with target   = Some t                         }\n    member inline this.Divider      = { this with divider  = true                           }\n    member inline this.OnClick  f   = { this with onClick  = Some f                         }\n    member inline this.Disabled dis = { this with disabled = Val.fixit dis                  }\n    member inline this.SubMenu  es  = { this with subMenu  = Some <| Menu.New( es).DropDown } \n    member inline this.SubMenu  es  = { this with subMenu  = Some <| Menu.New2(es).DropDown } \n    member        this.MenuNode     = MenuEntry this\nand MenuNode =\n    | MenuHtml  of HtmlNode\n    | MenuEntry of MenuEntry \n  with\n    member this.Render = match this with | MenuHtml h -> h | MenuEntry e -> e.Render\nand Menu = {\n    entries  : MenuNode seq\n    dropdown : bool\n} with\n    static member New es : Menu = { \n        entries = es\n        dropdown = false\n    }    \n    static member New2 es : Menu = Menu.New(es |> Seq.map MenuEntry) \n    member this.DropDown        = { this      with dropdown = true  }\n    member this.Render          =\n        (if this.dropdown then dropdown else nav) <|\n            seq [\n                for entry in this.entries -> \n                    entry.Render\n            ]","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"f3c86328-e5b6-4ef1-a3d9-d82098f4ffe2"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Action","content":"[<NoComparison ; NoEquality>]\ntype Action = {\n    text       : Val<string>\n    highlight  : Val<bool>\n    disabled   : Val<bool>\n    toolTip    : string option\n    onClick    : (Action -> Dom.Element -> Dom.MouseEvent -> unit) option\n    parms      : obj[] option\n} with\n    static member inline New txt = { \n        text      = Val.fixit  txt\n        highlight = Val.fixit  false \n        disabled  = Val.fixit  false\n        toolTip   = None\n        onClick   = None\n        parms     = None\n    } \n    member inline this.Text      txt = { this with text      = Val.fixit txt\n                                                   disabled  = Val.fixit false  }\n    member inline this.Parms     ps  = { this with parms     = Some ps          }\n    member inline this.OnClick   f   = { this with onClick   = Some (fun _ -> f)}\n    member inline this.OnClick2  f   = { this with onClick   = Some f           }\n    member inline this.Disabled  dis = { this with disabled  = Val.fixit dis    }\n    member inline this.Highlight h   = { this with highlight = Val.fixit h      }\n    member        this.MenuEntry     = {\n        MenuEntry.text      = this.text\n        MenuEntry.active    = this.highlight \n        MenuEntry.disabled  = this.disabled\n        MenuEntry.toolTip   = this.toolTip\n        MenuEntry.onClick   = this.onClick |> Option.map (fun f -> f this)\n        MenuEntry.ref       = Val.Constant None\n        MenuEntry.divider   = false\n        MenuEntry.subMenu   = None\n        MenuEntry.target    = None\n    }\n    member        this.Button       = {\n        Button.text      = this.text\n        Button.disabled  = this.disabled\n        Button.onClick   = this.onClick |> Option.map (fun f -> f this) |> Option.defaultValue (fun _ _ -> ())\n//        Button.toolTip   = this.toolTip\n        Button._class    = Val.map (fun h -> if h then \"btn btn-primary\" else \"btn\") this.highlight \n        Button._type     = Val.fixit \"button\" \n        Button.style     = Val.fixit \"\"\n        Button.id        = \"\"\n      }\n\nlet Do  f p = (fun     _ _ -> f     p)\nlet Do2 f p = (fun act _ _ -> f act p)\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"f3c86328-e5b6-4ef1-a3d9-d82098f4ffe2"}],"id":{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Layout","content":"open Useful\n\ntype GuiPart     = \n   | GuiRoot       of string\n   | GuiNode       of HtmlNode\n   | GuiAction     of Action\n   | GuiSplit      of first: bool * secT: SectionType * vertical: bool * per:float * string * string * min: float * max: float\n   | GuiTabStrip   of top  : bool * string []\n   | GuiCall       of name: string * action: string * parms: string[]\n\nlet HtmlGuiCall (p: string * string * string[]) = GuiCall p\n\ntype HtmlNodeFable = {\n    HtmlElementF    : (string * HtmlNodeFable [] ) option\n    HtmlAttributeF  : (string * string           ) option\n    HtmlAttributeOF : (string * string option    ) option\n    HtmlTextF       :  string                      option\n    HtmlEmptyF      :  string                      option\n    HtmlGuiPart     :  string                      option\n    HtmlGuiCall     : (string * string * string[]) option\n}\n\ntype LayoutDescriptionFable = \n    {\n       GuiRoot     :  string                                                          option  \n       GuiTabStrip : (bool * string[]                                               ) option\n       GuiSplit    : (bool * string * bool * float * string * string * float * float) option  \n       GuiNode     :  HtmlNodeFable                                                   option\n       GuiCall     : (string * string * string[]                                    ) option\n    }\n\ntype GuiPartSourceId =\n    | GPSI_Internal   of System.Guid\n    | GPSI_Json       of LayoutDescriptionFable\n    | GPSI_Root       of string\n    | GPSI_TabStrip   of bool * string[]                                               \n    | GPSI_Split      of first: bool * secT: SectionType * vertical: bool * string * string\n    | GPSI_Call       of string * string * string[]                                    \n    with static member New =  GPSI_Internal <| System.Guid.NewGuid()\n\nlet rec processLayoutSteps (steps: (string * GuiPart) seq) (parts: Map<string,GuiPart>) =\n    steps\n    |> Seq.tryHead\n    |> Option.map (fun (name, guiPart) ->\n        Map.add name guiPart parts\n        |> processLayoutSteps (steps |> Seq.skip 1)\n       )\n    |> Option.defaultValue parts\n\nlet inline addValue k v (dict: System.Collections.Generic.Dictionary<_, _>) = \n    dict.Remove k |> ignore\n    dict.Add(k, v)\n\nlet (|PHtmlElementF   |_|) (hnf: HtmlNodeFable) = hnf.HtmlElementF   \nlet (|PHtmlAttributeF |_|) (hnf: HtmlNodeFable) = hnf.HtmlAttributeF \nlet (|PHtmlAttributeOF|_|) (hnf: HtmlNodeFable) = hnf.HtmlAttributeOF\nlet (|PHtmlTextF      |_|) (hnf: HtmlNodeFable) = hnf.HtmlTextF      \nlet (|PHtmlEmptyF     |_|) (hnf: HtmlNodeFable) = hnf.HtmlEmptyF     \nlet (|PHtmlGuiPart    |_|) (hnf: HtmlNodeFable) = hnf.HtmlGuiPart     \nlet (|PHtmlGuiCall    |_|) (hnf: HtmlNodeFable) = hnf.HtmlGuiCall\n\nlet (|PGuiTabStrip|_|) (ldf:LayoutDescriptionFable) = ldf.GuiTabStrip  \nlet (|PGuiSplit   |_|) (ldf:LayoutDescriptionFable) = ldf.GuiSplit \nlet (|PGuiRoot    |_|) (ldf:LayoutDescriptionFable) = ldf.GuiRoot  \nlet (|PGuiNode    |_|) (ldf:LayoutDescriptionFable) = ldf.GuiNode  \nlet (|PGuiCall    |_|) (ldf:LayoutDescriptionFable) = ldf.GuiCall  \n\nlet toSect s =\n    match s with \n    | \"StVariable\"  -> StVariable\n    | \"StFixedPx\"   -> StFixedPx\n    | _             -> StFixedPerc\n\n[<NoComparison ; NoEquality>]\ntype Layout = {\n    parts         : System.Collections.Generic.Dictionary<string, Var<GuiPartSourceId * GuiPart> * HtmlNode * Val<GuiPart -> unit>>\n    tabStrips     : System.Collections.Generic.Dictionary<string, TabStrip>\n}\n\nlet t1of3 = function v, _, _ -> v\nlet t2of3 = function _, v, _ -> v\nlet t3of3 = function _, _, v -> v\n\ntype GuiPart with\n    member this.GetHtmlNode (lyt: Layout) name =\n        match this with\n        | GuiRoot    _root                                             -> HtmlEmpty                          , ignore\n        | GuiNode     node                                             -> node                               , ignore\n        | GuiAction   act                                              -> act.Button.Render                  , ignore\n        | GuiCall    (name, action, parms)                             -> lyt.GetCallButton name action parms, ignore\n        | GuiTabStrip(top  , nodes                                   ) -> let ts = TabStrip.New(nodes |> Seq.map (fun node -> node, lyt.GetNode node)).SetTop(top)\n                                                                          addValue name ts lyt.tabStrips\n                                                                          ts.Render                          , ignore\n        | GuiSplit   (first, secT , vertical, per, ch1, ch2, min, max) -> let minV   = Var.Create min\n                                                                          let maxV   = Var.Create max\n                                                                          let perV   = Var.Create per\n                                                                          let curper = ref        per\n                                                                          let grd = Grid.NewBisect(first, secT, vertical, perV, lyt.GetNode ch1, lyt.GetNode ch2).Min(minV).Max(maxV)\n                                                                          grd.Render\n                                                                         ,function \n                                                                          | GuiSplit   (_first, _secT , _vertical, per, _ch1, _ch2, min, max) -> \n                                                                              if !curper     <> per then\n                                                                                  curper     := per\n                                                                                  perV.Value <- per\n                                                                              minV.Value     <- min\n                                                                              maxV.Value     <- max\n                                                                          | _ -> ()\nand  Layout with\n    member this.GetGuiCallAction (name:string) (action:string) (parms:string[]) =\n        if this.parts.ContainsKey action then\n            match this.parts.[action] with\n            | partv, _, _ ->\n                match partv.Value with \n                | _, GuiAction act -> act.Text(name).Parms(parms |> Array.map (fun s -> s:>obj))           |> Result.succeed\n                | _                -> sprintf \"GuiPart %s is not a GuiAction\" action |> Result.failSimpleError\n        else                          sprintf \"GuiAction %s not found\"        action |> Result.failSimpleError\n    member this.GetCallButton name action parms =\n        match this.GetGuiCallAction name action parms with\n        | Result.Success(act, _) -> act.Button.Render\n        | Result.Failure ms      -> div [ ms |> Result.msgs2String |> String.concat \". \" |> htmlText ]\n    member this.AddNode name sid part =\n        let partV  = Var.Create (sid, part)\n        let nodeFv = partV  |> Val.map (fun (_si, p: GuiPart) -> p.GetHtmlNode this name)\n        let node   = nodeFv |> Val.map fst |> HtmlElementV \n        let update = nodeFv |> Val.map snd\n        this.parts.Add(name, (partV :> Var<_>, node, update))\n        node\n    member this.GetNode name =\n        let mutable res = Unchecked.defaultof<_>\n        let ok = this.parts.TryGetValue(name, &res)\n        if ok \n        then t2of3 res\n        else this.AddNode name GuiPartSourceId.New (GuiNode <| div [ htmlText (sprintf \"GuiPart %s not found\" name) ])\n    static member AddGuids steps = \n        steps \n        |> Seq.map (fun (name, part) -> \n            name\n           ,match part with\n             | GuiNode    _node                                             -> GuiPartSourceId.New\n             | GuiAction  _act                                              -> GuiPartSourceId.New\n             | GuiRoot     root                                             -> GPSI_Root     root                                            \n             | GuiSplit   (first, secT , vertical,_per, ch1, ch2,_min,_max) -> GPSI_Split   (first, secT , vertical, ch1, ch2)\n             | GuiTabStrip(top  , nodes                                   ) -> GPSI_TabStrip(top  , nodes                    )\n             | GuiCall    (name, action, parms)                             -> GPSI_Call    (name, action, parms)                            \n           ,part        )  \n        |> Seq.toArray\n    static member New(steps) =\n        let lyt = {\n            parts     = System.Collections.Generic.Dictionary<_, _>()\n            tabStrips = System.Collections.Generic.Dictionary<_, _>()\n        }\n        steps |> Seq.iter (fun (name, part, id) -> lyt.AddNode name part id |> ignore )\n        lyt\n    member this.Render  =\n        let node = \n            this.parts.Values \n            |> Seq.tryPick(t1of3 >> fun v -> match v.Value with | _, GuiRoot root -> Some root | _ -> None )\n            |> Option.defaultValue \"main\"\n        this.GetNode node\n    member this.AddNewSteps steps steps2 =\n        Array.append steps steps2\n        |> Array.groupBy (fun (name,_si,_part) -> name           )\n        |> Array.map     (fun(_name, det     ) -> det |> Seq.last)\n        |> Array.iter    (fun (name, si, part) -> if this.parts.ContainsKey name then\n                                                       let partv,_node, upd = this.parts.[name] \n                                                       let xsi,_xpart = partv.Value\n                                                       if xsi = si \n                                                       then Val.apply (Val.Constant part) upd |> Val.iter id\n                                                       else partv.Value <- (si, part)\n                                                  else this.AddNode name si part |> ignore\n        ) \n    member this.SetLayoutJson steps json =\n        let rec jsonF2HtmlNode =\n           function\n           | PHtmlElementF    (name, ch)          -> Some <| HtmlElement   (name, ch |> Seq.choose jsonF2HtmlNode)\n           | PHtmlAttributeF  (name, v )          -> Some <| HtmlAttribute (name, Val.Constant v  )\n           | PHtmlAttributeOF (name, vO)          -> Some <| HtmlAttributeO(name, Val.Constant vO )\n           | PHtmlTextF        txt                -> Some <| HtmlText      (      Val.Constant txt)\n           | PHtmlEmptyF       _                  -> Some <| HtmlEmpty\n           | PHtmlGuiPart      part               -> Some <| this.GetNode part\n           | PHtmlGuiCall     (name, call, parms) -> Some <| this.GetCallButton name call parms\n           | _                                    -> None\n        let jsonF2GuiRoot =\n           function\n           | PGuiNode      html                                                      -> Some <| GuiNode     (jsonF2HtmlNode html |> Option.defaultValue HtmlEmpty)\n           | PGuiRoot      root                                                      -> Some <| GuiRoot      root\n           | PGuiTabStrip  p                                                         -> Some <| GuiTabStrip  p\n           | PGuiSplit    (first, secT: string  , vertical, per, ch1, ch2, min, max) -> Some <| GuiSplit    (first, secT |> toSect, vertical, per, ch1, ch2, min, max)\n           | PGuiCall     (name, call, parms                                       ) -> Some <| GuiCall     (name, call, parms) \n           | _                                                                       -> None\n        try\n            let steps2 = if json = \"\" then [||] else\n                         json\n                         |> WebSharper.Json.Deserialize<(string * LayoutDescriptionFable)[]>\n                         |> Array.choose (fun (name, ldf) -> jsonF2GuiRoot ldf |> Option.map (fun v -> name, GPSI_Json ldf, v))\n            this.AddNewSteps steps steps2\n        with e -> printfn \"Error: %A\" e\n    member this.SelectTab (tName:string) =\n        this.tabStrips.Values\n        |> Seq.iter (fun ts -> ts.Select tName |> ignore )\n\nlet inline fixedHorSplitter  first px ch1 ch2         = GuiSplit(first, StFixedPx  , false, px, ch1, ch2, 5.0, 95.0)\nlet inline fixedVerSplitter  first px ch1 ch2         = GuiSplit(first, StFixedPx  , true , px, ch1, ch2, 5.0, 95.0)\nlet inline fixPcHorSplitter  first px ch1 ch2         = GuiSplit(first, StFixedPerc, false, px, ch1, ch2, 5.0, 95.0)\nlet inline fixPcVerSplitter  first px ch1 ch2         = GuiSplit(first, StFixedPerc, true , px, ch1, ch2, 5.0, 95.0)\nlet inline varHorSplitter          pc ch1 ch2 min max = GuiSplit(true , StVariable , false, pc, ch1, ch2, min,  max)\nlet inline varVerSplitter          pc ch1 ch2 min max = GuiSplit(true , StVariable , true , pc, ch1, ch2, min,  max)\n\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"cddabd38-7ecb-4692-99bd-13ca70e4232f"},{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"f3c86328-e5b6-4ef1-a3d9-d82098f4ffe2"},{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"}],"id":{"$":0,"Item":"9c870b72-8f9a-4e7d-ad81-7f1fd73fdd76"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"AllTemplates","content":"","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},{"$":0,"Item":"af2b60c6-a99f-433d-b938-f59fefe66c01"},{"$":0,"Item":"995f98ae-4f13-4225-9d00-9aa3e630058a"},{"$":0,"Item":"aa485846-7b78-4ca8-ae22-84ba0c42d962"},{"$":0,"Item":"e665bede-c870-4041-b7ed-8be419c52a83"},{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"},{"$":0,"Item":"8efdcd5a-95c4-4212-9c75-1ebedce83dd8"},{"$":0,"Item":"657c8f34-c917-4659-825d-c9ead206efcf"},{"$":0,"Item":"7a655466-e218-4121-a7b6-f9c70a922e07"},{"$":0,"Item":"8fb54777-3046-4aae-9282-33401a45c280"},{"$":0,"Item":"40614ad6-3f81-468b-a4ff-034124b82ae1"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"0a11766b-f227-4b38-88a3-919d964387bf"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"a05dd36e-a15e-4394-8013-128e21e69574"},{"$":0,"Item":"18d8153d-422c-42f6-8266-9a9d854bd6a1"},{"$":0,"Item":"a48d72fc-5220-4dac-b3b3-98bad48b0561"},{"$":0,"Item":"9c870b72-8f9a-4e7d-ad81-7f1fd73fdd76"}],"id":{"$":0,"Item":"4bae423e-08d8-4c40-8d30-ffa15f9161d3"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableWebSharper":"0"}},{"name":"RunCode","content":"[<JavaScript>]\nmodule RunCode       =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"1095ae38-19fc-4195-840c-c368a3a486c4"}],"id":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"expanded":false,"level":0,"levelCode":0,"properties":{}},{"name":"completeJS","content":"let completeJS js = \n  \"\"\"","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[],"id":{"$":0,"Item":"36fc221f-7e61-4a04-abf3-317f901e5211"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"1"}},{"name":"CIPHERSpaceLoadFiles","content":"    CIPHERSpaceLoadFileGlobalFileRef = null;\n    CIPHERSpaceLoadFile = function (filename, callback) {\n        if (filename.slice(-3) == \".js\" || filename.slice(-4) == \".fsx\" || filename.slice(-3) == \".fs\") { //if filename is a external JavaScript file\n            var fileRef = null;\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement('script')\n                fileRef.setAttribute(\"type\", \"text/javascript\")\n                fileRef.setAttribute(\"src\", filename)\n            }\n            else callback();\n        }\n        else if (filename.slice(-4) == \".css\") { //if filename is an external CSS file\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement(\"link\")\n                fileRef.setAttribute(\"rel\", \"stylesheet\")\n                fileRef.setAttribute(\"type\", \"text/css\")\n                fileRef.setAttribute(\"href\", filename)\n            }\n            else callback();\n        }\n        else if (filename.slice(-5) == \".html\") { //if filename is an external HTML file\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement(\"link\")\n                fileRef.setAttribute(\"rel\", \"import\")\n                fileRef.setAttribute(\"type\", \"text/html\")\n                fileRef.setAttribute(\"href\", filename)\n            }\n            else callback();\n        }\n        if (!!fileRef) {\n            CIPHERSpaceLoadFileGlobalFileRef = fileRef;\n\t\t\tfileRef.onload = function () { fileRef.onload = null;  callback(); }\n            document.getElementsByTagName(\"head\")[0].appendChild(fileRef);\n        }\n    }\n    CIPHERSpaceLoadFiles = function (files, callback) {\n        var newCallback = callback\n        if (!!CIPHERSpaceLoadFileGlobalFileRef && !!(CIPHERSpaceLoadFileGlobalFileRef.onload)) {\n            var oldCallback = CIPHERSpaceLoadFileGlobalFileRef.onload;\n            CIPHERSpaceLoadFileGlobalFileRef.onload = null;\n            newCallback = function () {\n                callback();\n                oldCallback();\n            }\n        }\n        var i = 0;\n        loadNext = function () {\n            if (i < files.length) {\n                var file = files[i];\n                i++;\n                CIPHERSpaceLoadFile(file, loadNext);\n            }\n            else newCallback();\n        };\n        loadNext();\n\t}\n    CIPHERSpaceLoadFiles(['https://code.jquery.com/jquery-3.1.1.min.js'], function() {}); \n\tCIPHERSpaceLoadFilesDoAfter = function (callback) {\n\t\tvar newCallback = callback\n\t\tif (!!CIPHERSpaceLoadFileGlobalFileRef) {\n\t\t\tif (!!(CIPHERSpaceLoadFileGlobalFileRef.onload)) {\n\t\t\t\tvar oldCallback = CIPHERSpaceLoadFileGlobalFileRef.onload;\n\t\t\t\tCIPHERSpaceLoadFileGlobalFileRef.onload = null;\n\t\t\t\tnewCallback = function () {\n\t\t\t\t\toldCallback();\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse CIPHERSpaceLoadFileGlobalFileRef = {};\n\t\tCIPHERSpaceLoadFileGlobalFileRef.onload = newCallback;\n\t}\n\nCIPHERSpaceLoadFilesDoAfter(function() { \n  if (typeof IntelliFactory !=='undefined')\n    IntelliFactory.Runtime.Start();\n  for (key in window) { \n    if (key.startsWith(\"StartupCode$\")) \n      try { window[key].$cctor(); } catch (e) {} \n  } \n})\n","parent":{"$":0,"Item":"36fc221f-7e61-4a04-abf3-317f901e5211"},"predecessors":[],"id":{"$":0,"Item":"a3676bbd-c1ea-4fc0-b599-6fde2c8d0816"},"expanded":true,"level":0,"levelCode":0,"properties":{"Theme":"colorforth","Mode":"javascript","NoLinePre":"1"}},{"name":"\"\"\" + js","content":"                 \"\"\" + js","parent":{"$":0,"Item":"36fc221f-7e61-4a04-abf3-317f901e5211"},"predecessors":[{"$":0,"Item":"a3676bbd-c1ea-4fc0-b599-6fde2c8d0816"}],"id":{"$":0,"Item":"afaac2af-143d-4745-9447-7e8d3044950f"},"expanded":true,"level":0,"levelCode":0,"properties":{"NoLinePre":"1"}},{"name":"","content":"type RunNode(nodeName, ?clearNode: bool, ?useShadowRoot:bool) =\n  let bClearNode    = defaultArg clearNode     true\n  let useShadowRoot = defaultArg useShadowRoot true\n  let createNode() =\n      let e = JS.Document.CreateElement \"div\"\n      e?style <- \"height: 100%; width: 100%;\"\n      e\n  let createBaseNode () =\n      let el = JS.Document.CreateElement \"div\"\n      el.SetAttribute(\"id\", nodeName)\n      JS.Document.Body.AppendChild el |> ignore\n      el\n  let baseNode = \n      match JS.Document.GetElementById nodeName with\n      | null -> createBaseNode()\n      | node -> node\n  let runNode =\n      if not useShadowRoot then baseNode else\n      match baseNode.ShadowRoot with\n      | null -> let p = createNode()\n                baseNode.AttachShadow(Dom.ShadowRootInit(Dom.ShadowRootMode.Open)).AppendChild p |> ignore\n                let e = createNode()\n                p.AppendChild e |> ignore\n                e\n      | root -> root.FirstChild :?> Dom.Element\n  do if bClearNode then runNode.InnerHTML <- \"\"\nwith\n  new(?clearNode: bool, ?useShadowRoot:bool) = RunNode(\"TestNode\", ?clearNode = clearNode, ?useShadowRoot = useShadowRoot)\n  member this.RunNode   = runNode\n","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[],"id":{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"AddBootstrap","content":"  member this.AddBootstrap =\n    JS.Document.CreateElement \"div\"\n    |> fun el -> \n        el.InnerHTML <- \n          @\"<script src='http://code.jquery.com/jquery-3.1.1.min.js' type='text/javascript' charset='UTF-8'></script>\n            <script src='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js' type='text/javascript' charset='UTF-8'></script>\n            <link type='text/css' rel='stylesheet' href='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css'>\n            <link type='text/css' rel='stylesheet' href='/EPFileX/css/main.css'>\n           \"\n        runNode.ParentElement.AppendChild el |> ignore\n    this","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"}],"id":{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"AddFontAwesome","content":"  member this.AddFontAwesome =\n    JS.Document.CreateElement \"div\"\n    |> fun el -> \n        el.InnerHTML <-  @\"<link type='text/css' rel='stylesheet' href='https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css'>\"\n        runNode.ParentElement.AppendChild el |> ignore\n    this","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"}],"id":{"$":0,"Item":"6332dfb8-b57a-40de-b669-f796820883db"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"AddBulma","content":"  member this.AddBulma =\n    JS.Document.CreateElement \"div\"\n    |> fun el -> \n        el.InnerHTML <-  @\"<link type='text/css' rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/bulma/0.6.1/css/bulma.min.css'>\"\n        runNode.ParentElement.AppendChild el |> ignore\n    this","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"}],"id":{"$":0,"Item":"47bf25cf-e7f5-452a-9247-156146348a14"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"RunDoc","content":"  member inline this.RunDoc doc = doc :> Doc |> Doc.Run this.RunNode","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"},{"$":0,"Item":"aba6c516-0ac9-4abe-95a2-7257d077e338"}],"id":{"$":0,"Item":"c110a9c9-bc3b-4be7-8e5d-f43cc75f93ed"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"RunHtml","content":"  member inline this.RunHtml node = node |> renderDoc |> this.RunDoc\n  ","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"c110a9c9-bc3b-4be7-8e5d-f43cc75f93ed"}],"id":{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"RunHtmlPlusFree","content":"  member        this.RunHtmlPlusFree node =\n    let freeHtml    = Var.Create \"\"\n    let freeCSS     = Var.Create \"\"\n    let freeFS      = Var.Create \"\"\n    let freeJS      = Var.Create \"\"\n    let freeMsgs    = Var.Create \"\"\n    let sendMsg msg = \n        freeMsgs.Value  <- \n            match freeMsgs.Value, msg with\n            | null, m \n            | \"\"  , m\n            | m   , null\n            | m   , \"\"   -> m\n            | m1  , m2   -> m1 + \"\\n\" + m2\n    let runJS () =\n        sendMsg \"Running JavaScript...\"\n        try JS.Eval(freeJS.Value) |> (fun v -> sendMsg \"Done!\"; v.ToString())\n        with e -> sendMsg \"Failed!\"; e.ToString()\n        |> sendMsg\n    let runFS () =\n        Useful.Wrap.wrapper {\n            freeMsgs.Value <- \"Compiling to JavaScript...\"\n            freeJS.Value   <- \"\"\n            let    code      = freeFS.Value\n            let!   jsR       = FsTranslator.translateAR code false\n            let!   js        = jsR\n            let    jsc       = completeJS js\n            freeJS.Value    <- jsc\n            sendMsg            \"Compiled!\"\n            runJS()\n        } |> Useful.Wrap.start sendMsg\n    div [ style \"height: 100%\"\n          node\n          Template.Button.New(\"Eval F#\").Style(\"vertical-align:top\").OnClick(fun _ _ -> runFS()                        ).Render  \n          someElt <| Doc.InputArea [ attr.placeholder \"F#:\"         ; attr.title \"Add F# code and invoke with Eval F#\" ] freeFS\n          someElt <| Doc.InputArea [ attr.placeholder \"HTML:\"       ; attr.title \"Enter HTML tags and text\"            ] freeHtml \n          someElt <| Doc.InputArea [ attr.placeholder \"CSS:\"        ; attr.title \"Test your CSS styles dynamically\"    ] freeCSS \n          someElt <| Doc.InputArea [ attr.placeholder \"JavaScript:\" ; attr.title \"Add JS code and invoke with Eval JS\" ] freeJS\n          Template.Button.New(\"Eval JS\").Style(\"vertical-align:top\").OnClick(fun _ _ -> freeMsgs.Value <- \"\" ; runJS() ).Render  \n          someElt <| Doc.InputArea [ attr.placeholder \"Output:\"     ; attr.title \"Messages\"                            ] freeMsgs\n          SomeDoc <| tag Doc.Verbatim (Val.map2 (sprintf \"%s<style>%s</style>\") freeHtml freeCSS)\n    ]\n    |> this.RunHtml","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"afaac2af-143d-4745-9447-7e8d3044950f"},{"$":0,"Item":"95a237c8-a9ff-40d1-bd72-bd298b20af8c"},{"$":0,"Item":"79f8f6c6-d1f5-4593-9775-60ba2863e94d"},{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"}],"id":{"$":0,"Item":"456562f7-0757-4431-9aeb-d58b050cecf7"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"ShowHtmlResult","content":"  member inline this.ShowHtmlResult res =\n    this.AddBootstrap |> ignore\n    div [ ``class`` \"container\"\n          Template.Panel.New\n            .Title(\"Result:\")\n            .Header([])\n            .Content([ h3 res ; style \"font-family:monospace;\" ])\n            .Render\n     ] |> this.RunHtml\n  member inline this.ShowHtmlResult res = this.ShowHtmlResult [res]\n","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"0a11766b-f227-4b38-88a3-919d964387bf"},{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"}],"id":{"$":0,"Item":"bf400a85-8264-4540-9381-f3be0c968c94"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"ShowResult","content":"  member inline this.ShowResult res = htmlText (sprintf \"%A\" res) |> this.ShowHtmlResult\n","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"bf400a85-8264-4540-9381-f3be0c968c94"}],"id":{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FSharpStation Code","content":"module FSharpStation =\n","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[],"id":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableWebSharper":"1","Layout":"[[\"main_messages\",{\"GuiSplit\":[true,\"StVariable\",false,18,\"messagesB\",\"snippets_code\",0,75]}],[\"compileFSStation\",{\"GuiCall\":[\"Compile & Run F# Station\",\"actEvalCode\",[\"FSSGlobal/WebSharper Code/FSharpStation Code/compile & run FSharpStation\"]]}],[\"NewTabFSStation\",{\"GuiCall\":[\"F# Station in New Tab\",\"actRunWSNewTab\",[\"FSSGlobal/WebSharper Code/FSharpStation Code/Invoke FSharpStation\"]]}],[\"buttons\",{\"GuiNode\":{\"HtmlElementF\":[\"div\",[{\"HtmlGuiPart\":\"actAddSnippet\"},{\"HtmlGuiPart\":\"actOutdentSnippet\"},{\"HtmlGuiPart\":\"actIndentSnippet\"},{\"HtmlElementF\":[\"span\",[]]},{\"HtmlGuiPart\":\"compileFSStation\"},{\"HtmlGuiPart\":\"NewTabFSStation\"},{\"HtmlGuiPart\":\"actDeleteSnippet\"},{\"HtmlGuiPart\":\"actFindDefinition\"},{\"HtmlElementF\":[\"span\",[]]},{\"HtmlGuiPart\":\"actSaveFile\"},{\"HtmlGuiPart\":\"actGetFsCode\"},{\"HtmlGuiPart\":\"actParseCode\"},{\"HtmlAttributeF\":[\"style\",\"                     overflow: hidden;                     display: grid;                     grid-template-columns: repeat(6, 16.5%);                     bxackground-color: #eee;                     padding : 5px;                     grid-gap: 5px;                 \"]}]]}}]]"}},{"name":"CodeSnippet Extensions, Position","content":"open Template\nopen FsStationShared\nopen System.Collections.Generic\nopen Useful\nopen FsTranslator\nopen FsEvaluator\n\n[< JavaScript >]\nmodule FsGlobal =\n    [< Inline >]\n    let inline storeVarCodeEditor name = storeVar <| \"CodeEditor.\" + name\n    \n    //let codeSnippetsStorage = WebSharper.UI.Next.Storage.LocalStorage \"CodeSnippets\" Serializer.Typed<CodeSnippet>\n    //let codeSnippets        = ListModel.CreateWithStorage<CodeSnippetId, CodeSnippet> (fun s -> s.id) codeSnippetsStorage\n    let codeSnippets        = ListModel.Create<CodeSnippetId, CodeSnippet> (fun s -> s.id) []\n\n    [< Inline \"(Date.now())\" >]\n    let now() = 0\n    let fsIds  = \"FSharpStation\" + (now() |> string)\n    \n    let tryPickI f s = s |> Seq.indexed |> Seq.filter f |> Seq.tryHead\n    \n    type CodeSnippet \n        with\n        static member PickIO       id   = codeSnippets.Value    |> tryPickI (fun (_, snp) -> snp.id = id)\n        static member FetchO       id   = codeSnippets.TryFindByKey id\n        static member FetchL       id   = CodeSnippet.FetchO id |> Option.toList\n        static member New(            pred    , cnt) = CodeSnippet.New(\"\", None   , pred, [], cnt)\n        static member New(        pa, pred    , cnt) = CodeSnippet.New(\"\", Some pa, pred, [], cnt)\n        static member New(        pa,           cnt) = CodeSnippet.New(\"\", Some pa, []  , [], cnt)\n        static member New(                      cnt) = CodeSnippet.New(\"\", None   , []  , [], cnt)\n        static member New(    nm, pa, pred, co, cnt) = CodeSnippet.New(codeSnippets.Length, nm, pa, pred, co, cnt)\n        static member New(od, nm, pa, pred, co, cnt) =\n            let newS =\n                {\n                    name         = nm\n                    content      = cnt\n                    parent       = pa\n                    predecessors = pred\n                    id           = CodeSnippetId.New\n                    expanded     = true\n                    level        = 0\n                    levelCode    = 0\n                    properties   = System.Collections.Generic.Dictionary<string, string>()\n                }\n            match od, codeSnippets.Length with\n            | _, 0            -> codeSnippets.Append newS\n            | 0, _            -> codeSnippets.Set <| Seq.append [| newS |] codeSnippets.Value\n            | i, n when i < n -> codeSnippets.Value \n                                    |> Seq.toArray\n                                    |> Array.splitAt od\n                                    |> fun (fst, snd) -> Array.append fst <| Array.append [| newS |] snd\n                                    |> codeSnippets.Set \n            | _, _            -> codeSnippets.Append newS\n            newS\n        member this.Levels =\n            let rec levels (out, out2) snp = \n                snp.parent\n                |> Option.bind CodeSnippet.FetchO\n                |> Option.map (levels <| (out + 1, out2 + if snp.properties.ContainsKey \"NoIndent\" then 0 else 1)) \n                |> Option.defaultValue (out, out2)\n            levels (0, 0) this\n        member this.PrepareSnippet   =\n            let lvl, lvlCode = this.Levels\n            { this with level     = lvl\n                        levelCode = lvlCode\n                        content   = this.content\n                                        .Replace(\"##\" + \"FSHARPSTATION_ID\" + \"##\"      , fsIds                  )\n                                        .Replace(\"##\" + \"FSHARPSTATION_ENDPOINT\" + \"##\", JS.Window.Location.Href) }\n        member this.Predecessors     () =\n            let preds = this.UniquePredecessors CodeSnippet.FetchO |> Seq.toArray\n            codeSnippets.Value\n            |> Seq.filter (fun snp -> preds |> Array.contains snp.id)\n            |> Seq.map    (fun snp -> snp.PrepareSnippet)\n            |> Seq.toArray\n        member this.GetCodeAndStarts addLinePrepos = this.Predecessors() |> CodeSnippet.CodeAndStarts addLinePrepos\n        member this.GetCodeFsx       addLinePrepos = this.GetCodeAndStarts addLinePrepos |> fst\n        member this.IsDescendantOf antId =\n            let rec isDescendantOf snp =\n                match snp.parent with\n                | None       -> false\n                | Some parId ->\n                if parId = antId then true else\n                CodeSnippet.FetchO parId\n                |> Option.map isDescendantOf\n                |> Option.defaultValue false\n            isDescendantOf this\n        static member FetchByPathO names      = \n            let tryFindByName      snps name  = snps |> Seq.filter (fun (snp:CodeSnippet) -> snp.Name = name) |> Seq.tryHead\n            let rec tryFindByPath  snps names = \n                let first = names |> Seq.tryHead |> Option.bind (tryFindByName snps)\n                if names |> Seq.length <= 1 then first else\n                first\n                |> Option.bind (fun f ->\n                    names \n                    |> Seq.tail\n                    |> tryFindByPath  (codeSnippets.Value |> Seq.filter (fun snp -> snp.parent = Some f.id))\n                )\n            names \n            |> tryFindByPath (codeSnippets.Value |> Seq.filter (fun snp -> snp.parent.IsNone))\n        member this.propValue p =\n            if this.properties.ContainsKey p \n            then Some this.properties.[p]\n            else this.parent |> Option.bind CodeSnippet.FetchO |> Option.bind (fun par -> par.propValue p)\n    \n    type Position =\n        | Below\n        | Right\n        | Tab\n        | NewBrowser\n        \n    \n    type ErrCompiler =\n        | JsCompilerMsg  of string * bool\n        | ``Snippet Missing``\n        | ``Could not open new browser, Popup blocker may be active``\n        interface ErrMsg with\n            member this.ErrMsg   : string = \n                match this with \n                | JsCompilerMsg(msg, err) -> sprintf \"%s\" msg\n                | _                       -> sprintf \"%A\" this\n            member this.IsWarning: bool   = \n                match this with \n                | JsCompilerMsg(msg, err) -> not err\n                | _                       -> false\n                \n    [< Inline \"saveAs(new Blob([$txt], {type: 'text/plain;charset=utf-8'}), $name)\" >]\n    let saveAs (txt:string) (name:string) = ()\n    \n    type KeyMapAutoComplete = { \n        F2              : Template.CodeMirrorEditor -> unit \n        LeftDoubleClick : Template.CodeMirrorEditor -> unit\n        ``Ctrl-Space``  : Template.CodeMirrorEditor -> unit\n        ``.``           : Template.CodeMirrorEditor -> unit\n    }\n    \n    type Property(setDirty: unit->unit, props: Dictionary<string, string>, keyP: string) =\n        inherit Var<string>()\n        let mutable key = keyP\n        let getK () = key\n        let setK k  = props.Add(k, props.[key]) ; props.Remove key |> ignore ; key <- k ; setDirty()\n        let getV () = props.[key]\n        let setV v  = props.[key] <- v ; setDirty()\n        override this.Id  = \"?\"\n        override this.SetFinal                              v = setK v\n        override this.Set                                   v = setK v\n        override this.Get ()                                  = getK()\n        override this.Update      (f:string -> string       ) = getK() |> f |>             setK\n        override this.UpdateMaybe (f:string -> string option) = getK() |> f |> Option.iter setK\n        override this.View                     : View<string> = getK() |> View.Const\n        member this.KeyVar   = this :> Var<string>  \n        member this.ValueVar = PropValue this\n        member this.GetK     = getK\n        member this.SetK     = setK\n        member this.GetV     = getV\n        member this.SetV     = setV\n        member this.Remove() = props.Remove key |> ignore ; setDirty()\n\n    and PropValue(prop: Property) =\n        inherit Var<string>()\n        let get  = prop.GetV\n        let set  = prop.SetV\n        override this.Id  = \"?\"\n        override this.SetFinal                              v = set v\n        override this.Set                                   v = set v\n        override this.Get ()                                  = get()\n        override this.Update      (f:string -> string       ) = get() |> f |>             set\n        override this.UpdateMaybe (f:string -> string option) = get() |> f |> Option.iter set\n        override this.View                     : View<string> = get() |> View.Const\n\n    let [< Inline >] inline genericPropertyVal currentCodeSnippetId p def f =\n        currentCodeSnippetId\n        |> Val.map\n            (CodeSnippet.FetchO\n             >> Option.bind (fun snp -> snp.propValue p |> Option.map f)\n             >> Option.defaultValue def\n            )\n        |> Val.consistent\n\n    let [< Inline \"Object.constructor('return function(parm) { return `' + $template + '`}')()($p)\" >] translateTemplate (template: string) p = \"\"\n\n\nopen FsGlobal                \n\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"},{"$":0,"Item":"95a237c8-a9ff-40d1-bd72-bd298b20af8c"},{"$":0,"Item":"336d6f19-0c57-4af9-8716-1b3fbf6b112c"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"}],"id":{"$":0,"Item":"1787d1fe-db11-4716-b3f6-164048e8991b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FableModule","content":"[< JavaScript >]\nmodule FableModule =\n    //open Useful\n    \n    //[< Require(typeof<Resources.BaseResource>, \"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.2/require.min.js\")      >]    \n    [< Require(typeof<Resources.BaseResource>, \"/EPFileX/Fable/babel-standalone.js\")                               >]    \n    type Babel() =    \n        [< Inline \"Babel.transformFromAst($ast , null, $options)\"                  >] static member transformFromAst(ast , xx, options)                = X<_>\n        [< Inline \"Babel.transform       ($ast ,       $options)\"                  >] static member transform       (ast ,     options)                = X<_>\n    \n    [< Require(typeof<Resources.BaseResource>, \"/EPFileX/Fable/babel-standalone.js\")                               >]    \n    [< Require(typeof<Resources.BaseResource>, \"/EPFileX/Fable\", \"Fable.js\", \"Worker.js\")                          >]\n    type Fable() =\n        [< Inline \"Fable.createChecker($f, $references)\"                           >] static member createChecker(f, references)  : obj                = X<_>\n        [< Inline \"Fable.makeCompiler($replacements)\"                              >] static member makeCompiler(replacements)    : obj                = X<_>\n        [< Inline \"Fable.parseFSharpProject($checker, $com, $fileName, $source)\"   >] static member parseFSharpProject(checker, com, fileName, source) = X<_>\n        [< Inline \"Fable.compileAst($com, $fsharpAst, $fileName)\"                  >] static member compileAst(com, fsharpAst, fileName)               = X<_>\n        [< Inline \"Fable.convertToJson($babelAst)\"                                 >] static member convertToJson(babelAst)                            = X<_>\n    \n    let [< Inline \"getFileBlob($key, $url)\"                                        >] getFileBlob(key, url)                                            = X<_>\n    let [< Inline \"metadata[$fn]\"                                                  >] readAllBytes fn                                                  = X<_>\n    let [< Inline \"Object.getOwnPropertyNames(metadata).length\"                    >] metadataLength (): int                                           = X<_>\n    let [< Inline \"babelPlugins\"                                                   >] babelPlugins () : obj                                            = X<_>\n    \n    \n    let references = [|\n        \"mscorlib.dll\"\n        \"System.dll\"\n        \"System.Core.dll\"\n        \"System.Data.dll\"\n        \"System.IO.dll\"\n        \"System.Xml.dll\"\n        \"System.Numerics.dll\"\n        \"FSharp.Core.sigdata\"\n        \"FSharp.Core.dll\"\n        \"Fable.Core.dll\"\n        \"Fable.Import.Browser.dll\"\n        // When loading the REPL the browser console always shows: \"Cannot find type System.ValueTuple`1\"\n        // However, adding the following reference prevents opening System namespace\n        // See https://github.com/fable-compiler/Fable/issues/1152#issuecomment-330315250\n        // \"System.ValueTuple.dll\",\n    |]\n\n    let loadReferences =\n        lazy\n            async {\n                do! LoadFiles.LoadFilesAsync [| \"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.2/require.min.js\" |] \n                let  options          = Object.Create null\n                options?skipDataMain <- 1\n                options?isBrowser    <- 1\n                JS.Window?require?config options\n                references |> Seq.iter (fun fn -> getFileBlob(fn, \"metadata/\" + fn))\n            } |> Async.Start\n        \n    let getChecker = \n        lazy Fable.createChecker(readAllBytes, references |> Array.choose (fun fn -> if fn.Contains \"sigdata\" then None else Some <| fn.Replace(\".dll\", \"\")) )\n        \n    let mutable addOutMsg : string -> unit = Console.Log\n\n    let ToConsole arg = \n        Console.Log arg\n        arg?cont addOutMsg\n\n    let fableTranslate source : Wrap<string> =\n        Wrap.wrapper {\n            loadReferences.Value\n            do! async { \n                    while metadataLength() < references.Length do\n                        do! Async.Sleep 200\n                }\n            let  checker       = getChecker.Value\n            let  com           = Fable.makeCompiler [| \"Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatLine\"\n                                                     , \"FSSGlobal.FSharpStation.FableModule.ToConsole($0)\" |]  \n            let  fileName      = \"stdin.fsx\"\n            let  fsharpAst     = Fable.parseFSharpProject(checker, com, fileName, source)\n            let  babelAst      = Fable.compileAst(com, fsharpAst, fileName)\n            let  jsonAst       = Fable.convertToJson(babelAst)\n            let  ast           = JSON.Parse(jsonAst)\n            let  options       = Object.Create null\n            options?plugins   <- [| babelPlugins()?transformMacroExpressions\n                                    babelPlugins()?removeUnneededNulls \n                                    \"transform-es2015-modules-amd\"    \n                                 |]\n            options?presets   <- [|  |]\n            options?filename  <- fileName\n            options?babelrc   <- false\n            let  transformed   = Babel.transformFromAst(ast , null, options)\n            let  jCode2:string = transformed?code\n            let  jCode3        = jCode2.Replace(\"define([\"       , \"require([\")\n                                       .Replace(\"\\\"use strict\\\";\", \"\\\"use strict\\\"; try { exports = exports || {}; } catch (err) {}\")\n            return jCode3\n        }\n    \n    ","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"1787d1fe-db11-4716-b3f6-164048e8991b"}],"id":{"$":0,"Item":"dca77d6a-5c2c-4c3e-9bef-14f0464f9ada"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CIPHERPrototype Module","content":"#r @\"ZafirTranspiler.dll\"\n    \n[< JavaScript >]\ntype CIPHERPrototypeMsg(msg: string, warning: bool) =\n    interface ErrMsg with\n        member this.ErrMsg    = msg\n        member this.IsWarning = warning\n\n[< JavaScript >]\nlet translateAR fsCode minified = \n    Wrap.wrapper {\n        let! vO, msgs = CIPHERPrototype.Editor.translate fsCode minified\n        let!   js     = Result (vO, [ CIPHERPrototypeMsg(msgs, vO.IsNone) :> ErrMsg ])\n        return js\n    } |> Wrap.getAsyncR\n\n[< JavaScript >]\nlet evaluateAR  fsCode = \n    Wrap.wrapper {\n        let! vO, msgs = CIPHERPrototype.Editor.evaluate fsCode\n        let!   txt    = Result (vO, [ CIPHERPrototypeMsg(msgs, vO.IsNone) :> ErrMsg ])\n        return txt\n    } |> Wrap.getAsyncR\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"8fbd59ac-9417-4309-8d01-3ccd5d62452c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FSharpStationClient","content":"[< JavaScript >]\nlet FSharpStationClient (loadFromUri: string) =\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"336d6f19-0c57-4af9-8716-1b3fbf6b112c"},{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"expanded":false,"level":0,"levelCode":0,"properties":{}},{"name":"currentCodeSnippetId","content":"\nlet missingVar  = Var.Create \"\"\nlet missing def find lens k =\n    match find k with\n    | Some _ -> lens k\n    | None   -> missingVar.Lens (fun _ -> def) (fun _ _ -> \"\")\n    \nlet currentCodeSnippetId  = Var.Create <| CodeSnippetId.New\n\nstoreVarCodeEditor \"currentCodeSnippetId\" currentCodeSnippetId\n\nlet refresh       = Var.Create()\nlet refreshView b = refresh.Value <- b\n\nlet currentCodeSnippetO = Val.map2 (fun k () -> codeSnippets.TryFindByKey k) currentCodeSnippetId refresh\n\nlet curSnippetNameOf k = missing \"\"        codeSnippets.TryFindByKey <| codeSnippets.LensInto (fun s -> s.Name      ) (fun s n -> { s with name       = n }) <| k\nlet curSnippetCodeOf k = missing \"\"        codeSnippets.TryFindByKey <| codeSnippets.LensInto (fun s -> s.content   ) (fun s n -> { s with content    = n }) <| k\nlet curSnippetPrpsOf k = missing (System.Collections.Generic.Dictionary<string, string>()) codeSnippets.TryFindByKey <| codeSnippets.LensInto (fun s -> s.properties) (fun s p -> { s with properties = p }) <| k\n    \nlet positionTxt v =\n    match v with\n    | Below      -> \"Below\"\n    | Right      -> \"Right\"\n    | Tab        -> \"In Tab\"\n    | NewBrowser -> \"New Browser\"\n    \nlet position = Var.Create Below\nstoreVarCodeEditor \"position\" position\n\nlet directionVertical    = \n    Val.map (fun pos -> \n        match pos with\n        | Right -> true\n        | _     -> false\n    ) position\n    \n()    ","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"1787d1fe-db11-4716-b3f6-164048e8991b"},{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"}],"id":{"$":0,"Item":"987560b0-1fe6-4835-ad99-aed93db7da1a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CodeEditorMain","content":"\n\nlet noSelection cur      = CodeSnippet.FetchO cur = None\nlet noSelectionVal       = Val.map noSelection currentCodeSnippetId\n\nlet propertyCssVal       = genericPropertyVal  currentCodeSnippetId \"CSS\"      \"\"         id\nlet propertyCssLinkVal   = genericPropertyVal  currentCodeSnippetId \"CSSLink\"  \"\"         id   \nlet propertyModeVal      = genericPropertyVal  currentCodeSnippetId \"Mode\"     \"fsharp\"   id   \nlet propertyThemeVal     = genericPropertyVal  currentCodeSnippetId \"Theme\"    \"\"         id   \nlet propertyLayoutVal    = genericPropertyVal  currentCodeSnippetId \"Layout\"   \"\"         id   \nlet propertyLayoutJSVal  = genericPropertyVal  currentCodeSnippetId \"LayoutJS\" \"\"         id   \nlet disablePropertyVal p = genericPropertyVal  currentCodeSnippetId p          \"\"         id\n\nlet disableEval parse ev = if ev = \"\" then parse else ev <> \"0\"\n\nlet disableParseVal      = disablePropertyVal \"DisableParse\"      |> Val.map (fun p -> p <> \"0\" && p <> \"\")\nlet disableFSIVal        = disablePropertyVal \"DisableFSI\"        |> Val.map2 disableEval disableParseVal  \nlet disableFableVal      = disablePropertyVal \"DisableFable\"      |> Val.map2 disableEval disableParseVal  \nlet disableWebSharperVal = disablePropertyVal \"DisableWebSharper\" |> Val.map2 disableEval disableParseVal \n\nlet mutable lastCodeAndStarts : (CodeSnippetId * bool * ((string * int * int) [] * string [] * string [] * string [] * string [] * string []) option) option = None\n\nlet getPredecessors curO =\n    curO\n    |> Option.map (fun (snp:CodeSnippet) -> snp.UniquePredecessors CodeSnippet.FetchO |> HashSet)\n    |> Option.defaultValue (System.Collections.Generic.HashSet())\n\nlet getPredecessorsM = Useful.ResetableMemoize(getPredecessors)\n\nlet codeFS         = Var.Create \"\"\nlet codeJS         = Var.Create \"\"\nlet parserMsgs     = Var.Create \"\"\nlet outputMsgs     = Var.Create \"\"\nlet mutable parsed = false\nlet dirty          = Var.Create false \nlet setDirtyPart() = parsed            <- false\n                     dirty.Value       <- true       \nlet setDirty()     = lastCodeAndStarts <- None\n                     setDirtyPart               ()\nlet setDirtyPred() = setDirty                   ()\n                     getPredecessorsM.ClearCache()\n                     refreshView                ()\nlet setClean()     = getPredecessorsM.ClearCache()\n                     dirty.Value       <- false\n                     lastCodeAndStarts <- None\n                     \n\n//storeVarCodeEditor \"dirty\" dirty\nlet appendMsg (var:Var<string>) msg =\n    if isUndefined msg then () else\n    let newM =\n        match var.Value, msg.ToString() with\n        | null, m \n        | \"\"  , m\n        | m   , null\n        | m   , \"\"   -> m\n        | m1  , m2   -> m1 + \"\\n\" + m2\n    if newM <> var.Value then\n        var.Value  <- newM\n\nlet setOutMsg msg = outputMsgs.Value <-  msg\nlet addOutMsg msg = appendMsg outputMsgs msg\nlet addPrsMsg msg = appendMsg parserMsgs msg\n\nlet getFSCode () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value \n    |> Option.iter (fun snp -> codeFS.Value <- snp.GetCodeFsx true )\n\ndo Val.sink (fun m -> \n    JS.Window.Onbeforeunload <- \n        if m then System.Action<Dom.Event>(fun (e:Dom.Event) -> e?returnValue  <- \"Changes you made may not be saved.\")\n        else null\n    ) dirty \n\n//let evalIFrameJS success failure js =\n//    createIFrame (fun frame ->\n//        try\n//             let window   = frame?contentWindow\n//             let eval   s = JS.Apply window \"eval\" [| s |]\n//             eval js           |> success\n//        with e -> e.ToString() |> failure\n//    )\n//    |> RunCode.RunNode().RunHtml\n//\n//let evalWindowUrlJS (url:string) success failure js =\n//    let window       = JS.Apply JS.Window \"open\" [| url |]\n//    match window with\n//    | null -> failure \"could not open new browser. Popup blocker may be active.\"\n//    | _    ->\n//    800 \n//    |> JS.SetTimeout (fun () -> \n//        try\n//             let eval   s = JS.Apply window   \"eval\" [| s |]\n//             //printfn \"Evaluating...\"\n//             JS.Apply window   \"focus\" [|  |]\n//             eval js           |> success\n//        with e -> e.ToString() |> failure)\n//    |> ignore\n//\n//let runUrlJS url pos msgs js =\n//    sendMsg \"Running JavaScript...\"\n//    match pos with\n//    | NewBrowser -> evalWindowUrlJS url\n//    | _          -> evalIFrameJS\n//    <| (fun res  -> sendMsg \"Done!\"   ; sendMsg res ; sendMsg msgs) \n//    <| (fun res  -> sendMsg \"Failed!\" ; sendMsg res ; sendMsg msgs)\n//    <| js\n//\n//let processSnippet getCode msg processCode =\n//    CodeSnippet.FetchO currentCodeSnippetId.Value \n//    |> Option.iter (fun snp -> \n//        codeMsgs.Value <- msg\n//        codeJS.Value   <- \"\"\n//        let code = getCode snp\n//        codeFS.Value   <- code\n//        processCode       code\n//    )\n//\n//let compileSnippet fThen fFail = \n//    processSnippet (fun snp -> snp.GetCodeFsx true) \"Compiling to JavaScript...\" (RunCode.compile (fun msgs js -> codeJS.Value <- js ; fThen msgs js) fFail)\n//\n//let compileRunP pos = compileSnippet (runJS pos)                                         sendMsg\n//let compileRun  ()  = compileRunP           position.Value\n//let justCompile ()  = compileSnippet (fun msgs _ -> sendMsg \"Compiled!\" ; sendMsg msgs)  sendMsg\n\nlet reorderSnippet toId fromId =\n    let trySnippet id = tryPickI (fun (_, snp) -> snp.id = id) \n    let moving, others = codeSnippets.Value |> Seq.toArray |> Array.partition (fun snp -> snp.id = fromId || snp.IsDescendantOf fromId)\n    match trySnippet fromId moving, trySnippet toId others with\n    | Some(_, snp), Some(ti, tsn) ->\n        [| others.[0..ti - 1] ; moving ; others.[ti..] |]\n        |> Array.collect id\n        |> codeSnippets.Set\n        codeSnippets.UpdateBy (fun c -> Some { c with parent = tsn.parent }) snp.id\n    | _ -> ()\n    setDirtyPred()\n\nlet indentCodeIn () =\n    CodeSnippet.PickIO currentCodeSnippetId.Value\n    |> Option.iter (fun (j, snp) ->\n        let rec doPriorUntil f i =\n            if i < 0 then () else\n            if codeSnippets.Value |> Seq.item i |> f then () else\n            doPriorUntil f (i - 1)\n        j - 1 |> doPriorUntil (fun pri ->\n            if pri.parent = snp.parent \n            then codeSnippets.UpdateBy (fun c -> Some { c with parent = Some pri.id }) snp.id\n                 true\n            else false\n        )\n        setDirtyPred()\n    )\n\nlet indentCodeOut () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value\n    |> Option.iter (fun snp ->\n        let newP = snp.parent\n                   |> Option.bind CodeSnippet.FetchO\n                   |> Option.bind (fun p -> p.parent)\n        codeSnippets.UpdateBy (fun c -> Some { c with parent = newP }) snp.id\n        setDirtyPred()\n    )\n\nlet draggedId   = ref CodeSnippetId.New\n\n()","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"8efdcd5a-95c4-4212-9c75-1ebedce83dd8"},{"$":0,"Item":"a28fe808-236e-4b7e-9509-51ebe21e35fc"},{"$":0,"Item":"987560b0-1fe6-4835-ad99-aed93db7da1a"}],"id":{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Compile","content":"let compileSnippetW (snpO: CodeSnippet option) =\n    Wrap.wrapper {\n        let!   snp         = snpO |> Result.fromOption ``Snippet Missing``\n        outputMsgs.Value  <- \"Compiling to JavaScript...\"\n        codeJS.Value      <- \"\"\n        let    code        = snp.GetCodeFsx true\n        codeFS.Value      <- code\n        let!   jsR         = translateAR code false\n        let!   js          = jsR\n        let    jsc         = RunCode.completeJS js\n        codeJS.Value      <- jsc\n        addOutMsg            \"Compiled!\"\n        return jsc\n    }\n    \nlet newWindow url = \n    JS.Apply JS.Window \"open\"  [| url |]\n    |> function\n       | null   -> Result.fail    ``Could not open new browser, Popup blocker may be active``\n       | window -> Result.succeed window\n    \nlet eval  window js = try JS.Apply window \"eval\"  [| js  |]           with e -> printfn \"%A\" e ; sprintf \"%A\" e\nlet focus window    = try JS.Apply window \"focus\" [|     |] |> ignore with e -> printfn \"%A\" e\n\nlet evalWindowUrlJSW (url:string) js =\n    Wrap.wrapper {\n        do!    Result.tryProtection()\n        let!   window       = newWindow url\n        do     focus window\n        do!    Async.Sleep 800 \n        let    res : string = eval window js\n        return res\n    }\n\nlet createIFrameA () =\n    Async.FromContinuations\n        (fun (cb, errF: exn -> unit, canF: System.OperationCanceledException -> unit) ->\n            try\n                createIFrame cb |> RunCode.RunNode().RunHtml     \n            with e -> errF e\n        )\n\nlet evalIFrameJSW js =\n    Wrap.wrapper {\n        do!    Result.tryProtection()\n        let!   frame        = createIFrameA () \n        let    window       = frame?contentWindow\n        window?document?body?style?margin <- \"0px\"\n        let    res : string = eval window js\n        return res\n    }\n\nlet compileRunUrlW url pos snpO =\n    Wrap.wrapper {\n        let! js  = compileSnippetW snpO\n        outputMsgs.Value <-  \"Running JavaScript...\"\n        let! res = match pos with\n                   | NewBrowser -> evalWindowUrlJSW url js\n                   | _          -> evalIFrameJSW        js\n        addOutMsg res\n        addOutMsg \"Done!\"\n        return  pos, res\n    }\n\nlet getSnpO () = CodeSnippet.FetchO currentCodeSnippetId.Value\n\nlet evalCodeW (code: string) =\n    Wrap.wrapper {\n        codeFS.Value     <- code\n        let! resR         = evaluateAR fsIds JS.Window.Location.Href true code\n        let! res          = resR\n        return  \"\"\n    }\n\nlet evalSnippetW (snpO: CodeSnippet option) =\n    Wrap.wrapper {\n        let!   snp        = snpO |> Result.fromOption ``Snippet Missing``\n        let    code       = snp.GetCodeFsx true\n        let!   res        = evalCodeW code\n        do!    Evaluator.addPresence (sprintf \"%A\" snp.id) \"ok\"\n        return res\n    }\n    \nlet doSomething msgStart msgFinish (doIt: unit -> Wrap<_>) = \n    Wrap.wrapper {\n        outputMsgs.Value <- msgStart // \"Evaluating F# code...\"\n        let! res          = doIt()\n        addOutMsg res\n        addOutMsg msgFinish          //\"Done!\"\n        return  res\n    }\n\nlet evaluateSnippetW snpO = doSomething \"Evaluating F# code...\" \"\" (fun () -> evalSnippetW snpO)\nlet evaluateCodeW    code = doSomething \"Evaluating F# code...\" \"\" (fun () -> evalCodeW    code)\n\nlet ToConsoleF arg = \n    Console.Log arg\n    arg?cont addOutMsg\n    \nFableModule.addOutMsg <- addOutMsg \n\nlet evalFableCodeW code =\n    Wrap.wrapper {\n        codeFS.Value     <- code\n        let! jsc          = FableModule.fableTranslate code\n        codeJS.Value     <- jsc\n        JS.Eval jsc |> ignore\n        return \"\"\n    }\n\nlet evalFableSnippetW (snpO: CodeSnippet option) =\n    Wrap.wrapper {\n        let!   snp        = snpO |> Result.fromOption ``Snippet Missing``\n        let    code       = snp.GetCodeFsx false\n        return!             evalFableCodeW code\n    }\n\nlet fableSnippetW snpO = doSomething \"Running Fable...\" \"Done!\" (fun () -> evalFableSnippetW snpO)\nlet fableCodeW    code = doSomething \"Running Fable...\" \"Done!\" (fun () -> evalFableCodeW    code)\n\n\nlet compileRunW = compileRunUrlW (JS.Window.Location.Origin + \"/Main.html\") \n\nlet compileRunP pos = getSnpO() |> compileRunW pos  //|> Wrap.map ignore |> Wrap.start addOutMsg\nlet justCompile     = getSnpO   >> compileSnippetW  //>> Wrap.map ignore >> Wrap.start addOutMsg\nlet evaluateFS      = getSnpO   >> evaluateSnippetW //>> Wrap.map ignore >> Wrap.start addOutMsg\nlet fableFS         = getSnpO   >> fableSnippetW\nlet compileRun  ()  = compileRunP position.Value\n\n()","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"},{"$":0,"Item":"dca77d6a-5c2c-4c3e-9bef-14f0464f9ada"},{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"},{"$":0,"Item":"afaac2af-143d-4745-9447-7e8d3044950f"},{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"3f2ec5e2-8ab6-4e5b-bb89-1943ed3a4964"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Snippet List","content":"let isDirectPredecessor pre curO =\n    curO\n    |> Option.map (fun snp -> snp.predecessors |> List.contains pre)\n    |> Option.defaultValue false\n\n\nlet curPredecessors = Val.map getPredecessorsM.Call currentCodeSnippetO\n\nlet isIndirectPredecessor pre (predecessors: HashSet<CodeSnippetId>) = predecessors.Contains pre //predecessors |> Set.contains pre\n\n//let isIndirectPredecessorT (preId, curId) = getPredecessors curId |> Set.contains preId            // horrible performance\n//let isIndirectPredecessorM  preId  curId  = (Useful.memoize isIndirectPredecessorT) (preId, curId) // horrible performance\n\nlet togglePredecessorForCur (pre:CodeSnippet) curO =\n    curO |> Option.iter (fun cur ->\n        if cur = pre || isIndirectPredecessor cur.id (pre.UniquePredecessors CodeSnippet.FetchO |> HashSet) then () else\n        let preds = \n            if cur.predecessors |> List.contains pre.id\n            then List.filter ((<>) pre.id)\n            else fun l -> pre.id :: l\n            <| cur.predecessors\n        codeSnippets.UpdateBy  (fun c -> Some { c with predecessors = preds }) cur.id\n        setDirtyPred()\n    )\n\nlet toggleExpanded snp =\n    codeSnippets.UpdateBy  (fun c -> Some { c with expanded = not c.expanded }) snp.id\n    refreshView()\n\nlet listEntry isParent isExpanded code =\n    Template.Hoverable.New\n        .Content( [ ``class`` \"code-editor-list-tile\"\n                    classIf   \"selected\"              <| Val.map ((=)                    code.id) currentCodeSnippetId\n                    classIf   \"direct-predecessor\"    <| Val.map (isDirectPredecessor    code.id) currentCodeSnippetO\n                    classIf   \"indirect-predecessor\"  <| Val.map (isIndirectPredecessor  code.id) curPredecessors\n                    draggable \"true\"\n                    SomeAttr <| on.dragOver(fun _ ev -> ev.PreventDefault()                                               )\n                    SomeAttr <| on.drag    (fun _ _  ->                                               draggedId := code.id)\n                    SomeAttr <| on.drop    (fun _ ev -> ev.PreventDefault() ; reorderSnippet code.id !draggedId           )\n                    span    [ ``class`` \"node\"\n                              classIf   \"parent\"   isParent\n                              classIf   \"expanded\" isExpanded\n                              SomeAttr <| on.click(fun _ _ -> if isParent then toggleExpanded code)\n                              title    <| if isParent then (if isExpanded then \"collapse\" else \"expand\") else \"\"\n                              htmlText <| if isParent then (if isExpanded then \"-\"        else \"+\"     ) else \"\"\n                            ]\n                    div     [ ``class`` \"code-editor-list-text\"\n                              style1 \"text-indent\" (code.Levels |> fst |> sprintf \"%dem\")\n                              style  \"white-space: pre\"\n                              htmlText <| Val.map2 snippetName (curSnippetNameOf code.id) (curSnippetCodeOf code.id)\n                              SomeAttr <| on.click (fun _ _ -> currentCodeSnippetId.Value <- code.id)\n                            ]\n                    span    [ ``class``   \"predecessor\"\n                              title       \"toggle predecessor\"\n                              SomeAttr <| on.click(fun _ _ -> Val.iter (togglePredecessorForCur code) currentCodeSnippetO)\n                              htmlText    \"X\"\n                            ]\n                    ])\n\nlet topScrollList = ref 0.0\n\nlet listEntries snps =\n    let list =\n      div [ \n        yield style \"overflow: auto\"\n        yield! \n            snps\n            |> Seq.indexed\n            |> Seq.mapFold (fun expanded (i, snp) ->\n                if snp.parent |> Option.map (fun p -> Set.contains p expanded) |> Option.defaultValue true then \n                    let isParent    = codeSnippets |> Seq.tryItem (i + 1) |> Option.map (fun nxt -> nxt.parent = Some snp.id) |> Option.defaultValue false\n                    let isExpanded  = isParent && snp.expanded\n                    (listEntry isParent isExpanded snp |> Some, if isExpanded then Set.add snp.id expanded else expanded)\n                else  (None, expanded)\n            )  (Set [])\n            |> fst\n            |> Seq.choose id\n        yield SomeAttr <| on.scroll      (fun e _ -> topScrollList :=  e.ScrollTop   )\n        yield SomeAttr <| on.afterRender (fun e   -> e.ScrollTop   <- !topScrollList )\n      ]\n    list\n\n()    ","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"},{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}],"id":{"$":0,"Item":"93f32df7-da8b-472f-8bad-e82cc58ec52b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Deserialize","content":"let inline ifUndef def v = if isUndefined v then def else v\nlet obj2CodeSnippetId o = \n    if isUndefined o then\n        System.Guid(\"00000000-0000-0000-0000-000000000000\")\n    else\n        o?Item\n    |> CodeSnippetId \n\nlet obj2CodeSnippetIdO o = // the json representation of an option is different from the internal representation\n    if isUndefined o then\n        None\n    else\n        Some <| obj2CodeSnippetId o\n\nlet obj2Map o =\n    let dict = System.Collections.Generic.Dictionary<string, string>()\n    if isUndefined o then\n        dict\n    else\n        JS.GetFields o |> Array.map (fun (f, v) -> f, v :?> string ) |> Seq.iter dict.Add\n        dict\n\nlet deserializeCodeSnipets v = \n    try\n        let objs= WebSharper.Json.Parse v |> unbox<obj[]>\n        printfn \"%A\" <| Array.length objs\n        let snps =\n            objs\n            |> Array.choose (fun o ->\n                 if isUndefined o then None else\n                 {\n                    name         = o?name         |> ifUndef \"\"\n                    content      = o?content      |> ifUndef \"\"\n                    parent       = o?parent       |> obj2CodeSnippetIdO\n                    predecessors = o?predecessors |> ifUndef [||] |> Array.map  obj2CodeSnippetId |> Seq.toList\n                    id           = o?id           |> obj2CodeSnippetId\n                    expanded     = o?expanded     |> ifUndef false\n                    level        = o?level        |> ifUndef 0\n                    levelCode    = o?levelCode    |> ifUndef 0\n                    properties   = o?properties   |> obj2Map\n                  } |> Some)\n        snps\n    with _ -> [||]\n    \n()    ","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}],"id":{"$":0,"Item":"54304360-819a-498c-a091-e6ece880a35a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Add,Delete,Load,Save","content":"let addCode   ()   =\n    CodeSnippet.PickIO currentCodeSnippetId.Value\n    |> Option.map (fun (i, snp) ->\n        let rec nextI lvl k =\n            codeSnippets.Value \n            |> Seq.tryItem k \n            |> Option.map (fun s -> if (fst s.Levels) <= lvl then k else nextI lvl (k + 1) ) \n            |> Option.defaultValue k\n        CodeSnippet.New(nextI (fst snp.Levels) (i + 1), \"\", snp.parent, [], [], \"\"))\n    |> Option.defaultWith (fun _ -> CodeSnippet.New \"\")\n    |> fun n -> currentCodeSnippetId.Value <- n.id\n    setDirty()\n    refreshView()\n\n\nlet deleteCode () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value\n    |> Option.iter (fun snp -> \n        if JS.Confirm (sprintf \"Do you want to delete %s?\" snp.Name) then\n            currentCodeSnippetId.Value <- CodeSnippetId.New\n            codeSnippets.Remove snp\n            setDirty()\n            refreshView()\n    )\n    \nlet justFileName (f:string) = f.Split [| '/' ; '\\\\' |] |> Seq.last\n\nlet fileName  = Var.Create \"\"\nlet emptyFile = Val.map (fun v -> v = \"\") fileName\n\nlet loadTextFile element (f: string -> unit) =\n    let files = element |> FileList.OfElement \n    if files.Length > 0 then\n        let  reader  = TextFileReader()\n        reader.Onload <- (fun e -> f e.Target?result)\n        reader.ReadAsText files.[0] \n\nlet parseText txt =\n    try\n        txt\n        |> deserializeCodeSnipets\n        |> codeSnippets.Set\n        setClean()\n        refreshView()\n    with e -> JS.Alert <| e.ToString()\n\nlet fileInputElementId = \"CodeEditorFileSel\"\nlet loadFile (e: Dom.Element) =\n    if (not dirty.Value) || JS.Confirm \"Changes have not been saved, do you really want to load?\" then\n      let root = findRootElement e\n      loadTextFile \n          <| root.QuerySelector(\"#\" + fileInputElementId)\n          <| parseText\n\nlet downloadFile() = // Save as...\n    codeSnippets.Value\n        |> Seq.toArray\n        |> Json.Serialize\n        |> saveAs <| match justFileName fileName.Value with | \"\" -> \"snippets.fsjson\" | fname -> fname\n    setClean()\n\nlet loadFileElement =\n    Template.Input.New(fileName.Lens justFileName (fun prev n -> prev) )\n        .Prefix( label [ ``class`` \"btn btn-primary\" ; htmlText \"Load File...\" \n                         Template.Input.New(fileName)\n                                 .Type(\"file\")\n                                 .Style(\"display: none\")\n                                 .Content([ on.change (fun el _ -> loadFile el   )\n                                            on.click  (fun el _ -> el?value <- \"\")\n                                          ])\n                                 .Id(fileInputElementId)\n                                 .Render \n                        ]\n                )\n                \nlet do_LoadFile (e:Dom.Element) _ =          \n    let root = findRootElement e\n    (root.QuerySelector(\"#\" + fileInputElementId))?click()\n\nif loadFromUri <> \"\" then\n    async {\n        do! Async.Sleep 3000\n        printfn \"loading %s...\" loadFromUri\n        let  r = JQuery.JQuery.GetJSON(loadFromUri + \"?t=\" + (now() |> string))\n        r.Done (fun () -> parseText r.ResponseText) |> ignore\n    } |> Async.Start\n    \n    ","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"54304360-819a-498c-a091-e6ece880a35a"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}],"id":{"$":0,"Item":"60191ea0-da20-4fbf-96b8-3871338a66d8"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"codeMirror","content":"let autoCompleteClient = FSAutoCompleteIntermediary.FSAutoCompleteIntermediaryClient(\"FSharpStation\", endPoint = JS.Window.Location.Href)\n\n#if FSS_SERVER\nlet parseFileName = fsIds + \".fsx\"\n#else\nlet parseFileName = \"..\\\\\" + fsIds + \".fsx\"\n#endif\n\nlet mutable latestParsedPrefix = \"a\"\nlet nextParsedPrefix() = if latestParsedPrefix = \"a\" then \"b\" else \"a\"\nlet parseFile prefix = prefix + parseFileName\n\nlet setDirtyCond() =\n    match lastCodeAndStarts with\n    | Some (pId, _, red) when pId = currentCodeSnippetId.Value -> setDirtyPart()\n    | _                                                        -> setDirty    ()\n\nlet isParseDisabled = disableParseVal |> Val.toView |> View.GetAsync\n\nlet getCodeAndStartsFast (snp:CodeSnippet) addLinePrepos =\n    let redO, cur = \n        match lastCodeAndStarts with\n        | Some (pId, alp, redO) when pId = snp.id && alp = addLinePrepos -> redO, snp.PrepareSnippet\n        | _ -> \n        let preds = snp.Predecessors()        \n        let redO  = if preds.Length = 1 then None else CodeSnippet.ReducedCode addLinePrepos preds.[0..preds.Length - 2] |> Some\n        let cur   = preds.[preds.Length - 1]\n        lastCodeAndStarts <- Some(cur.id, addLinePrepos, redO)\n        redO, cur\n    let red1 = CodeSnippet.ReducedCode addLinePrepos [| cur |]\n    redO\n    |> Option.map (fun red0 -> CodeSnippet.AddSeps red0 red1)\n    |> Option.defaultValue red1\n    |> CodeSnippet.FinishCode addLinePrepos\n\nlet mutable parseIn     = 0\nlet mutable parseOut    = 0\nlet mutable parsingCode = \"\"\n\nlet rec parseRecFSA silent reparse =\n    async {\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        let  code, starts  = getCodeAndStartsFast cur false\n        if code <> parsingCode || (parseIn = parseOut && reparse) then\n           try\n              parsed             <- false\n              parseIn            <- parseIn + 1\n              let prefix          = nextParsedPrefix()\n              printfn \"Parsing %s\" prefix\n              if not silent then parserMsgs.Set \"Parsing...\"\n              parsingCode        <- code\n              let! res            = autoCompleteClient.Parse(parseFile prefix, code, starts)\n              latestParsedPrefix <- prefix\n              if not silent then\n                  parserMsgs.Set  \"Parsed!\"\n                  addPrsMsg res\n              parsed             <- true\n              printfn \"Parse result= %A\" (res <> \"\")\n           finally\n              parseOut <- parseOut + 1\n           if parseIn = parseOut then\n              do! parseRecFSA silent false\n    }\n\nlet parseFSA silent = parseRecFSA silent true\n\n\nlet parseFS() = \n    Wrap.wrapper {\n        lastCodeAndStarts <- None\n        do! parseFSA false\n    }\n\nlet mustParse (cur:CodeSnippet) =\n    async {\n        if not parsed then return true \n        else\n            let! must = autoCompleteClient.MustParse(parseFile latestParsedPrefix, cur.NameSanitized)\n            return must\n    }\n\nlet parseIfMustThen silent =\n    async {\n        let! disabled = isParseDisabled \n        if disabled then () else\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        let! must = mustParse cur\n        if must then \n            do! parseFSA silent\n    }\n\nlet getStartWord (line:string) ch =\n    match line.Substring(0, ch) with\n    | REGEX @\"([a-zA-Z_]\\w*)$\" \"g\" [| txt |] -> txt\n    | _                                      -> \"\"          \n\nlet getEndWord (line:string) ch =\n    match line.Substring(ch) with\n    | REGEX @\"^([a-zA-Z_]\\w*)\" \"g\" [| txt |] -> txt\n    | _                                      -> \"\"          \n\nlet showToolTip (ed:Template.CodeMirrorEditor) =\n    async {\n        let! disabled = isParseDisabled \n        if disabled then () else\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        do!  parseIfMustThen false\n        let  pos   = ed.GetCursor()\n        let  l     = ed.GetLine pos.line\n        let  sub   = (getStartWord l pos.ch |> String.length)   \n        let  add0  = (getEndWord   l pos.ch |> String.length)    \n        let  add   = if sub = 0 && add0 = 0 then 2 else add0 \n        let! tip   = autoCompleteClient.ToolTip  (parseFile latestParsedPrefix, pos.line + 1, pos.ch + 1, cur.NameSanitized)\n        addPrsMsg <| sprintf \"InfoFSharp \\\"%s %A - %A %s \\\"\" cur.NameSanitized (pos.line + 1, pos.ch - sub + 1) (pos.line + 1, pos.ch + add + 1) (tip.Replace(\"\\\"\",\"''\"))\n    } |> Async.Start\n\nlet rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\"\"\"\nlet rex2 = \"\"\"(Err|Warning|Info)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) ?)?F?#? ?(.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\nlet rex = rex1 + \"|\" + rex2\n\nlet getAnnotations (txt, cb, _, ed:Template.CodeMirrorEditor) =\n    async {\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        printfn \"calling parseIfMustThen\"\n        do!  parseIfMustThen false\n        match parserMsgs.Value with\n        | REGEX rex \"g\" m -> m\n        | _               -> [||]\n        |> Array.choose (fun v ->\n            match v with\n            | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, indent, int fl, int fc    , int tl, int tc, sev, from , msg)\n            | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, indent, int fl, int fc - 1, int fl, int fc, sev, \"fsi\", msg)\n            | _ -> None\n        )\n        |> Array.choose (fun (file, indent, fl, fc, tl, tc, sev, from, msg) ->\n            if file.StartsWith cur.id.Text || file = sanitize cur.name then\n                let ind = if int indent > 0 then int indent else 0\n                { Template.LintResponse.message  = msg\n                  Template.LintResponse.severity = (if sev.ToUpper().StartsWith(\"ERR\") then \"error\" elif sev.ToUpper().StartsWith(\"INFO\") then \"info\" else \"warning\")\n                  Template.LintResponse.from     = Template.cmPos(fl - 1, fc - 1 - ind) \n                  Template.LintResponse.``to``   = Template.cmPos(tl - 1, tc - 1 - ind)\n                } |> Some\n            else     None\n          )        \n        |> cb\n    } |> Async.Start\n\nlet asyncStartDelayed = asyncStartCancelling()\nlet getAnnotationsDelayed parms =\n    //async {\n    //    printfn \"before delaying\"\n    //    do! Async.Sleep 400\n    //    printfn \"calling getAnnotations\"\n        do getAnnotations parms\n    //} |> asyncStartDelayed \n\nlet getSymbolType chr =\n    match chr with\n    | \"C\"   -> \"class\"     \n    | \"Cn\"  -> \"Constant\"  \n    | \"D\"   -> \"delegate\"  \n    | \"E\"   -> \"enum\"      \n    | \"P\"   -> \"property\"  \n    | \"e\"   -> \"event\"     \n    | \"X\"   -> \"exception\" \n    | \"F\"   -> \"field\"     \n    | \"I\"   -> \"interface\" \n    | \"M\"   -> \"function\"    \n    | \"N\"   -> \"module\"    \n    | \"S\"   -> \"struct\"    \n    | \"T\"   -> \"type\"      \n    | \"V\"   -> \"Variable\"  \n    | _     -> chr\n\nlet getHints (ed:Template.CodeMirrorEditor, cb, _) =\n    async {\n        let! disabled = isParseDisabled\n        printfn \"getHints (Complete) %A\" disabled\n        if disabled then () else\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        //do!  parseIfMustThen true\n        let  pos    = ed.GetCursor()\n        let  l      = ed.GetLine pos.line\n        let  word   = getStartWord l pos.ch\n        let! com    = autoCompleteClient.Complete(parseFile latestParsedPrefix, l + \"a\", pos.line + 1, pos.ch + 1, cur.NameSanitized)\n        cb { Template.list   = com \n                               |> Array.map (fun (dis, rep, cls, chr) -> \n                                    { text        = rep\n                                      displayText = (sprintf \"%-40s %20s\" dis (getSymbolType chr))\n                                      className   = cls                              \n                                    })\n             Template.from   = { pos with ch = pos.ch - word.Length }\n             Template.``to`` = pos \n           }\n    } |> asyncStartDelayed\n    \nlet codeMirror = \n    Template.CodeMirror.New(Val.bindIRef curSnippetCodeOf currentCodeSnippetId)\n        .OnChange(setDirtyCond)\n        .OnRender(fun ed ->\n          ed.AddKeyMap({  F2              = showToolTip            \n                          LeftDoubleClick = showToolTip\n                          ``Ctrl-Space``  = Template.showHints ed getHints false\n                          ``.``           = (fun _ -> ed.ReplaceSelection(\".\", \"end\"))\n                                            >> Template.showHints ed getHints false\n                       })\n          Template.setLint ed getAnnotationsDelayed \n          Val.sink (fun v ->\n              async {\n                  ed.SetOption(\"theme\", v)\n                  do! Async.Sleep(50)\n                  ed.Refresh()\n              } |> Async.Start\n              ) propertyThemeVal \n          Val.sink (fun v -> ed.SetOption(\"mode\" , v)) propertyModeVal \n        )\n        .Style(\"height: 100%\")\n\nlet rec expandParents snp = \n    snp.parent\n    |> Option.bind CodeSnippet.FetchO\n    |> Option.iter (fun me -> \n        expandParents me\n        if not me.expanded then toggleExpanded me)\n\nlet goto codeId line col =\n    async {\n        currentCodeSnippetId.Value <- codeId\n        CodeSnippet.FetchO codeId |> Option.iter expandParents\n        do! Async.Sleep 200\n        codeMirror.editorO \n        |> Option.iter (fun ed -> \n            ed.SetCursor(line - 1, col - 1) \n            ed.Focus()\n        )\n    } |> Async.Start\n\nlet rexGuid = \"\"\"([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}).+?\\((\\d+)\\,\\s*(\\d+)\\)\"\"\"\n\nlet jumpToLine (line:string) = \n    match line with\n    | REGEX rexGuid \"\" [| _ ; guid ; line ; col |] -> goto <| CodeSnippetId (System.Guid guid) <| int line <| int col\n    | _                                            -> ()\n\nlet gotoDefinition () =\n    async {\n        match CodeSnippet.FetchO currentCodeSnippetId.Value, codeMirror.editorO with \n        | _       , None     \n        | None    , _       -> ()\n        | Some cur, Some ed ->\n        let  pos   = ed.GetCursor()\n        let  l     = ed.GetLine pos.line\n        let! kind  = autoCompleteClient.FindDecl(parseFile latestParsedPrefix, pos.line + 1, pos.ch + 1, cur.NameSanitized)\n        match kind with\n        | FSAutoCompleteIntermediary.CommTypes.KFindDecl decl -> jumpToLine <| sprintf \"%s (%d, %d) - (%d, %d)\" decl.File decl.Line decl.Column decl.Line decl.Column\n        | FSAutoCompleteIntermediary.CommTypes.KError    err  -> JS.Alert   <| sprintf \"%A\" err\n        | _                                                   -> JS.Alert   <| sprintf \"%A\" kind\n    } |> Async.Start\n\nlet refreshCodeMirror() = codeMirror.editorO |> Option.iter (fun cm -> cm.Refresh())\n\nlet delayedRefreshCM delay =\n    async {\n        do! Async.Sleep delay\n        refreshCodeMirror() \n    } |> Async.Start\n    \nlet codeMirrorRender = \n    codeMirror.Render.AddChildren [ \n        SomeAttr <| on.dblClick (fun _ _ -> showToolTip codeMirror.editorO.Value)  \n        htmlElement     \"menu\" [  // does not work anymore. support for this was dropped by Chrome\n            ``type``    \"context\"\n            Id          \"right-menu\"\n            htmlElement \"menuitem\" [ \n                htmlAttribute \"label\" \"Goto Definition\"\n                SomeAttr <| on.click (fun _ _ -> gotoDefinition() )  \n            ] \n        ]\n        htmlAttribute \"contextmenu\" \"right-menu\"\n    ]\n\nparserMsgs\n|> Val.sink (fun msgs ->\n    async {\n        if not parsed then () else\n        match codeMirror.editorO  with\n        | None    -> () \n        | Some ed ->\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        //let! must = autoCompleteClient.MustParse(parseFile latestParsedPrefix, cur.NameSanitized)\n        //if must       then do! Async.Sleep 400\n        ed?performLint() |> ignore\n    } |> Async.Start      \n)\n//let mutable prior = \"\", \"\"\n//Val.map2 (fun msgs curO -> msgs, curO) codeMsgs currentCodeSnippetO\n//|> Val.sink (fun (msgs, curO) ->\n//    async {\n//        match codeMirror.editorO  with\n//        | None        -> () \n//        | Some editor ->\n//            match curO with \n//            | None -> () \n//            | Some cur ->\n//            curSnippetNameOf cur.id\n//            |> Val.iter (fun name ->\n//                printfn \"RemoveMarks: %s\" name\n//                if prior = (msgs, name) then () else\n//                prior   <- (msgs, name)\n//                editor.RemoveMarks()\n//                match msgs with\n//                | REGEX rex \"g\" m -> m\n//                | _               -> [||]\n//                |> Array.choose (fun v ->\n//                    match v with\n//                    | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, int fl, int fc - int indent    , int tl, int tc - int indent, sev, from , msg)\n//                    | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, int fl, int fc - int indent - 1, int fl, int fc - int indent, sev, \"fsi\", msg)\n//                    | _ -> None\n//                )\n//                |> Array.iter (fun (file, fl, fc, tl, tc, sev, from, msg) ->\n//                    printfn \"inside -%s-%s-\" file (sanitize name)\n//                    if file.StartsWith cur.id.Text || file = sanitize name then\n//                        100\n//                        |> JS.SetTimeout (fun () ->\n//                            editor.MarkText (fl - 1, fc - 1) (tl - 1, tc - 1) (if sev.ToUpper().StartsWith(\"ERR\") then \"Error\" else \"Warning\")  msg)\n//                        |> ignore\n//    \n//                )\n//            )\n//    } |> Async.Start\n//)\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"ece85c79-829d-4bec-a607-a1cd01f9dafa"},{"$":0,"Item":"93f32df7-da8b-472f-8bad-e82cc58ec52b"},{"$":0,"Item":"466e6783-0751-48d5-b79b-165aaa7d2173"},{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"},{"$":0,"Item":"18d8153d-422c-42f6-8266-9a9d854bd6a1"},{"$":0,"Item":"a05dd36e-a15e-4394-8013-128e21e69574"},{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"id":{"$":0,"Item":"47f7c0ba-35b0-466e-a759-4e4d9963e524"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"let styleEditor =\n     \"\"\"\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"id":{"$":0,"Item":"fa5b4506-b26d-4387-8e04-ac7a5a90861a"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"1"}},{"name":"CSS","content":"body { margin: 0px }     \n     \ndiv textarea {\n    font-family     : monospace;\n}\n.code-editor-list-tile {\n    white-space     : nowrap; \n    border-style    : solid none none;\n    border-color    : white;\n    border-width    : 1px;\n    background-color: #D8D8D8;\n    display         : flex;\n}\n.code-editor-list-text{\n    padding         : 1px 10px 1px 5px;\n    overflow        : hidden;\n    text-overflow   : ellipsis;\n    white-space     : nowrap;\n    flex            : 1;\n}\n\n.code-editor-list-tile.direct-predecessor {\n    font-weight     : bold;\n}\n.code-editor-list-tile.indirect-predecessor {\n    color           : blue;\n}\n.code-editor-list-tile.selected {\n    background-color: #77F;\n    color           : white;\n}\n.code-editor-list-tile.hovering {\n    background      : lightgray;\n}\n.code-editor-list-tile.hovering.selected {\n    background      : blue;\n}\n.code-editor-list-tile>.predecessor {\n    font-weight     : bold;\n    border-style    : inset;\n    border-width    : 1px;\n    text-align      : center;\n    color           : transparent;\n}\n.code-editor-list-tile.direct-predecessor>.predecessor {\n    color           : blue;\n}\n\n.CodeMirror { height: 100%; }\n\n.node {\n    background-color: white; \n    width           : 2ch; \n    color           : #A03; \n    font-weight     : bold; \n    text-align      : center;\n    font-family     : arial;\n}\n.Warning { text-decoration: underline lightblue } \n.Error   { text-decoration: underline red       } \n.body    { margin         : 0px                 }","parent":{"$":0,"Item":"fa5b4506-b26d-4387-8e04-ac7a5a90861a"},"predecessors":[],"id":{"$":0,"Item":"78648685-ff9c-4dc6-800a-3285f135dec4"},"expanded":true,"level":0,"levelCode":0,"properties":{"Theme":"bespin","Mode":"css","NoLinePre":"1"}},{"name":"","content":"\"\"\"","parent":{"$":0,"Item":"fa5b4506-b26d-4387-8e04-ac7a5a90861a"},"predecessors":[{"$":0,"Item":"78648685-ff9c-4dc6-800a-3285f135dec4"}],"id":{"$":0,"Item":"aeb92943-97ea-4297-9097-926410e9d10f"},"expanded":true,"level":0,"levelCode":0,"properties":{"NoLinePre":"1"}},{"name":"Properties","content":"//let setProp k v = props.[k] <- v\n\nlet redraw = Var.Create ()\nlet setDirtyP () = dirty.Value <- true\nlet getProperty props key   = Property(setDirtyP, props, key) \nlet setProperty props key v = ((getProperty props key).ValueVar :> Var<_>).Set v\n\nlet tableProps =\n  currentCodeSnippetId\n  |> Val.bind (curSnippetPrpsOf >> DynamicV)\n  |> Val.map2 (fun () (props: Dictionary<string,string>) ->\n      table [\n        yield thead [\n            th [ htmlText \"Property\" ; style \"padding-right:10px\" ] \n            th [ htmlText \"Value\"                                 ] \n        ] \n        yield! \n            props.Keys\n            |> Seq.sort\n            |> Seq.map (fun kvp ->\n                let prop = getProperty props kvp\n                tr [\n                    td [ Doc.Input     [                             ] prop.KeyVar   |> someElt ] \n                    td [ Doc.InputArea [ atr \"style\" \"height: 1.5em\" ] prop.ValueVar |> someElt ] \n                    td [ title \"remove\" ; style \" cursor: pointer \"\n                         htmlText \"x\" ; SomeAttr <| on.click (fun _ _ ->  prop.Remove()                    ; redraw.Value <- () ) ] |> hoverable\n                ])\n        yield tr [\n            td [ htmlText \"Add...\"    ; SomeAttr <| on.click (fun _ _ ->  props.Add(\"\", \"1\") ; setDirtyP() ; redraw.Value <- () ) ] |> hoverable\n            td [ htmlText \"\"    ] \n        ]\n      ]\n  ) redraw\n\nlet properties =\n    div [\n      HtmlElementV tableProps\n      css \"\"\" td.hovering { background: gray; } \"\"\"\n    ]\n\n()","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"93f32df7-da8b-472f-8bad-e82cc58ec52b"},{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}],"id":{"$":0,"Item":"7cdba50e-5de9-4377-a7fc-705df0d909fa"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Actions","content":"let triggerWSResult = Var.Create ()\n\nlet DoW  f p   _ _ = f p   |> Wrap.map ignore |> Wrap.start addOutMsg\nlet DoP  f p   _ _ = f p   |> Wrap.startV (function\n                                           | Some (Below, _), msgs -> msgs               |> addOutMsg ;  triggerWSResult.Value <- ()\n                                           | Some _         , msgs -> msgs               |> addOutMsg \n                                           | None           , msgs -> \"Failed!\\n\" + msgs |> addOutMsg)\n\nlet DoW2 f p t     = DoW (fun p' -> f t p') p\nlet DoP2 f p t     = DoP (fun p' -> f t p') p\n\nlet getSnippet     (act: Action) =\n    match act.parms with\n    | Some [| path |] -> path |> unbox<string> |> (fun s -> s.Split '/') |> CodeSnippet.FetchByPathO \n    | _               -> getSnpO()\n\nlet getCodeFromAct (act: Action) addOpen = \n    Wrap.wrap {\n        let! text = Val.getAsync act.text\n        setOutMsg (text + \"...\")\n        let snpO = getSnpO()\n        let propValue p = snpO |> Option.bind (fun snp -> snp.propValue p)\n        let openPre     = if addOpen then propValue \"open\" |> Option.map (__ (+) \"\\n\") |> Option.defaultValue \"\" else \"\"\n        let actionTempl = lazy (propValue \"action-template\" |> Option.defaultValue \"${parm}() |> printfn \\\"%A\\\"\")\n        let code =\n            act.parms\n            |> Option.map (Array.map unbox<string>)\n            |> function\n               | Some [| \"Code\"     ; code |] -> code |> Some\n               | Some [| \"Property\" ; prop |] -> prop |> propValue \n               | _                            -> None\n            |> Option.orElseWith  (fun () -> text |> propValue                           )\n            |> Option.defaultWith (fun () -> text |> translateTemplate actionTempl.Value )\n            |> (fun code -> if code.StartsWith \"////\" then code else openPre + code)\n        match snpO with\n        | None     -> return code\n        | Some snp -> let! presence = Evaluator.getPresence (Evaluator.extractConfig code) (sprintf \"%A\" snp.id) \n                      if presence = Some \"ok\" then return code else\n                      let! r = evalSnippetW snpO\n                      return code\n                      \n    }\n\nlet evalFsCode    (act: Action) () = getCodeFromAct act true  |> Wrap.bind evaluateCodeW\nlet evalFableCode (act: Action) () = getCodeFromAct act false |> Wrap.bind fableCodeW\nlet evaluateFS2   (act: Action) () = getSnippet     act       |>           evaluateSnippetW\nlet fableFS2      (act: Action) () = getSnippet     act       |>           fableSnippetW\nlet compileRunP2  (act: Action) p  = getSnippet     act       |>           compileRunW p\nlet setSnippetProp(act: Action) () =\n    Wrap.wrapper {\n        do!  Result.tryProtection()\n        let! res = \n            match act.parms with\n            | Some [| opth ; oprp; ov |] -> let path, prop, v = unbox<string> opth, unbox<string> oprp, unbox<string> ov\n                                            path.Split '/'\n                                            |> CodeSnippet.FetchByPathO \n                                            |> Option.map (fun snp -> setProperty snp.properties prop v)\n                                            |> Option.defaultWith (fun () -> printfn \"setSnippetProp snippet not found: %s\" path)\n                                            |> Result.succeed\n            | _                          -> sprintf \"setSnippetProp wrong parms: %A\" act.parms |> Result.failSimpleError\n        return res\n    }\n    \nlet showOutText (act: Action) () = \n    printfn \"showOutText: %A\" act\n    match act.parms with\n    | Some [|       txt |]                      -> setOutMsg <| unbox txt\n    | Some [| cmd ; txt |] when unbox cmd = \"\"  -> setOutMsg <| unbox txt\n    | Some [| cmd ; txt |] when unbox cmd = \"+\" -> addOutMsg <| unbox txt\n    | _                                         -> printfn \"error: showOutText %A\" act\n\nlet actLoadFile       = Template.Action.New(\"Load...\"                    ).OnClick( do_LoadFile                    )  \nlet actSaveFile       = Template.Action.New(\"Save as...\"                 ).OnClick( Do   downloadFile      ()      ).Highlight(dirty)\nlet actAddSnippet     = Template.Action.New(\"Add Snippet\"                ).OnClick( Do   addCode           ()      )\nlet actDeleteSnippet  = Template.Action.New(\"Delete Snippet\"             ).OnClick( Do   deleteCode        ()      ).Disabled(noSelectionVal      )\nlet actIndentSnippet  = Template.Action.New(\"Indent In  >>\"              ).OnClick( Do   indentCodeIn      ()      ).Disabled(noSelectionVal      )\nlet actOutdentSnippet = Template.Action.New(\"Indent Out <<\"              ).OnClick( Do   indentCodeOut     ()      ).Disabled(noSelectionVal      )\nlet actGetFsCode      = Template.Action.New(\"Get F# Code\"                ).OnClick( Do   getFSCode         ()      ).Disabled(disableParseVal     )\nlet actSetSnippetProp = Template.Action.New(\"actSetSnippetProp\"          ).OnClick2(DoW2 setSnippetProp    ()      ).Disabled(disableFSIVal       )\nlet actEvalFsCode     = Template.Action.New(\"Run FSI on Code\"            ).OnClick2(DoW2 evalFsCode        ()      ).Disabled(disableFSIVal       )\nlet actEvalCode       = Template.Action.New(\"Run FSI\"                    ).OnClick2(DoW2 evaluateFS2       ()      ).Disabled(disableFSIVal       )\nlet actFableFsCode    = Template.Action.New(\"Run Fable on Code\"          ).OnClick2(DoW2 evalFableCode     ()      ).Disabled(disableFableVal     )\nlet actFableCode      = Template.Action.New(\"Run Fable\"                  ).OnClick2(DoW2 fableFS2          ()      ).Disabled(disableFableVal     )\nlet actRunWSNewTab    = Template.Action.New(\"Run WebSharper in new tab\"  ).OnClick2(DoW2 compileRunP2   NewBrowser ).Disabled(disableWebSharperVal)\nlet actRunWSHere      = Template.Action.New(\"Run WebSharper in WS Result\").OnClick2(DoP2 compileRunP2   Below      ).Disabled(disableWebSharperVal)\nlet actRunWSIn        = Template.Action.New(\"Run WebSharper in ...\"      ).OnClick( DoP  compileRun        ()      ).Disabled(disableWebSharperVal)\nlet actParseCode      = Template.Action.New(\"Parse F#\"                   ).OnClick( DoW  parseFS           ()      ).Disabled(disableParseVal     )\nlet actCompileWS      = Template.Action.New(\"Compile WebSharper\"         ).OnClick( DoW  justCompile       ()      ).Disabled(disableWebSharperVal)\nlet actFindDefinition = Template.Action.New(\"Find Definition\"            ).OnClick( Do   gotoDefinition    ()      ).Disabled(disableParseVal     )\nlet actRefreshEditor  = Template.Action.New(\"Refresh CodeMirror\"         ).OnClick( Do   refreshCodeMirror ()      )\nlet actOutText        = Template.Action.New(\"Show Output text\"           ).OnClick2(Do2  showOutText       ()      )\nlet actAbortFsi       = Template.Action.New(\"Abort FSI\"                  ).OnClick( Do   abortFsiExe       ()      )\n     \nlet buttonsH =\n    div [ \n          actAddSnippet    .Button.Render\n          actOutdentSnippet.Button.Render\n          actIndentSnippet .Button.Render\n          loadFileElement.Render.AddChildren([ style \"grid-column: 4/6\" ])\n          actEvalCode      .Button.Render\n          actFableCode     .Button.Render\n          actRunWSIn       .Button.Render\n\n          actDeleteSnippet .Button.Render\n          actFindDefinition.Button.Render\n          span []       \n          actSaveFile      .Button.Render\n          span []       \n          actGetFsCode     .Button.Render\n          actParseCode     .Button.Render\n          Doc.Select [ attr.id \"Position\" ] positionTxt [ NewBrowser ; Below ] position |> someElt\n\n          style \"\"\"\n              overflow: hidden;\n              display: grid;\n              grid-template-columns: repeat(8, 12.1%);\n              bxackground-color: #eee;\n              padding : 5px;\n              grid-gap: 5px;\n          \"\"\"\n        ]\n\nlet menuLeft =\n    Menu.New2\n      [\n        MenuEntry.New(\"File\")\n            .SubMenu(\n                    [\n                        actLoadFile.MenuEntry\n                        actSaveFile.MenuEntry\n                    ]           \n            )            \n        MenuEntry.New(\"Code\")           \n            .SubMenu(           \n                    [           \n                        actAddSnippet    .MenuEntry\n                        actDeleteSnippet .MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actIndentSnippet .MenuEntry\n                        actOutdentSnippet.MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actFindDefinition.MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actGetFsCode     .MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actRefreshEditor .MenuEntry\n                    ]     \n            )      \n        MenuEntry.New(\"Run\")     \n            .SubMenu(     \n                    [     \n                        actEvalCode      .MenuEntry\n                        actAbortFsi      .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actFableCode     .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actRunWSNewTab   .MenuEntry\n                        actRunWSHere     .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actParseCode     .MenuEntry\n                        actCompileWS     .MenuEntry\n                    ]\n            ) \n      ]\n\nlet menuRight =\n    Menu.New2\n      [\n        MenuEntry.New(\"About\")\n            .SubMenu [\n                MenuEntry.New(\"Source @ GitHub\", \"https://github.com/amieres/FSharpStation\").Target \"_blank\"\n            ]\n      ]      \n\nlet menuBar =\n    navbar <| h1 [ htmlText \"F# Station\" ; style \"font-size: 48px; margin-top: -17px\" ]\n           <| menuLeft .Render \n           <| menuRight.Render\n           \n()           ","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"7cdba50e-5de9-4377-a7fc-705df0d909fa"},{"$":0,"Item":"3f2ec5e2-8ab6-4e5b-bb89-1943ed3a4964"},{"$":0,"Item":"60191ea0-da20-4fbf-96b8-3871338a66d8"},{"$":0,"Item":"47f7c0ba-35b0-466e-a759-4e4d9963e524"},{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"}],"id":{"$":0,"Item":"70bc3916-4714-4ee1-a2d0-d3917eeadf9d"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CodeEditorGrid","content":"let spl1         = Template.SplitterBar.New(20.0).Children([ style \"grid-row: 2 / 4\" ])\nstoreVarCodeEditor \"splitterV1\" spl1.Var\n//storeVarCodeEditor \"splitterV2\" splitterV2.Var\n//storeVarCodeEditor \"splitterH3\" splitterH3.Var\n\nlet jumpToRef (e:obj) (_:Dom.MouseEvent) = \n    let v : string = e?value |> unbox\n    let s : int    = e?selectionStart |> unbox\n    let lines = v.Split '\\n'\n    lines \n    |> Seq.mapFold (fun total line -> (line, total, total + line.Length + 1), total + line.Length + 1) 0 \n    |> fst\n    |> Seq.pick (fun (line, from, to_) -> if s >= from && s < to_ then Some line else None)\n    |> jumpToLine\n\nlet scrollToBottom (e:obj) _ = \n    async { \n        do! Async.Sleep 100\n        do  e?scrollTop <- e?scrollHeight\n    } |> Async.Start\n\n(*\nlet CodeEditor() =\n  Template.Grid.New\n     .ColVariable(spl1)\n     .ColAuto(     0.0)\n     .ColVariable( 0.0).Min(0.0).Max(Val.map ((-) 92.0) spl1.GetValue).Before.Children([ style \"grid-row   : 1 / 5\" ])\n     .RowFixedPx( 34.0) \n     .RowAuto(     0.0)\n     .RowVariable(17.0)                                               .Before.Children([ style \"grid-column: 2 / 3\" ])\n     .RowFixedPx( 80.0)\n     .Padding(1.0)\n     .Content(\"sidebar\", \n         codeSnippets.View\n         |> View.SnapshotOn codeSnippets.Value refresh.View\n         |> bindHElem listEntries\n      )\n     .Content(\"header\"  , Template.Input     .New(Val.bindIRef curSnippetNameOf currentCodeSnippetId).Prefix(htmlText \"name:\")         .Render)\n     .Content(\"content1\", codeMirror                                                                                                   .Render)\n     .Content(\"content2\", Template.TabStrip  .New(Messages).Top                                                                        .Render)\n     .Content(\"footer\"  ,       \n        div [ \n              actAddSnippet    .Button.Render\n              actOutdentSnippet.Button.Render\n              actIndentSnippet .Button.Render\n              loadFileElement.Render.AddChildren([ style \"grid-column: 4/6\" ])\n              actParseCode     .Button.Render\n              actEvalCode      .Button.Render\n              actGetFsCode     .Button.Render\n       \n              actDeleteSnippet .Button.Render\n              span []       \n              span []       \n              actSaveFile      .Button.Render\n              span []\n              actCompileWS     .Button.Render\n              actRunWSIn       .Button.Render\n              Doc.Select [ attr.id \"Position\" ] positionTxt [ Below ; Right ; NewBrowser ] position |> someElt\n              style \"\"\"\n                  overflow: hidden;\n                  display: grid;\n                  grid-template-columns: repeat(8, 12.1%);\n                  bxackground-color: #eee;\n                  padding : 5px;\n                  grid-gap: 5px;\n              \"\"\"\n            ]\n        )\n     .Content( script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                                     ; ``type`` \"text/javascript\"             ] )\n     .Content( script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ] )\n     .Content( script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ] )\n     .Content( link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ] )\n     .Content( link   [ href \"/EPFileX/css/main.css\"                                               ; ``type`` \"text/css\" ; rel \"stylesheet\" ] )\n     .Content( css styleEditor                                                                                                                )\n     .Render\n     .Style(\"\"\" \n            grid-template-areas:\n                'header0 header   sidebar2'\n                'sidebar content1 sidebar2'\n                'sidebar content2 sidebar2'\n                'footer  footer   sidebar2';\n            color      : #333;\n            height     : 100%;\n            font-size  : small;\n            font-family: monospace;\n            line-height: 1.2;\n                \"\"\")\n\n*)\n()","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"aeb92943-97ea-4297-9097-926410e9d10f"},{"$":0,"Item":"e702bf50-ad01-45eb-8b7b-813cc9046bef"},{"$":0,"Item":"70bc3916-4714-4ee1-a2d0-d3917eeadf9d"},{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"},{"$":0,"Item":"cddabd38-7ecb-4692-99bd-13ca70e4232f"},{"$":0,"Item":"47f7c0ba-35b0-466e-a759-4e4d9963e524"},{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"93f32df7-da8b-472f-8bad-e82cc58ec52b"},{"$":0,"Item":"60191ea0-da20-4fbf-96b8-3871338a66d8"},{"$":0,"Item":"b417f7b1-5e53-4c51-a23f-6f2c8c5a77b7"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"id":{"$":0,"Item":"75c3d033-99b5-409f-8ecb-cd9bd8b101ab"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Layout","content":"let snippetList = \n    codeSnippets.View\n       |> View.SnapshotOn codeSnippets.Value refresh.View\n       |> bindHElem listEntries\n\nlet steps = \n  Layout.AddGuids\n    [|\n        \"actLoadFile\"       , GuiAction actLoadFile      \n        \"actSaveFile\"       , GuiAction actSaveFile      \n        \"actAddSnippet\"     , GuiAction actAddSnippet    \n        \"actDeleteSnippet\"  , GuiAction actDeleteSnippet \n        \"actIndentSnippet\"  , GuiAction actIndentSnippet \n        \"actOutdentSnippet\" , GuiAction actOutdentSnippet\n        \"actGetFsCode\"      , GuiAction actGetFsCode     \n        \"actSetSnippetProp\" , GuiAction actSetSnippetProp\n        \"actEvalFsCode\"     , GuiAction actEvalFsCode\n        \"actEvalCode\"       , GuiAction actEvalCode\n        \"actRunFableFs\"     , GuiAction actFableFsCode\n        \"actRunFable\"       , GuiAction actFableCode\n        \"actRunWSNewTab\"    , GuiAction actRunWSNewTab   \n        \"actRunWSHere\"      , GuiAction actRunWSHere     \n        \"actRunWSIn\"        , GuiAction actRunWSIn       \n        \"actParseCode\"      , GuiAction actParseCode     \n        \"actCompileWS\"      , GuiAction actCompileWS     \n        \"actFindDefinition\" , GuiAction actFindDefinition    \n        \"actOutText\"        , GuiAction actOutText\n        \"Output\"            , GuiNode <| Template.TextArea.New(outputMsgs).Placeholder(\"Output:\"         ).Title(\"Output\"                   ).RenderWith [ on.dblClick jumpToRef |> SomeAttr; on.afterRender (fun e -> outputMsgs |> Val.sink (scrollToBottom e)) |> SomeAttr]\n        \"Parser\"            , GuiNode <| Template.TextArea.New(parserMsgs).Placeholder(\"Parser messages:\").Title(\"Parser\"                   ).RenderWith [ on.dblClick jumpToRef |> SomeAttr]\n        \"JavaScript\"        , GuiNode <| Template.TextArea.New(codeJS    ).Placeholder(\"Javascript:\"     ).Title(\"JavaScript code generated\").Render\n        \"F# code\"           , GuiNode <| Template.TextArea.New(codeFS    ).Placeholder(\"F# code:\"        ).Title(\"F# code assembled\"        ).Render\n        \"Properties\"        , GuiNode <| properties    \n        \"WS Result\"         , GuiNode <| div [ div [ Id \"TestNode\" ; style \"background: white; height: 100%; width: 100%; \"] ]\n        \"title\"             , GuiNode <| Template.Input.New(Val.bindIRef curSnippetNameOf currentCodeSnippetId).Prefix(htmlText \"name:\").Render\n        \"code\"              , GuiNode <| codeMirrorRender\n        \"snippets\"          , GuiNode <| snippetList\n        \"buttons\"           , GuiNode <| buttonsH\n        \"menu\"              , GuiNode <| menuBar\n        \"messagesR\"         , GuiTabStrip(     true ,  [| \"Properties\" |])\n        \"messagesB1\"        , GuiTabStrip(     true ,  [| \"Output\"    \n                                                          \"JavaScript\"\n                                                          \"F# code\"    |])\n        \"messagesB2\"        , GuiTabStrip(     true ,  [| \"Parser\"    \n                                                          \"WS Result\"  |])\n        \"messagesB\"         , varVerSplitter          55.0 \"messagesB1\"    \"messagesB2\"     0.0 100.0             \n        \"title_code\"        , fixedHorSplitter true   34.0 \"title\"         \"code\"\n        \"code_props\"        , varVerSplitter          85.0 \"title_code\"    \"messagesR\"     25.0 100.0\n        \"code_buttons\"      , fixedHorSplitter false  80.0 \"code_props\"    \"buttons\"\n        \"snippets_code\"     , varVerSplitter          15.0 \"snippets\"      \"code_buttons\"   5.0  95.0\n        \"main_messages\"     , varHorSplitter          82.0 \"snippets_code\" \"messagesB\"     35.0 100.0             \n        \"extrabuttons\"      , GuiNode <| div []\n        \"main_extra\"        , varVerSplitter         100.0 \"main_messages\" \"extrabuttons\"  20.0 100.0\n        \"main\"              , fixedHorSplitter true   50.0 \"menu\"          \"main_extra\"\n    |]   \n\nlet layout = Layout.New steps\n\nlet doGuiCallR(name:string, action:string, parms: string[]) =\n    Result.result {\n        do! Result.tryProtection()\n        let! act = layout.GetGuiCallAction name action parms\n        act.onClick |> Option.iter (fun f -> f act null null)\n    }\n    \nlet doGuiCall  v =\n    doGuiCallR v\n    |> function\n       | Result.Failure ms -> printfn \"Error doGuiCall %A: %A\" ms v\n       | _ -> ()\n\n\n\nlet addLayoutJson  json   = delayedRefreshCM 1000 ; delayedRefreshCM 2000 ; delayedRefreshCM 3000 ; layout.SetLayoutJson steps json\nlet addLayoutSteps steps2 = delayedRefreshCM 1000 ; delayedRefreshCM 2000 ; delayedRefreshCM 3000 ; layout.AddNewSteps steps steps2\nJS.Window?addLayoutJson <-    addLayoutJson\npropertyLayoutVal   |> Val.sink addLayoutJson \npropertyLayoutJSVal |> Val.sink (fun js -> if js = \"\" then addLayoutSteps [||] else eval JS.Window js |> ignore)\n\nlet setFSharpStationLayout (f:FuncWithArgs<Layout * CodeSnippet, _>)  =\n        CodeSnippet.FetchO currentCodeSnippetId.Value\n        |> Option.iter (fun cur -> f.Call(layout, cur) |> addLayoutSteps)\n\nJS.Window?doFSharpStationGuiCall <- doGuiCall\nJS.Window?setFSharpStationLayout <- setFSharpStationLayout\n\n// these are here so it gets included in the code for Layouts\nlet dict = Dictionary<string, string>()\nlet dictTryGetValue = Dict.tryGetValue \"\" dict \nlet pnl  = Template.Panel.New\n()\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"0a11766b-f227-4b38-88a3-919d964387bf"},{"$":0,"Item":"995f98ae-4f13-4225-9d00-9aa3e630058a"},{"$":0,"Item":"7cdba50e-5de9-4377-a7fc-705df0d909fa"},{"$":0,"Item":"75c3d033-99b5-409f-8ecb-cd9bd8b101ab"},{"$":0,"Item":"9c870b72-8f9a-4e7d-ad81-7f1fd73fdd76"},{"$":0,"Item":"70bc3916-4714-4ee1-a2d0-d3917eeadf9d"}],"id":{"$":0,"Item":"4e040028-ff11-458e-a43b-e8a1b7fcaeec"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Messaging","content":"#if NOMESSAGING\n#else\n\nlet wsStationClient = new WSMessagingBroker.WSMessagingClient(fsIds)\n//let fsStationClient = FsStationClient(fsIds, fsIds, endPoint = JS.Window.Location.Href)\n\nlet transMsgs (msgs: ErrMsg [])  =  msgs |> Seq.map (fun e -> e.ErrMsg, if e.IsWarning then FSWarning else FSError) |> Seq.toArray\n\nlet result2response res = \n    match res with \n    | Result (a, b) -> StringResponseR (a |> Option.map snd, b |> Seq.map (fun err -> err.ErrMsg, if err.IsWarning then FSWarning else FSError) |> Seq.toArray ) \n\nlet result2StringResponse res = \n    match res with \n    | Result (a, b) -> StringResponseR (a |> Option.map (sprintf \"%A\"), b |> Seq.map (fun err -> err.ErrMsg, if err.IsWarning then FSWarning else FSError) |> Seq.toArray ) \n\nlet respond (fromId:string) (msg:FSMessage) : Async<FSResponse> =\n    async {\n        match msg with\n        | GetWholeFile                     -> return  codeSnippets.Value            |> Seq.toArray |> Json.Serialize |> Some                                   |> StringResponse       \n        | GetSnippetContentById sId        -> return  CodeSnippet.FetchO       sId  |> Option.map (fun snp -> snp.content        )                             |> StringResponse       \n        | GetSnippetCodeById    sId        -> return  CodeSnippet.FetchO       sId  |> Option.map (fun snp -> snp.GetCodeFsx true)                             |> StringResponse \n        | GetSnippetPredsById   sId        -> return  CodeSnippet.FetchO       sId  |> Option.map (fun snp -> snp.Predecessors ()) |> Option.defaultValue [||] |> SnippetsResponse\n        | GetSnippetById        sId        -> return  CodeSnippet.FetchO       sId                                                                             |> SnippetResponse \n        | GetSnippetContent     path       -> return  CodeSnippet.FetchByPathO path |> Option.map (fun snp -> snp.content        )                             |> StringResponse\n        | GetSnippetCode        path       -> return  CodeSnippet.FetchByPathO path |> Option.map (fun snp -> snp.GetCodeFsx true)                             |> StringResponse\n        | GetSnippetJSCode      path       -> match   CodeSnippet.FetchByPathO path with\n                                              | Some snp -> let!    jsR = translateAR (snp.GetCodeFsx true) false\n                                                            return (jsR |> Result.map RunCode.completeJS |> Result.getOption, jsR |> Result.getMsgs |> transMsgs)      |> StringResponseR\n                                              | None     -> return (None, [| \"Snippet not found\" , FSError |] )                                                |> StringResponseR\n        | GetSnippetPreds       path       -> return  CodeSnippet.FetchByPathO path |> Option.map (fun snp -> snp.Predecessors ()) |> Option.defaultValue [||] |> SnippetsResponse\n        | GetSnippet            path       -> return  CodeSnippet.FetchByPathO path                                                                            |> SnippetResponse \n        | GenericMessage        txt        -> return  (Some <| \"Message received: \" + txt)                                                                     |> StringResponse\n        | GetIdentification                -> return  fsIds                                                                                                   |> IdResponse  \n        | RunSnippetUrlJSById  (sId , url) -> return! CodeSnippet.FetchO       sId  |> compileRunUrlW url NewBrowser |> Wrap.getAsyncR |> Async.map result2response\n        | RunSnippetUrlJS      (path, url) -> return! CodeSnippet.FetchByPathO path |> compileRunUrlW url NewBrowser |> Wrap.getAsyncR |> Async.map result2response\n        | RunActionCall        (nm,ac, ps) -> return  doGuiCallR(nm, ac, ps) |> Result.map (fun _ -> sprintf \"success: %s\" nm)                   |> result2StringResponse\n    }     \n     \n//async {\n//    do! Async.Sleep 1000\n//    do fsStationClient.MessagingClient.AwaitMessageG respond\n//} |> Async.Start\n\nasync {\n    do! Async.Sleep 1000\n    while true do\n        try       wsStationClient.ProcessIncoming (respond \"\" >> WAsync)\n                  do! Async.Sleep 60000\n        with e -> printfn \"%s\" e.Message\n                  do! Async.Sleep 1000\n} |> Async.Start\n\n#endif","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"e665bede-c870-4041-b7ed-8be419c52a83"},{"$":0,"Item":"4e040028-ff11-458e-a43b-e8a1b7fcaeec"},{"$":0,"Item":"70bc3916-4714-4ee1-a2d0-d3917eeadf9d"}],"id":{"$":0,"Item":"95ca1e9f-4029-4fc1-8b1c-ab12db71c90b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"MainForm","content":"Val.sink        (fun _  -> layout.SelectTab \"Output\"    |> ignore) outputMsgs \nVal.sink        (fun _  -> layout.SelectTab \"WS Result\" |> ignore) triggerWSResult\nAsync.sleepThen (fun () -> layout.SelectTab \"Parser\"    |> ignore) 1000 |> Async.Start\n\n\nlet cssLinks      = Var.Create [ \"/EPFileX/css/main.css\" ]\nlet addCssLink lnk =\n    if  cssLinks.Value |> List.contains lnk |> not then\n        cssLinks.Value <- lnk :: cssLinks.Value\n    delayedRefreshCM 300\n\nVal.sink addCssLink propertyCssLinkVal\nVal.sink (fun theme -> if theme <> \"\" then sprintf \"/EPFileX/codemirror/content/theme/%s.css\" theme |> addCssLink) propertyThemeVal\n\ndiv [\n    style \"height: 100vh; width: 100% \"\n    layout.Render.Style(\"height: 100%; width: 100% \")\n    script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                                     ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ]\n    link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    css styleEditor                                                                                                               \n    style  \"\"\" \n          color      : #333;\n          font-size  : small;\n          font-family: monospace;\n          line-height: 1.2;\n              \"\"\"\n    Val.map (fun csslnks ->\n        div [\n            yield! csslnks |> Seq.map (fun csslnk -> link   [ href csslnk; ``type`` \"text/css\" ; rel \"stylesheet\" ])\n        ]\n    ) cssLinks \n    |> HtmlElementV \n    css propertyCssVal\n] |> renderDoc \n\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"4e040028-ff11-458e-a43b-e8a1b7fcaeec"},{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},{"$":0,"Item":"95ca1e9f-4029-4fc1-8b1c-ab12db71c90b"}],"id":{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CodeEditor (old not used)","content":"let splitterMain1 =\n    Template.SplitterBar.New( 0.0).Vertical(directionVertical).Min( 0.0).Max(35.0)\n\nlet splitterMain2 =\n    Template.SplitterBar.New(24.0).Vertical(directionVertical).Min( 0.5).Max(Val.map (fun pos -> if pos = NewBrowser then 0.1 else 50.0) position).Before\n\nstoreVarCodeEditor \"splitterMain1\" splitterMain1.Var\nstoreVarCodeEditor \"splitterMain2\" splitterMain2.Var\n\n//RunCode.RunNode(\"CodeEditor\").AddBootstrap.RunHtml <| CodeEditor()\n//addNodeById \"pageStyle\"                            <| styleH [ htmlText pageStyle ]\n//addNodeById \"splitterMain1\"                        <| splitterMain1.Render\n//addNodeById \"splitterMain2\"                        <| splitterMain2.Render\n\nlet grid = \n    Template.Grid.New\n       .Padding(0.0)\n       .Content(\"editor\", CodeEditor())\n       .Content(style    \"height: 100vh; margin: 0px; \")\n       .Content(css \"\"\"\n           #CodeEditor              { grid-area: editor  ; overflow: hidden; }\n           #TestNode                { grid-area: testNode; overflow: auto  ; }\n           body > div:first-of-type { grid-area: header  ; overflow: hidden; }\n       \"\"\")\n\ndirectionVertical\n|> Val.map (fun dir ->\n    (if dir\n     then grid.ColVariable(splitterMain1).ColAuto(16.0).ColVariable(splitterMain2).Content(style \"\"\" grid-template-areas: 'header   editor   testNode'; \"\"\")\n     else grid.RowVariable(splitterMain1).RowAuto(16.0).RowVariable(splitterMain2).Content(style \"\"\" grid-template-areas: 'header' 'editor' 'testNode'; \"\"\")\n    ).GridTemplate())\n|> bindHElem body\n|> renderDoc\n|> Doc.RunReplace JS.Document.Body\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"75c3d033-99b5-409f-8ecb-cd9bd8b101ab"},{"$":0,"Item":"95ca1e9f-4029-4fc1-8b1c-ab12db71c90b"},{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},{"$":0,"Item":"456562f7-0757-4431-9aeb-d58b050cecf7"}],"id":{"$":0,"Item":"07f11803-2084-4a0a-9066-a43fd11be1c7"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Editor2","content":"// Version using ZafirTranspiler.dll & Remote.dll\n[< JavaScript >]\nlet Main = FSharpStationClient() |> Doc.Run JS.Document.Body\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"8fbd59ac-9417-4309-8d01-3ccd5d62452c"},{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"}],"id":{"$":0,"Item":"8d84a97a-8fbf-4ee6-81c3-cf70db4adfa4"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Site","content":"// Version using internal Rpc's\n#define FSS_SERVER\n//#define NOMESSAGING\n\nopen WebSharper.Sitelets\nopen WebSharper.UI.Server\nopen WebSharper.UI\n\ntype EndPoint = \n    | [< EndPoint \"/\" >] EPStart\n    | EPLoad of string\n    | FSharpStation\n\nlet FSharpStationPage uri =\n    Content.Page(\n        Title = \"F# Station\"\n      , Head  = [ Html.script [ attr.``type`` \"text/javascript\"; attr.src \"https://code.jquery.com/jquery-3.1.1.min.js\"] [] \n                  Html.script [ attr.``type`` \"text/javascript\"; attr.src \"/EPFileX/CIPHERSpaceLoadFiles.js\"           ] [] \n                ]\n      , Body  = [ Html.client <@  FSharpStationClient uri @> ])\n\nlet content (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n    printfn \"%A\" endpoint\n    match endpoint with\n    | FSharpStation -> FSharpStationPage \"https://raw.githubusercontent.com/amieres/FSharpStation/master/Start.fsjson\"\n    | EPStart       -> FSharpStationPage \"\"\n    | EPLoad    uri -> uri |> System.Web.HttpUtility.UrlDecode |> System.Web.HttpUtility.UrlDecode |> FSharpStationPage\n\nlet site = Application.MultiPage content\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"},{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"}],"id":{"$":0,"Item":"b9ca9697-6cb4-4085-b509-9f702a62086f"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FSharpStation","content":"#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Owin.Compression\\lib\\net452\\Owin.Compression.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net45\\Microsoft.Owin.Hosting.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net45\\Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net45\\Microsoft.Owin.StaticFiles.dll\"\n#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net45\\Microsoft.Owin.FileSystems.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n//#r @\"WebSharper.Core.JavaScript.dll\"\n//#r @\"..\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n\nopen global.Owin\nopen Microsoft.Owin.Hosting\nopen Microsoft.Owin.StaticFiles\nopen Microsoft.Owin.StaticFiles.ContentTypes\nopen Microsoft.Owin.FileSystems\nopen WebSharper.Owin\nopen WebSharper.Owin.WebSocket\nopen WSMessagingBroker\n\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://localhost\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://*\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"file://\"\nWebSharper.Web.Remoting.DisableCsrfProtection()\n\n[< EntryPoint >]\nlet Main args =\n    printfn \"Usage: FSharpStation URL ROOT_DIRECTORY MaxMessageSize\"\n    let url           = args |> Seq.tryItem 0 |>                   Option.defaultValue \"http://localhost:9010/\"\n    let rootDirectory = args |> Seq.tryItem 1 |>                   Option.defaultValue \"website\"\n    let max           = args |> Seq.tryItem 2 |> Option.map int |> Option.defaultValue 1_000_000\n    let epWebSocket = Endpoint.Create(url, \"/ws\", JsonEncoding.Readable)\n    let brokerAgent = Broker.BrokerAgent epWebSocket\n    Broker.BrokerAgent.FssWebSocketO <- Some brokerAgent\n    let provider = FileExtensionContentTypeProvider()\n    provider.Mappings.[\".fsjson\"] <- \"application/x-fsjson\"\n    use server = \n        WebApp.Start(url, fun appB ->\n            appB.UseCompressionModule()\n                .UseWebSharper( WebSharperOptions(ServerRootDirectory  = rootDirectory\n                                                , Sitelet              = Some site\n                                                , BinDirectory         = \".\"\n                                                , Debug                = true                             ))\n                .UseStaticFiles(StaticFileOptions(FileSystem           = PhysicalFileSystem(rootDirectory)\n                                                , ContentTypeProvider  = provider                         ))\n                .UseWebSocket(epWebSocket, brokerAgent.Start, maxMessageSize = max                         )\n            |> ignore\n            //let listener = appB.Properties.[\"Microsoft.Owin.Host.HttpListener.OwinHttpListener\"] |> unbox<Microsoft.Owin.Host.HttpListener.OwinHttpListener>\n            //listener.SetRequestProcessingLimits(1000, 1000)\n            //let maxA : int ref = ref 0\n            //let maxB : int ref = ref 0\n            //listener.GetRequestProcessingLimits(maxA, maxB)\n            //printfn \"Accepts: %d Requests:%d\" !maxA !maxB\n        )\n    stdout.WriteLine(\"Serving {0}\", url)\n    stdin.ReadLine() |> ignore\n    0\n    ","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"e137b990-172b-4879-bc74-8650123b7a5d"},{"$":0,"Item":"b9ca9697-6cb4-4085-b509-9f702a62086f"}],"id":{"$":0,"Item":"0dbfcc9d-8ea2-42a3-8f81-ce2bf7d0fad4"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Invoke FSharpStation","content":"\n[< JavaScript >]\nlet fss =\n    FSharpStationClient \"\"\n    |> RunCode.RunNode().AddBootstrap.RunDoc\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"}],"id":{"$":0,"Item":"c165e3de-7838-42a4-a7ec-2b2f8e5b69c6"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableWebSharper":"0","Layout":"[[\"main_messages\",{\"GuiSplit\":[true,\"StVariable\",false,18,\"messagesB\",\"snippets_code\",0,75]}],[\"buttons\",{\"GuiNode\":{\"HtmlElementF\":[\"div\",[{\"HtmlGuiPart\":\"actRunWSNewTab\"},{\"HtmlElementF\":[\"div\",[{\"HtmlAttributeF\":[\"style\",\" width:9px; height:auto; display:inline-block;\"]}]]},{\"HtmlGuiPart\":\"actSaveFile\"},{\"HtmlAttributeF\":[\"style\",\"text-align: center\"]}]]}}]]"}},{"name":"compile & run FSharpStation","content":"open System.IO\nopen WSMessagingBroker\n//open FsStationShared\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.RunProcess\nopen CompOptionsModule\n\nWrap.wrap {\n    let  options         = compileOptionsExeDebug \"FSSGlobal/WebSharper Code/FSharpStation Code/FSharpStation\"\n                           + opDirectory    /= @\"Compiled\\FSharpStation2\"\n                           + siteOptions\n                           + (opGenInternal /= \"showoptions\")\n    let  exeFile            = options?OutputFile\n    let  workDir            = options?Directory\n    let  site            = Path.GetFullPath(options?Website)\n//    let! res             = FsStationClient(\"Compile WebSharper\").CompileSnippetW options\n    let! res             = FStationMessaging(\"Compile WebSharper\", FSharp).CompileSnippetW options\n    do   printfn           \"%s\"              res\n    do   printfn           \"Starting %s\"     exeFile\n    let  url             = @\"http://localhost:9020\"\n    let  parms           = sprintf \"%A %A\" url site \n    do   startProcessDir   exeFile parms workDir |> ignore\n    do   startProcess      url     \"\"            |> ignore\n} |> Wrap.runSynchronouslyS true |> printfn \"%s\"\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"d9c4540a-85f5-4c62-91be-fcb2d60e9f17"}],"id":{"$":0,"Item":"5e8209e0-9203-4fe0-8289-fb4579b24038"},"expanded":true,"level":0,"levelCode":0,"properties":{"Theme":"rubyblue","DisableFSI":"0","Layout":"[[\"main_messages\",{\"GuiSplit\":[true,\"StVariable\",false,18,\"messagesB\",\"snippets_code\",0,75]}],[\"buttons\",{\"GuiNode\":{\"HtmlElementF\":[\"div\",[{\"HtmlGuiPart\":\"actEvalCode\"},{\"HtmlElementF\":[\"div\",[{\"HtmlAttributeF\":[\"style\",\" width:9px; height:auto; display:inline-block;\"]}]]},{\"HtmlGuiPart\":\"actSaveFile\"},{\"HtmlAttributeF\":[\"style\",\"text-align: center\"]}]]}}]]"}},{"name":"Snippets1","content":"[< JavaScript >]\nmodule Snippets =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"}],"id":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"expanded":false,"level":0,"levelCode":0,"properties":{}},{"name":"Demo Button","content":"\nTemplate.Button\n   .New(    \"Press me!\"                         )\n   .OnClick(fun _ _ -> JS.Alert \"Button pressed\")\n   .Style(  \"font-size: 48px\"                   )\n   .Render\n|> RunCode.RunNode(\"HEllo\").RunHtml//PlusFree\n   \nlet m = Var.Create 0\n\nView.Sink (fun currentValue -> printfn \"Value is now %d\" currentValue) m.View\n\nprintfn \"Value starts as  %d\" m.Value\nasync {\n// After this is set, a print will occur\n// Prints: \"Value is now 1\"\n    m.Value <- 1\n\n    do! Async.Sleep 1000\n// After this is set, a second print will occur with the new value\n// Prints: \"Value is now 2\"\n    m.Value <- 2\n} |> Async.Start\n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}],"id":{"$":0,"Item":"0a1fa320-b731-473a-93e2-dae49cc296f7"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Demo Input","content":"let inp = Template.Input.New(\"Type something...\")\n\nlet inline show3Sizes txt styleP =\n    div [\n      style styleP\n      htmlText txt\n      h2 [ htmlText txt ]\n      h1 [ htmlText <| Val.map (fun (s: string) -> s.ToUpper()) txt ]\n    ]\n    \ndiv [\n  inp.Render\n  show3Sizes inp.Var \"\"\n]    \n|> RunCode.RunNode().RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"f3a7ead2-49e1-4ff4-b96e-6fe699a1c8a9"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Demo TextArea","content":"let inp = Template.TextArea.New(\"Type Something...\").Placeholder(\"Output:\"    ).Title(\"Output\"                   )\n\nlet inline h1 ch = htmlElement \"h1\" ch\n\nlet text = htmlText inp.Var\n\nh3 [\n  inp.RenderWith [ on.dblClick (fun e m -> \n      let v : string = e?value |> unbox\n      let s : int    = e?selectionStart |> unbox\n      let lines = v.Split '\\n'\n      lines \n      |> Seq.mapFold (fun total line -> (line, total, total + line.Length + 1), total + line.Length + 1) 0 \n      |> fst\n      |> Seq.pick (fun (line, from, to_) -> if s >= from && s < to_ then Some line else None)\n      |> JS.Alert\n      ) ]\n  text\n  htmlElement \"h2\" [ text ]\n  h1 [ text ]\n  htmlElement \"menu\" // does not work anymore. support for this was dropped by Chrome\n      [ ``type`` \"context\"\n        Id       \"right-menu\"\n        htmlElement \"menuitem\" [ htmlAttribute \"label\" \"Goto Definition\" ; SomeAttr <| on.click (fun _ _ -> JS.Alert \"Goto Definition\")  ] \n      ]\n  htmlAttribute \"contextmenu\" \"right-menu\"\n]\n|> RunCode.RunNode().RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}],"id":{"$":0,"Item":"87770aad-e1d9-4fcb-be12-ff3c4ce58b7b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Demo CodeMirror","content":"open FSAutoComplete\nopen Template\nopen Useful\n\nlet  file               = @\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\bin\\Test.fsx\"\nlet  autoCompleteClient = FSAutoCompleteClient(\"Demo Code\")\n\ntype KeyMapAutoComplete = { \n    F2             : CodeMirrorEditor -> unit \n    ``Ctrl-Space`` : CodeMirrorEditor -> unit\n}\n\n[< Inline \"$editor.setOption('extraKeys', { 'F2': function(cm) { var pos = cm.getCursor(); $f(pos) } })\" >]\nlet addMiddleClick (f: CodeMirrorPos -> unit) (editor:CodeMirrorEditor) = ()\n\nlet showToolTip (ed:CodeMirrorEditor) =\n    printfn \"showToolTip\"\n    async {\n        let  pos = ed.GetCursor()\n        let! tip = autoCompleteClient.ToolTip(file, pos.line + 1, pos.ch + 1)\n        do   JS.Alert tip\n    } |> Async.Start\n\nlet getHints (ed:Template.CodeMirrorEditor, cb, _) =\n    async {\n        let  pos    = ed.GetCursor()\n        let  l      = ed.GetLine pos.line\n        let  word   = match l.Substring(0, pos.ch) with\n                      | REGEX @\"([a-zA-Z_]\\w*)$\" \"g\" [| txt |] -> txt\n                      | _                                      -> \"\"          \n        let! res    = autoCompleteClient.Parse   (file, ed.GetValue()           )\n        let! com    = autoCompleteClient.Complete(file, pos.line + 1, pos.ch + 1)\n        cb { list   = com |> Array.map (fun (dis, rep, cls, chr) -> \n                            { text        = rep\n                              displayText = chr + \"| \" + dis\n                              className   = cls                              \n                            })\n             from   = { pos with ch = pos.ch - word.Length }\n             ``to`` = pos \n           }\n    } |> Async.Start\n\nlet rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\"\"\"\nlet rex2 = \"\"\"(Err|Warning)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) ?)?F?#? ?(.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\nlet rex = rex1 + \"|\" + rex2\n\nlet getAnnotations (txt, cb, _, ed:Template.CodeMirrorEditor) =\n    async {\n        let! res    = autoCompleteClient.Parse   (file, ed.GetValue()           )\n        match res with\n        | REGEX rex \"g\" m -> m\n        | _               -> [||]\n        |> Array.choose (fun v ->\n            match v with\n            | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, int fl, int fc - int indent    , int tl, int tc - int indent, sev, from , msg)\n            | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, int fl, int fc - int indent - 1, int fl, int fc - int indent, sev, \"fsi\", msg)\n            | _ -> None\n        )\n        |> Array.map (fun (file, fl, fc, tl, tc, sev, from, msg) ->\n            { message  = msg\n              severity = (if sev.ToUpper().StartsWith(\"ERR\") then \"error\" else \"warning\")\n              from     = cmPos(fl - 1, fc - 1) \n              ``to``   = cmPos(tl - 1, tc - 1)\n            }\n          )\n        |> cb\n    } |> Async.Start\n\nlet code = \n    Template.CodeMirror.New(\"let a = \\\"123\\\" |> Str\")\n       .OnRender(fun ed -> \n          ed.SetOption(\"gutter\", [| \"CodeMirror-lint-markers\" |])\n          ed.AddKeyMap({ F2             = showToolTip \n                         ``Ctrl-Space`` = showHints   ed getHints false\n                       })\n          setLint ed getAnnotations\n       )\n\ndiv [ \n      code.Render.AddChildren [ SomeAttr <| on.dblClick (fun _ _ -> JS.Alert \"HIHI\")  ]\n      Template.Button.New(\"Mark\").OnClick(fun _ _ -> \n          printfn \"Mark\"\n          code.editorO \n          |> Option.iter (fun ed -> \n              printfn \"inside\"\n              ed.MarkText (0,5) (0,12) \"Error\"   \"this is wrong!\"\n              ed.MarkText (0,0) (0, 3) \"Warning\" \"this is not so bad.Fix it now.\"\n            )\n      ).Render\n      Template.Button.New(\"Unmark\").OnClick(fun _ _ -> \n          printfn \"Unmark\"\n          code.editorO \n          |> Option.iter (fun ed -> \n              printfn \"inside\"\n              ed.RemoveMarks()\n            )\n      ).Render\n      Template.Button.New(\"Parse\").OnClick(fun _ _ -> \n          code.editorO \n          |> Option.iter (fun ed -> autoCompleteClient.Parse(file, ed.GetValue()) |> Async.map ignore |> Async.Start)\n      ).Render\n      css  \".Error   { text-decoration: underline; text-decoration-color: orange; text-decoration-style: wavy } \n            .Warning { text-decoration: underline; text-decoration-color: yellow                              } \"\n      h1 [ htmlText code.Var ]      \n      htmlElement \"menu\" \n          [ ``type`` \"context\"\n            Id       \"right-menu\"\n            htmlElement \"menuitem\" [ htmlAttribute \"label\" \"Goto Definition\" ; SomeAttr <| on.click (fun _ _ -> JS.Alert \"Goto Definition\")  ] \n          ]\n      htmlAttribute \"contextmenu\" \"right-menu\"\n]\n|> RunCode.RunNode().RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"08e9600a-804b-4aba-a262-85f22e0cc8de"},{"$":0,"Item":"18d8153d-422c-42f6-8266-9a9d854bd6a1"},{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},{"$":0,"Item":"a05dd36e-a15e-4394-8013-128e21e69574"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"id":{"$":0,"Item":"f2cc3e92-5e61-47b2-982b-40f5c5784e6a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Demo SplitterBar","content":"let styleT   p =\n  sprintf \"\"\"\n.SplitterArea {\n    display: grid;\n    grid-template-columns: %f%% %f%%;\n    grid-template-areas:   \"left right\";\n    background-color: #41414d;\n    color: #444;\n    height: 50px;\n    width: 1000px;\n    grid-gap: 9px;\n    padding : 9px;\n}\n\n.SplitterArea > :nth-child(1){  grid-area: left  ; overflow: hidden; background-color: lightgreen; }\n.SplitterArea > :nth-child(2){  grid-area: right ; overflow: hidden; background-color: lightblue ; }\n\n.Splitter { \n    grid-column     :    2      ;\n    grid-row        :  1/2      ;\n    width           :    5px    ; \n    margin-left     :   -7px    ; \n    border          :    0px    ; \n    padding         :    0px    ;\n    cursor          : col-resize;\n  \tbackground-color: #eef      ; \n}   \"\"\"  (p * 0.99) (0.99 * (100.0 - p))\n\nlet min        = Template.Input.New(\"25.0\").Prefix(htmlText \"Min:  \")\nlet max        = Template.Input.New(\"75.0\").Prefix(htmlText \"Max:  \")\nlet value      = Template.Input.New(\"40.0\").Prefix(htmlText \"Value:\")\nlet splitter   = Template.SplitterBar.New(value.Var.Lens (fun s -> float s) (fun prev f -> sprintf \"%f\" <| (f * 10. |> Math.Round |> float ) / 10. ) )\n                     .Min(Val.map float min.Var)\n                     .Max(Val.map float max.Var)\n\nprintfn \"Demo SplitterBar\"\n\nlet bar =\n    div [\n      ``class`` \"SplitterArea\"\n      div    [ htmlText <| Val.map (             sprintf \"LEFT  %f\")  splitter.GetValue ]\n      div    [ htmlText <| Val.map (((-)100.) >>(sprintf \"RIGHT %f\")) splitter.GetValue ]\n      styleH [ htmlText <| Val.map styleT                             splitter.GetValue ]\n      splitter.Render\n    ]\n    \ndiv [\n  bar\n  min  .Render\n  max  .Render\n  value.Render\n]\n|> RunCode.RunNode().AddBootstrap.RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"id":{"$":0,"Item":"0aa90429-4e7c-42eb-b108-3dd70e710bf1"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Demo Grid","content":"open Template\n        \nlet sc1 = SplitterBar.New(30.0)\nlet sr1 = SplitterBar.New(30.0).Horizontal()\n\nlet inline content1 v     (g: Grid) = g.Content(v   )\nlet inline content2 (a,b) (g: Grid) = g.Content(a, b)\nlet inline render         (g: Grid)         = g.Render\n\nlet inline fixedHorSplitter1 px ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", ch1)\n                       .Content(\"two\", ch2).Padding(0.0)\n    grid.RowFixedPx(px).RowAuto(50.0).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\nlet inline fixedHorSplitter2 px ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", ch1)\n                       .Content(\"two\", ch2).Padding(0.0)\n    grid.RowAuto(50.0).RowFixedPx(px).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\nlet div22 =\n        fixedHorSplitter2 80.0    \n            <| (fixedHorSplitter1 34.0 \n                <| div [ htmlText \"Fixed34px\" ; style \"background-color: lightblue\"  ]\n                <| div [ htmlText \"Variable \" ; style \"background-color: lightgreen\" ])\n            <| div [ htmlText \"Fixed80px\" ; style \"background-color: magenta\"    ]\n\nlet grid =\n  Grid.New\n    .ColFixed(8.0).ColVariable(sc1).ColAuto(16.0).ColVariable(50.0).Before.Max(Val.map ((-) 84.0) sc1.GetValue)\n    .RowFixed(8.0).RowVariable(sr1).RowAuto(16.0).RowVariable(50.0).Before.Max(Val.map ((-) 84.0) sr1.GetValue)\n    .Content(         div [ htmlText \"Div11\" ; style \"background-color: lightblue\"  ])\n    .Content(\"1 / 2\", div [ htmlText \"Div12\" ; style \"background-color: lightgreen\" ])\n    .Content(\"1 / 3\", div [ htmlText \"Div13\" ; style \"background-color: pink\"       ])\n    .Content(\"1 / 4\", div [ htmlText \"Div14\" ; style \"background-color: magenta\"    ])\n    .Content(\"2 / 1\", div [ htmlText \"Div21\" ; style \"background-color: lightblue\"  ])\n    .Content(\"2 / 2\", div22                                                          )\n    .Content(\"3 / 3\", div [ htmlText \"Div33\" ; style \"background-color: pink\"       ])\n    .Content(\"4 / 4\", div [ htmlText \"Div44\" ; style \"background-color: magenta\"    ])\n\ngrid.Render\n|> fun el -> el.AddChildren [ style \"height: 600px\" ]\n|> RunCode.RunNode().ShowHtmlResult\n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"},{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"id":{"$":0,"Item":"9682eb8f-e1de-4d7c-adca-a5e2322558c2"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"F# Station Layout1","content":"printfn \"F# Station Layout\"\nopen Template\n        \nlet output = Var.Create \"HEre\"        \n\nlet mutable x: obj =  0 :> obj\n\nlet codeMirror = \n    Template.CodeMirror.New(\"let a = \\\"123\\\" |> Str\").Style(\"height: 100%\").Render\n        .AddChildren [\n            SomeAttr <| on.afterRender(fun el   -> \n                JS.SetTimeout\n                    (fun () ->\n                        addResizeObserver(fun () ->\n                            let r = el.GetBoundingClientRect()\n                            output.Value <- sprintf \"%A\" (r.Width, r.Height) ) el\n                        printfn \"F# Station Layout\"\n                    )\n                    2000 |> ignore\n            )\n        ]\n\n\nlet Messages =\n    [\n     \"Output\"    , Template.TextArea.New( output     ).Placeholder(\"Output:\"    ).Title(\"Output\"                   ).RenderWith [ on.dblClick (fun _ _ -> JS.Alert \"DblClick\") ]\n     \"Errors\"    , Template.TextArea.New(\"parserMsgs\").Placeholder(\"Errors:\"    ).Title(\"Messages\"                 ).RenderWith [ on.dblClick (fun _ _ -> JS.Alert \"DblClick\") ]\n     \"JavaScript\", Template.TextArea.New(\"codeJS    \").Placeholder(\"Javascript:\").Title(\"JavaScript code generated\").Render\n     \"F# code\"   , Template.TextArea.New(\"codeFS    \").Placeholder(\"F# code:\"   ).Title(\"F# code assembled\"        ).Render\n     \"WS Result\" , div [ div [ Id \"TestNode\" ; style \"background: white; height: 100%; width: 100%; \"] ]\n    ]\n\nlet inline fixedHorSplitter first px ch1 ch2 = Grid.NewBisect(first, StFixedPx, false, px, renderSplitterNode ch1, renderSplitterNode ch2).Render\nlet inline split (min:float) (max:float) ver (per:float) ch1 ch2 = Grid.NewBisect(true, StVariable, ver, per, renderSplitterNode ch1, renderSplitterNode ch2).Min(min).Max(max).Render\n\nlet title          = SHtmlNode <| div [ htmlText \"Title\"    ; style \"background-color: lightblue\"  ]\nlet snippets       = SHtmlNode <| div [ htmlText \"Snippets\" ; style \"background-color: lightgreen\" ]\nlet buttons        = SHtmlNode <| div [ htmlText \"Buttons\"  ; style \"background-color: magenta\"    ]\nlet menu           = SHtmlNode <| div [ htmlText \"Menu\"     ; style \"background-color: lightgray\"  ]\nlet code           = SHtmlNode <| codeMirror\nlet messagesT      = STabStrip <| TabStrip.New([]      ).Bottom\nlet messagesB      = STabStrip <| TabStrip.New(Messages).Top\nlet messagesL      = STabStrip <| TabStrip.New([]      ).Top   .Vertical\nlet messagesR      = STabStrip <| TabStrip.New([]      ).Top   .Vertical\n\nlet title_code     = SplitterStructure.New(       title         , code          , fixedHorSplitter true  34.0)\nlet code_buttons   = SplitterStructure.New(       title_code    , buttons       , fixedHorSplitter false 80.0)\nlet snippets_code  = SplitterStructure.New(true , snippets      , code_buttons  ,                        15.0)\nlet main_messagesB = SplitterStructure.New(       snippets_code , messagesB     , split 30. 100. false   82.0)\nlet main_messagesT = SplitterStructure.New(       messagesT     , main_messagesB, split  0.  75. false    0.0)\nlet main_messagesR = SplitterStructure.New(       main_messagesT, messagesR     , split 25. 100. true    99.5)\nlet main_messagesL = SplitterStructure.New(       messagesL     , main_messagesR, split  0.  75. true     0.0)\nlet main_window    = SplitterStructure.New(       menu          , main_messagesL, fixedHorSplitter true  50.0)\n\n//let code_messages = SplitterStructure.New(false, title_Code           , STabStrip messages,                   75.0)\n//let main_Buttons  = SplitterStructure.New(       snippets_code        , SHtmlNode buttons                 , fixedHorSplitter2 80.0)\n\nlet rootSplitter = SplitterNode.New(main_window)\n\nlet styleEditor    =\n     \"\"\"\nbody { margin: 0px }     \n     \ndiv textarea {\nfont-family: monospace;\n}\n.code-editor-list-tile {\nwhite-space: nowrap; \nborder-style: solid none none;\nborder-color: white;\nborder-width: 1px;\nbackground-color: #D8D8D8;\ndisplay: flex;\n}\n.code-editor-list-text{\npadding: 1px 10px 1px 5px;\noverflow:hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;\nflex: 1;\n}\n\n.code-editor-list-tile.direct-predecessor {\nfont-weight: bold;\n}\n.code-editor-list-tile.indirect-predecessor {\ncolor: blue;\n}\n.code-editor-list-tile.selected {\nbackground-color: #77F;\ncolor: white;\n}\n.code-editor-list-tile.hovering {\nbackground: lightgray;\n}\n.code-editor-list-tile.hovering.selected {\nbackground:  blue;\n}\n.code-editor-list-tile>.predecessor {\nfont-weight: bold;\nborder-style: inset;\nborder-width: 1px;\ntext-align: center;\ncolor: transparent;\n}\n.code-editor-list-tile.direct-predecessor>.predecessor {\ncolor: blue;\n}\n\n.CodeMirror { height: 100%; }\n\n.node {\n    background-color:white; \n    width: 2ch; \n    color: #A03; \n    font-weight:bold; \n    text-align: center;\n    font-family: arial;\n}\n.Warning { text-decoration: underline lightblue } \n.Error   { text-decoration: underline red       } \n.body    { margin         : 0px                 }\n    \"\"\"\n\ndiv [\n    style \"height: 100vh; width: 100% \"\n    rootSplitter.Render.Style(\"height: 100%; width: 100% \")\n    script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                                     ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ]\n    link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    link   [ href \"/EPFileX/css/main.css\"                                               ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    css styleEditor                                                                                                               \n    style  \"\"\" \n          color      : #333;\n          font-size  : small;\n          font-family: monospace;\n          line-height: 1.2;\n              \"\"\"\n] \n|> renderDoc\n|> RunCode.RunNode().RunDoc\n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},{"$":0,"Item":"a48d72fc-5220-4dac-b3b3-98bad48b0561"}],"id":{"$":0,"Item":"a6148457-ad15-4de6-a038-af77ff4af675"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"F# Station Layout2","content":"open Useful\nopen Template\n\ntype GuiPart     = \n   | GuiNode     of HtmlNode\n   | GuiAction   of Template.Action\n\nprintfn \"F# Station Layout\"\n\nlet swapped       = Var.Create (false, 15.0)\n\nlet SetTheSwap(swp, size) = swapped.Value <-  swp, size\n\nlet DoTheswap() = swapped.Value <- (not <| fst swapped.Value), 100.0 - snd swapped.Value\n\nlet actLoadFile       = Template.Action.New(\"Load...\"                    ).OnClick(Do id ()        )  \nlet actSaveFile       = Template.Action.New(\"Swap!\"                      ).OnClick(Do DoTheswap () )//.Highlight(dirty)\nlet actAddSnippet     = Template.Action.New(\"Add Snippet\"                ).OnClick(Do id ()        )\nlet actDeleteSnippet  = Template.Action.New(\"Delete Snippet\"             ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actIndentSnippet  = Template.Action.New(\"Indent In  >>\"              ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actOutdentSnippet = Template.Action.New(\"Indent Out <<\"              ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actGetFsCode      = Template.Action.New(\"Get F# Code\"                ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actEvalCode       = Template.Action.New(\"Evaluate F#\"                ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actRunWSNewTab    = Template.Action.New(\"Run WebSharper in new tab\"  ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actRunWSHere      = Template.Action.New(\"Run WebSharper in WS Result\").OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actRunWSIn        = Template.Action.New(\"Run WebSharper in ...\"      ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actParseCode      = Template.Action.New(\"Parse F#\"                   ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actCompileWS      = Template.Action.New(\"Compile WebSharper\"         ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actFindDefinition = Template.Action.New(\"Find Definition\"            ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\n\nlet buttonsH =\n    div [ \n          actAddSnippet    .Button.Render\n          actOutdentSnippet.Button.Render\n          actIndentSnippet .Button.Render\n          span []       \n          span []       \n          actParseCode     .Button.Render\n          actEvalCode      .Button.Render\n          actGetFsCode     .Button.Render\n       \n          actDeleteSnippet .Button.Render\n          actFindDefinition.Button.Render\n          span []       \n          actSaveFile      .Button.Render\n          span []\n          actCompileWS     .Button.Render\n          actRunWSIn       .Button.Render\n          span []       \n          style \"\"\"\n              overflow: hidden;\n              display: grid;\n              grid-template-columns: repeat(8, 12.1%);\n              bxackground-color: #eee;\n              padding : 5px;\n              grid-gap: 5px;\n          \"\"\"\n        ]\n\nlet menuLeft =\n    Menu.New2\n      [\n        MenuEntry.New(\"File\")\n            .SubMenu(\n                    [\n                        actLoadFile.MenuEntry\n                        actSaveFile.MenuEntry\n                    ]           \n            )            \n        MenuEntry.New(\"Code\")           \n            .SubMenu(           \n                    [           \n                        actAddSnippet    .MenuEntry\n                        actDeleteSnippet .MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actIndentSnippet .MenuEntry\n                        actOutdentSnippet.MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actFindDefinition.MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actGetFsCode     .MenuEntry\n                    ]     \n            )      \n        MenuEntry.New(\"Run\")     \n            .SubMenu(     \n                    [     \n                        actEvalCode      .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actRunWSNewTab   .MenuEntry\n                        actRunWSHere     .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actParseCode     .MenuEntry\n                        actCompileWS     .MenuEntry\n                    ]\n            ) \n      ]\n\nlet menuRight =\n    Menu.New2\n      [\n        MenuEntry.New(\"About\")\n      ]      \n\nlet menuBar =\n    navbar <| h1 [ htmlText \"F# Station\" ; style \"font-size: 48px; margin-top: -17px\" ]\n           <| menuLeft .Render \n           <| menuRight.Render\n\nlet output = Var.Create \"HEre\"        \nlet parser = Var.Create \"HEre\"        \n\nlet mutable x: obj =  0 :> obj\n\nlet codeMirror = \n    Template.CodeMirror.New(\"let a = \\\"123\\\" |> Str\").Style(\"height: 100%\").Render\n        .AddChildren [\n            SomeAttr <| on.afterRender(fun el   -> \n                JS.SetTimeout\n                    (fun () ->\n                        addResizeObserver(fun () ->\n                            let r = el.GetBoundingClientRect()\n                            output.Value <- sprintf \"%A\" (r.Width, r.Height) ) el\n                        printfn \"F# Station Layout\"\n                    )\n                    2000 |> ignore\n            )\n        ]\n\nlet guiParts =\n    Map [\n       \"actLoadFile      \", GuiAction actLoadFile       \n       \"actSaveFile      \", GuiAction actSaveFile       \n       \"actAddSnippet    \", GuiAction actAddSnippet     \n       \"actDeleteSnippet \", GuiAction actDeleteSnippet  \n       \"actIndentSnippet \", GuiAction actIndentSnippet  \n       \"actOutdentSnippet\", GuiAction actOutdentSnippet \n       \"actGetFsCode     \", GuiAction actGetFsCode      \n       \"actEvalCode      \", GuiAction actEvalCode       \n       \"actRunWSNewTab   \", GuiAction actRunWSNewTab    \n       \"actRunWSHere     \", GuiAction actRunWSHere      \n       \"actRunWSIn       \", GuiAction actRunWSIn        \n       \"actParseCode     \", GuiAction actParseCode      \n       \"actCompileWS     \", GuiAction actCompileWS      \n       \"actFindDefinition\", GuiAction actFindDefinition \n       \"title\"            , GuiNode   <| div [ htmlText \"Title\"    ; style \"background-color: lightblue\"  ]\n       \"snippets\"         , GuiNode   <| div [ htmlText \"Snippets\" ; style \"background-color: lightgreen\" ]\n       \"editor\"           , GuiNode   <| codeMirror\n       \"buttons\"          , GuiNode   <| buttonsH\n       \"menu\"             , GuiNode   <| menuBar\n       \"Output\"           , GuiNode   <| Template.TextArea.New( output     ).Placeholder(\"Output:\"         ).Title(\"Output\"                   ).RenderWith [ on.dblClick (fun _ _ -> JS.Alert \"DblClick\") ]\n       \"Parser\"           , GuiNode   <| Template.TextArea.New( parser     ).Placeholder(\"Parser Messages:\").Title(\"Parser Messages\"          ).RenderWith [ on.dblClick (fun _ _ -> JS.Alert \"DblClick\") ]\n       \"JavaScript\"       , GuiNode   <| Template.TextArea.New(\"codeJS    \").Placeholder(\"Javascript:\"     ).Title(\"JavaScript code generated\").Render\n       \"F# code\"          , GuiNode   <| Template.TextArea.New(\"codeFS    \").Placeholder(\"F# code:\"        ).Title(\"F# code assembled\"        ).Render\n       \"WS Result\"        , GuiNode   <| div [ div [ Id \"TestNode\" ; style \"background: white; height: 100%; width: 100%; \"] ]\n       \"Properties\"       , GuiNode   <| div [ htmlText \"Property   Value\"; style \"background-color: magenta ; font-weight: 900\"  ]\n    ]\n\ntype LayoutDescription =\n    | LdSplit    of first: bool * secT: SectionType * vertical: bool * per:float * string * string\n    | LdTabStrip of top  : bool * string []\n\nlet getNode name (parts: Map<string,GuiPart>) =\n    match Map.tryFind name parts with\n    | Some(GuiNode   node) -> node\n    | Some(GuiAction act ) -> act.Button.Render\n    | _                    -> div [ htmlText (sprintf \"GuiPart %s not found\" name) ]\n\nlet rec processLayoutSteps (steps: (string * LayoutDescription) seq) (parts: Map<string,GuiPart>) =\n    steps\n    |> Seq.tryHead\n    |> Option.map (fun (name, ld) ->\n        match ld with\n        | LdSplit   (first, secT , vertical, per, ch1, ch2) -> Grid.NewBisect(first, secT, vertical, per, getNode ch1 parts, getNode ch2 parts) .Render\n        | LdTabStrip(top  , nodes                         ) -> TabStrip.New(nodes |> Seq.map (fun node -> node, getNode node parts)).SetTop(top).Render\n        |> GuiNode \n        |> Map.add name <| parts\n        |> processLayoutSteps (steps |> Seq.skip 1)\n       )\n    |> Option.defaultValue parts\n    \nlet finishLayout parts steps  =\n    let name = steps |> Seq.last |> fst\n    processLayoutSteps steps parts\n    |> getNode name\n\nlet inline fixedHorSplitter first px ch1 ch2 = LdSplit(first, StFixedPx , false, px, ch1, ch2)\nlet inline varSplitter        ver pc ch1 ch2 = LdSplit(true , StVariable, ver  , pc, ch1, ch2)\n\nlet steps = \n    seq [\n        \"messages\"     , LdTabStrip(true \n                                  , [|\n                                       \"Output\"    \n                                       \"Parser\"    \n                                       \"JavaScript\"\n                                       \"F# code\"   \n                                       \"WS Result\" \n                                    |])\n        \"title_code\"   , fixedHorSplitter true  34.0 \"title\"         \"editor\"\n        \"code_buttons\" , fixedHorSplitter false 80.0 \"title_code\"    \"buttons\"\n        \"snippets_code\", varSplitter      true  15.0 \"snippets\"      \"code_buttons\"\n        \"main_messages\", varSplitter      false 82.0 \"snippets_code\" \"messages\"                            \n        \"main_window\"  , fixedHorSplitter true  50.0 \"menu\"          \"main_messages\"\n    ]             \n\nlet layoutSteps = Var.Create steps\n\nlet finalLayout = Val.map (finishLayout guiParts) layoutSteps |> HtmlElementV\n\nlet jsonLayout = \n    \"\"\"\n    [[\"messages\",{\"LdTabStrip\":[true,[\"Parser\",\"Output\",\"JavaScript\",\"F# code\",\"WS Result\"]]}],[\"title_code\",{\"LdSplit\":[true,\"StFixedPx\",false,34,\"title\",\"editor\"]}],[\"code_buttons\",{\"LdSplit\":[false,\"StFixedPx\",false,80,\"title_code\",\"buttons\"]}],[\"snippets_code\",{\"LdSplit\":[true,\"StVariable\",true,15,\"snippets\",\"code_buttons\"]}],[\"main_messages\",{\"LdSplit\":[true,\"StVariable\",false,82,\"snippets_code\",\"messages\"]}],[\"main_window\",{\"LdSplit\":[true,\"StFixedPx\",false,50,\"menu\",\"main_messages\"]}]]\n    \"\"\"\n\ntype LayoutDescriptionFable = \n    {\n       LdTabStrip : (bool * string[]                               ) option\n       LdSplit    : (bool * string * bool * float * string * string) option  \n    }\n\nlet toSect s =\n    match s with \n    | \"StVariable\"  -> StVariable\n    | \"StFixedPx\"   -> StFixedPx\n    | _ -> StFixedPerc\n\nlet setLayoutJson json =\n    try\n        let steps = \n            json\n            |> WebSharper.Json.Deserialize<(string * LayoutDescriptionFable)[]>\n            |> Array.choose (fun (name, ldf) ->\n                ldf.LdTabStrip\n                |> Option.map LdTabStrip\n                |> (function \n                    | Some e -> Some e \n                    | None   ->\n                    ldf.LdSplit\n                    |> Option.map (fun (first, secT: string  , vertical, per, ch1, ch2) -> \n                                LdSplit(first, secT |> toSect, vertical, per, ch1, ch2)))\n                |> Option.map (fun v -> name, v)\n            )\n        layoutSteps.Value <- steps\n        printfn \"updated layoutSteps\"\n    with e -> printfn \"Error: %A\" e\n\nsetLayoutJson jsonLayout\n\nJS.Window?setLayoutJson <- setLayoutJson\n\n//let code_messages = SplitterStructure.New(false, title_Code           , STabStrip messages,                   75.0)\n//let main_Buttons  = SplitterStructure.New(       snippets_code        , SHtmlNode buttons                 , fixedHorSplitter2 80.0)\n\nlet styleEditor    =\n     \"\"\"\nbody { margin: 0px }     \n     \ndiv textarea {\nfont-family: monospace;\n}\n.code-editor-list-tile {\nwhite-space: nowrap; \nborder-style: solid none none;\nborder-color: white;\nborder-width: 1px;\nbackground-color: #D8D8D8;\ndisplay: flex;\n}\n.code-editor-list-text{\npadding: 1px 10px 1px 5px;\noverflow:hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;\nflex: 1;\n}\n\n.code-editor-list-tile.direct-predecessor {\nfont-weight: bold;\n}\n.code-editor-list-tile.indirect-predecessor {\ncolor: blue;\n}\n.code-editor-list-tile.selected {\nbackground-color: #77F;\ncolor: white;\n}\n.code-editor-list-tile.hovering {\nbackground: lightgray;\n}\n.code-editor-list-tile.hovering.selected {\nbackground:  blue;\n}\n.code-editor-list-tile>.predecessor {\nfont-weight: bold;\nborder-style: inset;\nborder-width: 1px;\ntext-align: center;\ncolor: transparent;\n}\n.code-editor-list-tile.direct-predecessor>.predecessor {\ncolor: blue;\n}\n\n.CodeMirror { height: 100%; }\n\n.node {\n    background-color:white; \n    width: 2ch; \n    color: #A03; \n    font-weight:bold; \n    text-align: center;\n    font-family: arial;\n}\n.Warning { text-decoration: underline lightblue } \n.Error   { text-decoration: underline red       } \n.body    { margin         : 0px                 }\n    \"\"\"\n\ndiv [\n    style \"height: 100vh; width: 100% \"\n    finalLayout.Style(\"height: 100%; width: 100% \")\n    script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                                 ; ``type`` \"text/javascript\"             ]\n    link   [ href \"https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    link   [ href \"https://cdnjs.cloudflare.com/ajax/libs/bulma/0.6.1/css/bulma.min.css\"       ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    css styleEditor                                                                                                               \n    style  \"\"\" \n          color      : #333;\n          font-size  : small;\n          font-family: monospace;\n          line-height: 1.2;\n              \"\"\"\n] \n|> RunCode.RunNode().RunHtml\n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"6332dfb8-b57a-40de-b669-f796820883db"},{"$":0,"Item":"47bf25cf-e7f5-452a-9247-156146348a14"},{"$":0,"Item":"657c8f34-c917-4659-825d-c9ead206efcf"},{"$":0,"Item":"cddabd38-7ecb-4692-99bd-13ca70e4232f"},{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"}],"id":{"$":0,"Item":"a657ae67-b4ba-4249-a2f1-a4063843c9c6"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"F# Station Layout3","content":"open Useful\nopen Template\n\nprintfn \"F# Station Layout\"\n\nlet actLoadFile       = Template.Action.New(\"Load...\"                    ).OnClick(Do id ()        )  \nlet actSaveFile       = Template.Action.New(\"Swap!\"                      ).OnClick(Do id ()        )//.Highlight(dirty)\nlet actAddSnippet     = Template.Action.New(\"Add Snippet\"                ).OnClick(Do id ()        )\nlet actDeleteSnippet  = Template.Action.New(\"Delete Snippet\"             ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actIndentSnippet  = Template.Action.New(\"Indent In  >>\"              ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actOutdentSnippet = Template.Action.New(\"Indent Out <<\"              ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actGetFsCode      = Template.Action.New(\"Get F# Code\"                ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actEvalCode       = Template.Action.New(\"Evaluate F#\"                ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actRunWSNewTab    = Template.Action.New(\"Run WebSharper in new tab\"  ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actRunWSHere      = Template.Action.New(\"Run WebSharper in WS Result\").OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actRunWSIn        = Template.Action.New(\"Run WebSharper in ...\"      ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actParseCode      = Template.Action.New(\"Parse F#\"                   ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actCompileWS      = Template.Action.New(\"Compile WebSharper\"         ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actFindDefinition = Template.Action.New(\"Find Definition\"            ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\n\nlet buttonsH =\n    div [ \n          actAddSnippet    .Button.Render\n          actOutdentSnippet.Button.Render\n          actIndentSnippet .Button.Render\n          span []       \n          span []       \n          actParseCode     .Button.Render\n          actEvalCode      .Button.Render\n          actGetFsCode     .Button.Render\n       \n          actDeleteSnippet .Button.Render\n          actFindDefinition.Button.Render\n          span []       \n          actSaveFile      .Button.Render\n          span []\n          actCompileWS     .Button.Render\n          actRunWSIn       .Button.Render\n          span []       \n          style \"\"\"\n              overflow: hidden;\n              display: grid;\n              grid-template-columns: repeat(8, 12.1%);\n              bxackground-color: #eee;\n              padding : 5px;\n              grid-gap: 5px;\n          \"\"\"\n        ]\n\nlet menuLeft =\n    Menu.New2\n      [\n        MenuEntry.New(\"File\")\n            .SubMenu(\n                    [\n                        actLoadFile.MenuEntry\n                        actSaveFile.MenuEntry\n                    ]           \n            )            \n        MenuEntry.New(\"Code\")           \n            .SubMenu(           \n                    [           \n                        actAddSnippet    .MenuEntry\n                        actDeleteSnippet .MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actIndentSnippet .MenuEntry\n                        actOutdentSnippet.MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actFindDefinition.MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actGetFsCode     .MenuEntry\n                    ]     \n            )      \n        MenuEntry.New(\"Run\")     \n            .SubMenu(     \n                    [     \n                        actEvalCode      .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actRunWSNewTab   .MenuEntry\n                        actRunWSHere     .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actParseCode     .MenuEntry\n                        actCompileWS     .MenuEntry\n                    ]\n            ) \n      ]\n\nlet menuRight =\n    Menu.New2\n      [\n        MenuEntry.New(\"About\")\n      ]      \n\nlet menuBar =\n    navbar <| h1 [ htmlText \"F# Station\" ; style \"font-size: 48px; margin-top: -17px\" ]\n           <| menuLeft .Render \n           <| menuRight.Render\n\nlet output = Var.Create \"HEre\"        \nlet parser = Var.Create \"HEre\"        \n\nlet codeMirror = \n    Template.CodeMirror.New(\"let a = \\\"123\\\" |> Str\").Style(\"height: 100%\").Render\n        .AddChildren [\n            SomeAttr <| on.afterRender(fun el   -> \n                JS.SetTimeout\n                    (fun () ->\n                        addResizeObserver(fun () ->\n                            let r = el.GetBoundingClientRect()\n                            output.Value <- sprintf \"%A\" (r.Width, r.Height) ) el\n                        printfn \"F# Station Layout\"\n                    )\n                    2000 |> ignore\n            )\n        ]\n\nlet layout =\n  Layout.AddGuids\n    [\n       \"actLoadFile      \", GuiAction actLoadFile       \n       \"actSaveFile      \", GuiAction actSaveFile       \n       \"actAddSnippet    \", GuiAction actAddSnippet     \n       \"actDeleteSnippet \", GuiAction actDeleteSnippet  \n       \"actIndentSnippet \", GuiAction actIndentSnippet  \n       \"actOutdentSnippet\", GuiAction actOutdentSnippet \n       \"actGetFsCode     \", GuiAction actGetFsCode      \n       \"actEvalCode      \", GuiAction actEvalCode       \n       \"actRunWSNewTab   \", GuiAction actRunWSNewTab    \n       \"actRunWSHere     \", GuiAction actRunWSHere      \n       \"actRunWSIn       \", GuiAction actRunWSIn        \n       \"actParseCode     \", GuiAction actParseCode      \n       \"actCompileWS     \", GuiAction actCompileWS      \n       \"actFindDefinition\", GuiAction actFindDefinition \n       \"title\"            , GuiNode   <| div [ htmlText \"Title\"    ; style \"background-color: lightblue\"  ]\n       \"snippets\"         , GuiNode   <| div [ htmlText \"Snippets\" ; style \"background-color: lightgreen\" ]\n       \"editor\"           , GuiNode   <| codeMirror\n       \"buttons\"          , GuiNode   <| buttonsH\n       \"menu\"             , GuiNode   <| menuBar\n       \"Output\"           , GuiNode   <| Template.TextArea.New( output     ).Placeholder(\"Output:\"         ).Title(\"Output\"                   ).RenderWith [ on.dblClick (fun _ _ -> JS.Alert \"DblClick\") ]\n       \"Parser\"           , GuiNode   <| Template.TextArea.New( parser     ).Placeholder(\"Parser Messages:\").Title(\"Parser Messages\"          ).RenderWith [ on.dblClick (fun _ _ -> JS.Alert \"DblClick\") ]\n       \"JavaScript\"       , GuiNode   <| Template.TextArea.New(\"codeJS    \").Placeholder(\"Javascript:\"     ).Title(\"JavaScript code generated\").Render\n       \"F# code\"          , GuiNode   <| Template.TextArea.New(\"codeFS    \").Placeholder(\"F# code:\"        ).Title(\"F# code assembled\"        ).Render\n       \"WS Result\"        , GuiNode   <| div [ div [ Id \"TestNode\" ; style \"background: white; height: 100%; width: 100%; \"] ]\n       \"Properties\"       , GuiNode   <| div [ htmlText \"Property   Value\"; style \"background-color: magenta ; font-weight: 900\"  ]\n    ]\n\nlet steps = \n    seq [\n        \"messages\"     , GuiTabStrip(true \n                                   , [|\n                                        \"Output\"    \n                                        \"Parser\"    \n                                        \"JavaScript\"\n                                        \"F# code\"   \n                                        \"WS Result\" \n                                     |])\n        \"title_code\"   , fixedHorSplitter true  34.0 \"title\"         \"editor\"\n        \"code_buttons\" , fixedHorSplitter false 80.0 \"title_code\"    \"buttons\"\n        \"snippets_code\", varSplitter      true  15.0 \"snippets\"      \"code_buttons\"\n        \"main_messages\", varSplitter      false 82.0 \"snippets_code\" \"messages\"                            \n        \"main_window\"  , fixedHorSplitter true  50.0 \"menu\"          \"main_messages\"\n    ]             \n\nlet jsonLayout = \n    \"\"\"\n    [[\"messages\",{\"GuiTabStrip\":[true,[\"Parser\",\"Output\",\"JavaScript\",\"F# code\",\"WS Result\"]]}],[\"title_code\",{\"GuiSplit\":[true,\"StFixedPx\",false,34,\"title\",\"editor\"]}],[\"code_buttons\",{\"GuiSplit\":[false,\"StFixedPx\",false,80,\"title_code\",\"buttons\"]}],[\"snippets_code\",{\"GuiSplit\":[true,\"StVariable\",true,15,\"snippets\",\"code_buttons\"]}],[\"main_messages\",{\"GuiSplit\":[true,\"StVariable\",false,82,\"snippets_code\",\"messages\"]}],[\"main_window\",{\"GuiSplit\":[true,\"StFixedPx\",false,50,\"menu\",\"main_messages\"]}]]\n    \"\"\"\nlayout.ExportSetLayoutJson \"setLayoutJson\"\nlayout.SetLayoutJson jsonLayout\n\n\n//let code_messages = SplitterStructure.New(false, title_Code           , STabStrip messages,                   75.0)\n//let main_Buttons  = SplitterStructure.New(       snippets_code        , SHtmlNode buttons                 , fixedHorSplitter2 80.0)\n\nVal.sink (fun _ -> layout.SelectTab \"Output\"    |> ignore ) output \n\nlet styleEditor    =\n     \"\"\"\nbody { margin: 0px }     \n     \ndiv textarea {\nfont-family: monospace;\n}\n.code-editor-list-tile {\nwhite-space: nowrap; \nborder-style: solid none none;\nborder-color: white;\nborder-width: 1px;\nbackground-color: #D8D8D8;\ndisplay: flex;\n}\n.code-editor-list-text{\npadding: 1px 10px 1px 5px;\noverflow:hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;\nflex: 1;\n}\n\n.code-editor-list-tile.direct-predecessor {\nfont-weight: bold;\n}\n.code-editor-list-tile.indirect-predecessor {\ncolor: blue;\n}\n.code-editor-list-tile.selected {\nbackground-color: #77F;\ncolor: white;\n}\n.code-editor-list-tile.hovering {\nbackground: lightgray;\n}\n.code-editor-list-tile.hovering.selected {\nbackground:  blue;\n}\n.code-editor-list-tile>.predecessor {\nfont-weight: bold;\nborder-style: inset;\nborder-width: 1px;\ntext-align: center;\ncolor: transparent;\n}\n.code-editor-list-tile.direct-predecessor>.predecessor {\ncolor: blue;\n}\n\n.CodeMirror { height: 100%; }\n\n.node {\n    background-color:white; \n    width: 2ch; \n    color: #A03; \n    font-weight:bold; \n    text-align: center;\n    font-family: arial;\n}\n.Warning { text-decoration: underline lightblue } \n.Error   { text-decoration: underline red       } \n.body    { margin         : 0px                 }\n    \"\"\"\n\ndiv [\n    style \"height: 100vh; width: 100% \"\n    layout.Render.Style(\"height: 100%; width: 100% \")\n    script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                                     ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ]\n    link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    link   [ href \"/EPFileX/css/main.css\"                                               ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    css styleEditor                                                                                                               \n    style  \"\"\" \n          color      : #333;\n          font-size  : small;\n          font-family: monospace;\n          line-height: 1.2;\n              \"\"\"\n] \n|> RunCode.RunNode().AddFontAwesome.AddBulma.RunHtml\n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"6332dfb8-b57a-40de-b669-f796820883db"},{"$":0,"Item":"47bf25cf-e7f5-452a-9247-156146348a14"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},{"$":0,"Item":"9c870b72-8f9a-4e7d-ad81-7f1fd73fdd76"}],"id":{"$":0,"Item":"1fe628a8-4e42-47d0-bc2d-90cb7abe2153"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"let snippetName0 (content: string) =\n    content.Split([| '\\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n    |> Seq.map    (fun l -> l.Trim())\n    |> Seq.filter (fun l -> not (l.StartsWith(\"#\") || l.StartsWith(\"[<\")))\n    |> Seq.tryHead\n    |> Option.defaultValue \"<empty>\"\n\n[\n  \"\"\"#if INTERACTIVE\n  #I @\"../WebServer/bin\"\n  #else\n  namespace TestFS\n  #endif\n  #nowarn \"1182\"\n  \"\"\"    \n  |> snippetName0    \n  \"[< hjhj >]\n    let name = \n  \" \n  |> snippetName0\n]\n|> Seq.map (htmlText >> List.singleton >> li)\n|> ul\n|> RunCode.RunNode().ShowHtmlResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[],"id":{"$":0,"Item":"a54701f2-1d68-4997-a1ea-62deaeb73e1b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Test mouse","content":"//Template.Button.New(\"Run JS\").Style(\"vertical-align:top\").OnClick(fun _ _ -> JS.Eval(\"alert('hello')\") |> ignore).Render\n//|> getStyle\n//|> sprintf \"%A\"\n//|> RunCode.RunNode().ShowResult\nlet panel1 res =\n    Template.Panel.New\n      .Title(Val.map (fun pressed -> if pressed then \"PRESSED\" else \"---\") Input.Mouse.MousePressed)\n      .Header([])\n      .Content([ h3 [ htmlText <| sprintf \"%A\" res ; style \"font-family:monospace;\"] ])\n      .Render\n\n\ndiv [ ``class`` \"container\"\n      panel1 <| 7 * 7\n      div [ ``class`` \"container\"\n            div [ ``class`` \"container\"\n                  panel1 <| 7 * 8\n\n                ]\n          ]\n    ]\n|> RunCode.RunNode().AddBootstrap.RunHtml\n     ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}],"id":{"$":0,"Item":"4dc58ba1-75d1-4c96-9641-235ee7d8c2c2"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"[1..10] |> Seq.take 5 |> Seq.toArray\n|> RunCode.RunNode().ShowResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[],"id":{"$":0,"Item":"74b8570e-dcd4-4dff-87a5-cd7ec96b8527"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"InputSelect","content":"module InputSelect = \n    type Position =\n        | Below\n        | Right\n        | Tab\n        | NewBrowser\n        \n    let positionTxt v =\n        match v with\n        | Below      -> \"Below\"\n        | Right      -> \"Right\"\n        | Tab        -> \"In Tab\"\n        | NewBrowser -> \"New Browser\" \n    \n    let position = Var.Create Below \n    \n    let inp = Template.Input.New(position.Lens positionTxt (fun prev s -> \n        match s with\n        | \"Below\"        -> Below     \n        | \"Right\"        -> Right     \n        | \"In Tab\"       -> Tab       \n        | \"New Browser\"  -> NewBrowser\n        | _              -> prev\n        ) )\n    \n    div [\n      inp.Render\n      Doc.Select [] positionTxt [ Below ; Right ; Tab ; NewBrowser ] position |> someElt\n    ]\n    |> RunCode.RunNode().RunHtml\n        ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"38b21610-7350-4676-993b-88fea844314f"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Regex Pattern matching","content":"// WARNING THIS CAN GET FSHARPSTATION IN AN INFINITE LOOP. RUN IT FROM A SEPARATE INSTANCE\nmodule regex1 =\n    // from: https://github.com/intellifactory/websharper/blob/master/docs/ECMA-262.md\n    let str    = new String(\"Bob likes pineapples.\")\n    let regex  = new RegExp(@\"^\\w+\") // matches the first word\n    let newstr = str.Replace(regex,\"Alice\")\n    \n    let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n        if value = null then None else\n        try \n            match String(value).Match(RegExp(expr, opt)) with\n            | null         -> None\n            | [| |]        -> None\n            | m            -> Some m\n        with e -> None\n        \n    let duple a b = a, b\n    4 * 8\n    let txt = \"\"\"Compiling to JavaScript...\n    2 errors, 0 warnings\n    ErrFSharp\n      \"F# Regex Pattern matching (47,39) - (47,40) parse 10: Unexpected symbol '<' in expression\"\n    ErrFSharp\n      \"F# Regex Pattern matching (47,49) - (47,50) parse 514: End of file in string begun at or before here\" \n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"  \n    Evaluating F# code...\n    (6) F# 7k.fsx(1,7): error FS1156: This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).  \n    Compiling to JavaScript...\n    6 errors, 1 warnings\n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (120, 19) - (120, 46) Type not found in JavaScript compilation: System.Text.RegularExpressions.Regex\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 14) - (121, 23) Type not found in JavaScript compilation: System.Text.RegularExpressions.Group\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 67) - (121, 74) Type not found in JavaScript compilation: System.Text.RegularExpressions.Capture\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.Match\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Method name not found in JavaScript compilation: (EnumerateFromFunctions<_,_> : (unit -> 'T0) * ('T0 -> System.Boolean) * ('T0 -> 'T1) -> System.Collections.Generic.IEnumerable`1<'T1>), Members: safeDispose, EnumerateThenFinally, EnumerateUsing, EnumerateWhile, CreateEvent\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.GroupCollection\"\n    \"\"\"\n    let rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\\.\"\"\"\n    let rex2 = \"\"\"(Err|Warning|Info)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) ?)?F?#? ?(.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\n    //\"\n    let rex = rex1 + \"|\" + rex2\n    \n    //[ \"JavaScript RegExp:\"\n    //  sprintf \"String(%A).Match  %A: %A\" txt rex <| String(txt).Match rex\n    //  sprintf \"Active pattern: %A\" <|\n    //      match txt with\n    //      | REGEX rex m -> m\n    //      | _           -> \"<no match>\"\n    //]\n    //|> List.map  (fun t -> div [ htmlText t ] )\n    //|> fun lst -> List.Cons (style \"text-align: left\", lst)  // two different styles\n    //|> List.map  (htmlText >> List.singleton >> div )\n    //|> (duple (style \"text-align: left\") >> List.Cons) \n    //|> RunCode.RunNode().ShowHtmlResult\n    \n    let inp = Template.TextArea.New(txt)                            .Placeholder(\"Text\")\n    let rx  = Template.Input   .New(rex).Prefix(htmlText \"RegEx  :\").Placeholder(\"Regex: . \\d \\w \\s \\n \\r \\t \\f (|)[a-z]+*?{3,5}\")  \n    let opt = Template.Input   .New(\"g\").Prefix(htmlText \"Options:\").Placeholder(\"Options: g i m u y\") \n    \n    h5 [\n      htmlText \" WARNING! THIS CAN GET FSHARPSTATION IN AN INFINITE LOOP. RUN IT FROM A SEPARATE INSTANCE\"\n      inp.Render\n      rx .Render\n      opt.Render\n      Val.map3 (fun inp rx opt ->\n              ul [\n                  match inp with\n                  | REGEX rx opt m -> yield! m |> Array.map (htmlText >> List.singleton >> li)\n                  | _              -> yield  htmlText \"<no match>\" \n              ]\n          ) inp.Var rx.Var opt.Var\n          |> bindHElem id\n    ]\n    |> RunCode.RunNode().ShowHtmlResult\n    \n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n    //open System.Text.RegularExpressions\n    //\n    //let (|Regex|_|) pattern input =\n    //    let m = Regex.Match(input, pattern)\n    //    if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])\n    //    else None\n    //\n    ////Example:\n    //let phone = \"(555) 555-5555\"\n    //match phone with\n    //| Regex @\"\\(([0-9]{3})\\)[-. ]?([0-9]{3})[-. ]?([0-9]{4})\" [ area; prefix; suffix ] ->\n    //    printfn \"Area: %s, Prefix: %s, Suffix: %s\" area prefix suffix\n    //| _ -> printfn \"Not a phone number\"","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"7754c074-862e-4550-9d61-ea837adf6d85"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Regex Pattern matching2","content":"module regex2 =\n    let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n        if value = null then None else\n        try \n            match String(value).Match(RegExp(expr, opt)) with\n            | null         -> None\n            | [| |]        -> None\n            | m            -> Some m\n        with e -> None \n       \n    let txt = \"\"\"Compiling to JavaScript...\n    Compiling to JavaScript...\n    Compiled!\n    0 errors, 1 warnings\n    WarningFSharp\n      \"(6)47f7c0ba-35b0-466e-a759-4e4d9963e524 codeMirror (1,11) - (1,19) typecheck 1178: The struct, record or union type 'KeyMapF2' is not structurally comparable because the type 'obj' does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type 'KeyMapF2' to clarify that the type is not comparable\"\n      2 errors, 0 warnings\n    ErrFSharp\n      \"F# Regex Pattern matching (47,39) - (47,40) parse 10: Unexpected symbol '<' in expression\"\n    ErrFSharp\n      \"F# Regex Pattern matching (47,49) - (47,50) parse 514: End of file in string begun at or before here\" \n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"  \n    Evaluating F# code...\n    (6) F# 7k.fsx(1,7): error FS1156: This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).  \n    Compiling to JavaScript...\n    6 errors, 1 warnings\n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (120, 19) - (120, 46) Type not found in JavaScript compilation: System.Text.RegularExpressions.Regex\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 14) - (121, 23) Type not found in JavaScript compilation: System.Text.RegularExpressions.Group\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 67) - (121, 74) Type not found in JavaScript compilation: System.Text.RegularExpressions.Capture\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.Match\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Method name not found in JavaScript compilation: (EnumerateFromFunctions<_,_> : (unit -> 'T0) * ('T0 -> System.Boolean) * ('T0 -> 'T1) -> System.Collections.Generic.IEnumerable`1<'T1>), Members: safeDispose, EnumerateThenFinally, EnumerateUsing, EnumerateWhile, CreateEvent\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.GroupCollection\"\n    \"\"\"\n    let rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\\.\"\"\"\n    let rex2 = \"\"\"(Err|Warning)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) )?F# (.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\n    let rex = rex1 + \"|\" + rex2\n    \n    match txt with\n    | REGEX rex \"g\" m -> m\n    | _               -> [||]\n    |> Array.choose (fun v ->\n        match v with\n        | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, int fl, int fc - int indent, int tl, int tc - int indent, sev, from , msg)\n        | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, int fl, int fc - int indent, int fl, int fc - int indent, sev, \"fsi\", msg)\n        | _ -> None\n    )\n    |> Array.map (fun (file, fl, fc, tl, tc, sev, from, msg) -> sprintf \"%s (%d,%d)-(%d,%d) %s %s : %s\" file fl fc tl tc sev from msg)\n    |> Array.map (htmlText >> List.singleton >> List.append [ style \"text-align: left\" ] >> li)\n    |> h5\n    |> RunCode.RunNode().ShowHtmlResult\n    ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"ff6bfed0-83ae-4497-b197-fea6432aa958"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Load File","content":"let fileName = Var.Create \"\"\nlet justFileName (f:string) = f.Split [| '/' ; '\\\\' |] |> Seq.last\n\nTemplate.Input \n    .New(fileName.Lens justFileName (fun prev n -> prev) )\n    .Prefix(\n        label [ \n            ``class`` \"btn btn-primary\" \n            htmlText \"Browse...\" \n            Template.Input.New(fileName).Type(\"file\").Style(\"display: none\")\n              .Content([ on.change (fun el _ -> JS.Alert \"loading \" ) ]) \n              .Render \n        ])\n    .Render\n|> RunCode.RunNode().ShowHtmlResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"ee8fe0d0-14ad-4ae8-bd77-e0918817d67e"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Storage","content":"module Storage =\n    let min        = Template.Input.New(\"25.0\").Prefix(htmlText \"Min:  \")\n    let max        = Template.Input.New(\"75.0\").Prefix(htmlText \"Max:  \")\n    let value      = Template.Input.New(\"40.0\").Prefix(htmlText \"Value:\")\n    \n    let settingsStorage = JS.Window.LocalStorage\n    \n    settingsStorage.GetItem \"CodeEditor.min\"   |> fun v -> if v <> null then min  .Var.Value <- v\n    settingsStorage.GetItem \"CodeEditor.max\"   |> fun v -> if v <> null then max  .Var.Value <- v\n    settingsStorage.GetItem \"CodeEditor.value\" |> fun v -> if v <> null then value.Var.Value <- v\n    \n    Val.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.min\"  , v)) min  .Var\n    Val.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.max\"  , v)) max  .Var\n    Val.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.value\", v)) value.Var\n    \n    let styleT   p =\n      p |> sprintf \"\"\"\n    .SplitterArea {\n        display: grid;\n        grid-template-columns: %f%% auto;\n        grid-template-areas:   \"left right\";\n        background-color: #41414d;\n        color: #444;\n        height: 50px;\n        grid-gap: 9px;\n        padding : 9px;\n    }\n    \n    .SplitterArea > :nth-child(1){  grid-area: left  ; overflow: hidden; background-color: lightgreen; }\n    .SplitterArea > :nth-child(2){  grid-area: right ; overflow: hidden; background-color: lightblue ; }\n    \n    .Splitter { \n        grid-column     :    2      ;\n        grid-row        :  1/2      ;\n        width           :    5px    ; \n        margin-left     : -7.5px    ; \n        border          :    0px    ; \n        padding         :    0px    ;\n        cursor          : col-resize;\n      \tbackground-color: #eef      ; \n    }   \"\"\"\n    \n    let splitter   = Template.SplitterBar\n                         .New(value.Var.Lens (fun s -> float s) (fun prev f -> sprintf \"%f\" <| (f * 10. |> Math.Round |> float ) / 10. ) )\n                         .Min(Val.map float min.Var)\n                         .Max(Val.map float max.Var)\n                         \n    \n    let bar =\n        div [\n          ``class`` \"SplitterArea\"\n          div    [ htmlText <| Val.map (             sprintf \"LEFT  %f\")  splitter.GetValue ]\n          div    [ htmlText <| Val.map (((-)100.) >>(sprintf \"RIGHT %f\")) splitter.GetValue ]\n          styleH [ htmlText <| Val.map styleT                             splitter.GetValue ]\n          splitter.Render\n        ]\n        \n    div [\n      bar\n      min  .Render\n      max  .Render\n      value.Render\n    ]\n    |> RunCode.RunNode().AddBootstrap.RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"3d8bf6d2-a66b-4f18-aa83-8e74836e38e4"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Messaging Test","content":"//#r @\"remote.dll\"\n\n//open CIPHERPrototype.Messaging\nopen FsStationShared\nopen System\nopen Useful\n\nlet messageTypes = \n    [\n        GetSnippetContentById CodeSnippetId.New\n        GetSnippetCodeById    CodeSnippetId.New\n        GetSnippetPredsById   CodeSnippetId.New\n        GetSnippetById        CodeSnippetId.New\n        GetSnippetContent     [||]\n        GetSnippetPreds       [||]\n        GetSnippetCode        [||]\n        GetSnippetJSCode      [||]\n        GetSnippet            [||]\n        GenericMessage        \"\"\n        GetIdentification     \n        GetWholeFile\n    ]\n    \nlet messageTxt v =\n    match v with\n    | GetSnippetContentById _ -> \"GetSnippetContentById\"\n    | GetSnippetCodeById    _ -> \"GetSnippetCodeById   \"\n    | GetSnippetPredsById   _ -> \"GetSnippetCodeById   \"\n    | GetSnippetById        _ -> \"GetSnippetById       \"\n    | GetSnippetContent     _ -> \"GetSnippetContent    \"\n    | GetSnippetPreds       _ -> \"GetSnippetPreds      \"\n    | GetSnippetCode        _ -> \"GetSnippetCode       \"\n    | GetSnippetJSCode      _ -> \"GetSnippetJSCode     \" \n    | GetSnippet            _ -> \"GetSnippet           \"\n    | GenericMessage        _ -> \"GenericMessage       \"\n    | RunSnippetUrlJS       _ -> \"RunSnippetUrlJS      \"\n    | RunSnippetUrlJSById   _ -> \"RunSnippetUrlJSById  \"\n    | GetIdentification       -> \"GetIdentification    \"\n    | GetWholeFile            -> \"GetWholeFile         \"\n\nlet fsClient = FsStationClient(\"MessagingTest\")\n\nlet snpId       = Var.Create \"\" \nlet message     = Var.Create \"\"\nlet messageType = Var.Create GetIdentification\n\nlet listener  : Var<string option> = Var.Create None\nlet listeners : Var<string[]     > = Var.Create [||]\n\nlet getListeners _ _ =\n    async {\n        let! ls          = fsClient.MessagingClient.POListeners()\n        do   if listeners.Value <> ls then listeners.Value <- ls\n    } |> Async.Start\n\nlet requestMessage msgT (content:string) : Async<string> =\n    let msg =\n        match msgT with\n        | GetSnippetContentById _ -> GetSnippetContentById  <| CodeSnippetId (Guid content)\n        | GetSnippetCodeById    _ -> GetSnippetCodeById     <| CodeSnippetId (Guid content)\n        | GetSnippetPredsById   _ -> GetSnippetPredsById    <| CodeSnippetId (Guid content)\n        | GetSnippetById        _ -> GetSnippetById         <| CodeSnippetId (Guid content)\n        | RunSnippetUrlJSById   _ -> RunSnippetUrlJSById    <|(CodeSnippetId (Guid content), \"http://localhost:9000\")\n        | RunSnippetUrlJS       _ -> RunSnippetUrlJS        <|(content.Split '/'           , \"http://localhost:9000\")\n        | GetSnippetContent     _ -> GetSnippetContent      <| content.Split '/'\n        | GetSnippetPreds       _ -> GetSnippetPreds        <| content.Split '/'\n        | GetSnippetCode        _ -> GetSnippetCode         <| content.Split '/'\n        | GetSnippetJSCode      _ -> GetSnippetJSCode       <| content.Split '/'\n        | GetSnippet            _ -> GetSnippet             <| content.Split '/'\n        | GenericMessage        _ -> GenericMessage         <| content\n        | GetIdentification       -> GetIdentification    \n        | GetWholeFile            -> GetWholeFile         \n    async {\n        let! response = fsClient.SendMessage(AddressId(listener.Value |> Option.defaultValue \"WebServer:PostOffice\"), msg) |> Wrap.getAsync\n        let resp =\n            match response with\n            | SnippetResponse(Some snp )    -> snp  |> Json.Serialize\n            | SnippetsResponse     snps     -> snps |> Json.Serialize\n            | StringResponse (Some code)    -> code\n            | IdResponse      id            -> id\n            | _                             -> sprintf \"<Incomplete response: %A>\" response\n        return resp\n    }\n\ndiv [\n    Doc.SelectDynOptional [ on.click getListeners ] \"--\" id    (View.Map Seq.toList listeners.View) listener    |> someElt\n    Doc.Select            [ ] messageTxt messageTypes                         messageType |> someElt\n    Template.Input   .New(snpId  ).Render\n    Template.TextArea.New(message).Render\n    Template.Button.New(\"Send Message to Server\").OnClick(fun _ _ ->\n        async {\n          message.Value <- \"Sending request...\"\n          let! code = requestMessage messageType.Value snpId.Value\n          message.Value <- code\n          return ()\n        }  |> Async.Start\n      ).Render\n]    \n|> RunCode.RunNode().ShowHtmlResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}],"id":{"$":0,"Item":"e9c3ceaf-8fe5-4752-aa4c-2db6e1ac4577"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Messaging Test WebSockets","content":"#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net45\\Owin.WebSocket.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net45\\WebSharper.Owin.WebSocket.dll\"\n\nopen WSMessagingBroker\nopen System\nopen Useful\nopen WebSharper.Owin.WebSocket\nopen WebSharper.Owin.WebSocket.Client\n\nlet messaging = new WSMessagingClient(\"Messaging Test WebSockets\")\n\n[< NamedUnionCases \"type\" >]\ntype Incoming  =\n| MessageInt    of int\n| MessageString of string\n\n[< NamedUnionCases \"type\" >]\ntype Replies  =\n| ReplyInt    of int\n| ReplyString of string\n\nlet processor msg = Wrap.wrapper {\n    return\n        match msg with\n        | MessageInt    i -> ReplyString (sprintf \"%d\" i)\n        | MessageString s -> ReplyInt    (int s)\n}\n    \nmessaging.ProcessIncoming processor    \n\nlet messageTypes = \n    [\n      MsgInformation             // does not expect a reply, payload may or may not be structured\n      MsgRequest                 // expects a reply, structured payload\n      MsgReply                   // structured payload.\n      MsgFromBroker              // Broker ErrorMessage. Only Broker should use this payload is error message\n      MsgRequestForId            // expects reply as Information with id\n      MsgRequestForEcho          // expects reply as Information with same payload\n    ]\n\nlet messageTxt (v: MessageType) = sprintf \"%A\" v\n\n(*\nlet messageTxt v =\n    match v with\n    | MsgInformation    -> \"MsgInformation\"\n    | MsgRequest        -> \"MsgRequest\"\n    | MsgReply          -> \"MsgReply\"\n    | MsgFromBroker     -> \"MsgFromBroker\"\n    | MsgRequestForId   -> \"MsgRequestForId\"\n    | MsgRequestForEcho -> \"MsgRequestForEcho\"\n*)    \n\nlet content     = Var.Create \"\"\nlet message     = Var.Create \"\"\nlet messageType = Var.Create MsgInformation\n\nlet listener  : Var<string option> = Var.Create None\nlet listeners : Var<string[]     > = Var.Create [||]\n\nlet clientId      = \"Messaging Test WebSockets\"\nlet clientAddress = Address clientId\n\nlet out     s   = message.Value <- message.Value + s\nmessaging.Out  <-            out \nlet printfn fmt = printoutfn out fmt\n\nlet sendMessage() : Wrap<string> =\n    match listener.Value with\n    | None        -> Wrap.wrapper.Return(\"\")\n    | Some destId ->\n    let dest = Address destId\n    match messageType.Value with\n    | MsgInformation    \n    | MsgRequestForEcho -> newMsg           dest content.Value\n    | MsgRequestForId   -> newMsgSerialized dest \"\"           \n    | _                 -> newMsgSerialized dest content.Value\n    |> msgType messageType.Value\n    |> messaging.SendMsg\n\nlet getListeners _ _ =\n    Wrap.wrapper {\n        let! ls0 = messaging.MBListeners\n        let  ls  = ls0 |> Array.append [| MessageBrokerId |]\n        if listeners.Value <> ls then listeners.Value <- ls\n    } |> Wrap.start (printoutfn out \"%s\")\n\ndiv [\n    Doc.SelectDynOptional [ on.click getListeners ] \"--\" id    (View.Map Seq.toList listeners.View) listener    |> someElt\n    Doc.Select            [ ] messageTxt messageTypes                         messageType |> someElt\n    Template.Input   .New(content).Render\n    Template.TextArea.New(message).Render\n    Template.Button.New(\"Send Message\").OnClick(fun _ _ ->\n          if listener.Value.IsSome then\n              message.Value <- sprintf \"Sending %s...\" ((sprintf \"%A\" messageType.Value).Substring(3, 30))\n              sendMessage() |> Wrap.map ignore |> Wrap.start (printoutfn out \"%s\")\n      ).Render\n]    \n|> RunCode.RunNode().ShowHtmlResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"e665bede-c870-4041-b7ed-8be419c52a83"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"cc84fb0b-d0c9-4374-af92-587174f75d64"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Json.Parse","content":"module JsonParse =\n    open Useful\n    open FsStationShared\n    //let provider = WebSharper.Json.Provider\n    let inp = Template.TextArea.New(\"[ { \\\"name\\\": \\\"Hello\\\" }, { \\\"name\\\": \\\"How are you?\\\" } ]\").Placeholder(\"Text\")\n    \n    let inline ifUndef def v = if isUndefined v then def else v\n    let obj2CodeSnippetId o = \n        if isUndefined o then\n            System.Guid(\"00000000-0000-0000-0000-000000000000\")\n        else\n            o?Item\n        |> CodeSnippetId \n    \n    let obj2CodeSnippetIdO o = // the json representation of an option is different from the internal representation\n        if isUndefined o then\n            None\n        else\n            Some <| obj2CodeSnippetId o\n    \n    let obj2Map o =\n        if isUndefined o then\n            Map.empty\n        else\n            JS.GetFields o |> Array.map (fun (f, v) -> f, v :?> string ) |> Map.ofSeq\n    \n//    let deserializeCodeSnipets v = \n//        try\n//            let objs= WebSharper.Json.Parse v |> unbox<obj[]>\n//            printfn \"%A\" <| Array.length objs\n//            let snps =\n//                objs\n//                |> Array.choose (fun o ->\n//                     if isUndefined o then None else\n//                     {\n//                        name         = o?name         |> ifUndef \"\"\n//                        content      = o?content      |> ifUndef \"\"\n//                        parent       = o?parent       |> obj2CodeSnippetIdO\n//                        predecessors = o?predecessors |> ifUndef [||] |> Array.map  obj2CodeSnippetId |> Seq.toList\n//                        id           = o?id           |> obj2CodeSnippetId\n//                        expanded     = o?expanded     |> ifUndef false\n//                        level        = o?level        |> ifUndef 0\n//                        properties   = o?properties   |> obj2Map\n//                      } |> Some)\n//            snps\n//        with _ -> [||]\n    \n    let parse json =\n        try WebSharper.Json.Parse json |> sprintf \"%A\"\n        with e -> sprintf \"%A\" e\n    \n    h5 [\n      inp.Render\n      div [ htmlText <| Val.map parse inp.Var ]\n    ]\n    |> RunCode.RunNode().ShowHtmlResult\n    ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}],"id":{"$":0,"Item":"b47dbe9c-8623-4b35-98ee-5073edfc21b3"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Json Serialize Deserialize","content":"// CORS does not allow Ajax calls to a different origin\n\nmodule JsonSD =\n    type ParseRequest         = { FileName  : string ; IsAsync    : bool   ; Lines : string[]           ; Version : int                                            }\n    let value = {\n        FileName  = \"hello.fsx\"\n        IsAsync   = true\n        Lines     = [| \"line1\" ; \"line2\" ; \"line3\" |]\n        Version  = 8\n    }\n    let json = Json.Serialize value\n    let des : ParseRequest = Json.Deserialize json\n    \n    let ajaxCall url m (data:string) =\n        let ajaxInvoke (ok, ko, _) =\n            let success (result:obj)         _ _ = result :?> string                   |> ok\n            let error   (jqXHR:JQuery.JqXHR) _ _ = System.Exception jqXHR.ResponseText |> ko\n            let ajaxSettings : JQuery.AjaxSettings =\n                JQuery.AjaxSettings(\n                    Url         = url\n                  , Type        = m\n                  , ContentType = Union2Of2 \"application/json\" \n                  , DataType    = JQuery.DataType.Text\n                  , Success     = System.Action<_,_,_> success\n                  , Error       = System.Action<_,_,_> error\n                  , Data        = data\n                  , Timeout     = 300000.0\n                  , CrossDomain = true\n                )\n            JQuery.JQuery.Post ajaxSettings |> ignore\n        Async.FromContinuations ajaxInvoke\n\n    let HttpRequestCall (url:string) method_ (data:string) =\n        async {\n            let! resp = ajaxCall url method_ data           \n//            req.ProtocolVersion <- HttpVersion.Version10\n            return       resp\n        }\n        \n    let resp = Var.Create \"calling ...\"\n    async { \n        let! r = HttpRequestCall \"https://requestb.in/q01t7aq0\" JQuery.RequestType.POST json \n        //let! r = HttpRequestCall \"https://requestb.in/q01t7aq0\" //\"http://localhost:9001/parse\" JQuery.RequestType.POST json \n        resp.Value <- r\n    } |> Async.Start\n\n    h5 [\n      div [ htmlText (sprintf \"%A\" value) ]\n      div [ htmlText json                 ]\n      div [ htmlText (sprintf \"%A\" des  ) ]\n      div [ htmlText resp                 ]\n    ]\n    |> RunCode.RunNode().ShowHtmlResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[],"id":{"$":0,"Item":"8f3b3ae9-09e3-42cb-868f-04e8fd9e7a03"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Grid Bisect","content":"open Template\n\nGrid.NewBisect(true, StVariable, false, 38.1953\n      , Grid.NewBisect(true, StVariable, true , 38.1953, div[ htmlText \"One\"   ], div[ htmlText \"Two\"  ]).Render\n      , Grid.NewBisect(true, StVariable, true , 38.1953, div[ htmlText \"Three\" ], div[ htmlText \"Four\" ]).Render\n    ).Content(style \"height: 100vh\").Render\n|> RunCode.RunNode().RunHtml\n\n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"}],"id":{"$":0,"Item":"054a5cfc-2353-41a2-ab17-251c87cd4f38"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Snippets2","content":"[< JavaScript >]\nmodule Snippets2 = ","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"},{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"}],"id":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"expanded":false,"level":0,"levelCode":0,"properties":{}},{"name":"Tab Panel","content":"printfn \"strip\"\nopen Template\n#nowarn \"1178\"\n\ntype SplitterNode = | SplitterNode of Var<SplitterStructure>\nand  SplitterStructure =\n    | HtmlNode of HtmlNode\n    | TabStrip of TabStrip\n    | Split    of bool * Var<float> * SplitterNode * SplitterNode\nwith    \n    static member New(vertical : bool, child1, child2) = Split(vertical, Var.Create 50.0, SplitterNode (Var.Create             child1), SplitterNode (Var.Create             child2))\n    static member New(vertical : bool, child1, child2) = Split(vertical, Var.Create 50.0, SplitterNode (Var.Create <| HtmlNode child1), SplitterNode (Var.Create <| HtmlNode child2))\n    static member New(vertical : bool, child1, child2) = Split(vertical, Var.Create 50.0, SplitterNode (Var.Create <| TabStrip child1), SplitterNode (Var.Create <| TabStrip child2))\n    static member New(strip                          ) = TabStrip strip\n    static member New(node                           ) = HtmlNode node\n\nlet rec renderSplitterNode      sn = match sn with SplitterNode chV -> bindHElem (fun ch -> renderSplitterStructure ch) chV \nand     renderSplitterStructure ss =\n        match ss with\n        | HtmlNode node                -> node\n        | TabStrip strip               -> strip.Render  \n        | Split   (ver, var, ch1, ch2) ->\n        let grid = Grid.New.Content(\"one\", renderSplitterNode ch1)\n                           .Content(\"two\", renderSplitterNode ch2).Padding(0.0)\n        if ver then grid.ColVariable(50.0).ColAuto(50.0).Content( style \"grid-template-areas: 'one   two' \" ).Render\n               else grid.RowVariable(50.0).RowAuto(50.0).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\ntype SplitterNode with\n    static member New        ss           = SplitterNode <| Var.Create ss\n    static member New       (ss:HtmlNode) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    static member New       (ss:TabStrip) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    member this.Render                    = renderSplitterNode this\n    member this.Var                       = match this with SplitterNode chV -> chV\n    member this.Value                     = this.Var.Value\n    member this.SplitMe(first, ver, node) =\n        this.Var.Value <- if first then SplitterStructure.New(ver, node      , this.Value) \n                                   else SplitterStructure.New(ver, this.Value, node      )\n    member this.SplitMe(first, ver, node:TabStrip) = this.SplitMe(first, ver, TabStrip  node      )\n    member this.SplitMe(first, ver, node:HtmlNode) = this.SplitMe(first, ver, HtmlNode  node      )\n    member this.SplitMe(first, ver               ) = this.SplitMe(first, ver, TabStrip.New([||])  )\n    member this.IsEmpty                            =\n        match this.Value with\n        | HtmlNode HtmlEmpty           -> true\n        | HtmlNode _                   -> false\n        | TabStrip strip               -> strip.tabs.Value.Length = 0\n        | Split   (ver, var, ch1, ch2) -> ch1.IsEmpty && ch2.IsEmpty\n    member this.UnSplitEmpties()                   =\n        if                                    this.IsEmpty then this.Var.Value <- SplitterStructure.New(TabStrip.New([||])) else\n        match this.Value with\n        | Split   (ver, var, ch1, ch2) -> if   ch1.IsEmpty then ch2.UnSplitEmpties() ; this.Var.Value <- ch2.Value \n                                          elif ch2.IsEmpty then ch1.UnSplitEmpties() ; this.Var.Value <- ch1.Value \n                                                           else ch1.UnSplitEmpties()\n                                                                ch2.UnSplitEmpties()\n        | _                            -> ()  \n\nlet tabs1 = \n      [|\n        \"Hello\"   \n        \"How\"   \n        \"Are\"   \n        \"You\"   \n        \"Today?\"\n      |]\n\nlet tabs2 = \n      [|\n        \"Very\"   \n        \"Well\"  \n        \"Thank\" \n        \"You\"   \n      |]\n\nlet direction    = Var.Create true\nlet createdNodes = System.Collections.Generic.Dictionary<System.Guid, Dom.Element>()\n\nlet getU tabs =\n    [| for tab in tabs do \n           yield tab\n               , Template.TextArea.New(tab:string).Render\n    |]\n    \nlet getU2 tabs = tabs |> getU |> Array.map (fun def -> System.Guid.NewGuid(), def)    \n\nlet tabs1V = TabStrip.New(getU tabs1).Top   \nlet tabs2V = TabStrip.New(getU tabs2).Bottom\n\nlet rootSplitter = SplitterNode.New(SplitterStructure.New(true, tabs1V, tabs2V))\n\ndo  TabMoved <- Some (fun _ -> rootSplitter.UnSplitEmpties())\n\ndiv [ style \"height: 500px\"\n      rootSplitter.Render.Style(\"height: 100%; width: 100% \")\n      //direction\n      //|> Val.map3 (fun t1 t2 dir-> t1,t2,dir) tabs1V.tabs tabs2V.tabs\n      //|> bindHElem (fun (t1,t2,dir) ->\n      //    match t1.Length, t2.Length with\n      //    | _, 0 -> tabs1V.Render\n      //    | 0, _ -> tabs2V.Render\n      //    | _, _ -> Grid.New\n      //                   .Content(\"one\", tabs1V.Render.Style(\"height: 100%; width: 100% \")\n      //                   .Content(\"two\", tabs2V.Render.Style(\"height: 100%; width: 100% \") )\n      //              |> (fun grid -> if dir then grid.ColVariable(50.0).ColAuto(50.0).Content( style \"grid-template-areas: 'one   two' \" ).Render\n      //                                     else grid.RowVariable(50.0).RowAuto(50.0).Content( style \"grid-template-areas: 'one' 'two' \" ).Render)\n      //    |> (fun html -> html.Style(\"height: 100%; width: 100% \")\n      //)\n      Button.New(\"print\"  ).OnClick(fun _ _ -> printfn \"strip\"                                                                ).Render\n      Button.New(\"Split\"  ).OnClick(fun _ _ -> direction.Value <- not direction.Value\n                                               rootSplitter.SplitMe(false, direction.Value)                                   ).Render\n      Button.New(\"New\"    ).OnClick(fun _ _ -> tabs1V.tabs.Value <- Array.append tabs1V.tabs.Value <| getU2 [| \"New1\" |] \n                                               tabs2V.tabs.Value <- Array.append tabs2V.tabs.Value <| getU2 [| \"New2\" |]      ).Render\n      //Button.New(\"UnSplit\").OnClick(fun _ _ -> rootSplitter.UnSplitEmpties()                                                  ).Render\n]\n|> RunCode.RunNode().AddBootstrap.RunHtml\n\n//    css \"\n//:host {\n//  all: initial;\n//  display: block;\n//  contain: content; /* Boom. CSS containment FTW. */\n//}\"\n","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"cddabd38-7ecb-4692-99bd-13ca70e4232f"},{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"}],"id":{"$":0,"Item":"58e71035-74ac-4b97-8798-3a15d4944467"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Grid Bug","content":"\ntype Grid = {  before : bool }\nwith\n    static member New  = {           before = false }\n    member this.Before = { this with before = true  }\n\n\nGrid.New\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n|> printfn \"%A\"    ","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[],"id":{"$":0,"Item":"b3d2418a-1cb8-48bd-9f12-e90b61dcc572"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Demo Action","content":"printfn \"Menu00\"\nopen Template\n\nlet actionClick act () = Val.iter (fun txt -> JS.Alert <| txt + \" Clicked!\") act.text\n\nlet actLoadFile       = Action.New(\"Load...\"                    ).OnClick2(Do2 actionClick () ) \nlet actSaveFile       = Action.New(\"Save as...\"                 ).OnClick2(Do2 actionClick () ).Highlight(true)\nlet actAddSnippet     = Action.New(\"Add Snippet\"                ).OnClick2(Do2 actionClick () )\nlet actDeleteSnippet  = Action.New(\"Delete Snippet\"             ).OnClick2(Do2 actionClick () )\nlet actIndentSnippet  = Action.New(\"Indent Snippet\"             ).OnClick2(Do2 actionClick () )\nlet actOutdentSnippet = Action.New(\"Outdent Snippet\"            ).OnClick2(Do2 actionClick () )\nlet actGetFsCode      = Action.New(\"Get F# Code\"                ).OnClick2(Do2 actionClick () )\nlet actEvalCode       = Action.New(\"Evaluate F#\"                ).OnClick2(Do2 actionClick () )\nlet actRunWSNewTab    = Action.New(\"Run WebSharper in new tab\"  ).OnClick2(Do2 actionClick () )\nlet actRunWSHere      = Action.New(\"Run WebSharper in WS Result\").OnClick2(Do2 actionClick () )\nlet actParseCode      = Action.New(\"Parse F#\"                   ).OnClick2(Do2 actionClick () )\nlet actCompileWS      = Action.New(\"Compile WebSharper\"         ).OnClick2(Do2 actionClick () )\n\nlet menu1 =\n    Menu.New2\n      [\n        MenuEntry.New(\"File\")\n            .SubMenu(\n                    [\n                        actLoadFile      .MenuEntry\n                        actSaveFile      .MenuEntry\n                    ]\n            ) \n        MenuEntry.New(\"Code\")\n            .SubMenu(\n                    [\n                        actAddSnippet    .MenuEntry.MenuNode\n                        actDeleteSnippet .MenuEntry.MenuNode\n                        MenuHtml <| li [ ``class`` \"divider\" ] \n                        actIndentSnippet .MenuEntry.MenuNode\n                        actOutdentSnippet.MenuEntry.MenuNode\n                        MenuHtml <| li [ ``class`` \"divider\" ] \n                        actGetFsCode     .MenuEntry.MenuNode \n                    ]\n            ) \n        MenuEntry.New(\"Run\")\n            .SubMenu(\n                    [\n                        actEvalCode      .MenuEntry\n                        MenuEntry.New(\"\").Divider\n                        actRunWSNewTab   .MenuEntry\n                        actRunWSHere     .MenuEntry\n                        MenuEntry.New(\"\").Divider\n                        actParseCode     .MenuEntry\n                        actCompileWS     .MenuEntry\n                    ]\n            ) \n      ]\n\nlet buttons =\n        div [ \n              actAddSnippet    .Button.Render\n              actOutdentSnippet.Button.Render\n              actIndentSnippet .Button.Render\n              actLoadFile      .Button.Render\n              actParseCode     .Button.Render\n              actEvalCode      .Button.Render\n              actGetFsCode     .Button.Render\n       \n              actDeleteSnippet .Button.Render\n              span []       \n              span []       \n              actSaveFile      .Button.Render\n              span []\n              actRunWSNewTab   .Button.Render\n              actCompileWS     .Button.Render\n//              Doc.Select [ attr.id \"Position\" ] positionTxt [ Below ; Right ; NewBrowser ] position |> someElt\n              style \"\"\"\n                  overflow: hidden;\n                  display: grid;\n                  grid-template-columns: repeat(8, 12.1%);\n                  bxackground-color: #eee;\n                  padding : 5px;\n                  grid-gap: 5px;\n              \"\"\"\n            ]\n\n\nprintfn \"Menu1\"\n\ndiv [\n    navbar <| h1 [ htmlText \"F# Station\" ; style \"font-size: 48px; margin-top: -19px\" ]\n           <| menu1.Render \n           <| menu1.Render\n    buttons\n]       \n|> RunCode.RunNode().AddBootstrap.RunHtml","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"}],"id":{"$":0,"Item":"332b130a-111b-48ca-bd75-26f96dcbb779"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Properties Table","content":"\nopen Template\n\nlet props = System.Collections.Generic.Dictionary<string, string>()\n\ndo [ for i in 1..300 do yield i ]\n   |> Seq.iter (fun i -> props.Add(string i, string i) )  \n\nlet setProp k v = props.[k] <- v\n\ntype TVar(key: string) =\n    let get () = props.[key]\n    let set v  = setProp key v\n    interface IRef<string> with\n       member this.Id  = \"?\"\n       member this.Set                                   v = set v\n       member this.Value                        with set v = set v\n       member this.Get ()                                  = get()\n       member this.Value                                   = get()\n       member this.Update      (f:string -> string       ) = get() |> f |>             set\n       member this.UpdateMaybe (f:string -> string option) = get() |> f |> Option.iter set\n       member this.View                     : View<string> = get() |> View.Const\n\nlet redraw = Var.Create ()\n\nlet tableProps =\n  redraw\n  |> Val.map (fun () ->\n      table [\n        yield thead [\n            th [ htmlText \"Property\" ; style \"padding-right:10px\" ] \n            th [ htmlText \"Value\"                                 ] \n        ] \n        yield! \n            props.Keys\n            |> Seq.map (fun kvp ->\n                tr [\n                    td [ htmlText kvp ] |> hoverable\n                    td [ Doc.Input [] <| (TVar kvp :> IRef<string>) |> someElt ] |> hoverable\n                ])\n        yield tr [\n            td [ htmlText \"Add...\" ; SomeAttr <| on.click (fun _ _ ->  props.Add(\"New\", \"Prop\") ; redraw.Value <- () )]\n            td [ htmlText \"\"    ] \n        ]\n      ]\n  )\n\n\ndiv [\n  HtmlElementV tableProps\n  css \"\"\"\n    td.hovering { background: lightgray; }\n     \"\"\"\n]\n\n|> RunCode.RunNode().AddBootstrap.RunHtml","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"}],"id":{"$":0,"Item":"57b45464-1dcd-4ea0-b4a8-279d5cc5621e"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"kimsereyblog single-page-app-with-websharper-uinext","content":"// https://kimsereyblog.blogspot.com/2015/08/single-page-app-with-websharper-uinext.html\n\n#r \"WebSharper.JQuery.dll\"\n\nopen System\nopen WebSharper\n\n[<JavaScript>]\nmodule Domain =\n    type Claim = {\n        id: string\n        name: string\n    }\n\n    type Claims = Claim list\n\n    type User = {\n        id: string\n        fullName: string\n        emailAddress: Option<string>\n        phoneNumber: Option<string>\n        enabled: bool\n        claims: Claims\n    }\n\n[<JavaScript>]\nmodule Async =\n    let map f xAsync = async { let! x = xAsync\n                               return f x      }\n    let retn x       = async { return   x      }\n\n[<JavaScript>]\nmodule AsyncApi =\n    type ApiResult<'a> =\n        | Success of 'a\n        | Failure of ApiResponseException list\n\n    and ApiResponseException =\n        | Unauthorized of string\n        | NotFound of string\n        | UnsupportedMediaType of string\n        | BadRequest of string\n        | JsonDeserializeError of string\n        override this.ToString() =\n            match this with\n            | ApiResponseException.Unauthorized         err -> err\n            | ApiResponseException.NotFound             err -> err\n            | ApiResponseException.UnsupportedMediaType err -> err\n            | ApiResponseException.BadRequest           err -> err\n            | ApiResponseException.JsonDeserializeError err -> err\n\n    let map f xAsyncApiResult =\n        async {\n            let! xApiResult = xAsyncApiResult\n            match xApiResult with\n            | Success x   -> return Success(f x)\n            | Failure err -> return Failure err\n        }\n\n    let retn x = async { return ApiResult.Success x }\n\n    let apply fAsyncApiResult xAsyncApiResult =\n        async {\n            let! fApiResult = fAsyncApiResult\n            let! xApiResult = xAsyncApiResult\n            match fApiResult, xApiResult with\n            | Success f   , Success x    -> return Success(f x)\n            | Success f   , Failure err  -> return Failure err\n            | Failure err , Success f    -> return Failure err\n            | Failure err1, Failure err2 -> return Failure(List.concat [ err1; err2 ])\n        }\n\n    let bind f xAsyncApiResult =\n        async {\n            let! xApiResult = xAsyncApiResult\n            match xApiResult with\n            | Success x -> return! f x\n            | Failure err -> return (Failure err)\n        }\n\n    let start xAsyncApiRes =\n        xAsyncApiRes\n        |> Async.map (fun x -> ())\n        |> Async.Start\n\n    type ApiCallBuilder() =\n\n        member this.Bind(x, f) =\n            async {\n                let! xApiResult = x\n                match xApiResult with\n                | Success x -> return! f x\n                | Failure err -> return (Failure err)\n            }\n        member this.Return x = async { return ApiResult.Success x }\n        member this.ReturnFrom x = x\n\n    let apiCall = new ApiCallBuilder()\n\n[<JavaScript>]\nmodule ApiClient =\n    open WebSharper.JavaScript\n    open WebSharper.JQuery\n    open AsyncApi\n    open Domain\n    open WebSharper.UI.Next\n\n    type AuthToken =\n        { Token : string\n          Expiry : DateTime }\n        member this.IsExpired() = DateTime.UtcNow - this.Expiry < TimeSpan.FromMinutes(10.0)\n\n        static member Make token =\n            { Token = token\n              Expiry = DateTime.UtcNow }\n\n        static member Default =\n            { Token = \"\"\n              Expiry = DateTime.UtcNow }\n\n    type ValidToken =\n        | ValidToken of string\n\n    type Credentials =\n        { Username : string\n          Password : string }\n        static member Default =\n            { Username = \"admin\"\n              Password = \"admin\" }\n\n    type RequestSettings =\n        { RequestType :  JQuery.RequestType\n          Url         :  string\n          ContentType :  string option\n          Headers     : (string * string) list option\n          Data        :  string option }\n        member this.toAjaxSettings ok ko =\n            let success  (result:obj)  (_ : string) (_ : JqXHR ) : unit = ok (result :?> string)\n            let errorf   (jqXHR:JqXHR) (_ : string) (_ : string) : unit = ko (System.Exception(string jqXHR.Status))\n            let settings =\n                JQuery.AjaxSettings\n                    (Url      = \"http://localhost/api/\" + this.Url\n                   , Type     = this.RequestType\n                   , DataType = JQuery.DataType.Text\n                   , Success  = Action<obj,string,JqXHR> success\n                   , Error    = Action<JqXHR,string,string> errorf)\n\n            this.Headers     |> Option.iter (fun h -> settings.Headers     <- Object<string>(h |> Array.ofList))\n            this.ContentType |> Option.iter (fun c -> settings.ContentType <- Union2Of2 c                      )\n            this.Data        |> Option.iter (fun d -> settings.Data        <- d                                )\n            settings\n\n    type Api =\n        { Login     : Credentials -> Async<ApiResult<unit>>\n          Logout    : unit        -> unit\n          GetUsers  : unit        -> Async<ApiResult<User list>>\n          GetClaims : unit        -> Async<ApiResult<Claims>> }\n\n    [<Literal>]\n    let tokenStorageKey = \"authtoken\"\n\n    let private ajaxCall (requestSettings : RequestSettings) =\n        Async.FromContinuations <| fun (ok, ko, _) ->\n            requestSettings.toAjaxSettings ok ko\n            |> JQuery.Ajax\n            |> ignore\n\n    let private matchErrorStatusCode url code =\n        match code with\n        | \"401\" ->\n            Failure\n                [ ApiResponseException.Unauthorized\n                  <| sprintf \"\"\"\"%s\" - 401 The Authorization header did not pass security\"\"\" url ]\n        | \"404\" -> Failure [ ApiResponseException.NotFound <| sprintf \"\"\"\"%s\" - 404 Endpoint not found\"\"\" url ]\n        | \"415\" ->\n            Failure\n                [ ApiResponseException.UnsupportedMediaType\n                  <| sprintf \"\"\"\"%s\" - 415 The request Content-Type is not supported/invalid\"\"\" url ]\n        | code -> Failure [ ApiResponseException.BadRequest <| sprintf \"\"\"\"%s\" - %s Bad request\"\"\" url code ]\n\n    let private tryDeserialize deserialization input =\n        try\n            deserialization input |> ApiResult.Success\n        with _ ->\n            Failure [ ApiResponseException.JsonDeserializeError <| sprintf \"\"\"\"{%s}\" cannot be deserialized\"\"\" input ]\n        |> Async.retn\n\n    let private getToken() =\n        try\n            JS.Window.LocalStorage.GetItem tokenStorageKey\n            |> Json.Deserialize<AuthToken>\n            |> ApiResult.Success\n        with ex -> ApiResult.Failure [ Unauthorized \"Unauthorized\" ]\n        |> Async.retn\n\n    let private refreshToken (authToken : AuthToken) =\n        async {\n            let url = \"auth/login/token/renew\"\n            if not (authToken.IsExpired()) then return ApiResult.Success authToken.Token\n            else\n                try\n                    let! token = ajaxCall {\n                                    RequestType = JQuery.RequestType.POST\n                                    Url = url\n                                    ContentType = None\n                                    Headers = Some [ \"Authorization\", \"Bearer \" + authToken.Token ]\n                                    Data = None }\n                    return ApiResult.Success token\n                with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (tryDeserialize Json.Deserialize<string>)\n        |> AsyncApi.map (ValidToken)\n\n    let private login credentials =\n        async {\n            let url = \"auth/login/token\"\n            try\n                let! token = ajaxCall {\n                                RequestType = JQuery.RequestType.POST\n                                Url = url\n                                ContentType = Some \"application/json\"\n                                Headers = None\n                                Data = Some(Json.Serialize<Credentials>(credentials)) }\n                return ApiResult.Success token\n            with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (Json.Deserialize<string>\n                          >> AuthToken.Make\n                          |> tryDeserialize)\n        |> AsyncApi.map (fun token -> JS.Window.LocalStorage.SetItem(tokenStorageKey, Json.Serialize<AuthToken>(token)))\n\n    let private logout() = JS.Window.LocalStorage.RemoveItem(tokenStorageKey)\n\n    let private getClaims (ValidToken token) =\n        async {\n            let url = \"auth/claims\"\n            try\n                let! claims = ajaxCall {\n                                RequestType = JQuery.RequestType.GET\n                                Url = url\n                                ContentType = None\n                                Headers = Some [ \"Authorization\", \"Bearer \" + token ]\n                                Data = None\n                            }\n                return ApiResult.Success(claims)\n            with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (tryDeserialize Json.Deserialize<Claims>)\n\n    let private getUsers (ValidToken token) =\n        async {\n            let url = \"users\"\n            try\n                let! users = ajaxCall {\n                                RequestType = JQuery.RequestType.GET\n                                Url = url\n                                ContentType = None\n                                Headers = Some [ \"Authorization\", \"Bearer \" + token ]\n                                Data = None\n                            }\n                return ApiResult.Success users\n            with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (tryDeserialize Json.Deserialize<User list>)\n\n    let api =\n        { Login    = login\n          Logout   = logout\n          GetUsers = fun () -> apiCall {\n                                    let! token      = getToken()\n                                    let! validToken = refreshToken token\n                                    return! getUsers  validToken\n                                }\n          GetClaims = fun () -> apiCall {\n                                    let! token      = getToken()\n                                    let! validToken = refreshToken token\n                                    return! getClaims validToken\n                                } }\n\n[<JavaScript>]\nmodule BootstrapUI =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n\n    module Button =\n        type private ButtonColor =\n            | Default\n            | Primary\n\n        type private ButtonStyle =\n            | FullWidth\n            | Inline\n\n        let private makeButton txt btnColor btnStyle action =\n            let classes =\n                [ yield \"btn\"\n                  yield match btnColor with\n                        | Default -> \"btn-default\"\n                        | Primary -> \"btn-primary\"\n                  yield match btnStyle with\n                        | FullWidth -> \"full\"\n                        | Inline -> \"inline\" ]\n                |> String.concat (\" \")\n            Doc.Button <| txt <| [ attr.``class`` classes\n                                   attr.``type`` \"submit\" ]\n            <| action\n\n        let bsBtnDefaultInline txt action =\n            makeButton txt ButtonColor.Default ButtonStyle.Inline action\n\n        let bsBtnDefaultFull txt action =\n            makeButton txt ButtonColor.Default ButtonStyle.FullWidth action\n\n        let bsBtnPrimaryInline txt action =\n            makeButton txt ButtonColor.Primary ButtonStyle.Inline action\n\n        let bsBtnPrimaryFull txt action =\n            makeButton txt ButtonColor.Primary ButtonStyle.FullWidth action\n\n    let bsNav brand leftLinks rightLinks =\n        let navHeader =\n            divAttr [ attr.``class`` \"navbar-header\" ]\n                    [ buttonAttr [ attr.``class`` \"navbar-toggle collapsed\"\n                                   Attr.Create \"data-toggle\" \"collapse\"\n                                   Attr.Create \"data-target\" \"#menu\"\n                                   Attr.Create \"aria-expanded\" \"false\" ]\n                                 [ spanAttr [ attr.``class`` \"sr-only\" ] []\n                                   spanAttr [ attr.``class`` \"icon-bar\" ] []\n                                   spanAttr [ attr.``class`` \"icon-bar\" ] []\n                                   spanAttr [ attr.``class`` \"icon-bar\" ] [] ]\n                      aAttr [ attr.``class`` \"navbar-brand title\"\n                              attr.href \"#\" ] [ text brand ] ]\n\n        let navMenu =\n            divAttr [ attr.``class`` \"collapse navbar-collapse\"\n                      attr.id \"menu\" ]\n                    [ ulAttr [ attr.``class`` \"nav navbar-nav\" ] [ leftLinks ]\n                      ulAttr [ attr.``class`` \"nav navbar-nav navbar-right\" ]\n                             [ rightLinks ] ]\n\n        navAttr [ attr.``class`` \"navbar navbar-default\" ]\n            [ divAttr [ attr.``class`` \"container-fluid\" ]\n                      [ navHeader; navMenu ] ] :> Doc\n\n    let bsInput placeHolder rvTxt =\n        Doc.Input [ attr.``class`` \"form-control\"\n                    attr.placeholder placeHolder ] rvTxt\n\n    let bsPasswordInput placeHolder rvPwd =\n        Doc.PasswordBox [ attr.``class`` \"form-control\"\n                          attr.placeholder placeHolder ] rvPwd\n\n    let bsPanelDefault body =\n        divAttr [ attr.``class`` \"panel panel-default\" ] [ divAttr [ attr.``class`` \"panel-body\" ] body ]\n\n    let bsPanelDefaultWithTitle title body =\n        divAttr [ attr.``class`` \"panel panel-default\" ]\n                [ divAttr [ attr.``class`` \"panel-heading\" ]\n                          [ h3Attr  [ attr.``class`` \"panel-title\" ]\n                                    [ text title ] ]\n                  divAttr [ attr.``class`` \"panel-body\" ] body ]\n\n    let bsAlertDanger message =\n        divAttr [ attr.``class`` \"alert alert-danger\"\n                  Attr.Create \"role\" \"alert\" ] [ text message ] :> Doc\n\n    let bsRow bsCol = divAttr [ attr.``class`` \"row\" ] bsCol\n\n    let bsCol3 body = divAttr [ attr.``class`` \"col-md-3\" ] body\n\n    let bsCol4 body = divAttr [ attr.``class`` \"col-md-4\" ] body\n\n    let bsContainer body = divAttr [ attr.``class`` \"container\" ] body\n\n    let bsJumbotron title body =\n        divAttr [ attr.``class`` \"jumbotron\" ]\n                [ divAttr [ attr.``class`` \"container\" ]\n                          [ h1 [ text title ] \n                            body ] ]\n\n[<JavaScript>]\nmodule ClientRoutes =\n    open WebSharper.UI.Next\n\n    type Page =\n        | Home\n        | Claims\n        | Users\n        | Login\n        override this.ToString() =\n            match this with\n            | Home -> \"Home\"\n            | Claims -> \"Claims\"\n            | Users -> \"Users\"\n            | Login -> \"Login\"\n\n    let private map =\n        function\n        | Home -> []\n        | Claims -> [ \"claims\" ]\n        | Users -> [ \"users\" ]\n        | Login -> [ \"login\" ]\n\n    let private reverMap =\n        function\n        | [] -> Home\n        | [ \"home\" ] -> Home\n        | [ \"claims\" ] -> Claims\n        | [ \"users\" ] -> Users\n        | [ \"login\" ] -> Login\n        | _ -> failwith \"404\"\n\n    let install () =\n        RouteMap.Create map reverMap\n        |> RouteMap.Install\n\n[<JavaScript>]\nmodule NavBarPage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n    open ApiClient\n\n    let private makeNavlinks routerView go =\n        routerView\n        |> View.Map(fun currentPage ->\n               [ ClientRoutes.Home; ClientRoutes.Claims; ClientRoutes.Users ]\n               |> List.map\n                      (fun page ->\n                      liAttr [ if page = currentPage then yield attr.``class`` \"active\" ]\n                             [ Doc.Link (string page) [] (fun _ -> go page) ] :> Doc)\n               |> Doc.Concat)\n        |> Doc.EmbedView\n\n    let private logout go =\n        li [ Doc.Link \"Log out\" [] (fun () ->\n                                     api.Logout()\n                                     go ClientRoutes.Login) ] :> Doc\n\n    let doc routerView go = bsNav \"admin portal\" (makeNavlinks routerView go) (logout go)\n\n\n[<JavaScript>]\nmodule LoginPage =\n    open BootstrapUI\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open ApiClient\n\n    let private login rvUsername rvPassword rvLoginError go () =\n        async {\n            let! login = api.Login { Username = Var.Get rvUsername\n                                     Password = Var.Get rvPassword }\n            match login with\n            | AsyncApi.Failure err ->\n                Var.Set rvLoginError\n                        \"You may have keyed in an invalid Username or Password. Please try again.\"\n                api.Logout()\n            | _ -> ()\n            return login\n        }\n        |> AsyncApi.map (fun _ -> go ClientRoutes.Home)\n        |> AsyncApi.start\n\n    let doc go =\n        let rvUsername = Var.Create \"\"\n        let rvPassword = Var.Create \"\"\n        let rvErr = Var.Create \"\"\n\n        let nameInput = bsInput \"Username\" rvUsername\n        let pwdInput = bsPasswordInput \"Password\" rvPassword\n        let errDiv = rvErr.View\n                     |> View.Map(fun err ->     if err = \"\" then Doc.Empty\n                                                else bsAlertDanger err)\n                     |> Doc.EmbedView\n\n        let buttons =\n            bsPanelDefault\n                [ form [ errDiv\n                         nameInput\n                         pwdInput\n                         Button.bsBtnDefaultFull \"Log in\"\n                                                 (login rvUsername rvPassword rvErr go) ] ]\n        bsRow [ bsCol4 [ Doc.Empty ]\n                bsCol4 [ h1Attr [attr.``class`` \"title\"]\n                                [text \"admin portal\"]\n                         buttons ]\n                bsCol4 [ Doc.Empty ] ]\n\n\n[<JavaScript>]\nmodule HomePage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let doc go =\n        bsJumbotron \"Hello,\"\n                    ([p [text \"Welcome to the admin portal v1.0.\"] :> Doc\n                      Button.bsBtnPrimaryInline \"View claims\"\n                                                (fun () -> go ClientRoutes.Claims) :> Doc\n                      Button.bsBtnPrimaryInline \"View users\"\n                                                (fun () -> go ClientRoutes.Users) :> Doc]\n                     |> Doc.Concat)\n\n[<JavaScript>]\nmodule ClaimsPage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let doc go =\n        bsJumbotron \"Claims\" Doc.Empty\n\n[<JavaScript>]\nmodule UsersPage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let doc go =\n        bsJumbotron \"Users\" Doc.Empty\n\n[<JavaScript>]\nmodule Client =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let Main =\n        let router = ClientRoutes.install()\n\n        let doc =\n            router.View\n            |> View.Map(fun page ->\n                   let go = Var.Set router\n\n                   let addNavBar body =\n                       [ NavBarPage.doc router.View go\n                         body ]\n                       |> Doc.Concat\n\n                   let embedInContainer body = bsContainer [ body ]\n\n                   match page with\n                   | ClientRoutes.Login ->\n                       LoginPage.doc go\n                       |> embedInContainer :> Doc\n                   | ClientRoutes.Home ->\n                       HomePage.doc go\n                       |> embedInContainer\n                       |> addNavBar\n                   | ClientRoutes.Claims ->\n                       ClaimsPage.doc go\n                       |> embedInContainer\n                       |> addNavBar\n                   | ClientRoutes.Users ->\n                       UsersPage.doc go\n                       |> embedInContainer\n                       |> addNavBar)\n            |> Doc.EmbedView\n\n        RunCode.RunNode().AddBootstrap.RunDoc doc","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[],"id":{"$":0,"Item":"9ff8bc4a-76c7-4db5-b59a-9252f82fa61d"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Trying Fable","content":"open Useful\n\nprintfn \"Fable\"\n\n[< Require(typeof<Resources.BaseResource>, \"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.2/require.min.js\")      >]    \n[< Require(typeof<Resources.BaseResource>, \"/EPFileX/Fable/babel-standalone.js\")      >]    \ntype Babel() =    \n    [< Inline \"Babel.transformFromAst($ast , null, $options)\"                  >] static member transformFromAst(ast , xx, options)                = X<_>\n    [< Inline \"Babel.transform       ($ast ,       $options)\"                  >] static member transform       (ast ,     options)                = X<_>\n\n[< Require(typeof<Resources.BaseResource>, \"/EPFileX/Fable\", \"Fable.js\", \"Worker.js\") >]\ntype Fable() =\n    [< Inline \"Fable.createChecker($f, $references)\"                           >] static member createChecker(f, references)  : obj                = X<_>\n    [< Inline \"Fable.makeCompiler($replacements)\"                              >] static member makeCompiler(replacements)    : obj                = X<_>\n    [< Inline \"Fable.parseFSharpProject($checker, $com, $fileName, $source)\"   >] static member parseFSharpProject(checker, com, fileName, source) = X<_>\n    [< Inline \"Fable.compileAst($com, $fsharpAst, $fileName)\"                  >] static member compileAst(com, fsharpAst, fileName)               = X<_>\n    [< Inline \"Fable.convertToJson($babelAst)\"                                 >] static member convertToJson(babelAst)                            = X<_>\n\n\nlet [< Inline \"require.config({ skipDataMain: 1, isBrowser: 1 }) \"             >] requireConfig : obj                                              = X<_>\nlet [< Inline \"getFileBlob($key, $url)\"                                        >] getFileBlob(key, url)                                            = X<_>\nlet [< Inline \"metadata\"                                                       >] metadata : obj []                                                = X<_> \nlet [< Inline \"metadata[$fn]\"                                                  >] readAllBytes fn                                                  = X<_>\nlet [< Inline \"Object.getOwnPropertyNames(metadata).length\"                    >] metadataLength : int                                             = X<_>\nlet [< Inline \"babelPlugins\"                                                   >] babelPlugins : obj                                               = X<_>\n\n\nlet references = [|\n    \"mscorlib.dll\"\n    \"System.dll\"\n    \"System.Core.dll\"\n    \"System.Data.dll\"\n    \"System.IO.dll\"\n    \"System.Xml.dll\"\n    \"System.Numerics.dll\"\n    \"FSharp.Core.sigdata\"\n    \"FSharp.Core.dll\"\n    \"Fable.Core.dll\"\n    \"Fable.Import.Browser.dll\"\n    // When loading the REPL the browser console always shows: \"Cannot find type System.ValueTuple`1\"\n    // However, adding the following reference prevents opening System namespace\n    // See https://github.com/fable-compiler/Fable/issues/1152#issuecomment-330315250\n    // \"System.ValueTuple.dll\",\n|]\n\nreferences |> Seq.iter (fun fn -> getFileBlob(fn, \"metadata/\" + fn))\n    \nlet getChecker = \n    lazy Fable.createChecker(readAllBytes, references |> Array.choose (fun fn -> if fn.Contains \"sigdata\" then None else Some <| fn.Replace(\".dll\", \"\")) )\n\nlet fsCode = Template.TextArea.New(\"let mul a b = a * b\\nlet add a b = a + b\\nprintfn \\\"Multiply = %d\\\" <| mul 7 8\\nprintfn \\\"Add = %d\\\" <| add 7 8\")\nlet jsCode = Template.TextArea.New(\"\")\nlet errors = Template.TextArea.New(\"\")\nlet output = Template.TextArea.New(\"\")\n\nlet addOutput v =\n    output.Var.Value <- output.Var.Value + (if output.Var.Value = \"\" then \"\" else \"\\n\") + v\n\nlet ToConsole arg = \n    Console.Log arg\n    arg?cont addOutput\n\nlet fableTranslate source : Async<string> =\n    async {\n        while metadataLength < references.Length do\n            do! Async.Sleep 200\n        let  checker      = getChecker.Value\n        let  com          = Fable.makeCompiler [| \"Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatLine\"\n                                                , \"FSSGlobal.Snippets2.ToConsole($0)\" |]  \n        let  fileName     = \"stdin.fsx\"\n        let  fsharpAst    = Fable.parseFSharpProject(checker, com, fileName, source)\n        let  babelAst     = Fable.compileAst(com, fsharpAst, fileName)\n        let  jsonAst      = Fable.convertToJson(babelAst)\n        let  ast          = JSON.Parse(jsonAst)\n        let  options      = Object.Create null\n        options?plugins  <- [| babelPlugins?transformMacroExpressions\n                               babelPlugins?removeUnneededNulls \n                            //   \"transform-es2015-modules-amd\"    \n                            |]\n        options?presets  <- [|  |]\n        options?filename <- fileName\n        options?babelrc  <- false\n        let  transformed  = Babel.transformFromAst(ast , null, options)\n        return transformed?code\n    }\n\nlet compileCode fCode =\n    Wrap.wrapper {\n        let! jCode        = fableTranslate fCode \n        jsCode.Var.Value <- jCode\n    } |> Wrap.start (fun errs -> errors.Var.Value <- errs) \n\nlet runCode     jCode =\n    Wrap.wrapper {\n        //do!  Result.tryProtection()\n        output.Var.Value  <- \"\"\n        let  options       = Object.Create null\n        options?plugins   <- [| \"transform-es2015-modules-amd\" |]\n        options?presets   <- [|  |]\n        options?babelrc   <- false\n        let  transformed   = Babel.transform(jCode, options)\n        let  jCode2:string = transformed?code\n        let  jCode3        = jCode2.Replace(\"define([\"       , \"require([\")\n                                   .Replace(\"\\\"use strict\\\";\", \"\\\"use strict\\\"; try { exports = exports || {}; } catch (err) {}\")\n        JS.Eval jCode3 |> ignore\n    } |> Wrap.start addOutput \n\nVal.sink compileCode fsCode.Var\nVal.sink     runCode jsCode.Var\n\ndiv [\n style \"height: 100%\"\n Template.Grid.NewBisect(   true, Template.SectionType.StVariable, false, 80.0\n  , Template.Grid.NewBisect(true, Template.SectionType.StVariable, true , 50.0\n                      , fsCode.Render\n                      , jsCode.Render).Render\n  , Template.Grid.NewBisect(true, Template.SectionType.StVariable, true , 50.0\n                      , errors.Render\n                      , output.Render).Render\n  ).Content(style \"height: 100%\").Render\n]\n|> RunCode.RunNode().AddBootstrap.RunHtml\n","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"1f1aa135-fd74-42cc-b9a5-87f380c113a9"}],"id":{"$":0,"Item":"dc02ec40-9891-482d-8bdf-d409dfd3582c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Fable inline error","content":"let counter =\n    let mutable i = 0\n    fun () ->\n        i <- i + 1\n        i\n    \ntype Type = {\n    a     : int\n    b     : int\n    c     : int\n    d     : int\n    count : int\n}\n  with\n    static member New(n) = {\n        a     = n\n        b     = n * 2\n        c     = n * 3\n        d     = n * 4\n        count = counter()\n      }\n      \n    member        this.Method  (v:bool) = { this with a = this.a * if v then 2 else 3 }\n    member inline this.MethodI (v:bool) = { this with a = this.a * if v then 2 else 3 }\n    member        this.Method  ()       = { this with a = this.a * 10 }\n    member inline this.MethodI ()       = { this with a = this.a * 10 }\n\nType.New(5).Method(false).Method(true).Method()\n|> printfn \"not inline: %A\"\n    \nType.New(5).MethodI(false).MethodI(true).MethodI()\n|> printfn \"inline: %A\"\n\n","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[],"id":{"$":0,"Item":"dfd9972d-4887-4c01-88df-b4c1c16016bf"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Reactive Disable","content":"\nlet layout       = Var.Create true\nlet value        = Var.Create \"d\"\nlet disabled     = Val.map ((=) \"d\"                                           ) value \nlet text         = Val.map (fun v -> if v then \"Test1\"      else \"Test2\"      ) layout\nlet color        = Val.map (fun v -> if v then \"color: red\" else \"color: blue\") disabled\nlet button       = Template.Button.New(text).Disabled(disabled).Render\n//let colorAttr    = attr.styleDyn                          color\n//let clicked      = (fun () -> JS.Alert(\"Click\"))\n\ndiv [\n    Template.Button.New(\"Toggle\").OnClick(fun _ _ -> layout.Value <- not layout.Value).Render\n    Template.Input.New(value).Render\n    layout\n    |> Val.map (fun ly ->\n        if ly then\n               div  [ button ]\n        else\n               span [ button ]\n        )\n    |> HtmlElementV\n]    \n|> RunCode.RunNode().RunHtml\n\n(*\nlet layout   = Var.Create true\nlet value    = Var.Create \"\"\nlet disabled = View.Map ((=) \"d\") value.View \nlet button   = Html.div [ Doc.Button \"Test1\" [ attr.disabledDynPred (View.Const \"\") disabled ] id ]\n\nHtml.div [\n    Doc.Button \"Toggle\" [ ] (fun () -> layout.Value <- not layout.Value)\n    Doc.Input           [ ] value\n    layout.View\n    |> View.Map (fun ly ->\n        if ly then\n            Html.div [\n                button\n            ]\n        else\n            Html.span [\n                button\n            ]\n    )\n    |> Doc.EmbedView\n]    \n|> RunCode.RunNode().RunDoc\n*)","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"19bf49f6-8a7b-4f9a-906b-27a7c1c40cde"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Check All WebSharper Code","content":"// add everyone as a predecessor to check if they parse/compile","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"},{"$":0,"Item":"b9ca9697-6cb4-4085-b509-9f702a62086f"},{"$":0,"Item":"9ff8bc4a-76c7-4db5-b59a-9252f82fa61d"},{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"},{"$":0,"Item":"332b130a-111b-48ca-bd75-26f96dcbb779"},{"$":0,"Item":"58e71035-74ac-4b97-8798-3a15d4944467"},{"$":0,"Item":"0a1fa320-b731-473a-93e2-dae49cc296f7"},{"$":0,"Item":"f3a7ead2-49e1-4ff4-b96e-6fe699a1c8a9"},{"$":0,"Item":"f2cc3e92-5e61-47b2-982b-40f5c5784e6a"},{"$":0,"Item":"0aa90429-4e7c-42eb-b108-3dd70e710bf1"},{"$":0,"Item":"9682eb8f-e1de-4d7c-adca-a5e2322558c2"},{"$":0,"Item":"a54701f2-1d68-4997-a1ea-62deaeb73e1b"},{"$":0,"Item":"4dc58ba1-75d1-4c96-9641-235ee7d8c2c2"},{"$":0,"Item":"74b8570e-dcd4-4dff-87a5-cd7ec96b8527"},{"$":0,"Item":"38b21610-7350-4676-993b-88fea844314f"},{"$":0,"Item":"7754c074-862e-4550-9d61-ea837adf6d85"},{"$":0,"Item":"ff6bfed0-83ae-4497-b197-fea6432aa958"},{"$":0,"Item":"ee8fe0d0-14ad-4ae8-bd77-e0918817d67e"},{"$":0,"Item":"3d8bf6d2-a66b-4f18-aa83-8e74836e38e4"},{"$":0,"Item":"e9c3ceaf-8fe5-4752-aa4c-2db6e1ac4577"},{"$":0,"Item":"b47dbe9c-8623-4b35-98ee-5073edfc21b3"},{"$":0,"Item":"b3d2418a-1cb8-48bd-9f12-e90b61dcc572"}],"id":{"$":0,"Item":"a3bec308-c3bd-4fad-b400-b9a33d1b15c8"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"XSL Tester","content":"open Template\nopen Useful\n\nprintfn \"XSL Tester\"\n\n\nlet menuBar = h1 [ htmlText \"XSL Tester\" ; style \"font-size: 48px; margin-top: -17px\" ]\n(*\nlet delayedRefreshCM delay (cm: CodeMirrorEditor) =      \n    async {\n        do! Async.Sleep delay\n        printfn \"Refresh %s\" <| cm.GetValue()\n        cm.Refresh() \n    }\n\nlet code (var: Var<string>) onchange =\n    let mutable cm : CodeMirrorEditor option = None\n    Template.CodeMirror.New(var).Style(\"height: 100%\")\n        .OnChange(onchange)\n        .OnRender(fun ed -> cm <- Some ed ; printfn \"OnRender %s\" var.Value)\n        .Render\n        .AddChildren [\n            SomeAttr <| on.afterRender(fun el   ->\n                let asyncStart = asyncStartCancelling()\n                JS.SetTimeout\n                    (fun () ->\n                        printfn \"afterRender %s\" var.Value\n                        addResizeObserver(fun () -> printfn \"ResizeObs %s\" var.Value ; cm |> Option.iter (delayedRefreshCM 500 >> asyncStart)   ) el\n                    )\n                    2000 |> ignore\n            )\n        ]\n*)\n\nlet output     = Template.TextArea.New(\"\").Placeholder(\"Output:\").Title(\"Output\")      \nlet xslText    = Template.TextArea.New(\"\"\"  <xsl:template match=\"/hello-world\">\n    <HTML>\n      <HEAD>\n        <TITLE></TITLE>\n      </HEAD>\n      <BODY>\n        <H1>\n          <xsl:value-of select=\"greeting\"/>\n        </H1>\n        <xsl:apply-templates select=\"greeter\"/>\n      </BODY>\n    </HTML>\n  </xsl:template>\n  <xsl:template match=\"greeter\">\n    <DIV>from <I><xsl:value-of select=\".\"/></I></DIV>\n  </xsl:template>\"\"\").Placeholder(\"xsl\"    ).Title(\"xsl\"   )     \nlet xmlText    = Template.TextArea.New(\"\"\"<hello-world>   <greeter>An XSLT Programmer</greeter>   <greeting>Hello, World!</greeting></hello-world>\"\"\").Placeholder(\"xml\"    ).Title(\"xml\"   )     \nlet resultText = Template.TextArea.New(\"\").Placeholder(\"result\" ).Title(\"result\")\n\n\n\ntype XmlNode(b: int) =\n    let a = 1\n  with\n    [< Inline \"$this.outerHTML\"                                         >] member this.OuterHTML              : string  = \"\" \n    [< Inline \"$this.innerHTML\"                                         >] member this.InnerHTML  with get( ) : string  = \"\" \n    [< Inline \"$this.innerHTML = $v\"                                    >] member this.InnerHTML  with set(v  : string) = () \n    [< Inline \"$this.firstElementChild\"                                 >] member this.FirstElementChild : XmlNode = X<_> \n    [< Inline \"$this.setAttribute($att,$v)\"                             >] member this.SetAttribute (att:string) (v:string) = () \n\ntype XmlFragment(b: int) =\n    let a = 1\n  with\n    [< Inline \"$this.children\" >] member this.children : XmlNode[] = X<_>\n\ntype XmlDocument(b: int) =\n    let a = 1\n  with\n    [< Inline \"document.implementation.createDocument($name, $element, null)\" >] new(name:string, element:string) = XmlDocument(0)\n    [< Inline \"$this.firstElementChild\"                                 >] member this.FirstElementChild : XmlNode = X<_> \n\ntype XslProcessor(b: int) =\n    let a = 1\n  with\n    [< Inline \"new XSLTProcessor()\"                        >] new() = XslProcessor(0) \n    [< Inline \"$this.transformToFragment($node, document)\" >] member this.Transform  (node: XmlNode) : XmlFragment = X<_>\n    [< Inline \"$this.importStylesheet($xsl)\"               >] member this.ImportStylesheet  (xsl: XmlDocument)  = ()\n\nopen Result\n\nlet loadXmlDoc (name:string) (root:string) (xml:string) =\n    result {\n        do! Result.tryProtection()\n        printfn  \"doc\"\n        let xmlDoc = XmlDocument(name, root)\n        xmlDoc.FirstElementChild.InnerHTML <- xml\n        return xmlDoc\n    }\n\nlet loadXslProc (xsl:string) =\n    result {\n        do! Result.tryProtection()\n        printfn  \"proc\"\n        let  xslProc  = XslProcessor()\n        let! xslRef   = loadXmlDoc \"http://www.w3.org/1999/XSL/Transform\" \"xsl:stylesheet\" xsl\n        xslProc.ImportStylesheet xslRef\n        return xslProc\n    } \n\nlet transformer(xslProcR:Result<XslProcessor>, xmlDocR:Result<XmlDocument>) =\n    result {\n        do! Result.tryProtection()\n        printfn  \"transform\"\n        let! xmlDoc   = xmlDocR \n        let! xslProc  = xslProcR\n        let  result   = xslProc.Transform xmlDoc.FirstElementChild.FirstElementChild\n        return result.children |> Array.map (fun n -> n.OuterHTML) |> String.concat \"\\n\"\n    } \n    |> function\n       | Success (x, ms) -> x , ms\n       | Failure     ms  -> \"\", ms\n    |> fun (r, ms) -> \n        resultText.Var.Value <- r\n        output    .Var.Value <- getMessages ms\n\nVal.sink transformer (Val.map2 (fun a b -> a, b) \n                               (Val.map loadXslProc           xslText.Var) \n                               (Val.map (loadXmlDoc \"\" \"xml\") xmlText.Var))\n\nlet steps =\n  Layout.AddGuids\n    [\n       \"title\"            , GuiNode   <| div [ htmlText \"Title\"    ; style \"background-color: lightblue\"  ]\n       \"snippets\"         , GuiNode   <| div [ htmlText \"Snippets\" ; style \"background-color: lightgreen\" ]\n       \"Output\"           , GuiNode   <| output    .Render \n       \"XSL\"              , GuiNode   <| xslText   .Render\n       \"XML\"              , GuiNode   <| xmlText   .Render\n       \"Result\"           , GuiNode   <| resultText.Render\n       \"codeXX\"           , GuiTabStrip(     true ,  [| \"XSL\"    \n                                                        \"XML\"    |])\n       \"tResult\"          , GuiTabStrip(     true ,  [| \"Result\" |])\n       \"tOutput\"          , GuiTabStrip(     true ,  [| \"Output\" |])\n       \"menu\"             , GuiNode   <| menuBar\n//       \"codeXX\"           , varVerSplitter          50.0 \"tXML\"          \"tXSL\"            0.0 100.0\n       \"codeLR\"           , varVerSplitter          50.0 \"codeXX\"        \"tResult\"         0.0 100.0\n       \"main_messages\"    , varHorSplitter          82.0 \"codeLR\"        \"tOutput\"        35.0 100.0             \n       \"main\"             , fixedHorSplitter true   50.0 \"menu\"          \"main_messages\"\n    ]\n           \n\nlet layout = Layout.New steps\n\nlet styleEditor    =\n     \"\"\"\nbody { margin: 0px }     \n     \ndiv textarea {\nfont-family: monospace;\n}\n.code-editor-list-tile {\nwhite-space: nowrap; \nborder-style: solid none none;\nborder-color: white;\nborder-width: 1px;\nbackground-color: #D8D8D8;\ndisplay: flex;\n}\n.code-editor-list-text{\npadding: 1px 10px 1px 5px;\noverflow:hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;\nflex: 1;\n}\n\n.code-editor-list-tile.direct-predecessor {\nfont-weight: bold;\n}\n.code-editor-list-tile.indirect-predecessor {\ncolor: blue;\n}\n.code-editor-list-tile.selected {\nbackground-color: #77F;\ncolor: white;\n}\n.code-editor-list-tile.hovering {\nbackground: lightgray;\n}\n.code-editor-list-tile.hovering.selected {\nbackground:  blue;\n}\n.code-editor-list-tile>.predecessor {\nfont-weight: bold;\nborder-style: inset;\nborder-width: 1px;\ntext-align: center;\ncolor: transparent;\n}\n.code-editor-list-tile.direct-predecessor>.predecessor {\ncolor: blue;\n}\n\n.CodeMirror { height: 100%; }\n\n.node {\n    background-color:white; \n    width: 2ch; \n    color: #A03; \n    font-weight:bold; \n    text-align: center;\n    font-family: arial;\n}\n.Warning { text-decoration: underline lightblue } \n.Error   { text-decoration: underline red       } \n.body    { margin         : 0px                 }\n    \"\"\"\n\ndiv [\n    style \"height: 100vh; width: 100% \"\n    layout.Render.Style(\"height: 100%; width: 100% \")\n    script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ]\n    link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    link   [ href \"/EPFileX/css/main.css\"                                               ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    style  \"\"\" \n          color      : #333;\n          font-size  : small;\n          font-family: monospace;\n          line-height: 1.2;\n              \"\"\"\n] \n|> renderDoc\n|> RunCode.RunNode().RunDoc\n","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"ece85c79-829d-4bec-a607-a1cd01f9dafa"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"9c870b72-8f9a-4e7d-ad81-7f1fd73fdd76"}],"id":{"$":0,"Item":"da8cf1ea-25f9-47f2-a056-0eb7a26339b6"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Html Indent Compact mode","content":"\nlet best =\n    !!section      [ ``class`` \"section\"     ]\n      --div        [ ``class`` \"container\"   ]\n      ----h1       [ ``class`` \"title\"       ]\n      ------str                \"Hello World\"\n      ----p        [ ``class`` \"subtitle\"    ]\n      ------str                \"My first website with \"\n      ------strong [ str       \"Bulma\"       ]\n      ------str                \"!\"\n    |> endHtmlIndent \n\nlet compact = \n    !!section      [ ``class`` \"section\"     ]\n      + div        [ ``class`` \"container\"   ]\n        + h1       [ ``class`` \"title\"       ]\n        --- str                \"Hello World\"\n        + p        [ ``class`` \"subtitle\"    ]\n          - str                \"My first website with \"\n          - strong [ str       \"Bulma\"       ]\n        --- str                \"!\"\n    |> endHtmlIndent\n    \nlet originalIndented =    \n    section [ ``class``            \"section\"   \n              div [ ``class``      \"container\" \n                    h1 [ ``class`` \"title\" \n                         str       \"Hello World\" ]\n                    p  [ ``class`` \"subtitle\"  \n                         str       \"My first website with \"\n                         strong [ str \"Bulma\"    ]\n                         str       \"!\"           ] ] ]\n\nlet originalBarelyIndented =\n    section [ \n      ``class`` \"section\"   \n      div   [ \n        ``class`` \"container\" \n        h1 [\n          ``class`` \"title\" \n          str \"Hello World\"\n        ]\n        p  [ \n          ``class`` \"subtitle\"  \n          str \"My first website with \"\n          strong [\n              str \"Bulma\"\n          ]\n          str \"!\"\n        ]\n      ]\n    ]\n\nmodule Try1 =  // this one does not indent out\n    let ( +- ) (a: HtmlNode) (b: HtmlNode) = a.AddChildren [ b ]\n    let ( -- ) (a: HtmlNode) (b: HtmlNode) = a.AddChildren [ b ]\n    let def =\n        section  [ ``class`` \"section\"   ]\n        +- div   [ ``class`` \"container\" ]\n           +- h1 [ ``class`` \"title\" ]\n              +- str \"Hello World\"\n           -- p  [ ``class`` \"subtitle\"  ]\n              +-   str \"My first website with \"\n              --  strong []\n                  +-    str \"Bulma\"\n              --   str \"!\"\n\nmodule Try2 =\n    let inline ( -  ) (ps:HtmlNode list) (chn) : HtmlNode list = \n        match ps with \n        | h :: tail -> h.AddChildren [chn] :: tail\n        | [] -> []        \n    let inline ( +  ) (ps:HtmlNode list) (r:HtmlNode list -> HtmlNode) : (HtmlNode list) = r [] ::ps\n    \n    let start (r:HtmlNode list -> HtmlNode)                            = [ r [] ]\n    let out (ps:HtmlNode list) =\n        match ps with\n        | [ ]            -> [ ]\n        | [h]            -> [h]\n        | h :: p :: tail -> p.AddChildren [h] :: tail\n\n    let inline ( -<<- ) (ps:HtmlNode list) (_) : HtmlNode list = out ps\n    let inline ( ---- ) (ps:HtmlNode list) (_) : HtmlNode list = out ps\n\n    let x = 0\n\n    let rec finishO (ps:HtmlNode list) =\n        match ps with\n        | [ ]            -> None\n        | [h]            -> Some h\n        | h :: p :: tail -> finishO <| out ps        \n\n    let finish ps = finishO ps |> Option.defaultWith (fun () -> str \"Malformed HTMLNode\")\n\n    let def =\n        start \n          section \n          -     ``class`` \"section\"   \n          + div   \n            -   ``class`` \"container\" \n            + h1\n              - ``class`` \"title\" \n              -   str     \"Hello World\"\n              ----x\n            + p  \n              - ``class`` \"subtitle\"  \n              -   str     \"My first website with \"\n              + strong \n                - str     \"Bulma\"\n                ----x\n              -   str     \"!\"\n      |> finish \n\nmodule Try3 =\n    let inline ( -  ) (ps:HtmlNode list) (chn) : HtmlNode list = \n        match ps with \n        | h :: tail -> h.AddChildren [chn] :: tail\n        | [] -> []        \n    let inline ( +  ) (ps:HtmlNode list) (r:HtmlNode) : (HtmlNode list) = r::ps\n    \n    let start (r:HtmlNode list -> HtmlNode) (l:HtmlNode list)                        = [ r l ]\n    let out (ps:HtmlNode list) =\n        match ps with\n        | [ ]            -> [ ]\n        | [h]            -> [h]\n        | h :: p :: tail -> p.AddChildren [h] :: tail\n\n    let inline ( -<<- ) (ps:HtmlNode list) (_) : HtmlNode list = out ps\n    let inline ( ---- ) (ps:HtmlNode list) (_) : HtmlNode list = out ps\n\n    let x = 0\n\n    let rec finishO (ps:HtmlNode list) =\n        match ps with\n        | [ ]            -> None\n        | [h]            -> Some h\n        | h :: p :: tail -> finishO <| out ps        \n\n    let finish ps = finishO ps |> Option.defaultWith (fun () -> str \"Malformed HTMLNode\")\n\n    let def =\n        start \n          section      [ ``class`` \"section\"   ]\n          + div        [ ``class`` \"container\" ]\n            + h1       [ ``class`` \"title\"     ]\n              - str     \"Hello World\"\n              ----x\n            + p        [ ``class`` \"subtitle\"  ]\n              - str     \"My first website with \"\n              - strong [ str     \"Bulma\"  ]\n              - str     \"!\"\n      |> finish \n\ndiv [\n    best\n    compact\n    originalBarelyIndented\n    originalBarelyIndented\n    Try1.def\n    Try2.def\n    Try3.def\n]      \n|> RunCode.RunNode().AddFontAwesome.AddBulma.RunHtml\n","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"6332dfb8-b57a-40de-b669-f796820883db"},{"$":0,"Item":"47bf25cf-e7f5-452a-9247-156146348a14"}],"id":{"$":0,"Item":"c819dae6-fd00-440b-9eb8-c97750fa5efd"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Ace Code Editor // does not mark the right place","content":"#nowarn \"1182\"\n\nlet mutable aceEditor : obj option = None\n\nlet aceFiles = [|\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ace.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-language_tools.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-options.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/mode-ocaml.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-beautify.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-elastic_tabstops_lite.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-emmet.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-error_marker.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-keybinding_menu.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-language_tools.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-linking.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-modelist.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-options.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-searchbox.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-settings_menu.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-spellcheck.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-split.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-static_highlight.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-statusbar.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-textarea.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-themelist.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-whitespace.js\"\n|]\n\n[< Inline \"window.ace\" >]\nlet ace:obj = X<_>\n\n[<Inline \"new $ace.Range($l1, $c1, $l2, $c2)\">]\nlet range0 ace (l1:int) (c1:int) (l2:int) (c2:int) :obj = ace?Range  l1 c1 l2 c2\nlet newRange   (l1:int) (c1:int) (l2:int) (c2:int) :obj = range0 ace l1 c1 l2 c2\n\nlet addMarker ed         startRow startColumn endRow endColumn =\n    let range = newRange startRow startColumn endRow endColumn\n    let session = ed?session\n    range?start   <- session?doc?createAnchor range?start\n    range?``end`` <- session?doc?createAnchor range?``end``\n    let id = JS.Apply session \"addMarker\" [| range ; \"marker\" |]\n    id\n\nlet editor =\n    div [ \n        css  \".aceEditor { width:  100%; height: 100%; }\n            .marker { background: blue; }\n        \"\n        div [\n            ``class`` \"aceEditor\"\n            Id        \"aceEditor\"\n            htmlText \"Hello World\"\n            SomeAttr <| on.afterRender (fun el ->\n                LoadFiles aceFiles\n                    (fun () ->                       \n                       let editor = ace?edit el\n                       JS.Window?console?log editor\n                       editor?setTheme        \"ace/theme/twilight\"\n                       editor?session?setMode \"ace/mode/ocaml\"\n                       editor?setOption?apply(\"enableBasicAutocompletion\", true)\n                       addMarker editor 0 1 0 4 |> ignore\n                       aceEditor <- Some editor\n                       ()\n                    )\n            )\n        ]\n     ]\n\neditor   \n|> fun el -> el.AddChildren [ style \"height: 600px ; width: 1000px\" ]\n|> RunCode.RunNode(useShadowRoot = false).ShowHtmlResult\n","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"1f1aa135-fd74-42cc-b9a5-87f380c113a9"}],"id":{"$":0,"Item":"fa514631-1594-4dd9-b5ea-0dd24f2205b4"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FableModule","content":"[< JavaScript >]\nmodule FableModule =\n    open Useful\n    \n    //[< Require(typeof<Resources.BaseResource>, \"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.2/require.min.js\")      >]    \n    [< Require(typeof<Resources.BaseResource>, \"/EPFileX/Fable/babel-standalone.js\")                               >]    \n    type Babel() =    \n        [< Inline \"Babel.transformFromAst($_ast , null, $_options)\"                  >] static member transformFromAst(_ast , _xx, _options)                = X<_>\n        [< Inline \"Babel.transform       ($_ast ,       $_options)\"                  >] static member transform       (_ast ,      _options)                = X<_>\n    \n    [< Require(typeof<Resources.BaseResource>, \"/EPFileX/Fable/babel-standalone.js\")                               >]    \n    [< Require(typeof<Resources.BaseResource>, \"/EPFileX/Fable\", \"Fable.js\", \"Worker.js\")                          >]\n    type Fable() =\n        [< Inline \"Fable.createChecker($_f, $_references)\"                           >] static member createChecker(_f, _references)  : obj                  = X<_>\n        [< Inline \"Fable.makeCompiler($_replacements)\"                               >] static member makeCompiler(_replacements)     : obj                  = X<_>\n        [< Inline \"Fable.parseFSharpProject($_checker, $_com, $_fileName, $_source)\" >] static member parseFSharpProject(_checker, _com, _fileName, _source:string) = X<_>\n        [< Inline \"Fable.compileAst($_com, $_fsharpAst, $_fileName)\"                 >] static member compileAst(_com, _fsharpAst, _fileName)                = X<_>\n        [< Inline \"Fable.convertToJson($_babelAst)\"                                  >] static member convertToJson(_babelAst)                               = X<_>\n    \n    let [< Inline \"getFileBlob($_key, $_url)\"                                        >] getFileBlob(_key, _url)                                              = X<_>\n    let [< Inline \"metadata[$_fn]\"                                                   >] readAllBytes _fn                                                     = X<_>\n    let [< Inline \"Object.getOwnPropertyNames(metadata).length\"                      >] metadataLength (): int                                               = X<_>\n    let [< Inline \"babelPlugins\"                                                     >] babelPlugins () : obj                                                = X<_>\n    \n    \n    let references = [|\n        \"mscorlib.dll\"\n        \"System.dll\"\n        \"System.Core.dll\"\n        \"System.Data.dll\"\n        \"System.IO.dll\"\n        \"System.Xml.dll\"\n        \"System.Numerics.dll\"\n        \"FSharp.Core.sigdata\"\n        \"FSharp.Core.dll\"\n        \"Fable.Core.dll\"\n        \"Fable.Import.Browser.dll\"\n        // When loading the REPL the browser console always shows: \"Cannot find type System.ValueTuple`1\"\n        // However, adding the following reference prevents opening System namespace\n        // See https://github.com/fable-compiler/Fable/issues/1152#issuecomment-330315250\n        // \"System.ValueTuple.dll\",\n    |]\n\n    let loadReferences =\n        lazy\n            async {\n                do! LoadFilesAsync [| \"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.2/require.min.js\" |] \n                let  options          = Object.Create null\n                options?skipDataMain <- 1\n                options?isBrowser    <- 1\n                JS.Window?require?config options\n                references |> Seq.iter (fun fn -> getFileBlob(fn, \"metadata/\" + fn))\n            } |> Async.Start\n        \n    let getChecker = \n        lazy Fable.createChecker(readAllBytes, references |> Array.choose (fun fn -> if fn.Contains \"sigdata\" then None else Some <| fn.Replace(\".dll\", \"\")) )\n        \n    let mutable addOutMsg : string -> unit = Console.Log\n\n    let ToConsole arg = \n        Console.Log arg\n        arg?cont addOutMsg\n\n    let fableTranslate source : Wrap<string> =\n        Wrap.wrapper {\n            loadReferences.Value\n            do! async { \n                    while metadataLength() < references.Length do\n                        do! Async.Sleep 200\n                }\n            let  checker       = getChecker.Value\n            let  com           = Fable.makeCompiler [| \"Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatLine\"\n                                                     , \"FSSGlobal.FSharpStation.FableModule.ToConsole($0)\" |]  \n            let  fileName      = \"stdin.fsx\"\n            let  fsharpAst     = Fable.parseFSharpProject(checker, com, fileName, source)\n            let  babelAst      = Fable.compileAst(com, fsharpAst, fileName)\n            let  jsonAst       = Fable.convertToJson(babelAst)\n            let  ast           = JSON.Parse(jsonAst)\n            let  options       = Object.Create null\n            options?plugins   <- [| babelPlugins()?transformMacroExpressions\n                                    babelPlugins()?removeUnneededNulls \n                                    \"transform-es2015-modules-amd\"    \n                                 |]\n            options?presets   <- [|  |]\n            options?filename  <- fileName\n            options?babelrc   <- false\n            let  transformed   = Babel.transformFromAst(ast , null, options)\n            let  jCode2:string = transformed?code\n            let  jCode3        = jCode2.Replace(\"define([\"       , \"require([\")\n                                       .Replace(\"\\\"use strict\\\";\", \"\\\"use strict\\\"; try { exports = exports || {}; } catch (err) {}\")\n            return jCode3\n        }\n    \n    ","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"1f1aa135-fd74-42cc-b9a5-87f380c113a9"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"c6e83584-7ab1-4ff7-bb62-16cbc3198b65"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Thermostat Layout","content":"open Template\n\nlet thermostatDisplay name temp mode state fanState (set: IRef<string>) =\n    let title       = \n        h2 [ htmlText name ; style \"\"]\n    let information = \n        div [ h3 [ htmlText (temp |> float |> sprintf \"%A°F\") ]\n              h4 [ div [ htmlText state    ]\n                   div [ htmlText fanState ]\n                 ]\n            ]\n    let settings    = \n        div [ Template.Input.New(set).Prefix(\n                  Template.Button.New(\"Set:\").OnClick(fun _ _ -> ()).Render\n              ).Render.Style(\"\")\n              css \"\n                  .thermostat {\n                      text-align      : center     ; \n                  }\n                  .thermostat h2, .thermostat h3, .thermostat h4  {\n                      margin-top      : 3px     ; \n                  }\n                  .thermostat.ModeCool {\n                      background-color: blueviolet; \n                      color: white;\n                  }\n                  .thermostat.ModeCool button {\n                      background-color: navy; \n                      color: white;\n                  }\n                  .thermostat.ModeHeat {\n                      background-color: firebrick; \n                      color: white;\n                  }\n                  .thermostat.ModeHeat button {\n                      background-color: darkred; \n                      color: white;\n                  }\n                \"\n            ]\n    let layout =            \n        Layout.AddGuids\n          [\n             \"title\"        , GuiNode title\n             \"information\"  , GuiNode information\n             \"settings\"     , GuiNode settings\n             \"data\"         , fixPcVerSplitter true  50.0 \"information\"   \"settings\"\n             \"main\"         , fixPcHorSplitter true  25.0 \"title\"         \"data\"\n          ]\n        |> Layout.New\n    layout.Render\n        .Style(\"\n            width   : 200px;\n            grid-gap: 0px  ; \n            margin  : 10px ; \n         \" )\n        .AddClass(sprintf \"shadow panel thermostat Mode%s\" mode)\n\ndiv [ thermostatDisplay \"Arriba\" \"74\"   \"Cool\" \"Cooling\" \"\"       <| Var.Create \"74.50\"\n      thermostatDisplay \"Abajo\"  \"72.5\" \"Heat\" \"Heating\" \"Fan:on\" <| Var.Create \"72.50\"\n]\n|> RunCode.RunNode().AddBootstrap.RunHtml\n","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"9c870b72-8f9a-4e7d-ad81-7f1fd73fdd76"}],"id":{"$":0,"Item":"40e7813c-964c-4181-9832-54ec1f538386"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"purescript","content":"// PURESCRIPT (Haskell) code of a Flare reactive applet with state:  try.purescript.org\n//\n// module Main where\n// \n// import Prelude\n// import Math\n// import Flare\n// \n// fspipe  :: forall a b. a -> (a -> b) -> b\n// fspipe  a f = f a\n// infixl 1 fspipe  as |>\n// \n// fsbpipe :: forall a b. (a -> b) -> a -> b\n// fsbpipe f a = f a\n// infixl 1 fsbpipe as <|\n// \n// appButton txt   fU  =\n//   fU\n//   |> map      (\\f pressed -> if pressed then f else id)\n//   |> apply <| button txt false true\n// \n// incdec true v  state =  v + state\n// incdec _    v  state = -v + state\n// \n// main = \n//   pure incdec\n//   |> apply   <| boolean \"Increment\" true      \n//   |> apply   <| int     \"value\"     7   \n//   |> onclick \"Do it\"\n//   |> foldp   ($)  0\n//   |> runFlareShow \"controls\" \"output\"\n\n#r @\"../packages/WebSharper.Formlets/lib/net40/WebSharper.Formlets.dll\"\n#r @\"../packages/WebSharper.Html/lib/net40/WebSharper.Html.Client.dll\"\n#r @\"../packages/WebSharper.Reactive/lib/net40/IntelliFactory.Reactive.dll\"\n\nopen WebSharper.Formlets\n//open WebSharper.UI\n//open WebSharper.Html.Client\n\nlet incdec inc (v:int) = ((+) (if inc then v else -v))\n\nlet appButton txt   fU  =\n   fU\n   |> Formlet.Map      (fun f _pressed -> f)\n   <*> WebSharper.Formlets.Controls.Button  txt\n\nlet formlet = \n    Formlet.Return incdec\n    <*> WebSharper.Formlets.Controls.Checkbox true\n    <*> (WebSharper.Formlets.Controls.Input \"4\" |> Formlet.Map int)\n    |> appButton \"Do it\"\n    |> Formlet.Flowlet\n    |> Formlet.Run ignore\n    \nWebSharper.UI.Next.Doc.Element [ formlet ]\n//|> RunCode.RunNode().RunDoc","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[],"id":{"$":0,"Item":"062caaa2-87ef-4794-8ed3-90f80dc529a8"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"WebSharper Data JsonProvider","content":"#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n#r @\"..\\packages\\WebSharper.Data\\lib\\net461\\WebSharper.Data.dll\"\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI\nopen WebSharper.UI.Client\nopen FSharp.Data\n\ntype Simple = JsonProvider<\"\"\" { \"name\":\"John\", \"age\":94 } \"\"\">\nlet  simple = Simple.Parse(\"\"\" { \"name\":\"Tomas\", \"age\":4 } \"\"\")\n\nlet Main =\n    div [\n        htmlText (sprintf \"age: %d\" simple.Age)\n    ]\n    |> RunCode.RunNode().AddBootstrap.RunHtml\n\n","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[],"id":{"$":0,"Item":"cd685fab-7e8c-4161-a91b-3b82ff600c0c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"mbrace","content":"//let print x = printfn \"%A\" x\n\n//#load @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\HandsOnTutorial.FSharp\\ThespianCluster.fsx\"\n\n#I @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\HandsOnTutorial.FSharp\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools\" \n#I @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/Streams/lib/net45\" \n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/Streams/lib/net45/Streams.dll\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Flow/lib/net45\" \n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Flow/lib/net45/MBrace.Flow.dll\"\n//#load @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/MBrace.Thespian.fsx\"\n\n#I @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/Newtonsoft.Json.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/FsPickler.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/FsPickler.Json.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/Mono.Cecil.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/Vagabond.AssemblyParser.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/Vagabond.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/Thespian.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/Argu.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/MBrace.Core.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/MBrace.Runtime.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/MBrace.Thespian.dll\"\n\nopen System.IO\nopen MBrace.Thespian\n\nThespianWorker.LocalExecutable <- Path.Combine(__SOURCE_DIRECTORY__,  @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/mbrace.thespian.worker.exe\")\n\nmodule Config = \n\n    open MBrace.Core\n    open MBrace.Runtime\n    open MBrace.Thespian\n\n    // change to alter cluster size\n    let private workerCount = 4\n    \n    let mutable private thespian = None\n    /// Gets or creates a new Thespian cluster session.\n    let GetCluster() = \n        match thespian with \n        | None -> \n            let cluster = \n                ThespianCluster.InitOnCurrentMachine(workerCount, \n                                                     logger = new ConsoleLogger(), \n                                                     logLevel = LogLevel.Info)\n            thespian <- Some cluster\n        | Some t -> ()\n        thespian.Value\n\n    /// Kills the current cluster session\n    let KillCluster() =\n        match thespian with\n        | None -> ()\n        | Some t -> t.KillAllWorkers() ; thespian <- None\n\n\n\n(*** hide ***)\n//#load \"AzureCluster.fsx\"\n//#load \"AwsCluster.fsx\"\n\n// Note: Before running, choose your cluster version at the top of this script.\n// If necessary, edit AzureCluster.fsx to enter your connection strings.\n\nopen System\nopen System.IO\nopen MBrace.Core\nopen MBrace.Flow\n\n(**\n\n# Your First 'Hello World' Computation with MBrace\n\n> This tutorial is from the [MBrace Starter Kit](https://github.com/mbraceproject/MBrace.StarterKit).\n\nA guide to creating a cluster is [here](http://www.mbrace.io/#try).\n\nStart F# Interactive in your editor.  Highlight the text below and press \"Alt-Enter\" (Visual Studio) or the other\nappropriate execution command for your editor. This connects to the cluster.  If you are using a locally simulated\ncluster it also creates the cluster.\n\n*)\n\nlet cluster = Config.GetCluster()\n\n(**\nNext, get details of the workers in your cluster. Again, highlight the text below and\nexecute it in your scripting client:\n*)    \n\ncluster.ShowWorkers()\n\n\n(** Alternatively we can do this all in one line: *)\nlet quickText = \n    cloud { return \"Hello world!\" } \n    |> cluster.Run\n\n\n(** To check that you are running in the cloud, compare a workflow running locally \nwith one using cloud execution. (Note, if using an MBrace.Thespian locally simulated\ncluster, these will be identical.) *)\nlet localResult =\n    cloud { printfn \"hello, world\" ; return Environment.MachineName }\n    |> cluster.RunLocally\n\nlet remoteResult =\n    cloud { printfn \"hello, world\" ; return Environment.MachineName }\n    |> cluster.Run\n\n//(** \n//\n//## Controlling the Cluster\n//\n//To view the history of processes, execute the following line from your scriptin\n//*)\n//\n//cluster.ShowProcesses()\n//\n//(**\n//In case you run into trouble, you can clear all process records in the cluster\n//by executing the following from your scripting client:\n//*)\n//\n//cluster.ClearAllProcesses()\n//\n//(**\n//\n//> Note, you can use the above techniques from both scripts and compiled projects. To see the components referenced \n//> by this script, see [ThespianCluster.fsx](ThespianCluster.html) or [AzureCluster.fsx](AzureCluster.html).\n//\n//**)\n\n\n\n","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[],"id":{"$":0,"Item":"3f0bf09c-1de2-414a-a616-60e0b4ea2b36"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"mbrace2","content":"(** Now execute your first cloud workflow, returning a handle to the running job: *)\n//let task = \n//    cloud { return \"Hello world!\" } \n//    |> cluster.CreateProcess\n\n(** This submits a task to the cluster. To get details for the task, execute the \nfollowing in your scripting client: *)\n\n//task.ShowInfo()\n\n(** Your task is likely complete by now.  To get the result returned by your \ntask, execute the following in your scripting client: *)\nlet text = task.Result\n\nlet localResult =\n    cloud { printfn \"hello, local world\" ; return Environment.MachineName }\n    |> cluster.RunLocally\n\nlet remoteResult =\n    cloud { printfn \"hello, remote world\" ; return Environment.MachineName }\n    |> cluster.Run\n\n[\n    task.Result\n    localResult\n    remoteResult\n] |> printfn \"%A\"","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[],"id":{"$":0,"Item":"f5890da9-9fb8-4274-ab4f-23c77bc81cf0"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"open WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.JQuery\nopen WebSharper.UI\nopen WebSharper.UI.Client\nopen WebSharper.UI.Html\n\n\n[<JavaScript>]\nmodule Code =\n    type Person = { Username: string; Name: string }\n    \n    let myPeopleColl =\n        ListModel.Create (fun p -> p.Username)\n            [ { Username = \"johnny87\"; Name = \"John\" };\n              { Username = \"theana12\"; Name = \"Ana\" } ]\n\n    let inline concatn n x = \n        Console.Log (\"concat \" + n)\n        Doc.Concat x\n              \n    let myPeopleList =\n        myPeopleColl.ViewState\n        |> Doc.BindView (fun people ->\n            Console.Log \"people\"\n            ul [] [\n                people\n                |> Seq.map (fun p -> \n                    Console.Log p.Username\n                    li [] [ text p.Name ] :> Doc)\n                |> concatn \"BindView\"\n            ] :> Doc\n        )\n        \n    let myDoc =\n        myPeopleColl.Map(fun v ->\n            Console.Log v.Username\n            p [] [ text v.Name ] :> Doc\n        )\n        |> Doc.BindView (concatn \"Map\")\n        \n    let myDoc2 =\n        myPeopleColl.Map(fun k vp ->\n            Console.Log k\n            p [] [ text (vp.V.Name) ] :> Doc\n        )        \n        |> Doc.BindView (concatn \"Map2\")\n\n    let myDoc3 =\n        myPeopleColl.MapLens(fun k vp ->\n            Console.Log k\n            label [] [\n                text (vp.V.Username + \": \")\n                Doc.InputV [] vp.V.Name \n            ] :> Doc\n        )\n        |> Doc.BindView (concatn \"MapLens\")\n\n    let myDoc4 =\n        myPeopleColl.Doc(fun k vp ->\n            Console.Log k\n            p [] [ text (vp.V.Name) ] :> Doc\n        )        \n\n\n    let changes () =\n        myPeopleColl.Add({ Username = \"mynameissam\"; Name = \"Sam\" })\n        myPeopleColl.Add({ Username = \"johnny87\"; Name = \"Johnny\" })\n        \n\n    let Main =\n        [\n            myPeopleList\n            myDoc\n            myDoc2\n            myDoc3\n            myDoc4\n            button [ Html.on.click (fun _ _ -> changes()) ] [ text \"add\" ] :> Doc\n        ]\n        |> concatn \"Main\"\n        |> RunCode.RunNode().AddBootstrap.RunDoc\n","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[],"id":{"$":0,"Item":"52153260-1fc1-4a4d-b917-b4ad1776745f"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Layout","content":"[< JavaScript >]\nmodule Layout = ","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[],"id":{"$":0,"Item":"875d3aa7-2adf-4857-9df0-8c7c02ec6169"},"expanded":false,"level":0,"levelCode":0,"properties":{}},{"name":"Translate Layout(s)","content":"open Useful\nopen UsefulDotNet\nopen CompOptionsModule\nopen FsTranslator\n\nlet fsClient = new WSMessagingBroker.FStationMessaging(\"Translate Layout(s)\", WSMessagingBroker.FSharp)\n\nlet translateR snippet = \n    Wrap.wrap {\n        let!   code    = fsClient.RequestCode snippet\n        let!   js      = TranslatorCaller.getJSW false [] code\n        let    js2     = \"(\" + js.[js.IndexOf(\" function()\") .. js.LastIndexOf(\"});\") - 1] + \"Layout.setLayout(Layout.getLayout);})()\"\n        return js2;\n    } \n\nlet translate  snip =\n    translateR snip \n    |> Wrap.runSynchronouslyS false\n    |> printfn \"%s\"\n\nlet translateNSet target =\n    Wrap.wrap {\n        let  snippet = target |> String. splitByChar '/' |> Array.last\n                       |> String.append \"FSSGlobal/WebSharper Code/Layout/Layout: \"\n        printfn \"%s\" snippet\n        let! js      = translateR snippet\n        printfn \"translated\"\n        let! res     = fsClient.RunActionCall(\"actSetSnippetProp\", \"actSetSnippetProp\", [| target ; \"LayoutJS\" ; js |])\n        return res\n    } \n    |> Wrap.runSynchronouslyS false\n    |> printfn \"%s\"\n\n//translate \"Layout translate button\"\n//translateNSet \"FSSGlobal/WebSharper Code/Layout/Translate Layout(s)\"\n","parent":{"$":0,"Item":"875d3aa7-2adf-4857-9df0-8c7c02ec6169"},"predecessors":[{"$":0,"Item":"4413b3ee-f968-458d-8a5f-7a7c9281c38f"},{"$":0,"Item":"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"251bfd3b-3ea6-4761-8288-a978099aa06e"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableFSI":"0","open":"////-d:WEBSHARPER\nopen FSSGlobal.Layout\n","action-template":"translateNSet \"${parm}\"","LayoutJS":"( function()\n{\n \"use strict\";\n var Global,FSSGlobal,Layout,SC$1,WebSharper,Seq,Useful,String,Option,Template,Button,IntelliFactory,Runtime,Result,Utils,console,Layout$1,HtmlNode,List,Action,Collections,FSharpMap;\n Global=window;\n FSSGlobal=Global.FSSGlobal=Global.FSSGlobal||{};\n Layout=FSSGlobal.Layout=FSSGlobal.Layout||{};\n SC$1=Global[\"StartupCode$Temp_xxppndzp$bf864f3c-1370-42f2-ac8a-565a604892e8 FSSGlobal\"]=Global[\"StartupCode$Temp_xxppndzp$bf864f3c-1370-42f2-ac8a-565a604892e8 FSSGlobal\"]||{};\n WebSharper=Global.WebSharper;\n Seq=WebSharper&&WebSharper.Seq;\n Useful=FSSGlobal&&FSSGlobal.Useful;\n String=Useful&&Useful.String;\n Option=Useful&&Useful.Option;\n Template=FSSGlobal&&FSSGlobal.Template;\n Button=Template&&Template.Button;\n IntelliFactory=Global.IntelliFactory;\n Runtime=IntelliFactory&&IntelliFactory.Runtime;\n Result=Useful&&Useful.Result;\n Utils=WebSharper&&WebSharper.Utils;\n console=Global.console;\n Layout$1=Template&&Template.Layout;\n HtmlNode=FSSGlobal&&FSSGlobal.HtmlNode;\n List=WebSharper&&WebSharper.List;\n Action=Template&&Template.Action;\n Collections=WebSharper&&WebSharper.Collections;\n FSharpMap=Collections&&Collections.FSharpMap;\n Layout.getLayout=function(lyt,snp)\n {\n  return Layout.getButtonsLayout(Layout.evalFsCodeButtonNoParms(lyt),snp);\n };\n Layout.getButtonsLayout=function(f,snp)\n {\n  return Layout.extraButtonsLayout(f(Seq.filter(function(y)\n  {\n   return\"\"!==y;\n  },Seq.map(String.trim,String.splitByChar(\"\\n\",Option.defaultValue(\"\",function(d)\n  {\n   var res;\n   res=null;\n   return d.TryGetValue(\"LayoutButtons\",{\n    get:function()\n    {\n     return res;\n    },\n    set:function(v)\n    {\n     res=v;\n    }\n   })?{\n    $:1,\n    $0:res\n   }:null;\n  }(snp.properties)))))));\n };\n Layout.buttonPwd=function(code,lyt)\n {\n  return Button.New$1(\"Send\").OnClick(Runtime.Curried(Layout.sendPwd,2,[code,lyt])).get_Render();\n };\n Layout.sendPwd=function(code,lyt,el,ev)\n {\n  var a,act,x,o;\n  a=Result.Success(lyt.GetGuiCallAction(\"sendPwd\",\"actEvalFsCode\",[\"Code\",code()]));\n  a.$==1?(function($1)\n  {\n   return function($2)\n   {\n    return $1(Utils.printArray(Utils.prettyPrint,$2));\n   };\n  }(function(s)\n  {\n   console.log(s);\n  }))(a.$0):(act=a.$0[0],x=(o=act.onClick,o==null?null:{\n   $:1,\n   $0:((o.$0(act))(el))(ev)\n  }),Option.defaultWith(function($1)\n  {\n   return function()\n   {\n    return $1(\"OnClick is null\");\n   };\n  }(function(s)\n  {\n   console.log(s);\n  }),x));\n };\n Layout.evalFsCodeButtonNoParms=function(lyt)\n {\n  var f,f$1;\n  function p(y)\n  {\n   return\"\"!==y;\n  }\n  function g(t)\n  {\n   return Layout.evalFsCodeButtons(lyt,t);\n  }\n  f=(f$1=function(s)\n  {\n   return Seq.filter(p,s);\n  },function(x)\n  {\n   return Layout.passNoParms(f$1(x));\n  });\n  return function(x)\n  {\n   return g(f(x));\n  };\n };\n Layout.evalFsCodeButtonNoParm=function(lyt)\n {\n  function g(t,p)\n  {\n   return Layout.evalFsCodeButton(lyt,t,p);\n  }\n  return function(x)\n  {\n   return g.apply(null,Layout.passNoParm(x));\n  };\n };\n Layout.passNoParms=function(txts)\n {\n  return Seq.map(Layout.passNoParm,txts);\n };\n Layout.passNoParm=function(txt)\n {\n  return[txt,[]];\n };\n Layout.runFableFsButton=function(lyt,txt,parms)\n {\n  return lyt.GetCallButton(txt,Layout.actRunFableFs(),parms);\n };\n Layout.evalFsCodeButtons=function(lyt,txts)\n {\n  function m(t,p)\n  {\n   return Layout.evalFsCodeButton(lyt,t,p);\n  }\n  return Seq.map(function($1)\n  {\n   return m($1[0],$1[1]);\n  },txts);\n };\n Layout.evalFsCodeButton=function(lyt,txt,parms)\n {\n  return lyt.GetCallButton(txt,Layout.actEvalFsCode(),parms);\n };\n Layout.extraButtonsLayout=function(buttons)\n {\n  return Layout$1.AddGuids([[\"extrabuttons\",new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.div(List.ofSeq(Seq.delay(function()\n   {\n    return Seq.append([HtmlNode.style(\"text-align: center ; overflow: auto ; \")],Seq.delay(function()\n    {\n     return Seq.append(buttons,Seq.delay(function()\n     {\n      return[HtmlNode.css(\" button.btn { margin: 2px; font-size: small; } \")];\n     }));\n    }));\n   })))\n  })],[\"main_extra\",Template.varVerSplitter(85,\"main_messages\",\"extrabuttons\",50,100)],[\"main\",Template.fixedHorSplitter(true,50,\"menu\",\"main_extra\")]]);\n };\n Layout.layout=function()\n {\n  SC$1.$cctor();\n  return SC$1.layout;\n };\n Layout.set_layout=function($1)\n {\n  SC$1.$cctor();\n  SC$1.layout=$1;\n };\n Layout.doGuiCall=function(name,action,parms)\n {\n  Global.doFSharpStationGuiCall([name,action,parms]);\n };\n Layout.setLayout=function(f)\n {\n  Global.setFSharpStationLayout(f);\n };\n Layout.guiParts=function()\n {\n  SC$1.$cctor();\n  return SC$1.guiParts;\n };\n Layout.dummyAction=function()\n {\n  SC$1.$cctor();\n  return SC$1.dummyAction;\n };\n Layout.Properties=function()\n {\n  SC$1.$cctor();\n  return SC$1.Properties;\n };\n Layout.WSResult=function()\n {\n  SC$1.$cctor();\n  return SC$1.WSResult;\n };\n Layout.FScode=function()\n {\n  SC$1.$cctor();\n  return SC$1.FScode;\n };\n Layout.JavaScript=function()\n {\n  SC$1.$cctor();\n  return SC$1.JavaScript;\n };\n Layout.Parser=function()\n {\n  SC$1.$cctor();\n  return SC$1.Parser;\n };\n Layout.Output=function()\n {\n  SC$1.$cctor();\n  return SC$1.Output;\n };\n Layout.menu=function()\n {\n  SC$1.$cctor();\n  return SC$1.menu;\n };\n Layout.buttons=function()\n {\n  SC$1.$cctor();\n  return SC$1.buttons;\n };\n Layout.code=function()\n {\n  SC$1.$cctor();\n  return SC$1.code;\n };\n Layout.snippets=function()\n {\n  SC$1.$cctor();\n  return SC$1.snippets;\n };\n Layout.titleX=function()\n {\n  SC$1.$cctor();\n  return SC$1.titleX;\n };\n Layout.actFindDefinition=function()\n {\n  SC$1.$cctor();\n  return SC$1.actFindDefinition;\n };\n Layout.actCompileWS=function()\n {\n  SC$1.$cctor();\n  return SC$1.actCompileWS;\n };\n Layout.actParseCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actParseCode;\n };\n Layout.actRunWSIn=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunWSIn;\n };\n Layout.actRunWSHere=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunWSHere;\n };\n Layout.actRunWSNewTab=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunWSNewTab;\n };\n Layout.actRunFable=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunFable;\n };\n Layout.actRunFableFs=function()\n {\n  SC$1.$cctor();\n  return SC$1.actRunFableFs;\n };\n Layout.actEvalCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actEvalCode;\n };\n Layout.actEvalFsCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actEvalFsCode;\n };\n Layout.actGetFsCode=function()\n {\n  SC$1.$cctor();\n  return SC$1.actGetFsCode;\n };\n Layout.actOutdentSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actOutdentSnippet;\n };\n Layout.actIndentSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actIndentSnippet;\n };\n Layout.actDeleteSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actDeleteSnippet;\n };\n Layout.actAddSnippet=function()\n {\n  SC$1.$cctor();\n  return SC$1.actAddSnippet;\n };\n Layout.actSaveFile=function()\n {\n  SC$1.$cctor();\n  return SC$1.actSaveFile;\n };\n Layout.actLoadFile=function()\n {\n  SC$1.$cctor();\n  return SC$1.actLoadFile;\n };\n SC$1.$cctor=function()\n {\n  SC$1.$cctor=Global.ignore;\n  SC$1.actLoadFile=\"actLoadFile\";\n  SC$1.actSaveFile=\"actSaveFile\";\n  SC$1.actAddSnippet=\"actAddSnippet\";\n  SC$1.actDeleteSnippet=\"actDeleteSnippet\";\n  SC$1.actIndentSnippet=\"actIndentSnippet\";\n  SC$1.actOutdentSnippet=\"actOutdentSnippet\";\n  SC$1.actGetFsCode=\"actGetFsCode\";\n  SC$1.actEvalFsCode=\"actEvalFsCode\";\n  SC$1.actEvalCode=\"actEvalCode\";\n  SC$1.actRunFableFs=\"actRunFableFs\";\n  SC$1.actRunFable=\"actRunFable\";\n  SC$1.actRunWSNewTab=\"actRunWSNewTab\";\n  SC$1.actRunWSHere=\"actRunWSHere\";\n  SC$1.actRunWSIn=\"actRunWSIn\";\n  SC$1.actParseCode=\"actParseCode\";\n  SC$1.actCompileWS=\"actCompileWS\";\n  SC$1.actFindDefinition=\"actFindDefinition\";\n  SC$1.titleX=\"title\";\n  SC$1.snippets=\"snippets\";\n  SC$1.code=\"code\";\n  SC$1.buttons=\"buttons\";\n  SC$1.menu=\"menu\";\n  SC$1.Output=\"Output\";\n  SC$1.Parser=\"Parser\";\n  SC$1.JavaScript=\"JavaScript\";\n  SC$1.FScode=\"F# code\";\n  SC$1.WSResult=\"WS Result\";\n  SC$1.Properties=\"Properties\";\n  SC$1.dummyAction=Action.New$1(\"dummy\");\n  SC$1.guiParts=new FSharpMap.New(List.ofArray([[Layout.actLoadFile(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actSaveFile(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actAddSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actDeleteSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actIndentSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actOutdentSnippet(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actGetFsCode(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actEvalCode(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actRunWSNewTab(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actRunWSHere(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actRunWSIn(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actParseCode(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actCompileWS(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.actFindDefinition(),new Template.GuiPart({\n   $:2,\n   $0:Layout.dummyAction()\n  })],[Layout.titleX(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"title\")\n  })],[Layout.snippets(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"snippets\")\n  })],[Layout.code(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"editor\")\n  })],[Layout.buttons(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"buttons\")\n  })],[Layout.menu(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"menu\")\n  })],[Layout.Output(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"Output\")\n  })],[Layout.Parser(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"Parser\")\n  })],[Layout.JavaScript(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"JavaScript\")\n  })],[Layout.FScode(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"F# code\")\n  })],[Layout.WSResult(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"WS Result\")\n  })],[Layout.Properties(),new Template.GuiPart({\n   $:1,\n   $0:HtmlNode.htmlText(\"Properties\")\n  })]]));\n  SC$1.layout=[];\n };\nLayout.setLayout(Layout.getLayout);})()","LayoutButtons":"FSSGlobal/F# Code/Garage & other things/Adb Run OpenGarage3\nFSSGlobal/F# Code/Garage & other things/AbeRaspi\nFSSGlobal/F# Code/Garage & other things/Ping computers\nFSSGlobal/F# Code/Garage & other things/Thermostats\nFSSGlobal/WebSharper Code/Layout/Translate Layout(s)"}},{"name":"Layout","content":"//#r @\"Compiled\\RemotingDll\\RemotingDll.dll\"\n#r \"FSharpStation.exe\"\nopen FSSGlobal.Useful\nopen FSSGlobal.HtmlNode\nopen FSSGlobal.Template\nopen FSSGlobal\n\nlet actLoadFile       = \"actLoadFile\"\nlet actSaveFile       = \"actSaveFile\"\nlet actAddSnippet     = \"actAddSnippet\"\nlet actDeleteSnippet  = \"actDeleteSnippet\"\nlet actIndentSnippet  = \"actIndentSnippet\"\nlet actOutdentSnippet = \"actOutdentSnippet\"\nlet actGetFsCode      = \"actGetFsCode\"\nlet actEvalFsCode     = \"actEvalFsCode\"\nlet actEvalCode       = \"actEvalCode\"\nlet actRunFableFs     = \"actRunFableFs\"\nlet actRunFable       = \"actRunFable\"\nlet actRunWSNewTab    = \"actRunWSNewTab\"\nlet actRunWSHere      = \"actRunWSHere\"\nlet actRunWSIn        = \"actRunWSIn\"\nlet actParseCode      = \"actParseCode\"\nlet actCompileWS      = \"actCompileWS\"\nlet actFindDefinition = \"actFindDefinition\"\nlet titleX            = \"title\"            \nlet snippets          = \"snippets\"         \nlet code              = \"code\"           \nlet buttons           = \"buttons\"          \nlet menu              = \"menu\"             \nlet Output            = \"Output\"           \nlet Parser            = \"Parser\"           \nlet JavaScript        = \"JavaScript\"       \nlet FScode            = \"F# code\"          \nlet WSResult          = \"WS Result\"        \nlet Properties        = \"Properties\"  \n\nlet dummyAction = Action.New \"dummy\"\n\nlet guiParts =\n    Map[\n       actLoadFile      , GuiAction dummyAction \n       actSaveFile      , GuiAction dummyAction \n       actAddSnippet    , GuiAction dummyAction \n       actDeleteSnippet , GuiAction dummyAction \n       actIndentSnippet , GuiAction dummyAction \n       actOutdentSnippet, GuiAction dummyAction \n       actGetFsCode     , GuiAction dummyAction \n       actEvalCode      , GuiAction dummyAction \n       actRunWSNewTab   , GuiAction dummyAction \n       actRunWSHere     , GuiAction dummyAction \n       actRunWSIn       , GuiAction dummyAction \n       actParseCode     , GuiAction dummyAction \n       actCompileWS     , GuiAction dummyAction \n       actFindDefinition, GuiAction dummyAction \n       titleX           , GuiNode <| htmlText \"title\"       \n       snippets         , GuiNode <| htmlText \"snippets\"    \n       code             , GuiNode <| htmlText \"editor\"      \n       buttons          , GuiNode <| htmlText \"buttons\"     \n       menu             , GuiNode <| htmlText \"menu\"        \n       Output           , GuiNode <| htmlText \"Output\"      \n       Parser           , GuiNode <| htmlText \"Parser\"      \n       JavaScript       , GuiNode <| htmlText \"JavaScript\"  \n       FScode           , GuiNode <| htmlText \"F# code\"     \n       WSResult         , GuiNode <| htmlText \"WS Result\"   \n       Properties       , GuiNode <| htmlText \"Properties\"  \n    ]\n\nlet setLayout (f: Layout -> FsStationShared.CodeSnippet -> (string * GuiPartSourceId * GuiPart) [] ) =\n    JS.Window?setFSharpStationLayout f |> ignore\n \nlet doGuiCall (name: string) (action: string) (parms: string[]) =\n    JS.Window?doFSharpStationGuiCall (name, action, parms) |> ignore\n\nlet mutable layout :(string * GuiPartSourceId * GuiPart) [] = [||]\n\nlet extraButtonsLayout buttons =\n    Layout.AddGuids\n          [ \"extrabuttons\"      , div [ yield  style \"text-align: center ; overflow: auto ; \" \n                                        yield! buttons\n                                        yield  css \" button.btn { margin: 2px; font-size: small; } \" \n                                  ] |> GuiNode \n            \"main_extra\"        , varVerSplitter          85.0 \"main_messages\" \"extrabuttons\"   50.0  100.0\n            \"main\"              , fixedHorSplitter true   50.0 \"menu\"          \"main_extra\"\n          ]\n\nlet evalFsCodeButton (lyt: Layout) (txt, parms) = lyt.GetCallButton txt actEvalFsCode parms\nlet evalFsCodeButtons lyt           txts        = txts |> Seq.map (evalFsCodeButton lyt)\n\nlet runFableFsButton (lyt: Layout) (txt, parms) = lyt.GetCallButton txt actRunFableFs parms\n\nlet passNoParm  txt  = txt, [||]\nlet passNoParms txts = txts |> Seq.map passNoParm\n\nlet evalFsCodeButtonNoParm  lyt =                           passNoParm  >> evalFsCodeButton  lyt\nlet evalFsCodeButtonNoParms lyt = (Seq.filter ((<>) \"\")) >> passNoParms >> evalFsCodeButtons lyt\n\nlet sendPwd (code: unit -> string) (lyt:Layout) el ev = \n    lyt.GetGuiCallAction \"sendPwd\" \"actEvalFsCode\" [| \"Code\" ; code() |]\n    |> function\n       | Result.Success(act, _) -> act.onClick |> Option.map (fun f -> f act el ev) |> Option.defaultWith (printfn \"OnClick is %A\")\n       | Result.Failure ms      -> printfn \"%A\" ms\n    \nlet buttonPwd code lyt     = Button.New(\"Send\").OnClick(sendPwd code lyt).Render\n\nlet getButtonsLayout f (snp:FsStationShared.CodeSnippet) =\n    snp.properties\n    |> Dict.tryGetValue \"LayoutButtons\"\n    |> Option.defaultValue \"\"\n    |> String.splitByChar '\\n'\n    |> Seq.map    String.trim\n    |> Seq.filter ((<>) \"\")\n    |> f\n    |> extraButtonsLayout\n","parent":{"$":0,"Item":"875d3aa7-2adf-4857-9df0-8c7c02ec6169"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"de383f39-4beb-4e97-ba06-30b8b454ffb2"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Layout: Adb Run OpenGarage3","content":"//open Template\n\nlet password       = Input.New(\"\").Placeholder(\"Enter Passhrase\").Type(\"Password\")\nlet sendPwdCode () = sprintf \"FSSGlobal.Garage.OldHtcPassword <- Some %A\" password.Var.Value\n\nlet mutable dragStartCoords = (0, 0)\n\nlet image (file: string) = \n    img [ src file\n          SomeAttr <| on.click     (fun em ev -> \n              doGuiCall \"clickScreen\" actEvalFsCode \n                  [| \"Code\" \n                     (ev?offsetX * em?naturalWidth / em?width, ev?offsetY * em?naturalHeight / em?height) |> sprintf \"click %A\" \n                  |]) \n          SomeAttr <| on.dragOver (fun _  ev -> ev.PreventDefault() )\n          SomeAttr <| on.drag     (fun _  ev -> ev.PreventDefault() )\n          SomeAttr <| on.dragStart(fun _  ev -> dragStartCoords <- (ev?offsetX, ev?offsetY))\n          SomeAttr <| on.drop     (fun em ev -> \n              ev.PreventDefault() \n              doGuiCall \"clickScreen\" actEvalFsCode \n                  [| \"Code\" \n                     ((fst dragStartCoords * em?naturalWidth / em?width, snd dragStartCoords * em?naturalHeight / em?height) \n                     ,(ev?offsetX          * em?naturalWidth / em?width, ev?offsetY          * em?naturalHeight / em?height))\n                     |> sprintf \"dragDrop %A\" \n                  |])\n          Id \"PhoneScreen\"\n          style \"width: 95%\"] \n                                 \nlet [< Inline \"Date.now()\" >] now() = 1\n\nlet getLayout lyt snp =\n    snp\n    |> getButtonsLayout (\n        Seq.map (\n            function\n            | \"Image\"      -> image (sprintf \"/screen.png?time=%d\" <| now())\n            | \"Refresh\"    -> runFableFsButton       lyt <| passNoParm \"Refresh\"\n            | \"Passphrase\" -> password.Prefix(buttonPwd sendPwdCode lyt).Render\n            | b            -> evalFsCodeButtonNoParm lyt b\n        )\n    )\n\n\n //Fable.Import.Browser.document.getElementById(\"PhoneScreen\").getAttribute(\"src\")\n ","parent":{"$":0,"Item":"875d3aa7-2adf-4857-9df0-8c7c02ec6169"},"predecessors":[{"$":0,"Item":"de383f39-4beb-4e97-ba06-30b8b454ffb2"}],"id":{"$":0,"Item":"1444403d-05ba-4f4c-bc27-f1134d58a482"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Layout: AbeRaspi","content":"let password       = Input.New(\"\").Placeholder(\"Enter Password\").Type(\"password\")\nlet sendPwdCode () = sprintf \"FSSGlobal.Garage.AbeRaspiPassword <- Some %A\" password.Var.Value\n\nlet getLayout lyt snp =\n    snp\n    |> getButtonsLayout (evalFsCodeButtonNoParms lyt \n                         >> Seq.append [ password.Prefix(buttonPwd sendPwdCode lyt).Render ])\n    ","parent":{"$":0,"Item":"875d3aa7-2adf-4857-9df0-8c7c02ec6169"},"predecessors":[{"$":0,"Item":"de383f39-4beb-4e97-ba06-30b8b454ffb2"}],"id":{"$":0,"Item":"1daccd12-b24a-45e0-9609-1f500500b69d"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Layout: Ping computers","content":"let getLayout lyt snp =\n    snp\n    |> getButtonsLayout (\n        Seq.collect (fun c ->\n            match c with\n            | \"computers\" -> Garage.computers |> Seq.map fst |> Seq.distinct |> Seq.sort\n            | _           -> Seq.singleton c\n        )\n        >> evalFsCodeButtonNoParms lyt\n    )\n       ","parent":{"$":0,"Item":"875d3aa7-2adf-4857-9df0-8c7c02ec6169"},"predecessors":[{"$":0,"Item":"7bb04b3c-b71e-4827-bd9e-b18fbabc1495"},{"$":0,"Item":"de383f39-4beb-4e97-ba06-30b8b454ffb2"}],"id":{"$":0,"Item":"161a6d53-ec0a-4b46-8445-ab14ec5e5ebe"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Layout: Translate Layout(s)","content":"let getLayout lyt snp = snp |> getButtonsLayout (evalFsCodeButtonNoParms lyt)\n","parent":{"$":0,"Item":"875d3aa7-2adf-4857-9df0-8c7c02ec6169"},"predecessors":[{"$":0,"Item":"de383f39-4beb-4e97-ba06-30b8b454ffb2"}],"id":{"$":0,"Item":"03b4ea7d-508a-4553-9c5a-f2b18280a27a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Layout: Thermostats","content":"#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n\nopen Template\nopen WSMessagingBroker\nopen Garage\nopen Useful\nopen FsStationShared\n\n[< Inline \"iwasherebefore = $v\">]\nlet setPrexistence v = ignore v\n[< Inline \"if (iwasherebefore) {} \">]\nlet checkPrexistence() = ()\n\ncheckPrexistence()\nlet messaging   = new WSMessagingClient(\"ThermostatsSite\")\nsetPrexistence messaging\n\nlet time2Str day hour minute =\n    match day with\n    | 0 -> \"Mon\"\n    | 1 -> \"Tue\"\n    | 2 -> \"Wed\"\n    | 3 -> \"Thu\"\n    | 4 -> \"Fri\"\n    | 5 -> \"Sat\"\n    | 6 -> \"Sun\"\n    | _ -> \"---\"\n    |> sprintf \"%s, %02d:%02d\" <| hour <| minute\n\n[<NoComparison ; NoEquality>]\ntype ThermostatData = {\n    name : string \n    data : Var<Map<string, Var<string>>>\n} \n\nlet getData key (therm: ThermostatData) =\n    Val.valFlow {\n        let! map   = therm.data\n        let  dataO = map |> Map.tryFind key\n        match dataO with \n        | None       -> return \"\" \n        | Some dataV -> \n        let!   data = dataV\n        return data\n    }\n    \nlet setData k v therm = \n    match therm.data.Value |> Map.tryFind k with\n    | None     -> therm.data.Value <- therm.data.Value |> Map.add k (Var.Create v)\n    | Some dat -> dat      .Value <- v\n    \nlet getMode        therm = Val.valFlow { return! getData \"tstat/tmode\" therm }\nlet getSettingParm therm = \n    Val.valFlow { \n        let! mode = getMode therm\n        return\n            match mode with\n            | \"1\" -> Some \"tstat/t_heat\"\n            | \"2\" -> Some \"tstat/t_cool\"\n            | _   -> None\n    }\n\nlet missingIRef = (Var.Create \"\").Lens (fun _ -> \"\") (fun _ _ -> \"\")\nlet getIRef key (therm: ThermostatData) = \n    therm.data.Value \n    |> Map.tryFind key\n    |> Option.map (fun v -> v :> Var<_>)\n    |> Option.defaultValue missingIRef\n    \nlet getSettingVar therm =\n    getSettingParm therm\n    |> Val.bindIRef (fun parmO ->\n        parmO\n        |> Option.map (fun key  -> getIRef key therm)\n        |> Option.map (fun iref -> (iref :?> Var<_>).Lens (float >> sprintf \"%A\") (fun _old newV -> newV))\n        |> Option.defaultValue missingIRef\n    )\n\nlet postTstat parm value therm =\n    async {\n        JS.Window?doFSharpStationGuiCall(\"setTstatParameter\", actEvalFsCode, [| \"Code\" ; sprintf \"postTstat %A %A %A \"  parm value therm.name |])\n    } |> Async.Start\n    JS.Alert(sprintf \"setting %s = %A\" parm value)\n\nlet setSetpoint therm =\n    async {\n        let!  parmO = therm |> getSettingParm |> Val.getAsync\n        match parmO with\n        | None -> ()\n        | Some parm ->\n        let! value  = therm |> getData parm   |> Val.getAsync\n        let parm2 = parm.[\"tstat/\".Length..]\n        therm |> postTstat parm2 value\n    }\n\nlet setHold v therm =\n    async {\n        let parm  = \"hold\"\n        let value = if v then \"1\" else \"0\"\n        therm |> setData parm (if v then \"1\" else \"0\")\n        therm |> postTstat parm value\n    }\n\nlet thermostatDisplay (therm:ThermostatData) =\n    let temp        = therm |> getData \"tstat/temp\"        |> Val.map (float >> sprintf \"%A°F\")\n    let mode        = therm |> getData \"tstat/tmode\"       |> Val.map (function | \"1\" -> \"Heat\"     | \"2\" -> \"Cool\"      | _ -> \"Off\")\n    let state       = therm |> getData \"tstat/tstate\"      |> Val.map (function | \"1\" -> \"Heating\"  | \"2\" -> \"Cooling\"   | _ -> \"\"   )\n    let fanState    = therm |> getData \"tstat/fstate\"      |> Val.map (function | \"1\" -> \"Fan:On\"   |                      _ -> \"\"   )\n    let hold        = therm |> getData \"tstat/hold\"\n    let day         = therm |> getData \"tstat/time/day\"    |> Val.map int\n    let hour        = therm |> getData \"tstat/time/hour\"   |> Val.map int\n    let minute      = therm |> getData \"tstat/time/minute\" |> Val.map int\n    let time        = Val.map3 time2Str day hour minute\n    let set         = getSettingVar therm\n    let title       = div [ h2  [ htmlText therm.name ]\n                            htmlText time\n                          ]\n    let information = div [ h3 [ htmlText temp           ]\n                            h4 [ div [ htmlText state    ]\n                                 div [ htmlText fanState ]\n                               ]\n                          ]\n    let settings    = div [ Template.Input.New(set).Prefix(\n                                Template.Button.New(\"Set:\").OnClick(fun _ _ -> therm |> setSetpoint |> Async.Start).Render\n                            ).Render.Style(\"\")\n                            label [\n                                ``class`` \"checkbox-inline\"\n                                htmlElement \"input\" \n                                      [ ``type`` \"checkbox\"\n                                        on.click       (fun e _ -> therm |>            setHold e?``checked`` |> Async.Start) |> SomeAttr\n                                        on.afterRender (fun e   -> hold  |> Val.sink (fun v -> e?``checked`` <- v = \"1\")   ) |> SomeAttr\n                                        style \"bottom: 0px\"\n                                      ]\n                                htmlText \"Hold\" \n                            ]\n                          ]\n    let layout      = Layout.AddGuids\n                          [\n                             \"title\"        , GuiNode title\n                             \"information\"  , GuiNode information\n                             \"settings\"     , GuiNode settings\n                             \"data\"         , fixPcVerSplitter true  50.0 \"information\"   \"settings\"\n                             \"main\"         , fixPcHorSplitter true  25.0 \"title\"         \"data\"\n                          ]\n                      |> Layout.New\n    layout.Render\n        .Style(\"\n            grid-gap: 0px  ; \n            margin  : 10px ; \n         \")\n        .AddClass(Val.map (sprintf \"shadow panel thermostat Mode%s\") mode)\n\nlet newThermostat n   = { name = n ; data = Var.Create Map.empty }\n    \nlet readProperties (snp:CodeSnippet) therm =\n    snp.properties.Keys\n    |> Seq.iter (fun k -> \n        match k with\n        | REGEX \"(.+)\\((.+)\\)\" \"\" v when v.[1] = therm.name -> therm |> setData v.[2] snp.properties.[k]\n        | _ -> () )\n\n\nlet         message     = Var.Create \"\"\nlet         temperature = Var.Create 0.0\nlet         tempText    = Val.map (sprintf \"%A\") temperature\nlet         deactivated = Var.Create \"\"\nlet mutable currentSnpO = None\n\nlet Thermostats =\n    [| \n        newThermostat \"Arriba\"\n        newThermostat \"Abajo\"\n    |]\n    \nlet getThermostat nm = Thermostats |> Array.tryFind (fun t -> t.name = nm)\n\nlet ThermostatHtmls =\n    Thermostats\n    |> Seq.map thermostatDisplay\n    |> Seq.append [ \n            htmlText message\n            css \"\"\"\n                  .thermostat {\n                      text-align      : center     ; \n                  }\n                  .thermostat h2, .thermostat h3, .thermostat h4  {\n                      margin-top      : 3px     ; \n                      margin-bottom   : 0px     ; \n                  }\n                  .thermostat.ModeCool {\n                      background-color: blue; \n                      color: white;\n                  }\n                  .thermostat.ModeCool button {\n                      background-color: navy; \n                      color: white;\n                  }\n                  .thermostat.ModeHeat {\n                      background-color: firebrick; \n                      color: white;\n                  }\n                  .thermostat.ModeHeat button {\n                      background-color: darkred; \n                      color: white;\n                  }\n            \"\"\"\n       ]\n    |> div    \n\nlet weather (snp : CodeSnippet) =\n    let cityId        = snp.properties |> Dict.tryGetValue \"CityId\"        |> Option.defaultValue \"4711801\"\n    let openWeatherId = snp.properties |> Dict.tryGetValue \"OpenWeatherId\" |> Option.defaultValue \"1b76ef58915a2c784ce5dcb7899b81f2\"    \n    div [\n      div [ style \"height: 1em\"]\n      div [ Id \"openweathermap-widget\" ]\n      script [ src \"//openweathermap.org/themes/openweathermap/assets/vendor/owm/js/d3.min.js\" ]\n      script [ htmlText (sprintf \"window.myWidgetParam = [{id: 15,cityid: '%s',appid: '%s',units: 'imperial',containerid: 'openweathermap-widget',  }];\" cityId openWeatherId) ]\n      script [ src \"//openweathermap.org/themes/openweathermap/assets/vendor/owm/js/weather-widget-generator.js\" ]\n    ]\n \nlet readThermostatsProperties snp = \n    currentSnpO <- Some snp\n    Thermostats |> Seq.iter (readProperties snp)\n\nlet getLayout lyt snp =\n    readThermostatsProperties snp\n    snp\n    |> getButtonsLayout (\n        Seq.map (\n            function\n            | \"Thermostat\" -> ThermostatHtmls\n            | \"Weather\"    -> weather snp\n            | \"Refresh\"    -> runFableFsButton       lyt <| passNoParm \"Refresh\"\n            | b            -> evalFsCodeButtonNoParm lyt b\n        )\n    )\n\nlet processData (THMData(name, data: (string * string) [])) = \n    printfn \"Thermostats: %A %A\" name data\n    Wrap.wrap {\n        data\n        |> Array.iter (fun (cmd, dat) ->\n            let key = sprintf \"%s(%s)\" name cmd\n            getThermostat name |> Option.iter (setData cmd  dat)\n            currentSnpO        |> Option.iter (fun snp   -> snp.properties |> Dict.add key  dat)\n        )\n        return \"got it!\"\n    }    \n\nprintfn \"Thermostats registering\"\nmessaging.ProcessIncoming processData\n\n//Fable.Import.Browser.document.getElementById(\"PhoneScreen\").getAttribute(\"src\")\n ","parent":{"$":0,"Item":"875d3aa7-2adf-4857-9df0-8c7c02ec6169"},"predecessors":[{"$":0,"Item":"77ddaeb8-a657-4246-8f17-65e10712930f"},{"$":0,"Item":"de383f39-4beb-4e97-ba06-30b8b454ffb2"}],"id":{"$":0,"Item":"6972a03e-2093-495e-8c0d-bc0aa3aa9ab7"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Tests","content":"[< JavaScript >]\nmodule Tests =\n","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[],"id":{"$":0,"Item":"dd763e28-a1e1-4e69-bc18-6241efdf251d"},"expanded":false,"level":0,"levelCode":0,"properties":{}},{"name":"Equal DomRects are not comparable","content":"\n\nlet r1 = JS.Window.Document.Body.GetBoundingClientRect()\nlet r2 = JS.Window.Document.Body.GetBoundingClientRect()\n\nprintfn \"%A = %A  : %b\" (r1.ToString()) r2 (r1 = r2)","parent":{"$":0,"Item":"dd763e28-a1e1-4e69-bc18-6241efdf251d"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"3dd43e2f-5818-47c0-bf53-0c49d8d3d344"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Two CodeMirrors","content":"open Template\n\nprintfn \"XSL Tester\"\n\nlet codeA = Template.CodeMirror.New(\"A\").OnRender(fun _ -> printfn \"OnRender A\").Style(\"height: 100%\").Render\nlet codeB = Template.CodeMirror.New(\"B\").OnRender(fun _ -> printfn \"OnRender B\").Style(\"height: 100%\").Render\n\ndiv [\n    style \"height: 100vh; width: 100% \"\n    codeA\n    codeB\n] \n|> RunCode.RunNode().RunHtml\n","parent":{"$":0,"Item":"dd763e28-a1e1-4e69-bc18-6241efdf251d"},"predecessors":[{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"id":{"$":0,"Item":"e29cd12a-a20d-4d1c-8c0e-316ea26ed87e"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"inline counter","content":"\n\nlet counter =\n    let mutable i = 0\n    fun () ->\n        i <- i + 1\n        i\n    \ntype Type = {\n    a     : int\n    b     : int\n    c     : int\n    d     : int\n    count : int\n}\n  with\n    static member New(n) = {\n        a     = n\n        b     = n * 2\n        c     = n * 3\n        d     = n * 4\n        count = counter()  // <== should only be called once per invocation\n      }\n      \n    member        this.MethodN (v:bool) = { this with a = this.a * if v then 2 else 3 }\n    member inline this.MethodI (v:bool) = { this with a = this.a * if v then 2 else 3 }\n    member        this.MethodN ()       = { this with a = this.a * 10                 }\n    member inline this.MethodI ()       = { this with a = this.a * 10                 }\n\n[\n    Type.New(5).MethodN(false).MethodN(true).MethodN() |> sprintf \"not inline: %A\"    \n    Type.New(5).MethodN(false).MethodN(true).MethodN() |> sprintf \"not inline: %A\"    \n    Type.New(5).MethodI(false).MethodI(true).MethodI() |> sprintf \"inline: %A\"\n    Type.New(5).MethodI(false).MethodI(true).MethodI() |> sprintf \"inline: %A\"\n]\n|> Seq.map (htmlText >> List.singleton >> li)\n|> ul\n|> RunCode.RunNode().RunHtml\n","parent":{"$":0,"Item":"dd763e28-a1e1-4e69-bc18-6241efdf251d"},"predecessors":[{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"},{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"}],"id":{"$":0,"Item":"69b57aa2-2911-4e5e-93a4-87b38e3c8420"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"WebSocket Demo","content":"module WSServer = ","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[],"id":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableWebSharper":"0"}},{"name":"Client (and Rpc)","content":"#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net45\\Microsoft.Owin.Hosting.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net45\\Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net45\\Microsoft.Owin.StaticFiles.dll\"\n#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net45\\Microsoft.Owin.FileSystems.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net45\\WebSharper.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net45\\HttpMultipartParser.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net45\\Owin.WebSocket.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net45\\WebSharper.Owin.WebSocket.dll\"\n\nopen WebSharper.Owin.WebSocket\nopen WebSharper.Owin.WebSocket.Client\n\ntype [<JavaScript; NamedUnionCases>]\n    C2SMessage =\n    | Request1 of str: string[]\n    | Request2 of int: int   []\n\ntype [<JavaScript; NamedUnionCases \"type\">]\n    S2CMessage =\n    | [<Name \"int\"   >] Response2 of value: int\n    | [<Name \"string\">] Response1 of value: string\n\n[< JavaScript >]\nlet WebSocketClient (epWebSocket : Endpoint<S2CMessage, C2SMessage>) =\n    let output = Var.Create \"\"\n    let writen fmt = Printf.ksprintf (fun s -> output.Value <- output.Value + \"\\n\" + s) fmt\n    async {\n        do  writen \"Checking regression #4...\"\n            JQuery.AjaxSettings(Url     = \"/ws.txt\"\n                              , Method  = JQuery.RequestType.GET\n                              , Success = (fun x _ _ -> writen \"%s\" (x :?> _))\n                              , Error   = (fun _ _ e -> writen \"KO: %s.\" e)\n            )\n            |> JQuery.JQuery.Ajax\n            |> ignore\n        let! server =\n            ConnectStateful epWebSocket <| fun server -> async {\n                return 0, fun state msg -> async {\n                    match msg with\n                    | Message data ->\n                        match data with\n                        | Response1 x -> writen \"Response1 %s (state: %i)\" x state\n                        | Response2 x -> writen \"Response2 %i (state: %i)\" x state\n                        return (state + 1)\n                    | Close ->\n                        writen \"WebSocket connection closed.\"\n                        return state\n                    | Open ->\n                        writen \"WebSocket connection open.\"\n                        return state\n                    | Error ->\n                        writen \"WebSocket connection error!\"\n                        return state\n                }\n            }\n        \n        let lotsOfHellos = \"HELLO\" |> Array.create 1000\n        let lotsOf123s = 123 |> Array.create 1000\n        while true do\n            do! Async.Sleep 1000\n            server.Post (Request1 [| \"HELLO\" |])\n            do! Async.Sleep 1000\n            server.Post (Request2 lotsOf123s)\n    }\n    |> Async.Start\n    output\n\nlet invert (txt: string) : string = txt |> Seq.rev |> Seq.map string |> String.concat \"\"\n\n[< Rpc >]\nlet invertA txt = async { return invert txt }\n\n[< JavaScript >]\nlet ClientForm epWebSocket =\n    let inp    = Template.Input.New(\"Type something...\")\n    let output = WebSocketClient epWebSocket\n    div [ \n      ``class`` \"container\"    \n      Template.Bootstrap().Render\n      Template.Panel.New\n        .Title(\"Client Server Demo\")\n        .Header([])\n        .Content(\n          [ h3 [\n              inp.Render\n              htmlText inp.Var\n              htmlElement \"h2\" [ htmlText inp.Var ]\n              h1 [ htmlText <| Val.mapAsync invertA inp.Var ]\n            ]\n            htmlText output\n          ]).Render\n    ] |> renderDoc\n","parent":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"predecessors":[{"$":0,"Item":"0a11766b-f227-4b38-88a3-919d964387bf"},{"$":0,"Item":"40614ad6-3f81-468b-a4ff-034124b82ae1"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"0dabc34f-673d-4f79-ae00-3960ca196392"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Site","content":"#r @\"..\\packages\\WebSharper.UI.Next\\lib\\net40\\HtmlAgilityPack.dll\"\n#r @\"..\\packages\\WebSharper.UI.Next\\lib\\net40\\WebSharper.UI.Next.Templating.dll\"\n#r @\"..\\packages\\WebSharper.UI.Next\\lib\\net40\\WebSharper.UI.Next.Templating.Common.dll\"\n#r @\"..\\packages\\WebSharper.UI.Next\\lib\\net40\\WebSharper.UI.Next.Templating.Runtime.dll\"\n\n\nopen WebSharper.Sitelets\nopen WebSharper.UI.Next.Server\nopen WebSharper.UI.Next.Templating\n\ntype EndPoint = | [< EndPoint \"/\" >] EP\n\ntype MainTemplate = Template< @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\bin/Compiled/ClientServerDemo/website/test.html\">\n\nlet content epWebSocket (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n    MainTemplate()\n        .Title(\"Main Page\")\n        .Body( [ Html.client <@  ClientForm epWebSocket @> ])\n        .Doc()\n    |> Content.Page\n\nlet site epWebSocket = Application.MultiPage (content epWebSocket)\n\n","parent":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"predecessors":[{"$":0,"Item":"0dabc34f-673d-4f79-ae00-3960ca196392"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"92837099-e4e4-4c7f-ac52-6c922824304f"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"WebSocketServer","content":"module Server =\n    open WebSharper\n    open WebSharper.Owin.WebSocket.Server\n\n    let Start epWebSocket : StatefulAgent<S2CMessage, C2SMessage, int> =\n        /// print to debug output and stdout\n        let dprintfn x =\n            Printf.ksprintf (fun s ->\n                System.Diagnostics.Debug.WriteLine s\n                stdout.WriteLine s\n            ) x\n\n        fun client -> async {\n            let clientIp = client.Connection.Context.Request.RemoteIpAddress\n            return 0, fun state msg -> async {\n                eprintfn \"Received message #%i from %s\" state clientIp\n                match msg with\n                | Message data -> \n                    match data with\n                    | Request1 x -> do! client.PostAsync (Response1 x.[0])\n                    | Request2 x -> do! client.PostAsync (Response2 x.[0])\n                    return state + 1\n                | Error exn -> \n                    dprintfn \"Error in WebSocket server connected to %s: %s\" clientIp exn.Message\n                    do! client.PostAsync (Response1 (\"Error: \" + exn.Message))\n                    return state\n                | Close ->\n                    eprintfn \"Closed connection to %s\" clientIp\n                    return state\n            }\n        }\n\n","parent":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"predecessors":[{"$":0,"Item":"0dabc34f-673d-4f79-ae00-3960ca196392"}],"id":{"$":0,"Item":"c93a7f5a-cf6f-4789-9998-47ee7b99bbb6"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"ClientServerDemo","content":"#r @\"..\\packages\\Owin.Compression\\lib\\net452\\Owin.Compression.dll\"\n\nopen global.Owin\nopen Microsoft.Owin.Hosting\nopen Microsoft.Owin.StaticFiles\nopen Microsoft.Owin.FileSystems\nopen WebSharper.Owin\nopen WebSharper.Owin.WebSocket\n\n[< EntryPoint >]\nlet Main args =\n    let rootDirectory, url =\n        match args with\n        | [| rootDirectory; url |] -> rootDirectory, url\n        | [| url                |] -> \"website\"    , url\n        | [|                    |] -> \"website\"    , \"http://localhost:9033/\"\n        | _ -> eprintfn \"Usage: WebServer3 ROOT_DIRECTORY URL\"; exit 1\n    let epWebSocket = Endpoint.Create(url, \"/ws\", JsonEncoding.Readable)\n    //printfn \"Starting, hit <Enter>...\" ; stdin.ReadLine() |> ignore\n    use server = \n        WebApp.Start(url, fun appB ->\n            appB.UseWebSharper(WebSharperOptions(ServerRootDirectory = rootDirectory\n                                               , Sitelet             = Some (site epWebSocket)\n                                               , BinDirectory        = \".\"\n                                               , Debug               = true))\n                .UseWebSocket(  epWebSocket, Server.Start epWebSocket)\n                .UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(rootDirectory)))\n                .UseCompressionModule()\n            |> ignore\n            let listener = appB.Properties.[\"Microsoft.Owin.Host.HttpListener.OwinHttpListener\"] |> unbox<Microsoft.Owin.Host.HttpListener.OwinHttpListener>\n            listener.SetRequestProcessingLimits(1000, 1000)\n            let maxA = ref 0\n            let maxB = ref 0\n            listener.GetRequestProcessingLimits(maxA, maxB)\n            printfn \"Accepts: %d Requests:%d\" !maxA !maxB\n        )\n    stdout.WriteLine(\"Serving {0}\", url)\n    stdin.ReadLine() |> ignore\n    0\n    ","parent":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"predecessors":[{"$":0,"Item":"c93a7f5a-cf6f-4789-9998-47ee7b99bbb6"},{"$":0,"Item":"92837099-e4e4-4c7f-ac52-6c922824304f"}],"id":{"$":0,"Item":"7e36bd56-d4fa-4509-bece-b4444df38c5c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"compile & run ClientServerDemo","content":"open System.IO\nopen WSMessagingBroker\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.CompOptionsModule\nopen RunProcess\n\nWrap.wrapper {\n    let  options      = compileOptionsExeDebug \"FSSGlobal/WebSharper Code/WebSocket Demo/ClientServerDemo\"\n                        + siteOptions + (opGenInternal /= \"showoptions\")\n    let  exeFile      = options?Output\n    let  site         = Path.GetFullPath(options?Website)\n    let! res          = FStationMessaging(\"Compile WebSharper\", FSharp).CompileSnippetW options\n    do   printfn        \"Starting %s\"     exeFile\n    let  url          = @\"http://localhost:9005/\"\n    let  parms        = sprintf \"%A %A\" site url \n    do   startProcess   exeFile parms |> ignore\n    do   startProcess   url     \"\"    |> ignore\n    return res\n} |> Wrap.runSynchronouslyS true |> printfn \"%s\"\n","parent":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"predecessors":[{"$":0,"Item":"d9c4540a-85f5-4c62-91be-fcb2d60e9f17"}],"id":{"$":0,"Item":"c8c93861-321c-4d73-beb0-2fef0052bc7b"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableFSI":"0"}},{"name":"WebSocket demo Not Working","content":"","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[],"id":{"$":0,"Item":"e5253dd2-c887-4822-887b-ab249aeae88a"},"expanded":false,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"\nmodule WebSocket =\n    open Microsoft.Practices.ServiceLocation\n    open global.Owin\n    open Owin.WebSocket\n    open Owin.WebSocket.Extensions\n\n    module private Async =\n        let AwaitUnitTask (tsk : System.Threading.Tasks.Task) =\n            tsk.ContinueWith(ignore) |> Async.AwaitTask\n\n    [<JavaScript>]\n    type Endpoint<'T> =\n        private {\n            URI : string\n        }\n\n    type Endpoint =\n        static member FromUri (uri : string) =\n            { URI = uri }\n\n    module MessageCoder =\n        module J = WebSharper.Core.Json\n\n        let ToJString (jP: J.Provider) (msg: 'T) =\n            let enc = jP.GetEncoder<'T>()\n            enc.Encode msg\n            |> jP.Pack\n            |> J.Stringify\n\n        let FromJString (jP: J.Provider) str : 'T =\n            let dec = jP.GetDecoder<'T>()\n            J.Parse str\n            |> dec.Decode\n\n    type private InternalMessage<'T> =\n        | Message of WebSocketConnection * 'T\n        | Error of WebSocketConnection * exn\n        | Close of WebSocketConnection\n        | Open of WebSocketConnection\n\n    type Action<'T> =\n        | Message of 'T\n        | Close\n    \n    [<ReferenceEquality>]\n    type WebSocketClient<'T> =\n        {\n            Conn           : WebSocketConnection\n            ReplyChan      : AsyncReplyChannel<Action<'T>>\n        }\n\n    let private mkWSClient conn rc = { Conn = conn; ReplyChan = rc }\n\n    [<JavaScript>]\n    type Message<'T> =\n        | Message of 'T\n        | Error of exn\n        | Open of MailboxProcessor<Action<'T>>\n        | Close\n\n    [<JavaScript>]\n    module Client =\n        open WebSharper.JavaScript\n\n        let private processResponse (sock : WebSocket) msg =\n            async {\n//                while sock.ReadyState <> WebSocketReadyState.Open do\n//                    do! Async.Sleep 10\n                let! msg = msg\n                match msg with\n                | Action.Message (value : 'T) ->\n                    value \n                    |> Json.Stringify\n                    |> sock.Send\n                | Action.Close -> sock.Close ()\n            }\n\n        type private State =\n            | Open\n            | Closed\n\n        type private ServerStatus<'T> =\n            {\n                State : State\n                Queue : Action<'T> list\n            }\n\n        type private ServerMessage<'T> =\n            | Open\n            | Close\n            | Message of Action<'T>\n\n        let ConnectTo (endpoint : Endpoint<'T>) \n            (agent : MailboxProcessor<Message<'T> * AsyncReplyChannel<Action<'T>>>) =\n\n            let socket = new WebSocket(endpoint.URI)\n\n            let proc (msg : Message<'T>) =\n                agent.PostAndAsyncReply (fun chan -> msg, chan)\n                |> processResponse socket\n                |> Async.Start\n\n            let internalServer =\n                MailboxProcessor.Start <| fun inbox ->\n                    let rec loop (st : ServerStatus<'T>) : Async<unit> =\n                        async {\n                            let! msg = inbox.Receive ()\n                            match msg with\n                            | Open ->\n                                for a in st.Queue do\n                                    do! processResponse socket <| async.Return a\n                                return! loop { State = State.Open; Queue = [] }\n                            | Close ->\n                                return! loop { st with State = State.Closed }\n                            | Message msg ->\n                                match st.State with\n                                | State.Open -> \n                                    do! processResponse socket (async.Return msg)\n                                    return! loop st\n                                | State.Closed ->\n                                    return! loop { st with Queue = msg :: st.Queue }\n                        }\n                    loop { State = State.Closed; Queue = [] }\n\n            let server = MailboxProcessor.Start <| fun inbox ->\n                let rec loop () : Async<unit> =\n                    async {\n                        let! msg = inbox.Receive ()\n                        internalServer.Post <| ServerMessage.Message msg\n                        return! loop ()\n                    }\n                loop ()\n\n            socket.Onopen <- fun () -> \n                internalServer.Post Open\n                proc <| Message.Open server\n            socket.Onclose <- fun () -> \n                internalServer.Post Close\n                proc <| Message.Close\n            socket.Onmessage <- fun msg -> \n                As<string> msg.Data |> Json.Parse |> Json.Activate |> Message.Message |> proc\n            socket.Onerror <- fun () -> System.Exception \"error\" |> Message.Error |> proc\n\n            server\n\n    type private WebSocketProcessor<'T>\n        (agent : MailboxProcessor<WebSocketClient<'T> option * Message<'T>>,\n         jP: Core.Json.Provider) =\n\n        let processResponse (sock : WebSocketConnection) msg =\n            async {\n                let! msg = msg\n                match msg with\n                | Action.Message value ->\n                    let msg = MessageCoder.ToJString jP value\n                    let bytes = System.Text.Encoding.UTF8.GetBytes(msg)\n                    do! sock.SendText(bytes, true) |> Async.AwaitUnitTask\n                | Action.Close -> \n                    do! sock.Close (System.Net.WebSockets.WebSocketCloseStatus.NormalClosure,\n                                        \"Client requested.\") |> Async.AwaitUnitTask\n            }\n\n        let newClientProcessor (sock : WebSocketConnection) = \n            MailboxProcessor.Start <| fun inbox ->\n                let rec loop () = async {\n                    do! processResponse sock <| inbox.Receive()\n                    return! loop ()\n                }\n                loop ()\n        \n        let mailbox = \n            MailboxProcessor.Start <| fun inbox ->\n                async {\n                    while true do\n                        let! (msg, replyChan) = inbox.Receive()\n                        let conn, imsg =\n                            match msg with\n                            | InternalMessage.Open socket -> socket, Message.Open <| newClientProcessor socket\n                            | InternalMessage.Close soscket -> soscket, Message.Close\n                            | InternalMessage.Message (socket, msg) -> socket, Message.Message msg\n                            | InternalMessage.Error (socket, ex) -> socket, Message.Error ex\n                        agent.Post <| (Some <| mkWSClient conn replyChan, imsg) \n                }   \n                \n        member this.Mailbox = mailbox\n        member this.ProcessResponse socket msg = processResponse socket msg\n        member this.JsonProvider = jP\n\n    type private ProcessWebSocketonnection<'T>\n        (processor : WebSocketProcessor<'T>) =\n\n        inherit WebSocketConnection()\n\n        let proc socket msg =\n            processor.Mailbox.PostAndAsyncReply (fun chan -> msg, chan)\n            |> processor.ProcessResponse socket\n            |> Async.Start\n\n        override x.OnClose(status, desc) =\n            proc x <| InternalMessage.Close x\n\n        override x.OnOpen() =\n            proc x <| InternalMessage.Open x\n\n        override x.OnMessageReceived(message, typ) =\n            async {\n                let json = System.Text.Encoding.UTF8.GetString(message.Array)\n                let m = MessageCoder.FromJString processor.JsonProvider json\n                proc x <| InternalMessage.Message (x, m)\n            }\n            |> Async.StartAsTask :> _\n\n        override x.OnReceiveError(ex) = \n            proc x <| InternalMessage.Error (x, ex)\n\n    type private WebSocketServiceLocator<'T>(processor : WebSocketProcessor<'T>) =\n        interface IServiceLocator with\n\n            member x.GetService(typ) =\n                raise <| System.NotImplementedException()\n\n            member x.GetInstance(t : System.Type) =\n                let ctor = t.GetConstructor([| processor.GetType() |])\n                ctor.Invoke([| processor |])\n\n            member x.GetInstance(t, key) =\n                raise <| System.NotImplementedException()\n\n            member x.GetInstance<'TService>() =\n                let t = typeof<'TService>\n                let ctor = t.GetConstructor([| processor.GetType() |])\n                ctor.Invoke([| processor |]) :?> 'TService\n\n            member x.GetInstance<'TService>(key : string) : 'TService =\n                raise <| System.NotImplementedException()\n\n            member x.GetAllInstances(t) =\n                raise <| System.NotImplementedException()\n\n            member x.GetAllInstances<'TService>() : System.Collections.Generic.IEnumerable<'TService> =\n                raise <| System.NotImplementedException()\n\n    let GetWebSocketEndPoint (url : string) (route : string) =\n        let uri = System.Uri(System.Uri(url), route)\n        let wsuri = sprintf \"ws://%s%s\" uri.Authority uri.AbsolutePath\n        Endpoint.FromUri<'T> wsuri\n    \n    let StartWebSocketServer (route : string) (builder : IAppBuilder) (json: Core.Json.Provider)\n        (agent : MailboxProcessor<WebSocketClient<'T> option * Message<'T>>) =\n\n        let processor = WebSocketProcessor(agent, json)\n\n        builder.MapWebSocketRoute<ProcessWebSocketonnection<'T>>(route, WebSocketServiceLocator<'T>(processor))\n\n\n","parent":{"$":0,"Item":"e5253dd2-c887-4822-887b-ab249aeae88a"},"predecessors":[],"id":{"$":0,"Item":"e82e9f07-e611-4496-8247-03f03be16906"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Server","content":"\nmodule Server =\n    open WebSharper.WebSockets.WebSocket\n\n    type Message =\n        | Request of string\n        | Response of string\n\n    let Server route json builder =\n        let wrtln (x : string) = System.Diagnostics.Debug.WriteLine x\n\n        let proc = MailboxProcessor.Start(fun inbox ->\n            async {\n                while true do\n                    let! (cl, msg) = inbox.Receive ()\n                    let a = msg.ToString ()\n                    match (msg, cl) with\n                    | Message data, Some cl -> \n                        match data with\n                        | Request x ->\n                            cl.ReplyChan.Reply <| Action.Message (Response x)\n                        | _ -> ()\n                    | Message data, _ -> \n                        ()\n                    | Error exn, _ -> \n                        wrtln <| sprintf \"Panic! %s\" exn.Message\n                    | Open a, _ -> ()\n                    | Close, _ -> ()\n                    | _ -> ()\n            }\n        )\n\n        StartWebSocketServer route builder json proc\n\n","parent":{"$":0,"Item":"e5253dd2-c887-4822-887b-ab249aeae88a"},"predecessors":[],"id":{"$":0,"Item":"3336735a-2788-46aa-bcda-0ee282cd2d24"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Client","content":"\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Html.Client\nopen WebSharper.WebSockets.WebSocket\n\n[<JavaScript>]\nmodule Client =\n\n    let WS (endpoint : Endpoint<Server.Message>) =\n\n        let server =\n            Client.ConnectTo endpoint <| MailboxProcessor.Start(fun inbox ->\n                let rec loop () : Async<unit> =\n                    async {\n                        let! (msg, rc) = inbox.Receive ()\n                        match msg with\n                        | Message data ->\n                            match data with\n                            | Server.Response x -> Console.Log x\n                            | _ -> ()\n                        | Close -> \n                            Console.Log \"Connection closed.\"\n                        | Open server ->\n                            Console.Log \"WebSocket conenction open.\"\n                        | Error ex ->\n                            Console.Log ex.Message\n                        return! loop ()\n                    }\n                loop ()\n            )\n\n        async {\n            while true do\n                do! Async.Sleep 1000\n                server.Post <| Action.Message (Server.Request \"HELLO\")\n        }\n        |> Async.Start\n\n        Text \"\"","parent":{"$":0,"Item":"e5253dd2-c887-4822-887b-ab249aeae88a"},"predecessors":[],"id":{"$":0,"Item":"6673999d-4406-4484-aea4-a28158084671"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Main","content":"#r @\"Owin.dll\"\n#r @\"Microsoft.Owin.dll\"\n#r @\"Microsoft.Owin.Hosting.dll\"\n#r @\"Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"Microsoft.Owin.StaticFiles.dll\"\n#r @\"Microsoft.Owin.FileSystems.dll\"\n#r @\"WebSharper.Owin.dll\"\n#r @\"HttpMultipartParser.dll\"\n#r @\"WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\Zafir.Owin.WebSocket\\lib\\net45\\WebSharper.Owin.WebSocket.dll\"\n\nopen WebSharper.Html.Server\nopen WebSharper\nopen WebSharper.Sitelets\n\ntype Action =\n    | Home\n\nmodule Skin =\n    open System.Web\n\n    type Page =\n        {\n            Title : string\n            Body : list<Element>\n        }\n\n    let MainTemplate =\n        Content.Template<Page>(\"~/Main.html\")\n            .With(\"title\", fun x -> x.Title)\n            .With(\"body\", fun x -> x.Body)\n\n    let WithTemplate title body : Content<Action> =\n        Content.WithTemplate MainTemplate <| fun context ->\n            {\n                Title = title\n                Body = body context\n            }\n\nmodule Site =\n\n    let ( => ) text url =\n        A [HRef url] -< [Text text]\n\n    let Links (ctx: Context<Action>) =\n        UL [\n            LI [\"Home\" => ctx.Link Home]\n        ]\n\n    let HomePage ep =\n        Skin.WithTemplate \"HomePage\" <| fun ctx ->\n            [\n                Div [Text \"HOME\"]\n                Div [ClientSide <@ Client.WS ep @>]\n                Links ctx\n            ]\n\n    let MainSitelet ep =\n        Sitelet.Sum [\n            Sitelet.Content \"/\" Home (HomePage ep)\n        ]\n\nmodule SelfHostedServer =\n\n    open global.Owin\n    open Microsoft.Owin.Hosting\n    open Microsoft.Owin.StaticFiles\n    open Microsoft.Owin.FileSystems\n    open WebSharper.Owin\n    open WebSharper.Owin.WebSocket\n\n    [<EntryPoint>]\n    let Main args =\n        match args with\n        | [| rootDirectory; url |] ->\n            use server = WebApp.Start(url, fun appB ->\n                let ep = WebSocket.GetWebSocketEndPoint  url \"/ws\"\n                let options = Options.Create(rootDirectory)\n                appB.UseStaticFiles(\n                        StaticFileOptions(\n                            FileSystem = PhysicalFileSystem(rootDirectory)))\n                    .UseSitelet(rootDirectory, Site.MainSitelet ep)\n                |> Server.Server \"/ws\" options.Json)\n            stdout.WriteLine(\"Serving {0}\", url)\n            stdin.ReadLine() |> ignore\n            0\n        | _ ->\n            eprintfn \"Usage: WebSharper.WebSockets.Owin.Test ROOT_DIRECTORY URL\"\n            1","parent":{"$":0,"Item":"e5253dd2-c887-4822-887b-ab249aeae88a"},"predecessors":[{"$":0,"Item":"e82e9f07-e611-4496-8247-03f03be16906"},{"$":0,"Item":"3336735a-2788-46aa-bcda-0ee282cd2d24"},{"$":0,"Item":"6673999d-4406-4484-aea4-a28158084671"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"5f55d127-2a8c-4b4b-8121-bf8e56e15b3c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Simple Client-Server","content":"module WSServer = ","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[],"id":{"$":0,"Item":"83d96c6d-a55e-4975-8d93-06a0fe00f01a"},"expanded":false,"level":0,"levelCode":0,"properties":{}},{"name":"SimpleClientServer","content":"#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net45\\Microsoft.Owin.Hosting.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net45\\Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net45\\Microsoft.Owin.StaticFiles.dll\"\n#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net45\\Microsoft.Owin.FileSystems.dll\"\n\nopen WebSharper.Sitelets\nopen WebSharper.UI.Html\n\n[< JavaScript >]\nmodule Client =\n    let mailbox = MailboxProcessor.Start(fun mail -> async {\n        while true do\n            let! m = mail.Receive()\n            printfn \"%s\" m\n    })\n    \n    let value = Var.Create \"Hello World!\"\n    let form () =\n        div [] [ \n            h3 [] [\n                text \"Type something: \"\n                Doc.Input [] value\n            ] \n            h2 [] [ textView value.View ]\n        ]\n\nopen WebSharper.UI.Server\n\ntype EndPoint = | [< EndPoint \"/\" >] EP\n\nlet content (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n    Content.Page(Title = \"Main Page\" , Body  = [ Html.client <@  Client.form () @> ])\n\nopen global.Owin\nopen Microsoft.Owin.Hosting\nopen WebSharper.Owin\nopen Microsoft.Owin.StaticFiles\nopen Microsoft.Owin.FileSystems\n\n[< EntryPoint >]\nlet Main args =\n    use server = \n        WebApp.Start(\"http://localhost:9033/\", fun appB ->\n            appB.UseWebSharper(WebSharperOptions(ServerRootDirectory = \"website\"\n                                               , Sitelet             = Some (Application.MultiPage content)\n                                               , BinDirectory        = \".\"\n                                               , Debug               = true))\n                .UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(\"website\")))\n            |> ignore\n        )\n    stdout.WriteLine(\"Starting, hit enter to finish\")\n    stdin.ReadLine() |> ignore\n    0\n","parent":{"$":0,"Item":"83d96c6d-a55e-4975-8d93-06a0fe00f01a"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"3d2a9b7f-889c-4826-b539-6de57ee5f573"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"compile & run Simple Client-Server","content":"open System.IO\nopen WSMessagingBroker\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.CompOptionsModule\nopen RunProcess\n\nWrap.wrapper {\n    let  options         = compileOptionsExeDebug \"FSSGlobal/WebSharper Code/Simple Client-Server/SimpleClientServer\"\n                           + siteOptions + (opGenInternal /= \"showoptions\")\n    let  exeFile         = options?OutputFile\n    let  workDir         = options?Directory\n    let  site            = Path.GetFullPath(options?Website)\n    let! res             = FStationMessaging(\"Compile WebSharper\", FSharp).CompileSnippetW options\n    do   printfn           \"Starting %s\"     exeFile\n    let  url             = @\"http://localhost:9033/\"\n    let  parms           = sprintf \"%A %A\" site url \n    do   startProcessDir   exeFile parms workDir |> ignore\n    do   startProcess      url     \"\"            |> ignore\n    return res\n} |> Wrap.runSynchronouslyS true |> printfn \"%s\"\n","parent":{"$":0,"Item":"83d96c6d-a55e-4975-8d93-06a0fe00f01a"},"predecessors":[{"$":0,"Item":"d9c4540a-85f5-4c62-91be-fcb2d60e9f17"}],"id":{"$":0,"Item":"dcc7ed8b-2697-4558-9bef-159e39fd3361"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableFSI":"0"}},{"name":"Calculation Editor Code","content":"#if WEBSHARPER\n[< JavaScript >]\n#endif\nmodule CalcEditor = ","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[],"id":{"$":0,"Item":"be49e291-252c-4064-a3d6-bc61b39895fa"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableWebSharper":"1"}},{"name":"FSAutoCompleteInterfase","content":"module FSAutoCompleteInterfase =\n    type ResponseError =\n        {\n          Code: int\n          Message: string\n          //AdditionalData: 'T\n        }\n    type Location =\n      {\n        File: string\n        Line: int\n        Column: int\n      }\n    type CompletionResponse =\n      {\n        Name: string\n        ReplacementText: string\n        Glyph: string\n        GlyphChar: string\n      }\n    //type ProjectResponse =\n    //  {\n    //    Project: ProjectFilePath\n    //    Files: List<SourceFilePath>\n    //    Output: string\n    //    References: List<ProjectFilePath>\n    //    Logs: Map<string, string>\n    //  }\n    type OverloadDescription =\n      {\n        Signature: string\n        Comment: string\n      }\n    type OverloadParameter =\n      {\n        Name : string\n        CanonicalTypeTextForSorting : string\n        Display : string\n        Description : string\n      }\n    type Overload =\n      {\n        Tip : OverloadDescription list list\n        TypeText : string\n        Parameters : OverloadParameter list\n        IsStaticArguments : bool\n      }\n    type Parameter = {\n        Name : string\n        Type : string\n      }\n    type SignatureData = {\n        OutputType : string\n        Parameters : Parameter list list\n      }\n    type MethodResponse =\n      {\n        Name : string\n        CurrentParameter : int\n        Overloads : Overload list\n      }\n    type SymbolUseRange =\n      {\n        FileName: string\n        StartLine: int\n        StartColumn: int\n        EndLine: int\n        EndColumn: int\n        IsFromDefinition: bool\n        IsFromAttribute : bool\n        IsFromComputationExpression : bool\n        IsFromDispatchSlotImplementation : bool\n        IsFromPattern : bool\n        IsFromType : bool\n      }\n    type SymbolUseResponse =\n      {\n        Name: string\n        Uses: SymbolUseRange list\n      }\n    type HelpTextResponse =\n      {\n        Name: string\n        Overloads: OverloadDescription list list\n      }\n    type CompilerLocationResponse =\n      {\n        Fsc: string\n        Fsi: string\n        MSBuild: string\n      }\n    type FSharpErrorInfo =\n      {\n        FileName: string\n        StartLine:int\n        EndLine:int\n        StartColumn:int\n        EndColumn:int\n       // Severity:FSharpErrorSeverity\n        Message:string\n        Subcategory:string\n      }\n    type ErrorResponse =\n      {\n        File: string\n        Errors: FSharpErrorInfo []\n      }\n    type Colorization =\n      {\n    //    Range: Range\n        Kind: string\n      }\n    type Declaration =\n      {\n        UniqueName: string\n        Name: string\n        Glyph: string\n        GlyphChar: string\n        IsTopLevel: bool\n    //  Range     : Utils.Range\n    //    BodyRange : Utils.Range\n        File : string\n        EnclosingEntity: string\n        IsAbstract: bool\n      }\n    type DeclarationResponse = {\n        Declaration : Declaration;\n        Nested : Declaration []\n    }\n    type OpenNamespace = {\n      Namespace : string\n      Name : string\n      Type : string\n      Line : int\n      Column : int\n      MultipleNames : bool\n    }\n    type QualifySymbol = {\n      Name : string\n      Qualifier : string\n    }\n    type ResolveNamespaceResponse = {\n      Opens : OpenNamespace []\n      Qualifies: QualifySymbol []\n      Word : string\n    }\n    type UnionCaseResponse = {\n      Text : string\n    //  Position : Pos\n    }\n    type Kind = \n    | KInfo             of string\n    | KError            of ResponseError\n    | KHelpText         of HelpTextResponse\n    | KCompletion       of CompletionResponse  []\n    | KSymbolUse        of SymbolUseResponse\n    | KHelp             of string\n    | KMethod           of MethodResponse\n    | KErrors           of ErrorResponse\n    | KColorizations    of Colorization list\n    | KFindDecl         of Location\n    | KDeclarations     of DeclarationResponse []\n    | KToolTip          of OverloadDescription [][]\n    | KTypeSig          of string\n    | KSignatureData    of SignatureData\n    | KCompilerLocation of CompilerLocationResponse\n    | KNamespaces       of ResolveNamespaceResponse\n    | KUnionCase        of UnionCaseResponse\n    | KMultiple         of Kind                []\n\n    type ParseRequest         = { FileName  : string ; IsAsync    : bool   ; Lines : string[]           ; Version : int                                            }\n    type DeclarationsRequest  = { FileName  : string ;                       Lines : string[]           ; Version : int                                            }\n    type CompletionRequest    = { FileName  : string ; SourceLine : string ; Line  : int                ; Column  : int ; Filter : string; IncludeKeywords : bool  }\n    type PositionRequest      = { FileName  : string ;                       Line  : int                ; Column  : int ; Filter : string                          }\n    type ProjectRequest       = { FileName  : string                                                                                                               }\n    type LintRequest          = { FileName  : string                                                                                                               }\n    type HelptextRequest      = { Symbol    : string                                                                                                               }\n    type WorkspacePeekRequest = { Directory : string ; Deep       : int    ; ExcludedDirs : string []                                                              }\n    \n    type FARequest =\n        | FarParse         of ParseRequest         \n        | FarTooltip       of PositionRequest      \n        | FarDeclaration   of PositionRequest  \n        | FarCompletion    of CompletionRequest    \n\n    let requestJson req =\n        match req with \n        | FarParse         data -> Json.Serialize data\n        | FarTooltip       data -> Json.Serialize data \n        | FarDeclaration   data -> Json.Serialize data \n        | FarCompletion    data -> Json.Serialize data \n\n    let requestCommand req =\n        match req with \n        | FarParse         _    -> \"parse\"\n        | FarTooltip       _    -> \"tooltip\"\n        | FarDeclaration   _    -> \"signatureData\"\n        | FarCompletion    _    -> \"completion\"\n\n    let UrlAddress = \"http://localhost:9001/\"\n\n    let ajaxCall url m (data:string) =\n        let ajaxInvoke (ok, ko, _) =\n            let success (result:obj)         _ _ = result :?> string                   |> ok\n            let error   (jqXHR:JQuery.JqXHR) _ _ = System.Exception jqXHR.ResponseText |> ko\n            let ajaxSettings : JQuery.AjaxSettings =\n                JQuery.AjaxSettings(\n                    Url         = url\n                  , Type        = m\n                  , ContentType = Union2Of2 \"application/json\" \n                  , DataType    = JQuery.DataType.Text\n                  , Success     = System.Action<_,_,_> success\n                  , Error       = System.Action<_,_,_> error\n                  , Data        = data\n                  , Timeout     = 300_000.0\n                )\n            JQuery.JQuery.Ajax ajaxSettings |> ignore\n        Async.FromContinuations ajaxInvoke\n\n    let HttpRequestCall (url:string) (data:string) =\n        async {\n            let! resp = ajaxCall url JQuery.RequestType.POST data           \n//            req.ProtocolVersion <- HttpVersion.Version10\n            return       resp\n        }\n    \n    let KindError msg = KError { Code = 0 ; Message = msg }\n    \n    let json2Kind (v:JsonValue) = \n        let item =JsonValue.Parse <| v.AsString()\n        match item?Kind.AsString() with\n        | \"info\"             -> jsonData2Obj item |> KInfo\n        | \"error\"            -> jsonData2Obj item |> KError\n        | \"errors\"           -> jsonData2Obj item |> KErrors\n        | \"tooltip\"          -> jsonData2Obj item |> KToolTip\n        | \"typesig\"          -> jsonData2Obj item |> KTypeSig\n        | \"completion\"       -> jsonData2Obj item |> KCompletion\n        | \"signatureData\"    -> jsonData2Obj item |> KSignatureData\n        | \"finddecl\"         -> jsonData2Obj item |> KFindDecl\n        | \"compilerlocation\" -> jsonData2Obj item |> KCompilerLocation\n        | _                  -> KindError <| v.ToString()\n    \n    let FSAutocompleteCall cmd f (req: FARequest) =\n        Wrap.wrapper {\n            let  data         = req.Json\n            let! jsonV        = HttpRequestCall (UrlAddress + cmd) data\n            let  several      = jsonV.AsArray() |> Array.map json2Kind\n            let  good, others = several |> Array.partition f\n            let  msgs         = others  |> Seq.map (fun v -> (v.ToString(), match v with | KInfo _ -> true | _ -> false) |> ErrSimple :> ErrMsg) |> Seq.toArray\n            let! result       = Result (Seq.tryHead good, msgs) \n            return result\n        } \n        ","parent":{"$":0,"Item":"be49e291-252c-4064-a3d6-bc61b39895fa"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"c68a9ed7-9d5c-4d86-a7fd-79ba996d56be"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"calculations","content":"open Useful\nopen Template\n\nmodule ListModel =\n    let lensInto' (m:ListModel<_,_>) (get: 'T       -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) (view: View<'V>) : Var<'V> =\n        let id = Var.freshId()\n        { new Var<'V>() with\n            member r.Get         () = m.FindByKey key |> get\n            member r.Set         v  = m.UpdateBy (fun i -> v          |>             update i |> Some) key\n            member r.Update      f  = m.UpdateBy (fun i -> get i |> f |>             update i |> Some) key\n            member r.UpdateMaybe f  = m.UpdateBy (fun i -> get i |> f |> Option.map (update i)       ) key\n            member r.SetFinal    v  = r.Set v\n            member r.View           = view\n            member r.Id             = id\n        }\n    let lensIntoO'(m: ListModel<_,_>) (get: 'T option -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) (view: View<'V>) : Var<'V> =\n        let id = Var.freshId()\n        { new Var<'V>() with\n            member r.Get         () = m.TryFindByKey key |> get\n            member r.Set         v  = m.UpdateBy (fun i -> v                  |>             update i |> Some) key\n            member r.Update      f  = m.UpdateBy (fun i -> Some i |> get |> f |>             update i |> Some) key\n            member r.UpdateMaybe f  = m.UpdateBy (fun i -> Some i |> get |> f |> Option.map (update i)       ) key\n            member r.SetFinal    v  = r.Set v\n            member r.View           = view\n            member r.Id             = id\n        }\n    let docLensMapView      mapView (f: 'Key -> Var<'T> -> 'V) (m:ListModel<_,_>) =\n        let get k v = f k (lensInto' m   id                        (fun _ -> id) k v)\n        Doc.BindSeqCachedViewBy m.Key get (View.Map mapView m.View)\n    let docLensMapViewO def mapView (f: 'Key -> Var<'T> -> 'V) (m:ListModel<_,_>) =\n        let get k v = f k (lensIntoO' m (Option.defaultValue def)  (fun _ -> id) k v)\n        Doc.BindSeqCachedViewBy m.Key get (View.Map mapView m.View)\n    let lensDef def k (m:ListModel<_,_>) =\n        let get = Option.defaultValue def\n        lensIntoO' m get (fun _ -> id) k (m.TryFindByKeyAsView k |> View.Map get)\n\nlet trueV = Val.Constant true\n\n[< Inline >]\nlet getItemIRefO (listm:ListModel<'K,'T>) get upd kO =\n    kO\n    |> Option.bind (fun    k -> \n        listm.TryFindByKey k\n        |> Option.map(fun _ -> listm.LensInto get upd k)\n    )\n\n//[< Inline >]\n//let lensInto<'K, 'T, 'F> (def:'F) (find:'K -> 'T option) lens (k:'K) =        \n//    match find k with\n//    | Some _ -> lens k\n//    | None   -> (Var.Create ()).Lens   (fun _ -> def) (fun u _ -> u)\n\n//[< Inline >]\n//let getItemIRef def (listm:ListModel<'K,'T>) get upd k = lensInto<'K,'T,'F> def listm.TryFindByKey (listm.LensInto get upd) k\n\ntype TypeCalc = Input | Calc\n    with override this.ToString() = sprintf \"%A\" this\n\ntype CalcId   = CalcId of System.Guid\n    with member this.Guid = match this with CalcId gid -> gid\n\n[< NamedUnionCases \"type\" >]\ntype Calculation = {\n    id        : CalcId\n    name      : string\n    typeC     : TypeCalc\n    order     : string\n    isText    : bool\n    isBalance : bool\n    format    : string\n}\n\nlet newCalculation() = {\n    id        = CalcId <| System.Guid.NewGuid()\n    name      = \"\"\n    typeC     = Input\n    order     = \"\"\n    isText    = false\n    isBalance = false\n    format    = \"0,000\"\n}\n\ntype TotId   = TotId of System.Guid\n    with member this.Guid = match this with TotId gid -> gid\n\ntype Weight =\n| Zero\n| Add\n| Subtract\n\ntype Child =\n    | Leaf of CalcId\n    | Node of TotId\n\nand  Total = {\n    id        : TotId\n    totName   : string\n    order     : string\n    format    : string\n    children  : Map<Child, Weight>\n}\n\nlet newTotal() = {\n    id        = TotId <| System.Guid.NewGuid()\n    totName   = \"\"\n    order     = \"\"\n    format    = \"0,000\"\n    children  = Map Seq.empty\n}\n\n","parent":{"$":0,"Item":"be49e291-252c-4064-a3d6-bc61b39895fa"},"predecessors":[{"$":0,"Item":"a21525b8-a16c-4e98-b05e-8eef61ff4539"},{"$":0,"Item":"7a655466-e218-4121-a7b6-f9c70a922e07"},{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"}],"id":{"$":0,"Item":"ecccc1a6-726e-438a-8804-16063c8a5107"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"formulas, dimensions","content":"type TypeForm = Base | Consolidated | All\n    with override this.ToString() = sprintf \"%A\" this\n\ntype FormId   = FormId of System.Guid\n    with member this.Guid = match this with FormId gid -> gid\n\n[< NamedUnionCases \"type\" >]\ntype Formula   = {\n    id         : FormId\n    idCalc     : CalcId\n    formula    : string\n    typeF      : TypeForm\n    order      : string\n    alsoActual : bool\n} \n \nlet newFormula idCalc = {\n    id         = FormId <| System.Guid.NewGuid()\n    idCalc     = idCalc\n    formula    = \"\"\n    typeF      = Base\n    order      = \"\"\n    alsoActual = false\n} \n \ntype DimId     = DimId  of System.Guid\n    with member this.Guid = match this with DimId gid -> gid\n\n[< NamedUnionCases \"type\" >]\ntype DimType =\n    | DtDataType\n    | DtTime\n    | DtVersion\n    | DtTCalc\n    | DtCalc\n    | DtMeasure\n    | DtOther\n    with override this.ToString() = (sprintf \"%A\" this).[2..]\n\n[< NamedUnionCases \"type\" >]\ntype Dimension = {\n    id            : DimId\n    dimension     : string\n    abbreviation  : string\n    order         : string\n    excludeCube   : bool\n    includeFreeze : bool\n    dimType       : DimType\n}\n\nlet newDimension() = {\n    id            = DimId <| System.Guid.NewGuid()\n    dimension     =  \"\"   \n    abbreviation  =  \"\"   \n    order         =  \"\"   \n    excludeCube   =  false\n    includeFreeze =  false    \n    dimType       =  DtOther\n}\n\n[< NamedUnionCases \"type\" >]\ntype Destination = {\n    idForm       : FormId\n    idDim        : DimId\n    destination  : string\n}\n\nlet getDstKey d = d.idForm, d.idDim\n\nlet newDestination fid did = {\n    idForm      = fid\n    idDim       = did\n    destination =  \"\"   \n}\n\ntype CubeId    = CubeId  of System.Guid\n    with member this.Guid = match this with CubeId gid -> gid\n\n[< NamedUnionCases \"type\" >]\ntype Cube = {\n    id            : CubeId\n    cube          : string\n}\n\nlet newCube() = {\n    id   = CubeId <| System.Guid.NewGuid()\n    cube =  \"\"   \n}\n\ntype Selection =\n| NoSelection\n| SelCalcForm of CalcId * (FormId option)\n| SelTotal    of TotId\n\n[<NoComparison ; NoEquality>]\ntype Model = {\n    calculations     : ListModel<CalcId        , Calculation>\n    totals           : ListModel<TotId         , Total      >\n    formulas         : ListModel<FormId        , Formula    >\n    dimensions       : ListModel<DimId         , Dimension  >\n    cubes            : ListModel<CubeId        , Cube       >\n    destinations     : ListModel<FormId * DimId, Destination>\n    calcDims         : Var<Set<CalcId * DimId>>\n    cubeDims         : Var<Set<CubeId * DimId>>\n    globalDefs       : Var<string>\n    server           : Var<string>\n    selection        : Var<Selection>\n    selectedDim      : Var<DimId  option>\n    selectedCube     : Var<CubeId option>\n}\n\ntype MsgModel =\n| AddTotal\n| AddChild          of TotId * Child * Weight\n| SelectTotal       of TotId\n| RemoveTotal       of TotId\n| RemoveChild       of Child\n| AddCalculation\n| RemoveCalculation of CalcId\n| SelectCalculation of CalcId\n| AddFormula        of CalcId\n| RemoveFormula     of FormId\n| SelectFormula     of CalcId * FormId\n| AddDimension\n| RemoveDimension   of DimId\n| SelectDimension   of DimId\n| AddFormDim        of FormId * DimId * string\n| RemoveFormDim     of FormId * DimId\n\nlet [< Inline >] inline getId            (x: ^T) = (^T : (member id            : 'U) x)\nlet [< Inline >] inline getname          (x: ^T) = (^T : (member name          : 'U) x)\nlet [< Inline >] inline gettotName       (x: ^T) = (^T : (member totName       : 'U) x)\nlet [< Inline >] inline getchildren      (x: ^T) = (^T : (member children      : 'U) x)\nlet [< Inline >] inline gettypeC         (x: ^T) = (^T : (member typeC         : 'U) x)\nlet [< Inline >] inline getorder         (x: ^T) = (^T : (member order         : 'U) x)\nlet [< Inline >] inline getisText        (x: ^T) = (^T : (member isText        : 'U) x)\nlet [< Inline >] inline getisBalance     (x: ^T) = (^T : (member isBalance     : 'U) x)\nlet [< Inline >] inline getformat        (x: ^T) = (^T : (member format        : 'U) x)\nlet [< Inline >] inline getidCalc        (x: ^T) = (^T : (member idCalc        : 'U) x)\nlet [< Inline >] inline getidForm        (x: ^T) = (^T : (member idForm        : 'U) x)\nlet [< Inline >] inline getidDim         (x: ^T) = (^T : (member idDim         : 'U) x)\nlet [< Inline >] inline getformula       (x: ^T) = (^T : (member formula       : 'U) x)\nlet [< Inline >] inline getcube          (x: ^T) = (^T : (member cube          : 'U) x)\nlet [< Inline >] inline gettypeF         (x: ^T) = (^T : (member typeF         : 'U) x)\nlet [< Inline >] inline getdimension     (x: ^T) = (^T : (member dimension     : 'U) x)\nlet [< Inline >] inline getabbreviation  (x: ^T) = (^T : (member abbreviation  : 'U) x)\nlet [< Inline >] inline getexcludeCube   (x: ^T) = (^T : (member excludeCube   : 'U) x)\nlet [< Inline >] inline getincludeFreeze (x: ^T) = (^T : (member includeFreeze : 'U) x)\nlet [< Inline >] inline getdimType       (x: ^T) = (^T : (member dimType       : 'U) x)\nlet [< Inline >] inline getdestination   (x: ^T) = (^T : (member destination   : 'U) x)\nlet [< Inline >] inline getalsoActual    (x: ^T) = (^T : (member alsoActual    : 'U) x)\nlet [< Inline >] inline getKey           (x: ^T) = (^T : (member Key           : 'U) x)\n\nlet [< Inline >] inline setIdD           v x = { x with Dimension  .id     = v }\nlet [< Inline >] inline setIdC           v x = { x with Calculation.id     = v }\nlet [< Inline >] inline setIdT           v x = { x with Total      .id     = v }\nlet [< Inline >] inline setIdF           v x = { x with Formula    .id     = v }\nlet [< Inline >] inline setIdCu          v x = { x with Cube       .id     = v }\nlet [< Inline >] inline setname          v x = { x with name               = v }\nlet [< Inline >] inline settotName       v x = { x with totName            = v }\nlet [< Inline >] inline setchildren      v x = { x with Total.children     = v }\nlet [< Inline >] inline settypeC         v x = { x with typeC              = v }\nlet [< Inline >] inline setorderD        v x = { x with Dimension  .order  = v }\nlet [< Inline >] inline setorderC        v x = { x with Calculation.order  = v }\nlet [< Inline >] inline setorderT        v x = { x with Total      .order  = v }\nlet [< Inline >] inline setorderF        v x = { x with Formula    .order  = v }\nlet [< Inline >] inline setisText        v x = { x with isText             = v }\nlet [< Inline >] inline setisBalance     v x = { x with isBalance          = v }\nlet [< Inline >] inline setformatC       v x = { x with Calculation.format = v }\nlet [< Inline >] inline setformatT       v x = { x with Total      .format = v }\nlet [< Inline >] inline setidCalc        v x = { x with idCalc             = v }\nlet [< Inline >] inline setidForm        v x = { x with idForm             = v }\nlet [< Inline >] inline setidDim         v x = { x with idDim              = v }\nlet [< Inline >] inline setformula       v x = { x with formula            = v }\nlet [< Inline >] inline setcube          v x = { x with cube               = v }\nlet [< Inline >] inline settypeF         v x = { x with typeF              = v }\nlet [< Inline >] inline setdimension     v x = { x with dimension          = v }\nlet [< Inline >] inline setabbreviation  v x = { x with abbreviation       = v }\nlet [< Inline >] inline setexcludeCube   v x = { x with excludeCube        = v }\nlet [< Inline >] inline setincludeFreeze v x = { x with includeFreeze      = v }\nlet [< Inline >] inline setdimType       v x = { x with dimType            = v }\nlet [< Inline >] inline setdestination   v x = { x with destination        = v }\nlet [< Inline >] inline setalsoActual    v x = { x with alsoActual         = v }\n\n\nlet selectedString txt (selectedV:View<bool>) = V(if selectedV.V then txt else \"\") \n\nlet refreshView, refreshNow =\n    let refresh = Var.Create ()\n    refresh.View, fun () -> refresh.Value <- ()\n\nlet modelNew() = {\n    calculations = ListModel.Create getId     []\n    totals       = ListModel.Create getId     [] \n    formulas     = ListModel.Create getId     []\n    dimensions   = ListModel.Create getId     []\n    cubes        = ListModel.Create getId     []\n    destinations = ListModel.Create getDstKey []\n    calcDims     = Var      .Create <| Set    []\n    cubeDims     = Var      .Create <| Set    []\n    globalDefs   = Var      .Create <| \"\"\n    server       = Var      .Create <| \"\"\n    selection    = Var      .Create <| NoSelection\n    selectedDim  = Var      .Create <| None\n    selectedCube = Var      .Create <| None\n}\n\nlet model = modelNew()\n\nlet nonTotal        = { newTotal       ()                with id = TotId  System.Guid.Empty }\nlet nonCalculation  = { newCalculation ()                with id = CalcId System.Guid.Empty } \nlet nonFormula      = { newFormula     nonCalculation.id with id = FormId System.Guid.Empty }\nlet nonDestination  = newDestination nonFormula.id (DimId System.Guid.Empty)\n\nlet nonTotalV       = Var.Create nonFormula     |> Var.Lens <| id <| (fun v _ -> v)\nlet nonCalculationV = Var.Create nonCalculation |> Var.Lens <| id <| (fun v _ -> v)\nlet nonFormulaV     = Var.Create nonFormula     |> Var.Lens <| id <| (fun v _ -> v)\n\nlet currentTotalV = ListModel.currentLens nonTotal       (model.selection.View |> View.Map (function | SelTotal    tId          -> Some tId  | _ -> None)) model.totals\nlet currentCalcV  = ListModel.currentLens nonCalculation (model.selection.View |> View.Map (function | SelCalcForm( cId, _fIdO) -> Some cId  | _ -> None)) model.calculations\nlet currentFormV  = ListModel.currentLens nonFormula     (model.selection.View |> View.Map (function | SelCalcForm(_cId,  fIdO) ->      fIdO | _ -> None)) model.formulas     \n\nlet isCalcSelectedV     cid     = model.selection.View |> View.Map (function | SelCalcForm (sid, _) -> sid = cid | _ -> false )\nlet isCalcFormSelectedV cid fid = model.selection.View |> View.Map ((=) <| SelCalcForm (cid, if fid = nonFormula.id then None else Some fid) )\nlet isTotalSelectedV    tid     = model.selection.View |> View.Map ((=) <| SelTotal     tid       )\n\nlet tryFindTotal  model tid = model.totals      .TryFindByKey tid\nlet tryFindCalc   model cid = model.calculations.TryFindByKey cid\nlet tryFindParent model ch  = model.totals |> Seq.tryFind (fun tot -> tot.children |> Seq.map getKey|> Seq.contains ch)\nlet getChildOrder model ch  = match ch with\n                              | Node tid -> tryFindTotal model tid |> Option.map getorder\n                              | Leaf cid -> tryFindCalc  model cid |> Option.map getorder\n\nlet selAsChild() = match model.selection.Value with\n                   | NoSelection         -> None\n                   | SelTotal    tid     -> Node tid |> Some\n                   | SelCalcForm(cid, _) -> Leaf cid |> Some\n\n\n[< Inline >]\nlet inline sortByOrder cs = cs |> Seq.sortBy getorder\n\nlet totalsCalcsWithParent() = \n    let children = model.totals   |> Seq.collect (fun tot -> tot.children) |> Seq.map(fun kvp -> kvp.Key)\n    children |> Seq.toArray |> Array.partition (function | Node _ -> true | _ -> false) |> fun (a, b) -> Set a, Set b\nlet inline totalsWithoutParent() = \n    let totalsWithParent = totalsCalcsWithParent() |> fst\n    model.totals       |> Seq.filter (getId >> Node >> (swap Set.contains totalsWithParent) >> not) |> sortByOrder\nlet inline calcsWithoutParent () = \n    let calcsWithParent  = totalsCalcsWithParent() |> snd\n    model.calculations |> Seq.filter (getId >> Leaf >> (swap Set.contains calcsWithParent ) >> not) |> sortByOrder\n\nlet tryFindSiblingTotal model ch =\n    match tryFindParent model ch with\n    | Some parent -> parent.children \n                     |> Seq.map        getKey \n                     |> Seq.sortBy    (getChildOrder model) \n                     |> Seq.takeWhile ((<>) ch) \n                     |> Seq.choose    (function | Node v -> Some v | _ -> None) \n                     |> Seq.rev \n                     |> Seq.tryHead \n                     |> Option.bind   (tryFindTotal  model)\n    | None        -> totalsWithoutParent() |> Seq.filter (getId >> Node >> ((<>) ch)) |> Seq.sortByDescending getorder |> Seq.tryHead\n\n","parent":{"$":0,"Item":"be49e291-252c-4064-a3d6-bc61b39895fa"},"predecessors":[{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"9c870b72-8f9a-4e7d-ad81-7f1fd73fdd76"},{"$":0,"Item":"ecccc1a6-726e-438a-8804-16063c8a5107"}],"id":{"$":0,"Item":"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"codemirror","content":"[<NoComparison ; NoEquality>]\ntype KeyMapAutoComplete = { \n    F2              : Template.CodeMirrorEditor -> unit \n    LeftDoubleClick : Template.CodeMirrorEditor -> unit\n    ``Ctrl-Space``  : Template.CodeMirrorEditor -> unit\n    ``.``           : Template.CodeMirrorEditor -> unit\n}\n\nlet codeMirrorRender() =\n\n    let setDirtyCond() = ()\n    let showToolTip _  = ()\n    let getHints    _  = ()\n    \n    let codeMirror =\n        Template.CodeMirror.New(Lens currentFormV.V.formula)\n            .OnChange(setDirtyCond)\n            .OnRender(fun ed ->\n              ed.AddKeyMap({  F2              = showToolTip            \n                              LeftDoubleClick = showToolTip\n                              ``Ctrl-Space``  = Template.showHints ed getHints false\n                              ``.``           = (fun _ -> ed.ReplaceSelection(\".\", \"end\"))\n                                                >> Template.showHints ed getHints false\n                           })\n              ed.SetOption(\"mode\" , \"fsharp\"  )\n              ed.SetOption(\"theme\", \"rubyblue\")\n            )\n            .Style(\"height: 100%\")\n    \n    let refreshCodeMirror() = codeMirror.editorO |> Option.iter (fun cm -> cm.Refresh())\n    \n    let delayedRefreshCM delay =\n        async {\n            do! Async.Sleep delay\n            refreshCodeMirror() \n        } |> Async.Start\n        \n    codeMirror.Render.AddChildren [ \n        htmlElement     \"menu\" [  // does not work anymore. support for this was dropped by Chrome\n            ``type``    \"context\"\n            Id          \"right-menu\"\n        ]\n        htmlAttribute \"contextmenu\" \"right-menu\"\n    ]\n    \n","parent":{"$":0,"Item":"be49e291-252c-4064-a3d6-bc61b39895fa"},"predecessors":[{"$":0,"Item":"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"},{"$":0,"Item":"18d8153d-422c-42f6-8266-9a9d854bd6a1"},{"$":0,"Item":"a05dd36e-a15e-4394-8013-128e21e69574"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},{"$":0,"Item":"4180353c-9dc5-438d-862d-851539b02075"}],"id":{"$":0,"Item":"72c6586f-0129-40d8-8c3f-8e81325a4d0f"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"renderers","content":"let levelitem                    = ``class`` \"level-item\"\nlet onClick                    f = on.click (fun _ -> f) |> SomeAttr\nlet check                      v = if v then \"\" else \"\"\nlet flipO (vo: Var<bool option>) = vo.Value |> Option.iter (fun v -> vo.Value <- Some <| not v)\nlet flip  (vv: Var<bool       >) = vv.Value |>             (fun v -> vv.Value <-         not v)\nlet disabled                   v = addChildren [SomeAttr  <| attr.disabledDynPred (View.Const \"\") (Val.toView v)]\nlet falseV                       = Val.Constant false\n\nlet tdl h = td [ levelitem ; h] \n\nopen WebSharper.UI.Templating\nlet [< Literal >] TemplatesFileName = @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\bin\\Compiled\\RuleEditor\\website\\Templates.html\"\ntype TemplateLib  = Template< TemplatesFileName, ClientLoad.FromDocument, ServerLoad.WhenChanged, LegacyMode.New>\n\n[< Inline >]\nlet inline filterSortForms cid fs = \n    match fs |> Seq.filter (getidCalc >> ((=) cid)) |> sortByOrder with\n    | fss when Seq.isEmpty fss -> seq [ nonFormula ]\n    | fss -> fss\n\nlet listNodes (totals: seq<Total>) (calcs: seq<Calculation>)  =\n    Console.Log \"listNodes\"\n    let children            = totals   |> Seq.collect (fun tot -> tot.children) |> Seq.map(fun kvp -> kvp.Key)\n    let totalsWithParent\n      , calcsWithParent     = children |> Seq.toArray |> Array.partition (function | Node _ -> true | _ -> false) |> fun (a, b) -> Set a, Set b\n    let totalsWithoutParent = totals   |> Seq.filter (getId >> Node >> (swap Set.contains totalsWithParent) >> not) |> sortByOrder\n    let calcsWithoutParent  = calcs    |> Seq.filter (getId >> Leaf >> (swap Set.contains calcsWithParent ) >> not) |> sortByOrder\n    let rec totalChildrenIds tid =\n        let tot = totals |> Seq.find (fun t -> t.id = tid)\n        seq {\n            yield Node tid\n            for ch in tot.children do \n                match ch.Key with\n                | Node chid -> yield! totalChildrenIds chid\n                | Leaf _    -> yield  ch.Key\n        }\n    seq {\n        for tot  in totalsWithoutParent do yield! totalChildrenIds tot.id\n        for calc in calcsWithoutParent  do yield  Leaf calc.id\n    }\n\nlet rowChild processor (totals: ListModel<_, _>) (calcs: ListModel<_, _>) (child: View<Child>) =\n    let calcRow cid =\n        let calcV = calcs |> ListModel.lensDef nonCalculation cid\n        let selCalc              = isCalcSelectedV cid\n        TemplateLib.CalculationRow()\n               .SelectedMark( selectedString \">\"        selCalc )\n               .Selected(     selectedString \"selected\" selCalc )\n               .CalcName(     Lens calcV.V.name      )\n               .Format(       Lens calcV.V.format    )\n               .IsText(       Lens calcV.V.isText    )\n               .IsBalance(    Lens calcV.V.isBalance )\n               .OrderCalc(    Lens calcV.V.order     )\n               .CalcType(    (Lens calcV.V.typeC).Lens (sprintf \"%A\") (fun _ s -> match s with |\"Calc\" -> Calc                                 | _ -> Input) )\n               .Remove(       fun _ -> RemoveCalculation cid |> processor        )\n               .AfterRender(  fun (e:Dom.Element) -> selCalc |> Val.sink (fun s -> if s then e?scrollIntoViewIfNeeded()) )\n               .Select(       fun _ -> SelectCalculation cid |> processor  )\n               .Formulas(     model.formulas  |> ListModel.docLensMapView (filterSortForms cid) (fun fid formV ->\n                               let selCalc              = isCalcFormSelectedV cid fid\n                               TemplateLib.FormulaRow()\n                                   .SelectedMark( selectedString \">\"        selCalc )\n                                   .Selected(     selectedString \"selected\" selCalc )\n                                   .OrderForm(    Lens formV.V.order     )\n                                   .FormType(    (Lens formV.V.typeF).Lens (sprintf \"%A\") (fun _ s -> match s with |\"Base\" -> Base |\"Consolidated\" -> Consolidated | _ -> All  ) )\n                                   .Formula(      Lens formV.V.formula   )\n                                   .Remove(       fun _ -> RemoveFormula fid |> processor        )\n                                   .AfterRender(  fun (e:Dom.Element) -> selCalc |> Val.sink (fun s -> if s then e?scrollIntoViewIfNeeded()) )\n                                   .Select(       fun _ -> SelectFormula(cid, fid) |> processor  )\n                                   .Doc()\n                             )\n               )\n               .Doc()\n    \n    let totalRow tid =\n        let totV      = totals |> ListModel.lensDef nonTotal tid\n        let selTotal  = isTotalSelectedV tid\n        TemplateLib.TotalRow()\n            .SelectedMark( selectedString \">\"        selTotal    )\n            .Selected(     selectedString \"selected\" selTotal    )\n            .TotName(      Lens totV.V.totName                   )\n            .Format(       Lens totV.V.format                    )\n            .OrderTot(     Lens totV.V.order                     )\n            .Remove(       fun _ -> RemoveTotal tid |> processor )\n            .Select(       fun _ -> SelectTotal tid |> processor )\n            .AfterRender(  fun (e:Dom.Element) -> selTotal |> Val.sink (fun s -> if s then e?scrollIntoViewIfNeeded()) )\n            .Doc()\n\n    match child |> View.TryGet with\n    | Some (Node tid) -> totalRow tid\n    | Some (Leaf cid) -> calcRow  cid\n    | _               -> Doc.Empty\n\nmodule View =\n    let [<Inline>] inline consistent   (vl:View<_>)  = \n        let prior      = ref <| Var.Create Unchecked.defaultof<_>\n        let setPrior v = if (!prior).Value <> v then (!prior).Value <- v \n        View.Sink setPrior vl\n        !prior |> View.FromVar\n\nlet [<Inline>] inline getIds ls = ls |> Seq.map getId |> Seq.toArray\n\nlet renderTable processor (model:Model) =\n    let totalIds = View.Map getIds model.totals      .View |> View.consistent\n    let calcIds  = View.Map getIds model.calculations.View |> View.consistent\n    TemplateLib.CalculationTable()\n        .TBody( \n            View.Map3 (fun _ _ _ -> listNodes model.totals.Value model.calculations.Value) totalIds calcIds refreshView\n            |> Doc.BindSeqCachedView (rowChild processor model.totals model.calculations)\n         )\n        .Doc() |> someElt\n\nlet renderDetail processor model =\n    let noCalcV () = attr.disabledDynPred (View.Const \"\") (V(currentCalcV.V.id = nonCalculation.id))\n    let noFormV () = attr.disabledDynPred (View.Const \"\") (V(currentFormV.V.id = nonFormula.id    ))\n    TemplateLib.FormulaDetail()\n        .CalcName(    Lens currentCalcV.V.name      )\n        .Format(      Lens currentCalcV.V.format    )\n        .IsText(      Lens currentCalcV.V.isText    )\n        .IsBalance(   Lens currentCalcV.V.isBalance )\n        .AlsoActual(  Lens currentFormV.V.alsoActual)\n        .CalcType(   (Lens currentCalcV.V.typeC).Lens (sprintf \"%A\") (fun _ s -> match s with |\"Calc\" -> Calc                                 | _ -> Input) )\n        .FormType(   (Lens currentFormV.V.typeF).Lens (sprintf \"%A\") (fun _ s -> match s with |\"Base\" -> Base |\"Consolidated\" -> Consolidated | _ -> All  ) )\n        .Formula(     codeMirrorRender() |> renderDoc)\n        .DisableCalc1(noCalcV())\n        .DisableCalc2(noCalcV())\n        .DisableCalc3(noCalcV())\n        .DisableCalc4(noCalcV())\n        .DisableCalc5(noCalcV())\n        .DisableCalc6(noCalcV())\n        .DisableForm1(noFormV())\n        .DisableForm2(noFormV())\n        .AddFormula(  fun _ -> (V currentCalcV.V.id) |> View.Get (AddFormula >> processor) )\n        .Doc() |> SomeDoc\n    \n\nlet dtypes =[ \n    DtDataType\n    DtTime\n    DtVersion\n    DtOther    ] \n    \nlet filterDims = Seq.filter (fun d -> dtypes |> Seq.contains d.dimType)\nlet sortDims (ds:Dimension seq) = ds |> Seq.sortBy getorder\nlet filterSortDims = filterDims >> sortDims\n\nlet renderDimensions processor model =\n    div [\n      TemplateLib.DimensionTable()\n        .TBody(\n            model.dimensions |> ListModel.docLensMapView filterSortDims (fun did dimV ->\n                let selDim = Val.map ((=) (Some did)) model.selectedDim\n                TemplateLib.DimensionRow()\n                    .Name(          Lens dimV.V.dimension     )\n                    .Abbreviation(  Lens dimV.V.abbreviation  )\n                    .Order(         Lens dimV.V.order         )\n                    .Type(         (Lens dimV.V.dimType       ).Lens (sprintf \"%A\" >> fun s -> s.[2..]) (fun _ s -> match s with |\"DataType\" -> DtDataType |\"Time\" -> DtTime |\"Version\" -> DtVersion | _ -> DtOther) )\n                    .ExcludeName(   Lens dimV.V.excludeCube   )\n                    .IncludeFreeze( Lens dimV.V.includeFreeze )\n                    .Remove(        fun _ -> RemoveDimension did |> processor )\n                    .Select(        fun _ -> SelectDimension did |> processor )\n                    .Doc()        \n            )\n        )\n        .NewDimension(fun _ -> AddDimension |> processor)\n        .Doc() |> someElt\n    ]\n\nlet renderDimsSelected _processor model =\n    let setDestination (d:Destination) (fid, did) = \n        if d.destination.Trim() <> \"\" \n        then model.destinations.Add { idForm = fid ; idDim = did ; destination = d.destination }\n        else model.destinations.RemoveByKey (fid, did)\n    div [\n      TemplateLib.DimsSelected()\n        .TBody(\n            model.dimensions |> ListModel.docLensMapView filterSortDims (fun did dimV ->\n                let currDest = currentFormV.Lens (fun form -> if form.id = nonFormula.id then None else Some(form.id, did)) (fun v _ -> v)\n                let destV    = model.destinations |> ListModel.currentLensUpd nonDestination currDest setDestination\n                let checkV   = model.calcDims     |> Var.lensView \n                                (fun cds   -> model.selection.Value |> function | SelCalcForm (cid, _) -> cds |> Set.contains(cid, did)                         | _ -> false ) \n                                (fun cds v -> model.selection.Value |> function | SelCalcForm (cid, _) -> cds |> (if v then Set.add else Set.remove) (cid, did) | _ -> cds   )\n                                model.selection.View                                     \n                let visibFor = V(if currentFormV.V.id <> nonFormula.id && checkV.V then \"\" else \"Hidden\")\n                TemplateLib.DimSelectedRow()\n                    .Dimension(    V dimV.V.dimension )\n                    .DimensionCheck( checkV                                )\n                    .Destination(    Lens destV.V.destination              )\n                    .Hidden(         visibFor                              )\n                    .Doc()\n            )\n        )\n        .Doc() |> someElt\n    ]\n    \nlet renderGlobalDefs _processor model =\n    div [  \n        TemplateLib.GlobalText()\n            .Var(model.globalDefs)\n            .Doc() |> SomeDoc\n    ]\n\n","parent":{"$":0,"Item":"be49e291-252c-4064-a3d6-bc61b39895fa"},"predecessors":[{"$":0,"Item":"657c8f34-c917-4659-825d-c9ead206efcf"},{"$":0,"Item":"72c6586f-0129-40d8-8c3f-8e81325a4d0f"},{"$":0,"Item":"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"}],"id":{"$":0,"Item":"dd65606a-9194-4699-8c83-25dd52970a44"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"updateModel","content":"let rec updateModelR model msg =\n    let setSelection sel          = if model.selection.Value = sel then false else\n                                    model.selection.Value   <- sel\n                                    true\n    match msg with\n    | AddCalculation         -> let n = newCalculation()\n                                model.calculations.Add n\n                                SelectCalculation   n.id  |> updateModelR model\n    | AddTotal               -> let n = newTotal()\n                                model.totals.Add n\n                                SelectTotal         n.id  |> updateModelR model\n    | AddFormula         cid -> if  cid = nonCalculation.id then false else\n                                let n = newFormula cid\n                                model.formulas.Add n\n                                SelectFormula (cid, n.id) |> updateModelR model\n    | AddDimension           -> let n = newDimension()\n                                model.dimensions.Add n\n                                SelectDimension n.id |> updateModelR model\n    | AddFormDim(fid, did, s)-> model.destinations.Add   { idForm = fid ; idDim = did ; destination = s }\n                                true\n    | AddChild(tid, ch, we)  -> model.totals.TryFindByKey tid |> Option.map( fun tot ->\n                                    RemoveChild ch |> updateModelR model |> ignore\n                                    model.totals.Add { tot with children = tot.children |> Map.add ch we }\n                                    true\n                                ) |> Option.defaultValue false\n    | RemoveChild      ch    -> tryFindParent model ch |> Option.map( fun tot ->\n                                    model.totals.Add { tot with children = tot.children |> Map.remove ch }\n                                    true\n                                ) |> Option.defaultValue false\n    | RemoveTotal        tid -> model.totals.RemoveByKey tid\n                                model.selection.Value   <- NoSelection\n                                true\n    | RemoveCalculation  cid -> model.calcDims.Value <- model.calcDims.Value |> Set.filter (fst >> ((<>) cid))\n                                model.formulas.Value\n                                |> Seq.filter (fun f -> f.idCalc = cid)\n                                |> Seq.map    (getId >> RemoveFormula)\n                                |> Seq.iter   (updateModelR model >> ignore)\n                                model.selection.Value   <- NoSelection\n                                model.calculations.RemoveByKey cid    \n                                true\n    | RemoveFormula      fid -> model.formulas.RemoveByKey fid\n                                model.destinations.RemoveBy (fun d -> d.idForm = fid)\n                                currentCalcV.Value.id |> SelectCalculation |> updateModelR model |> ignore\n                                false\n    | RemoveDimension    did -> model.dimensions.RemoveByKey did\n                                true\n    | RemoveFormDim(fid, did)-> model.destinations.RemoveByKey(fid, did)\n                                true\n    | SelectTotal        tid -> (if tid = nonTotal      .id then NoSelection else SelTotal tid                                                    ) |> setSelection\n    | SelectCalculation  cid -> (if cid = nonCalculation.id then NoSelection else SelCalcForm(cid,                             None              )) |> setSelection\n    | SelectFormula(cid, fid)-> (if cid = nonCalculation.id then NoSelection else SelCalcForm(cid, if fid = nonFormula.id then None else Some fid)) |> setSelection\n    | SelectDimension    did -> (if did = DimId System.Guid.Empty then None  else Some did)\n                                |> (fun s -> if s = model.selectedDim.Value then false else\n                                             model.selectedDim.Value    <- s\n                                             true)\n\nlet updateModel model msg = if updateModelR model msg then refreshNow()\n\nlet processor = updateModel model\n","parent":{"$":0,"Item":"be49e291-252c-4064-a3d6-bc61b39895fa"},"predecessors":[{"$":0,"Item":"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"}],"id":{"$":0,"Item":"e58f6eb7-bde5-4404-a752-1451fec828c7"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Parse","content":"type LocationDet =\n| InDimension   of DimId\n| InCalculation of CalcId\n| InGlobalDefs\n| InFormula     of FormId\n| InFormulaDest of FormId\n| InFsCode\n\ntype MsgLocation = {\n    lines    : int\n    indent   : int\n    location : LocationDet\n}\n\nlet codeFS     = Var.Create \"\"\nlet parserMsgs = Var.Create \"\"\nlet codeJS     = Var.Create \"\"\nlet outputMsgs = Var.Create \"\"\n\nlet appendMsg (var:Var<string>) msg =\n    if isUndefined msg then () else\n    let newM =\n        match var.Value, msg.ToString() with\n        | null, m \n        | \"\"  , m\n        | m   , null\n        | m   , \"\"   -> m\n        | m1  , m2   -> m1 + \"\\n\" + m2\n    if newM <> var.Value then\n        var.Value  <- newM\n\nlet setOutMsg msg = outputMsgs.Value <-  msg\nlet addOutMsg msg = appendMsg outputMsgs msg\n\nlet getDim  did = model.dimensions  .FindByKey did\nlet getCalc cid = model.calculations.FindByKey cid\nlet getForm fid = model.formulas    .FindByKey fid\n\nlet getDims () =\n    model.dimensions.Value\n    |> Seq.sortBy getorder\n    |> Seq.map (fun d -> sprintf \"let %s = newDim %A %A %A\" (d.dimension.Trim().Replace(\" \", \"_\")) d.dimension d.dimType (if d.excludeCube then \"\" else d.abbreviation), d.id)\n\nlet getCalcDims cid =\n    model.calcDims.Value\n    |> Seq.filter (fst >> ((=) cid))\n    |> Seq.map    (snd >> model.dimensions.FindByKey >> (fun d -> d.dimension))\n    |> String.concat \" ; \"\n\nlet getCalcs () =\n    model.calculations.Value\n    |> Seq.sortBy getorder\n    |> Seq.map (fun c -> sprintf \"let %s = newCalc %s %A %A [ %s ]\" (c.name.Trim().Replace(\" \", \"_\")) (if c.typeC = Input then \"Input\" else \"Calc\") c.name c.order (getCalcDims c.id), c.id)\n\nlet getDest fid =\n    model.destinations.Value\n    |> Seq.filter (fun d -> d.idForm = fid)\n    |> Seq.map    (fun d -> sprintf \"%s.[%A]\" (getDim d.idDim).dimension d.destination )\n    |> String.concat \" ; \"\n    |> sprintf \"[ %s ]\"\n\nlet prepare (f:string) =\n    f.Replace(\"@=\", \"&=\").Replace(\"@<\", \"&<\").Replace(\"@>\", \"&>\")\n    |> indent 4\n\nlet getForms () =\n    model.calculations.Value\n    |> Seq.sortBy getorder\n    |> Seq.collect (fun c -> \n        model.formulas.Value\n        |> Seq.filter (fun f -> f.idCalc = c.id)\n        |> Seq.sortBy getorder\n        |> Seq.map    (fun f -> c, f)\n    )\n    |> Seq.map (fun (c, f) ->\n        let txt = prepare f.formula\n        let n   = txt |> Seq.length\n        [ \n            yield  sprintf \"newForm %s %s (\" (c.name.Trim().Replace(\" \", \"_\")) (if f.typeF = Base then \"ForBase\" else \"ForConsolidated\")\n            yield! txt\n            yield  sprintf \") %s %A %A\"     (getDest f.id)  f.order (txt |> Seq.map String.trim |> Seq.map (fun s -> s.Replace(\"\\\\\", \"\\\\\\\\\").Replace(\"\\\"\", \"\\\\\\\"\")) |> String.concat \" \")\n        ]\n      , { lines = n + 2 ; indent = 4 ; location = InFormula f.id}\n    )\n\nlet getFSCode () =\n    let calcModel = unindent \"\"\"\n        #nowarn \"86\"\n        #r @\"..\\CalculationModelDll\\CalculationModelDll.dll\"\n        open FSSGlobal.CalculationModel\n        open CalculationModel\n        open CalculationSyntax\n        open InitModel\n        \n        {\n            modId           = ModId <| System.Guid.NewGuid()\n            server          = @\"LOCAL\\CipherSpace\"\n            actualElem      = \"Actual\"\n            modCubes        = [| |]\n            modDims         = [| |]\n            modCalculations = [| |]\n        } |> setInitModel\n            \"\"\"\n    let dims       = getDims ()\n    let calcs      = getCalcs()\n    let forms      = getForms()\n    let globalDefs = model.globalDefs.Value.Split '\\n'\n    let lines = seq [\n                    yield! calcModel\n                    yield! dims  |> Seq.map     fst\n                    yield  \"addDims()\"\n                    yield! calcs |> Seq.map     fst\n                    yield  \"addCalcs()\"\n                    yield! globalDefs\n                    yield! forms |> Seq.collect fst\n                    yield  \"addFrms()\"\n                ]\n    let code = lines |> String.concat \"\\n\"\n    codeFS.Value <- code\n    let locs  = seq [\n                    yield                          { lines = calcModel  |> Seq.length ; indent = 0 ; location = InFsCode          }\n                    for (_, did) in dims  do yield { lines = 1                        ; indent = 4 ; location = InDimension   did }\n                    yield                          { lines = 1                        ; indent = 0 ; location = InFsCode          }\n                    for (_, cid) in calcs do yield { lines = 1                        ; indent = 4 ; location = InCalculation cid }\n                    yield                          { lines = 1                        ; indent = 0 ; location = InFsCode          }\n                    yield                          { lines = globalDefs |> Seq.length ; indent = 0 ; location = InGlobalDefs      }\n                    for (_, fsd) in forms do yield fsd\n                    yield                          { lines = 1                        ; indent = 0 ; location = InFsCode          }\n                ]\n    code, locs\n    \nlet getFSCodeA = getFSCode >> ignore    \n\nlet adaptMessage locs (lf:int) (cf:int) (lt:int) (ct:int) msg =\n    locs \n    |> Seq.mapFold (fun  from  l  -> (from, l ), from + l.lines) 0\n    |> fst\n    |> Seq.tryFind (fun (from, l) -> lf - 1 >= from && lf - 1 < from + l.lines)\n    |> Option.map  (fun (from, l) -> \n        match l.location with \n        | InDimension   did -> sprintf \"%s: %s %A\"                   (getDim  did     ).dimension                                                            msg did \n        | InCalculation cid -> sprintf \"%s: %s %A \"                  (getCalc cid     ).name                                                                 msg cid \n        | InFormulaDest fid -> let f = getForm fid\n                               sprintf \"%s: %s %A \"                  (getCalc f.idCalc).name                                                                 msg fid \n        | InFormula     fid -> let f = getForm fid\n                               sprintf \"%s (%d,%d) - (%d,%d): %s %A\" (getCalc f.idCalc).name (lf - 1 - from) (cf - l.indent) (lt - 1 - from) (ct - l.indent) msg fid \n        | InFsCode          -> sprintf \"F# Code (%d,%d) - (%d,%d): %s\"                       (lf     - from) (cf - l.indent) (lt     - from) (ct - l.indent) msg\n        | InGlobalDefs      -> sprintf \"Global  (%d,%d) - (%d,%d): %s\"                       (lf     - from) (cf - l.indent) (lt     - from) (ct - l.indent) msg\n    )\n    |> Option.defaultWith (fun () -> sprintf \"%d %d - %d %d %s\" lf cf lt ct msg)\n    \n\nlet rex = \".*\\((\\d+),(\\d+)\\) \\- \\((\\d+),(\\d+)\\)(.*)\"\n\nlet adaptMessages locs ms =\n    ms \n    |> String.splitByChar '\\n'\n    |> Seq.map     (\n        function\n        | REGEX rex \"\" [| _ ; lf ; cf ; lt ; ct ; msg |] -> adaptMessage locs (int lf) (int cf) (int lt) (int ct) msg \n        | o                                              -> o\n    )\n\nlet autoCompleteClient = FSAutoCompleteIntermediary.FSAutoCompleteIntermediaryClient(\"RuleEditor\")//, endPoint = JS.Window.Location.Href)\n\nlet getJSCode() =\n    async {\n        codeJS.Value     <- \"\"\n        parserMsgs.Value <- \"\"\n        let  fs, locs     = getFSCode()\n        let! res0         = autoCompleteClient.Parse(\"RuleEditor.fsx\", fs)\n        let  res          = adaptMessages locs res0 |> String.concat \"\\n\"\n        parserMsgs.Value <- res + \"\\nParsed!\"\n    } |> Async.Start\n    \nlet getJSCodeA = getJSCode >> ignore    \n\n//let goto codeId line col =\n//    async {\n//        currentCodeSnippetId.Value <- codeId\n//        CodeSnippet.FetchO codeId |> Option.iter expandParents\n//        do! Async.Sleep 200\n//        codeMirror.editorO \n//        |> Option.iter (fun ed -> \n//            ed.SetCursor(line - 1, col - 1) \n//            ed.Focus()\n//        )\n//    } |> Async.Start\n\nlet rexFormId = rex + \"FormId \\\"\" + rexGuid\nlet rexCalcId =       \"CalcId \\\"\" + rexGuid\nlet rexDimId  =       \"DimId \\\"\"  + rexGuid\n\nlet jumpToLine (line:string) = \n    match line with\n    | REGEX rexFormId \"\" [| _ ; _lf; _cf; _lt; _ct; _msg; gid |] -> let fid = System.Guid gid |> FormId\n                                                                    let f   = getForm fid\n                                                                    SelectFormula     (getidCalc f, fid         ) |> processor\n    | REGEX rexCalcId \"\" [| _ ;                           gid |] -> SelectCalculation (System.Guid gid |> CalcId) |> processor\n//    | REGEX rexDimId  \"\" [| _ ;                           gid |] -> SelectDimension (System.Guid gid |> DimId ) |> processor\n    | _                                                          -> ()\n\nlet jumpToRef (e:obj) = \n    let v : string = e?value |> unbox\n    let s : int    = e?selectionStart |> unbox\n    let lines = v.Split '\\n'\n    lines \n    |> Seq.mapFold (fun total line -> (line, total, total + line.Length + 1), total + line.Length + 1) 0 \n    |> fst\n    |> Seq.pick (fun (line, from, to_) -> if s >= from && s < to_ then Some line else None)\n    |> jumpToLine\n\n","parent":{"$":0,"Item":"be49e291-252c-4064-a3d6-bc61b39895fa"},"predecessors":[{"$":0,"Item":"e58f6eb7-bde5-4404-a752-1451fec828c7"},{"$":0,"Item":"466e6783-0751-48d5-b79b-165aaa7d2173"},{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},{"$":0,"Item":"68511118-6a1b-4ae9-aea0-942b6073ff67"},{"$":0,"Item":"9cc5cba5-719f-4e72-9216-be14381557bf"},{"$":0,"Item":"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"}],"id":{"$":0,"Item":"a6966f1d-4d4c-4ac2-be2d-7aeb76e2e2e2"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"translate","content":"open FsEvaluator\n\nlet updateRules() =\n    Wrap.wrap {\n        outputMsgs.Value <- \"\"\n        let  fs0, _locs   = getFSCode()\n        let  pre          = \"////-d:FSI32BIT\\n\"\n        let  fs           = pre + fs0 + unindentStr \"\"\"\n                open FSSGlobal.Useful\n                \n                InitModel.initModel\n                |> Model.prepareModel \n                |> CalcRules.addModelRules\n                |> WriteRules.createCubesR\n                |> Result.getMsgs |> Seq.iter (printfn \"%A\")\n        \"\"\"\n#if FSS_SERVER\n        let! resA         = evaluateAR \"RuleEditor\" JS.Window.Location.Href true fs\n        let! res          = resA\n#else\n        let! res          = autoCompleteClient.MessagingClient.EvaluateFS fs\n#endif        \n        outputMsgs.Value <- res\n    }\n    \nlet updateRulesA = updateRules >> ignore    \n\n","parent":{"$":0,"Item":"be49e291-252c-4064-a3d6-bc61b39895fa"},"predecessors":[{"$":0,"Item":"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"},{"$":0,"Item":"a6966f1d-4d4c-4ac2-be2d-7aeb76e2e2e2"}],"id":{"$":0,"Item":"e01c4aa8-1574-4de8-8d1f-856c822592af"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Serializer","content":"let inline ifUndef  def v   = if isUndefined v then def   else   v\nlet inline ifUndefF def f v = if isUndefined v then def v else f v\n\nlet deserGuid = ifUndef (System.Guid \"00000000-0000-0000-0000-000000000000\")\n\nlet serializerDimId     = (fun(DimId  v) -> sprintf \"\"\"{\"DimId\" :%A}\"\"\" v)           , (fun (x: obj) -> x?DimId  |> deserGuid |> DimId )\nlet serializerCalcId    = (fun(CalcId v) -> sprintf \"\"\"{\"CalcId\":%A}\"\"\" v)           , (fun (x: obj) -> x?CalcId |> deserGuid |> CalcId)\nlet serializerTotId     = (fun(TotId  v) -> sprintf \"\"\"{\"TotId\" :%A}\"\"\" v)           , (fun (x: obj) -> x?TotId  |> deserGuid |> TotId )\nlet serializerFormId    = (fun(FormId v) -> sprintf \"\"\"{\"FormId\":%A}\"\"\" v)           , (fun (x: obj) -> x?FormId |> deserGuid |> FormId)\nlet serializerCubeId    = (fun(CubeId v) -> sprintf \"\"\"{\"cubeId\":%A}\"\"\" v)           , (fun (x: obj) -> x?CubeId |> deserGuid |> CubeId)\nlet serializerDimType   = (fun v -> sprintf \"\\\"%A\\\"\"            (v:DimType ))        , (unbox >> function\n                                                                                                 | \"DtDataType\" -> DtDataType      \n                                                                                                 | \"DtTime\"     -> DtTime      \n                                                                                                 | \"DtVersion\"  -> DtVersion      \n                                                                                                 | \"DtTCalc\"    -> DtTCalc      \n                                                                                                 | \"DtCalc\"     -> DtCalc      \n                                                                                                 | \"DtMeasure\"  -> DtMeasure      \n                                                                                                 | _            -> DtOther      )\nlet serializerWeight    = (fun v -> sprintf \"\\\"%A\\\"\"            (v:Weight  ))        , (unbox >> function\n                                                                                                 | \"Add\"        -> Add      \n                                                                                                 | \"Subtract\"   -> Subtract      \n                                                                                                 | _            -> Zero      )\nlet serializerTypeC     = (fun v -> sprintf \"\\\"%A\\\"\"            (v:TypeCalc))        , (unbox >> function | \"Input\" -> Input | \"Calc\"         -> Calc         | _ -> Input)\nlet serializerTypeF     = (fun v -> sprintf \"\\\"%A\\\"\"            (v:TypeForm))        , (unbox >> function | \"Base\"  -> Base  | \"Consolidated\" -> Consolidated | _ -> All  )\nlet serializerFloat     = (fun v -> sprintf \"%A\"                (v:float   ))        , (fun (x: obj) -> x |> unbox<float>  |> ifUndef 0.0   )\nlet serializerInt       = (fun v -> sprintf \"%A\"                (v:int     ))        , (fun (x: obj) -> x |> unbox<int>    |> ifUndef 0     )\nlet serializerBool      = (fun v -> sprintf \"%A\"                (v:bool    ))        , (fun (x: obj) -> x |> unbox<bool>   |> ifUndef false )\nlet serializerString    = (fun v -> Json.Serialize              (v:string  ))        , (fun (x: obj) -> x |> unbox<string> |> ifUndef \"\"    )\n\nlet serializerField name (serFuncs:('e->string) * (obj->'e)) (get:'D->'e) (set:'e->'D->'D) = \n    name, serFuncs |> (fun (ser, deser) -> get >> ser, (fun o obj -> obj |> set (deser o)) )\n\nlet dimensionFields =\n    [|\n        serializerField \"id\"            serializerDimId   getId            setIdD       \n        serializerField \"dimension\"     serializerString  getdimension     setdimension \n        serializerField \"abbreviation\"  serializerString  getabbreviation  setabbreviation \n        serializerField \"order\"         serializerString  getorder         setorderD       \n        serializerField \"excludeCube\"   serializerBool    getexcludeCube   setexcludeCube  \n        serializerField \"includeFreeze\" serializerBool    getincludeFreeze setincludeFreeze\n        serializerField \"dimType\"       serializerDimType getdimType       setdimType      \n    |] \n    \nlet [< Inline >] serializerRecord init (fields: (string * (('D -> string) * (obj -> 'D -> 'D))) []) =\n    let serialize   dim = fields |> Seq.map  (fun     (n, ( ser, _deser)) -> sprintf \"%A: %s\" n (ser dim)) |> String.concat \", \" |> sprintf \"{%s}\"\n    let deserialize o   = if isUndefined o then init else fields |> Seq.fold (fun dim (n, (_ser,  deser)) ->  deser (o?(n)) dim )   init\n    serialize, deserialize\n\nlet serializerArray (ser: 'D -> string, deser:obj -> 'D) =\n    let serialize   arr = arr |>                 Array.map   ser |> String.concat \", \" |> sprintf \"[%s]\"\n    let deserialize o   = o   |> unbox<obj[]> |> ifUndefF (fun _ -> [||]) (Array.map deser)\n    serialize, deserialize\n    \nlet serializerDuple serFst serSnd =\n    let serialize (f, s) = sprintf \"[%s, %s]\" (fst serFst <| f) (fst serSnd <| s)\n    let deserialize o    =  o |> unbox<obj[]> |> ifUndefF (fun _ -> snd serFst o, snd serSnd o ) (fun os -> snd serFst <| os.[0], snd serSnd <| os.[1] )\n    serialize, deserialize\n\nlet serializerMap   serFst serSnd =\n    let arrSer, arrDeser           = serializerArray (serializerDuple serFst serSnd)\n    let serialize   (map:Map<_,_>) = map |> Seq.map (fun kvp -> kvp.Key, kvp.Value) |> Seq.toArray |> arrSer\n    let deserialize o              = o                                                             |> arrDeser |> Map\n    serialize, deserialize\n\nlet calculationFields =\n    [|\n        serializerField \"id\"        serializerCalcId getId        setIdC\n        serializerField \"name\"      serializerString getname      setname           \n        serializerField \"typeC\"     serializerTypeC  gettypeC     settypeC          \n        serializerField \"order\"     serializerString getorder     setorderC           \n        serializerField \"isText\"    serializerBool   getisText    setisText         \n        serializerField \"isBalance\" serializerBool   getisBalance setisBalance    \n        serializerField \"format\"    serializerString getformat    setformatC\n    |]\n\nlet serializerChild = \n    (function\n     | Node tid -> (fst serializerTotId ) tid |> sprintf \"\"\"{\"Node\" :%A}\"\"\" \n     | Leaf cid -> (fst serializerCalcId) cid |> sprintf \"\"\"{\"Leaf\" :%A}\"\"\" \n    )\n  , (fun (x: obj) -> \n      if   isUndefined x?Node |> not then x?Node |> (snd serializerTotId ) |> Node\n      elif isUndefined x?Leaf |> not then x?Leaf |> (snd serializerCalcId) |> Leaf\n                                     else x?Leaf |>  deserGuid |>  CalcId  |> Leaf\n    )\n\nlet serializerchildren    = serializerMap serializerChild serializerWeight  \n\nlet totalFields =\n    [|\n        serializerField \"id\"        serializerTotId    getId        setIdT\n        serializerField \"totName\"   serializerString   gettotName   settotName           \n        serializerField \"format\"    serializerString   getorder     setformatT\n        serializerField \"order\"     serializerString   getorder     setorderT\n        serializerField \"children\"  serializerchildren getchildren  setchildren\n    |]\n\nlet formulaFields =\n    [|\n        serializerField \"id\"         serializerFormId getId         setIdF\n        serializerField \"idCalc\"     serializerCalcId getidCalc     setidCalc          \n        serializerField \"formula\"    serializerString getformula    setformula          \n        serializerField \"typeF\"      serializerTypeF  gettypeF      settypeF         \n        serializerField \"order\"      serializerString getorder      setorderF          \n        serializerField \"alsoActual\" serializerBool   getalsoActual setalsoActual        \n    |]\n\nlet cubeFields =\n    [|\n        serializerField \"id\"         serializerCubeId getId         setIdCu\n        serializerField \"cube\"       serializerString getcube       setcube\n    |]\n\nlet destinationFields =\n    [|\n        serializerField \"idForm\"      serializerFormId getidForm      setidForm\n        serializerField \"idDim\"       serializerDimId  getidDim       setidDim\n        serializerField \"destination\" serializerString getdestination setdestination          \n    |]\n        \n        \nlet getdimensions     model = model.dimensions  .Value |> Seq.toArray\nlet getcalculations   model = model.calculations.Value |> Seq.toArray\nlet gettotals         model = model.totals      .Value |> Seq.toArray\nlet getformulas       model = model.formulas    .Value |> Seq.toArray\nlet getcubes          model = model.cubes       .Value |> Seq.toArray\nlet getdestinations   model = model.destinations.Value |> Seq.toArray\nlet getcalcDims       model = model.calcDims    .Value |> Seq.toArray\nlet getcubeDims       model = model.cubeDims    .Value |> Seq.toArray\nlet getglobalDefs     model = model.globalDefs  .Value\nlet getserver         model = model.server      .Value\n\nlet setdimensions   v model = model.dimensions  .Set      v ; model\nlet setcalculations v model = model.calculations.Set      v ; model\nlet settotals       v model = model.totals      .Set      v ; model\nlet setformulas     v model = model.formulas    .Set      v ; model\nlet setcubes        v model = model.cubes       .Set      v ; model\nlet setdestinations v model = model.destinations.Set      v ; model\nlet setcalcDims     v model = model.calcDims    .Set (Set v); model\nlet setcubeDims     v model = model.cubeDims    .Set (Set v); model\nlet setglobalDefs   v model = model.globalDefs  .Set      v ; model\nlet setserver       v model = model.server      .Set      v ; model\n\nlet serializerdimension      = serializerRecord (newDimension  ()                                                 ) dimensionFields  \nlet serializercalculation    = serializerRecord (newCalculation()                                                 ) calculationFields\nlet serializertotal          = serializerRecord (newTotal()                                                       ) totalFields\nlet serializerformula        = serializerRecord (newFormula    (CalcId System.Guid.Empty)                         ) formulaFields    \nlet serializercube           = serializerRecord (newCube       ()                                                 ) cubeFields\nlet serializerdestination    = serializerRecord (newDestination(FormId System.Guid.Empty)(DimId System.Guid.Empty)) destinationFields\nlet serializercalcDim        = serializerDuple serializerCalcId serializerDimId\nlet serializercubeDim        = serializerDuple serializerCubeId serializerDimId\n  \nlet serializerdimensions     = serializerArray serializerdimension  \nlet serializercalculations   = serializerArray serializercalculation\nlet serializertotals         = serializerArray serializertotal\nlet serializerformulas       = serializerArray serializerformula    \nlet serializercubes          = serializerArray serializercube\nlet serializerdestinations   = serializerArray serializerdestination\nlet serializercalcDims       = serializerArray serializercalcDim\nlet serializercubeDims       = serializerArray serializercubeDim\n\nlet modelFields =\n    [|\n        serializerField \"dimensions\"   serializerdimensions   getdimensions   setdimensions     \n        serializerField \"calculations\" serializercalculations getcalculations setcalculations     \n        serializerField \"totals\"       serializertotals       gettotals       settotals\n        serializerField \"formulas\"     serializerformulas     getformulas     setformulas     \n        serializerField \"cubes\"        serializercubes        getcubes        setcubes        \n        serializerField \"destinations\" serializerdestinations getdestinations setdestinations        \n        serializerField \"calcDims\"     serializercalcDims     getcalcDims     setcalcDims        \n        serializerField \"cubeDims\"     serializercubeDims     getcubeDims     setcubeDims        \n        serializerField \"globalDefs\"   serializerString       getglobalDefs   setglobalDefs        \n        serializerField \"server\"       serializerString       getserver       setserver        \n    |] \n\nlet serializeModel   model     = (serializerRecord model modelFields |> fst) model\nlet deserializeModel model obj = (serializerRecord model modelFields |> snd) obj\n","parent":{"$":0,"Item":"be49e291-252c-4064-a3d6-bc61b39895fa"},"predecessors":[{"$":0,"Item":"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"}],"id":{"$":0,"Item":"601c8cf3-33cd-41f9-94d0-79ac3be4f164"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Load Save","content":"#r \"../packages/FSharp.Data/lib/net45/FSharp.Data.dll\"\n\nopen FSharp.Data\n\n[< Inline \"saveAs(new Blob([$_txt], {type: 'text/plain;charset=utf-8'}), $_name)\" >]\nlet saveAs (_name:string) (_txt:string) = ()\n    \nlet steps() = \n    let dirty          = Var.Create     false\n    let setDirty()     = dirty.Value <- true       \n    let setClean()     = dirty.Value <- false\n    \n    let justFileName (f:string) = f.Split [| '/' ; '\\\\' |] |> Seq.last\n    \n    let fileName  = Var.Create \"\"\n    let emptyFile = Val.map (fun v -> v = \"\") fileName\n    \n    let loadTextFile element (f: string -> unit) =\n        let files = element |> FileList.OfElement \n        if files.Length > 0 then\n            let  reader  = TextFileReader()\n            reader.Onload <- (fun e -> f e.Target?result)\n            reader.ReadAsText files.[0] \n    \n    //let setModel models =\n    //    model.dimensions  .Set     models.dimensions  \n    //    model.calculations.Set     models.calculations\n    //    model.formulas    .Set     models.formulas    \n    //    model.destinations.Set     models.destinations\n    //    model.calcDims    .Value <- models.calcDims   \n    //    model.cubeDims    .Value <- models.cubeDims   \n    //    model.globalDefs  .Value <- models.globalDefs \n    //    model.server      .Value <- models.server   \n    \n    let parseText txt =\n        try\n            txt\n            |> Json.Parse\n            |> deserializeModel model\n            |> ignore\n    //        refreshView()\n        with e -> JS.Alert <| e.ToString()\n                  printfn \"%A\" e\n    \n    let fileInputElementId = \"RuleEditorFileSel\"\n    let loadFile (e: Dom.Element) =\n        if (not dirty.Value) || JS.Confirm \"Changes have not been saved, do you really want to load?\" then\n          let root = findRootElement e\n          loadTextFile \n              <| root.QuerySelector(\"#\" + fileInputElementId)\n              <| parseText\n    \n    let downloadFile() = // Save as...\n        let name = match justFileName fileName.Value with \n                   | \"\"    -> \"rules.json\" \n                   | fname -> fname\n        model\n        |> serializeModel\n        |> saveAs name\n        setClean()\n        \n    let loadFileElement =\n        Template.Input.New(fileName.Lens justFileName (fun prev _n -> prev) )\n            .Prefix( label [ ``class`` \"btn btn-primary\" ; htmlText \"Load File...\" \n                             Template.Input.New(fileName)\n                                     .Type(\"file\")\n                                     .Style(\"display: none\")\n                                     .Content([ on.change (fun el _ -> loadFile el   )\n                                                on.click  (fun el _ -> el?value <- \"\")\n                                              ])\n                                     .Id(fileInputElementId)\n                                     .Render \n                            ]\n                    )\n    \n    let do_LoadFile (e:Dom.Element) () =          \n        let root = findRootElement e\n        (root.QuerySelector(\"#\" + fileInputElementId))?click() |> ignore\n        \n    ()","parent":{"$":0,"Item":"be49e291-252c-4064-a3d6-bc61b39895fa"},"predecessors":[{"$":0,"Item":"601c8cf3-33cd-41f9-94d0-79ac3be4f164"},{"$":0,"Item":"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"}],"id":{"$":0,"Item":"1da05dcf-8d1b-4f21-b570-389d3e1030b2"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Actions","content":"    let DoW  f p   _ _ = f p   |> Wrap.map ignore |> Wrap.start addOutMsg\n    let DoW2 f p t     = DoW (fun p' -> f t p') p\n    \n    \n    //let actLoadFile       = Template.Action.New(\"Load...\"                    ).OnClick( do_LoadFile                    )  \n    let actSaveFile       = Template.Action.New(\"Save as...\"                 ).OnClick( Do   downloadFile      ()      ).Highlight(dirty)\n    let actAddCalculation = Template.Action.New(\"Add Calculation\"            ).OnClick( Do (updateModel model) AddCalculation )\n    let actDeleteSnippet  = Template.Action.New(\"Delete Snippet\"             )//.OnClick( Do   deleteCode        ()      ).Disabled(noSelectionVal      )\n    let actIndentSnippet  = Template.Action.New(\"Indent In  >>\"              )//.OnClick( Do   indentCodeIn      ()      ).Disabled(noSelectionVal      )\n    let actOutdentSnippet = Template.Action.New(\"Indent Out <<\"              )//.OnClick( Do   indentCodeOut     ()      ).Disabled(noSelectionVal      )\n    let actGetFsCode      = Template.Action.New(\"Get F# Code\"                ).OnClick( Do   getFSCodeA        ()      )//.Disabled(disableParseVal     )\n    let actSetSnippetProp = Template.Action.New(\"actSetSnippetProp\"          )//.OnClick2(DoW2 setSnippetProp    ()      ).Disabled(disableFSIVal       )\n    let actEvalFsCode     = Template.Action.New(\"Run FSI on Code\"            )//.OnClick2(DoW2 evalFsCode        ()      ).Disabled(disableFSIVal       )\n    let actEvalCode       = Template.Action.New(\"Update Rules\"               ).OnClick(DoW   updateRules       ()      )//.Disabled(disableFSIVal       )\n    let actFableFsCode    = Template.Action.New(\"Run Fable on Code\"          )//.OnClick2(DoW2 evalFableCode     ()      ).Disabled(disableFableVal     )\n    let actFableCode      = Template.Action.New(\"Run Fable\"                  )//.OnClick2(DoW2 fableFS2          ()      ).Disabled(disableFableVal     )\n    let actRunWSNewTab    = Template.Action.New(\"Run WebSharper in new tab\"  )//.OnClick2(DoW2 compileRunP2   NewBrowser ).Disabled(disableWebSharperVal)\n    let actRunWSHere      = Template.Action.New(\"Run WebSharper in WS Result\")//.OnClick2(DoP2 compileRunP2   Below      ).Disabled(disableWebSharperVal)\n    let actRunWSIn        = Template.Action.New(\"Run WebSharper in ...\"      )//.OnClick( DoP  compileRun        ()      ).Disabled(disableWebSharperVal)\n    let actParseCode      = Template.Action.New(\"Parse F#\"                   ).OnClick( Do   getJSCodeA        ()      )//.Disabled(disableParseVal     )\n    let actCompileWS      = Template.Action.New(\"Compile WebSharper\"         )//.OnClick( DoW  justCompile       ()      ).Disabled(disableWebSharperVal)\n    let actFindDefinition = Template.Action.New(\"Find Definition\"            )//.OnClick( Do   gotoDefinition    ()      ).Disabled(disableParseVal     )\n    let actRefreshEditor  = Template.Action.New(\"Refresh CodeMirror\"         )//.OnClick( Do   refreshCodeMirror ()      )\n    let actOutText        = Template.Action.New(\"Show Output text\"           )//.OnClick2(Do2  showOutText       ()      )\n    let actAbortFsi       = Template.Action.New(\"Abort FSI\"                  )//.OnClick( Do   abortFsiExe       ()      )\n         \n    let buttonsH =\n        TemplateLib.Buttons()\n            .AddCalculation( fun _ -> AddCalculation |> processor                  )\n            .AddTotal(       fun _ -> AddTotal       |> processor                  )\n            .Parse(          fun _ -> getJSCodeA()                                 )\n            .GetFSCode(      fun _ -> getFSCodeA()                                 )\n            .UpdateRules(    fun _ -> updateRules() |> Wrap.toAsync |> Async.Start )\n            .SaveAs(         fun _ -> downloadFile()                               )\n            .LoadFileChanged(fun e -> loadFile e.Target                            )\n            .LoadFileClear(  fun e -> e.Target?value <- \"\"                         )\n            .IndentIn(       fun _ -> selAsChild () |> Option.bind (fun ch -> tryFindSiblingTotal model ch |> Option.map(fun p -> p.id, ch, Add)) |> Option.iter(AddChild    >> processor))\n            .IndentOut(      fun _ -> selAsChild ()                                                          |> Option.iter(RemoveChild >> processor))\n            .Doc() |> SomeDoc\n\n    let buttonsHOld =\n        div [ \n              actAddCalculation.Button.Render\n              actOutdentSnippet.Button.Render\n              actIndentSnippet .Button.Render\n              loadFileElement         .Render.AddChildren([ style \"grid-column: 4/6\" ])\n              actEvalCode      .Button.Render\n              actFableCode     .Button.Render\n              actRunWSIn       .Button.Render\n    \n              actDeleteSnippet .Button.Render\n              actFindDefinition.Button.Render\n              span []       \n              actSaveFile      .Button.Render\n              span []       \n              actGetFsCode     .Button.Render\n              actParseCode     .Button.Render\n              //Doc.Select [ attr.id \"Position\" ] positionTxt [ NewBrowser ; Below ] position |> someElt\n    \n              style \"\"\"\n                  overflow: hidden;\n                  display: grid;\n                  grid-template-columns: repeat(8, 12.1%);\n                  bxackground-color: #eee;\n                  padding : 5px;\n                  grid-gap: 5px;\n              \"\"\"\n            ]\n    \n    let menuLeft =\n        Menu.New2\n          [\n            MenuEntry.New(\"File\")\n                .SubMenu(\n                        [\n                            //actLoadFile.MenuEntry\n                            actSaveFile.MenuEntry\n                        ]           \n                )            \n            MenuEntry.New(\"Code\")           \n                .SubMenu(           \n                        [           \n                            actAddCalculation.MenuEntry\n                            actDeleteSnippet .MenuEntry\n                            MenuEntry.New(\"\").Divider           \n                            actIndentSnippet .MenuEntry\n                            actOutdentSnippet.MenuEntry\n                            MenuEntry.New(\"\").Divider           \n                            actFindDefinition.MenuEntry\n                            MenuEntry.New(\"\").Divider           \n                            actGetFsCode     .MenuEntry\n                            MenuEntry.New(\"\").Divider           \n                            actRefreshEditor .MenuEntry\n                        ]     \n                )      \n            MenuEntry.New(\"Run\")     \n                .SubMenu(     \n                        [     \n                            actEvalCode      .MenuEntry\n                            actAbortFsi      .MenuEntry\n                            MenuEntry.New(\"\").Divider     \n                            actFableCode     .MenuEntry\n                            MenuEntry.New(\"\").Divider     \n                            actRunWSNewTab   .MenuEntry\n                            actRunWSHere     .MenuEntry\n                            MenuEntry.New(\"\").Divider     \n                            actParseCode     .MenuEntry\n                            actCompileWS     .MenuEntry\n                        ]\n                ) \n          ]\n    \n    let menuRight =\n        Menu.New2\n          [\n            MenuEntry.New(\"About\")\n                .SubMenu [\n                    MenuEntry.New(\"Source @ GitHub\", \"https://github.com/amieres/FSharpStation\").Target \"_blank\"\n                ]\n          ]      \n    \n    let menuBar =\n        navbar <| h1 [ htmlText \"Rule Editor\" ; style \"font-size: 48px; margin-top: -17px\" ]\n               <| menuLeft .Render \n               <| menuRight.Render\n    ()","parent":{"$":0,"Item":"be49e291-252c-4064-a3d6-bc61b39895fa"},"predecessors":[{"$":0,"Item":"1da05dcf-8d1b-4f21-b570-389d3e1030b2"},{"$":0,"Item":"dd65606a-9194-4699-8c83-25dd52970a44"},{"$":0,"Item":"e01c4aa8-1574-4de8-8d1f-856c822592af"},{"$":0,"Item":"a6966f1d-4d4c-4ac2-be2d-7aeb76e2e2e2"},{"$":0,"Item":"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"}],"id":{"$":0,"Item":"f74e568b-473d-4f0e-a38a-ad8c70d05abb"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Layout","content":"  \n    let calculations      = renderTable        processor model\n    let calcDetail        = renderDetail       processor model\n    let dimsSelected      = renderDimsSelected processor model\n    let dimensions        = renderDimensions   processor model\n    let globalDefinitions = renderGlobalDefs   processor model\n    Layout.AddGuids\n      [|\n          //\"actLoadFile\"       , GuiAction actLoadFile      \n          \"actSaveFile\"       , GuiAction actSaveFile      \n          \"actAddCalculation\" , GuiAction actAddCalculation\n          \"actDeleteSnippet\"  , GuiAction actDeleteSnippet \n          \"actIndentSnippet\"  , GuiAction actIndentSnippet \n          \"actOutdentSnippet\" , GuiAction actOutdentSnippet\n          \"actGetFsCode\"      , GuiAction actGetFsCode     \n          \"actSetSnippetProp\" , GuiAction actSetSnippetProp\n          \"actEvalFsCode\"     , GuiAction actEvalFsCode\n          \"actEvalCode\"       , GuiAction actEvalCode\n          \"actRunFableFs\"     , GuiAction actFableFsCode\n          \"actRunFable\"       , GuiAction actFableCode\n          \"actRunWSNewTab\"    , GuiAction actRunWSNewTab   \n          \"actRunWSHere\"      , GuiAction actRunWSHere     \n          \"actRunWSIn\"        , GuiAction actRunWSIn       \n          \"actParseCode\"      , GuiAction actParseCode     \n          \"actCompileWS\"      , GuiAction actCompileWS     \n          \"actFindDefinition\" , GuiAction actFindDefinition    \n          \"actOutText\"        , GuiAction actOutText\n          \"Output\"            , GuiNode <| div [ TemplateLib.Output().Var(outputMsgs)                   .Doc() |> SomeDoc ]\n          \"Parser\"            , GuiNode <| div [ TemplateLib.Parser().Var(parserMsgs).JumpRef(jumpToRef).Doc() |> SomeDoc ] \n          \"F# code\"           , GuiNode <| div [ TemplateLib.FSCode().Var(codeFS    )                   .Doc() |> SomeDoc ] \n          //\"Properties\"        , GuiNode <| properties    \n          \"Dimensions\"        , GuiNode dimensions\n          \"Dimensionality\"    , GuiNode dimsSelected\n          \"Global\"            , GuiNode globalDefinitions\n          //\"title\"             , GuiNode <| Template.Input.New(Val.bindIRef curSnippetNameOf currentCodeSnippetId).Prefix(htmlText \"name:\").Render\n          //\"code\"              , GuiNode <| codeMirrorRender\n          //\"snippets\"          , GuiNode <| snippetList\n          \"calculations\"      , GuiNode <| calculations\n          \"calcDetail\"        , GuiNode <| calcDetail\n          \"buttons\"           , GuiNode <| buttonsH\n          \"menu\"              , GuiNode <| HtmlEmpty //menuBar\n          \"messagesR\"         , GuiTabStrip(     true ,  [| \"Dimensionality\" \n                                                            \"Dimensions\"     \n                                                            \"Global\"         |])\n          \"messagesB1\"        , GuiTabStrip(     true ,  [| \"Output\"    \n                                                            \"F# code\"        |])\n          \"messagesB2\"        , GuiTabStrip(     true ,  [| \"Parser\"         |])\n          \"messagesB\"         , varVerSplitter          55.0 \"messagesB1\"    \"messagesB2\"     0.0 100.0             \n          \"title_code\"        , fixedHorSplitter true   34.0 \"title\"         \"code\"\n          \"calc-detail\"       , varHorSplitter          65.0 \"calculations\"  \"calcDetail\"    25.0  90.0\n          \"code_props\"        , varVerSplitter          85.0 \"calc-detail\"   \"messagesR\"     25.0 100.0\n          \"code_buttons\"      , fixedHorSplitter false  80.0 \"code_props\"    \"buttons\"\n          \"snippets_code\"     , varVerSplitter          00.0 \"snippets\"      \"code_buttons\"   0.0  95.0\n          \"main_messages\"     , varHorSplitter          82.0 \"snippets_code\" \"messagesB\"     35.0 100.0             \n          \"extrabuttons\"      , GuiNode <| div []\n          \"main_extra\"        , varVerSplitter         100.0 \"main_messages\" \"extrabuttons\"  20.0 100.0\n          \"main\"              , fixedHorSplitter true   50.0 \"menu\"          \"main_extra\"\n      |]   \n  \nlet layout() = Layout.New <| steps()\n  ","parent":{"$":0,"Item":"be49e291-252c-4064-a3d6-bc61b39895fa"},"predecessors":[{"$":0,"Item":"1da05dcf-8d1b-4f21-b570-389d3e1030b2"},{"$":0,"Item":"dd65606a-9194-4699-8c83-25dd52970a44"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"f74e568b-473d-4f0e-a38a-ad8c70d05abb"}],"id":{"$":0,"Item":"df220a82-0d24-4992-ba0c-4e043b9c596d"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"init","content":"module init =\n    model.globalDefs.Value <-\n        unindentStr \"\"\"\n                let Value                    = DataType.[\"Value\"]\n                let For_NoSeasonal           = [ Season?(\"21\")     ; Value ]\n                let For_FallWinterM1         = [ Season?(\"07\")     ; Value ]\n                let For_SeasonCarryOver      = [ Season?(\"19\")     ; Value ]\n                let For_NoSeasonalThirdParty =   Brand?(\"06\") :: For_NoSeasonal\n                \n                let isOutlet                  = SUBST(!CostCenter, 2, 1) &= \"O\"\n                let isThirdParty              = DE_ISCHILD(Product, \"TP\", !Product)\n                let isFallWinterM1            = !Season &= \"07\"\n                let isSeasonCarryOver         = !Season &= \"19\"\n            \"\"\"\n\n    let        withTypeC    t         c = { c with typeC     = t                          }\n    let inline withName    (n:string) c = { c with name      = n.Trim().Replace(\"_\", \" \") }\n    let        withDims   ds         (c:Calculation) =\n        ds |> Seq.iter (fun (d:Dimension) -> \n            model.calcDims.Value <- model.calcDims.Value |> Set.add (c.id, d.id)\n        )\n        c\n    \n    let        withDimName (n:string) d = { d with dimension   = n.Trim().Replace(\"_\", \" \") }\n    let        withExclude  x         d = { d with excludeCube = x                          }\n    let        withDimType dt d = { d with dimType = dt }\n    \n    let TCalc      = newDimension() |> withDimType DtTCalc     |> withDimName \"TCalc\"     |> withExclude true\n    let DataType   = newDimension() |> withDimType DtDataType  |> withDimName \"DataType\"  |> withExclude true\n    let Version    = newDimension() |> withDimType DtVersion   |> withDimName \"Version\"   |> withExclude true\n    let Year       = newDimension() |> withDimType DtTime      |> withDimName \"Year\"      |> withExclude true\n    let Price      = newDimension() |> withDimType DtOther     |> withDimName \"Price\"     \n    let Brand      = newDimension() |> withDimType DtOther     |> withDimName \"Brand\"     \n    let Product    = newDimension() |> withDimType DtOther     |> withDimName \"Product\"   \n    let Season     = newDimension() |> withDimType DtOther     |> withDimName \"Season\"    \n    let CostCenter = newDimension() |> withDimType DtOther     |> withDimName \"CostCenter\"\n    let Account    = newDimension() |> withDimType DtOther     |> withDimName \"Account\"   \n    \n    model.dimensions.AppendMany [\n        TCalc     \n        DataType  \n        Version   \n        Year      \n        Price     \n        Brand     \n        Product   \n        Season    \n        CostCenter\n        Account   \n    ]\n    \n    let comb1 = [ Version; DataType; Price; Brand; Product; Season; CostCenter; Account ]    \n        \n    let Sales_by_Brand                           = newCalculation() |> withTypeC Input |> withName \"Sales_by_Brand                           \" |> withDims comb1\n    let FP_vs_MD_Perc                            = newCalculation() |> withTypeC Input |> withName \"FP_vs_MD_Perc                            \" |> withDims comb1\n    let Sales_by_Brand_Price                     = newCalculation() |> withTypeC  Calc |> withName \"Sales_by_Brand_Price                     \" |> withDims comb1\n    let Gross_Perc                               = newCalculation() |> withTypeC Input |> withName \"Gross_Perc                               \" |> withDims comb1\n    let Gross_Sales_by_Brand_Price               = newCalculation() |> withTypeC  Calc |> withName \"Gross_Sales_by_Brand_Price               \" |> withDims comb1\n    let Seasonal_Allocation                      = newCalculation() |> withTypeC Input |> withName \"Seasonal_Allocation                      \" |> withDims comb1\n    let Seasonal_Allocation_2                    = newCalculation() |> withTypeC  Calc |> withName \"Seasonal_Allocation_2                    \" |> withDims comb1\n    let Seasonal_Allocation_Outlet               = newCalculation() |> withTypeC Input |> withName \"Seasonal_Allocation_Outlet               \" |> withDims comb1\n    let Discount                                 = newCalculation() |> withTypeC Input |> withName \"Discount                                 \" |> withDims comb1\n    let Sales_by_Season                          = newCalculation() |> withTypeC  Calc |> withName \"Sales_by_Season                          \" |> withDims comb1\n    let Net_Sales_by_Season                      = newCalculation() |> withTypeC  Calc |> withName \"Net_Sales_by_Season                      \" |> withDims comb1\n    let Markup                                   = newCalculation() |> withTypeC  Calc |> withName \"Markup                                   \" |> withDims comb1\n    let Seasonal_Cost_Factor                     = newCalculation() |> withTypeC Input |> withName \"Seasonal_Cost_Factor                     \" |> withDims comb1\n    let COGS                                     = newCalculation() |> withTypeC  Calc |> withName \"COGS                                     \" |> withDims comb1\n    let Inventory_Beginning                      = newCalculation() |> withTypeC  Calc |> withName \"Inventory_Beginning                      \" |> withDims comb1\n    let Average_Price                            = newCalculation() |> withTypeC Input |> withName \"Average_Price                            \" |> withDims comb1\n    let Inventory_Beginning_Quantity             = newCalculation() |> withTypeC  Calc |> withName \"Inventory_Beginning_Quantity             \" |> withDims comb1\n    let Inventory_Transfer_IN                    = newCalculation() |> withTypeC  Calc |> withName \"Inventory_Transfer_IN                    \" |> withDims comb1\n    let Purchases                                = newCalculation() |> withTypeC  Calc |> withName \"Purchases                                \" |> withDims comb1\n    let Inventory_Transfer_OUT                   = newCalculation() |> withTypeC  Calc |> withName \"Inventory_Transfer_OUT                   \" |> withDims comb1\n    let Sell_Through                             = newCalculation() |> withTypeC Input |> withName \"Sell_Through                             \" |> withDims comb1\n    let Purchases_Timing_Perc                    = newCalculation() |> withTypeC Input |> withName \"Purchases_Timing_Perc                    \" |> withDims comb1\n    let Total_Stock                              = newCalculation() |> withTypeC  Calc |> withName \"Total_Stock                              \" |> withDims comb1\n    let Inventory_Ending                         = newCalculation() |> withTypeC  Calc |> withName \"Inventory_Ending                         \" |> withDims comb1\n    let VAT_Rate_Sales_Tax                       = newCalculation() |> withTypeC Input |> withName \"VAT_Rate_Sales_Tax                       \" |> withDims comb1\n    let Selling_Squared_meters                   = newCalculation() |> withTypeC Input |> withName \"Selling_Squared_meters                   \" |> withDims comb1\n    let Net_Squared_meters                       = newCalculation() |> withTypeC Input |> withName \"Net_Squared_meters                       \" |> withDims comb1\n    let Gross_Squared_Meters                     = newCalculation() |> withTypeC Input |> withName \"Gross_Squared_Meters                     \" |> withDims comb1\n    let CAPEX                                    = newCalculation() |> withTypeC Input |> withName \"CAPEX                                    \" |> withDims comb1\n    let CASHOUT                                  = newCalculation() |> withTypeC Input |> withName \"CASHOUT                                  \" |> withDims comb1\n    let Landed_Factor_Custom_Duties              = newCalculation() |> withTypeC Input |> withName \"Landed_Factor_Custom_Duties              \" |> withDims comb1\n    let Landed_Factor_Insurance                  = newCalculation() |> withTypeC Input |> withName \"Landed_Factor_Insurance                  \" |> withDims comb1\n    let Landed_Factor_Freight                    = newCalculation() |> withTypeC Input |> withName \"Landed_Factor_Freight                    \" |> withDims comb1\n    let Net_Sales_Stockist                       = newCalculation() |> withTypeC Input |> withName \"Net_Sales_Stockist                       \" |> withDims comb1\n    let Net_Sales_Inter_Company                  = newCalculation() |> withTypeC Input |> withName \"Net_Sales_Inter_Company                  \" |> withDims comb1\n    let PercNet_Sales_Full_Price                 = newCalculation() |> withTypeC  Calc |> withName \"PercNet_Sales_Full_Price                 \" |> withDims comb1\n    let PercNet_Sales_Markdown                   = newCalculation() |> withTypeC  Calc |> withName \"PercNet_Sales_Markdown                   \" |> withDims comb1\n    let PercNet_Sales_Stockist                   = newCalculation() |> withTypeC  Calc |> withName \"PercNet_Sales_Stockist                   \" |> withDims comb1\n    let PercNet_Sales_InterCompany               = newCalculation() |> withTypeC  Calc |> withName \"PercNet_Sales_InterCompany               \" |> withDims comb1\n    let Average_Sales_Price_Full_Price           = newCalculation() |> withTypeC Input |> withName \"Average_Sales_Price_Full_Price           \" |> withDims comb1\n    let Average_Sales_Price_Markdown             = newCalculation() |> withTypeC Input |> withName \"Average_Sales_Price_Markdown             \" |> withDims comb1\n    let Average_Sales_Price_Stockist             = newCalculation() |> withTypeC Input |> withName \"Average_Sales_Price_Stockist             \" |> withDims comb1\n    let Average_Sales_Price_Intercompany         = newCalculation() |> withTypeC Input |> withName \"Average_Sales_Price_Intercompany         \" |> withDims comb1\n    let Mark_Up_Boutique                         = newCalculation() |> withTypeC  Calc |> withName \"Mark_Up_Boutique                         \" |> withDims comb1\n    let Mark_Up_Outlet                           = newCalculation() |> withTypeC  Calc |> withName \"Mark_Up_Outlet                           \" |> withDims comb1\n    let Custom_Duties_Beginning_Inventory        = newCalculation() |> withTypeC Input |> withName \"Custom_Duties_Beginning_Inventory        \" |> withDims comb1\n    let Freight_Beginning_Inventory              = newCalculation() |> withTypeC Input |> withName \"Freight_Beginning_Inventory              \" |> withDims comb1\n    let Insurance_Beginning_Inventory            = newCalculation() |> withTypeC Input |> withName \"Insurance_Beginning_Inventory            \" |> withDims comb1\n    let Index_Perc                               = newCalculation() |> withTypeC Input |> withName \"Index_Perc                               \" |> withDims comb1\n    let Depreciation_IC_Initial_Provision        = newCalculation() |> withTypeC Input |> withName \"Depreciation_IC_Initial_Provision        \" |> withDims comb1\n    let Depreciation_IC_Final_Provision          = newCalculation() |> withTypeC Input |> withName \"Depreciation_IC_Final_Provision          \" |> withDims comb1\n    let Depreciation_TP_Initial_Provision        = newCalculation() |> withTypeC Input |> withName \"Depreciation_TP_Initial_Provision        \" |> withDims comb1\n    let Depreciation_TP_Final_Provision          = newCalculation() |> withTypeC Input |> withName \"Depreciation_TP_Final_Provision          \" |> withDims comb1\n    let Depreciation_IC_Initial_Provision_Factor = newCalculation() |> withTypeC  Calc |> withName \"Depreciation_IC_Initial_Provision_Factor \" |> withDims comb1\n    let Depreciation_IC_Final_Provision_Factor   = newCalculation() |> withTypeC  Calc |> withName \"Depreciation_IC_Final_Provision_Factor   \" |> withDims comb1\n    let Depreciation_TP_Initial_Provision_Factor = newCalculation() |> withTypeC  Calc |> withName \"Depreciation_TP_Initial_Provision_Factor \" |> withDims comb1\n    let Depreciation_TP_Final_Provision_Factor   = newCalculation() |> withTypeC  Calc |> withName \"Depreciation_TP_Final_Provision_Factor   \" |> withDims comb1\n    let Depreciation_Beginning                   = newCalculation() |> withTypeC  Calc |> withName \"Depreciation_Beginning                   \" |> withDims comb1\n    let Depreciation_Ending                      = newCalculation() |> withTypeC  Calc |> withName \"Depreciation_Ending                      \" |> withDims comb1\n    let Depreciation_Change                      = newCalculation() |> withTypeC  Calc |> withName \"Depreciation_Change                      \" |> withDims comb1\n    let AMOUNT                                   = newCalculation() |> withTypeC  Calc |> withName \"AMOUNT                                   \" |> withDims comb1\n    \n    model.calculations.AppendMany [\n         Sales_by_Brand                           \n         FP_vs_MD_Perc                            \n         Sales_by_Brand_Price                     \n         Gross_Perc                               \n         Gross_Sales_by_Brand_Price               \n         Seasonal_Allocation                      \n         Seasonal_Allocation_2                    \n         Seasonal_Allocation_Outlet               \n         Discount                                 \n         Sales_by_Season                          \n         Net_Sales_by_Season                      \n         Markup                                   \n         Seasonal_Cost_Factor                     \n         COGS                                     \n         Inventory_Beginning                      \n         Average_Price                            \n         Inventory_Beginning_Quantity             \n         Inventory_Transfer_IN                    \n         Purchases                                \n         Inventory_Transfer_OUT                   \n         Sell_Through                             \n         Purchases_Timing_Perc                    \n         Total_Stock                              \n         Inventory_Ending                         \n         VAT_Rate_Sales_Tax                       \n         Selling_Squared_meters                   \n         Net_Squared_meters                       \n         Gross_Squared_Meters                     \n         CAPEX                                    \n         CASHOUT                                  \n         Landed_Factor_Custom_Duties              \n         Landed_Factor_Insurance                  \n         Landed_Factor_Freight                    \n         Net_Sales_Stockist                       \n         Net_Sales_Inter_Company                  \n         PercNet_Sales_Full_Price                 \n         PercNet_Sales_Markdown                   \n         PercNet_Sales_Stockist                   \n         PercNet_Sales_InterCompany               \n         Average_Sales_Price_Full_Price           \n         Average_Sales_Price_Markdown             \n         Average_Sales_Price_Stockist             \n         Average_Sales_Price_Intercompany         \n         Mark_Up_Boutique                         \n         Mark_Up_Outlet                           \n         Custom_Duties_Beginning_Inventory        \n         Freight_Beginning_Inventory              \n         Insurance_Beginning_Inventory            \n         Index_Perc                               \n         Depreciation_IC_Initial_Provision        \n         Depreciation_IC_Final_Provision          \n         Depreciation_TP_Initial_Provision        \n         Depreciation_TP_Final_Provision          \n         Depreciation_IC_Initial_Provision_Factor \n         Depreciation_IC_Final_Provision_Factor   \n         Depreciation_TP_Initial_Provision_Factor \n         Depreciation_TP_Final_Provision_Factor   \n         Depreciation_Beginning                   \n         Depreciation_Ending                      \n         Depreciation_Change                      \n         AMOUNT                                   \n    ]\n    \n    let withElem (e:string) d = { d with destination = e.Trim() }\n    \n    let withDestination ds     (f:Formula) =\n        ds \n        |> Seq.map (fun (d:Dimension, elem:string) -> newDestination f.id d.id |> withElem elem)    \n        |> model.destinations.AppendMany\n        f\n    \n    let withBase   (s:string) ds f = { f with formula = s.Trim() } |> withDestination ds\n    let withConsol (s:string) ds f = { withBase s ds f with typeF = Consolidated }\n    let (?) (d:Dimension) elem = d, elem\n    let Value                  = DataType?Value\n    let For_NoSeasonal           = [ Season,(\"21\")     ; Value ]\n    let For_FallWinterM1         = [ Season,(\"07\")     ; Value ]\n    let For_SeasonCarryOver      = [ Season,(\"19\")     ; Value ]\n    let For_NoSeasonalThirdParty =  (Brand, (\"06\")) :: For_NoSeasonal\n    \n    model.formulas.AppendMany [\n        Sales_by_Brand_Price                    .id |> newFormula |> withBase   \" Sales_by_Brand * FP_vs_MD_Perc                  \" []\n    \n        FP_vs_MD_Perc                           .id |> newFormula |> withBase   \" 1 - FP_vs_MD_Perc.For[ Price?Full_Price ]       \" [ Price?Mark_Down ; Value ]\n        FP_vs_MD_Perc                           .id |> newFormula |> withBase   \" Sales_by_Brand_Price / Sales_by_Brand           \" []                                                             \n                      \n    \n        Gross_Sales_by_Brand_Price              .id |> newFormula |> withBase   \" Sales_by_Brand_Price / (1 - Gross_Perc)          \" []                                                                                           \n    \n        Seasonal_Allocation                     .id |> newFormula |> withBase   \" 1                                                \" For_NoSeasonalThirdParty\n        Seasonal_Allocation                     .id |> newFormula |> withBase   \" 1 - Seasonal_Allocation.For[ Season?Seasons ]    \" For_SeasonCarryOver     \n    \n        Seasonal_Allocation_2                   .id |> newFormula |> withBase   \" 1            \" For_NoSeasonalThirdParty      \n        Seasonal_Allocation_2                   .id |> newFormula |> withBase   \" 0.5          \" For_FallWinterM1                                    \n        Seasonal_Allocation_2                   .id |> newFormula |> withBase   \" 0.5          \" For_SeasonCarryOver                            \n        Seasonal_Allocation_2                   .id |> newFormula |> withBase   \" 0            \" []                                                                                                              \n        Seasonal_Allocation_2                   .id |> newFormula |> withBase   \" IF(isFallWinterM1 || isSeasonCarryOver, 0.5, 0) \" []\n    \n        Seasonal_Allocation_Outlet              .id |> newFormula |> withBase   \" 1 - Seasonal_Allocation_Outlet.For[ Season?Seasons2 ] \" For_NoSeasonal\n    \n        Sales_by_Season                         .id |> newFormula |> withBase   \"\"\" Sales_by_Brand_Price    \n    * IF( isOutlet                                           \n        , Seasonal_Allocation_Outlet                                           \n        , IF(!CostCenter &= \"RBUS19\"                                           \n          || !CostCenter &= \"RBUS20\"                                           \n          || !CostCenter &= \"RBUS42\"                                           \n          || !CostCenter &= \"RBUS41\"                                          \n            , Seasonal_Allocation_2                                          \n            , Seasonal_Allocation                                          \n        )                                           \n     )                                           \"\"\" []\n                                                       \n        Discount                                .id |> newFormula |> withConsol \" 1 - Sales_by_Season / Net_Sales_by_Season \" []\n                                                      \n        Net_Sales_by_Season                     .id |> newFormula |> withBase   \"  Sales_by_Season / (1 - Discount) \" []                                                                  \n                                                      \n        Markup                                  .id |> newFormula |> withBase   \" IF (isOutlet, 1.25, 2.5) \" [ Value ] \n        Markup                                  .id |> newFormula |> withConsol \" Net_Sales_by_Season / COGS   * Seasonal_Cost_Factor  \" []\n                                                      \n        COGS                                    .id |> newFormula |> withBase   \" Net_Sales_by_Season / Markup * Seasonal_Cost_Factor   \" []\n                                                                                    \n        Inventory_Beginning                     .id |> newFormula |> withBase   \" IF( isOutlet                                           \n    , NA                                          \n    , COGS \n      * (Inventory_Transfer_IN.For[ CostCenter?Outlets ]                                          \n         /  COGS.For[ CostCenter?Boutiques ]                                          \n         +  COGS.For[ CostCenter?Boutiques ] ) )                     \" For_FallWinterM1\n        Inventory_Beginning                     .id |> newFormula |> withBase   \" IF (isOutlet, COGS, COGS / 0.47 * 0.55) \" [] \n                                                                                                                               \n        Inventory_Beginning_Quantity            .id |> newFormula |> withBase   \" Inventory_Beginning / (Average_Price * Seasonal_Cost_Factor) \" []\n        Inventory_Transfer_IN                   .id |> newFormula |> withBase   \" COGS \" [ CostCenter?ROUS08 ]\n        Inventory_Transfer_IN                   .id |> newFormula |> withBase   \"  IF( isOutlet, COGS / 0.35, NA) \" For_FallWinterM1 \n        Inventory_Transfer_IN                   .id |> newFormula |> withBase   \" IF( isOutlet                                           \n    , Inventory_Transfer_OUT.For[ CostCenter?Boutiques ]               \n      * Sales_by_Brand / Sales_by_Brand.For[ CostCenter?Outlets ]               \n    , NA)     \" []\n                                                                                            \n        Purchases                               .id |> newFormula |> withBase   \" COGS * Purchases_Timing_Perc / Sell_Through \" []\n        Inventory_Transfer_OUT                  .id |> newFormula |> withBase   \" IF( isOutlet, NA, Inventory_Beginning + Purchases - COGS) \" []\n        Total_Stock                             .id |> newFormula |> withBase   \" Inventory_Beginning + Inventory_Transfer_IN - Inventory_Transfer_OUT + Purchases \" []\n        Inventory_Ending                        .id |> newFormula |> withBase   \" Total_Stock - COGS \" []\n                                                          \n        Mark_Up_Boutique                        .id |> newFormula |> withBase   \" IF(isOutlet, NA    , Markup)                                                     \" []\n        Mark_Up_Outlet                          .id |> newFormula |> withBase   \" IF(isOutlet, Markup, NA    )                                                     \"  []\n                                                          \n        Depreciation_IC_Initial_Provision_Factor.id |> newFormula |> withBase   \" IF(Depreciation_IC_Initial_Provision <= 0, 0, MAX(0, 1 - (1 - Depreciation_IC_Initial_Provision) / Index_Perc) )   \" []\n        Depreciation_IC_Final_Provision_Factor  .id |> newFormula |> withBase   \" IF(Depreciation_IC_Final_Provision   <= 0, 0, MAX(0, 1 - (1 - Depreciation_IC_Final_Provision  ) / Index_Perc) )   \" []\n        Depreciation_TP_Initial_Provision_Factor.id |> newFormula |> withBase   \" IF(Depreciation_TP_Initial_Provision <= 0, 0, MAX(0, 1 - (1 - Depreciation_TP_Initial_Provision) / Index_Perc) )   \" []\n        Depreciation_TP_Final_Provision_Factor  .id |> newFormula |> withBase   \" IF(Depreciation_TP_Final_Provision   <= 0, 0, MAX(0, 1 - (1 - Depreciation_TP_Final_Provision  ) / Index_Perc) )   \" []\n        Depreciation_Beginning                  .id |> newFormula |> withBase   \" IF(isOutlet,              \n        IF( isThirdParty              \n          , Depreciation_TP_Initial_Provision_Factor              \n          , Depreciation_IC_Initial_Provision_Factor)              \n        * Inventory_Beginning              \n    , 0) \" []\n        Depreciation_Ending                     .id |> newFormula |> withBase   \" IF(isOutlet,              \n        IF( isThirdParty              \n          , Depreciation_TP_Final_Provision_Factor              \n          , Depreciation_IC_Final_Provision_Factor)              \n        * Inventory_Ending              \n    , 0) \" []\n        Depreciation_Change                     .id |> newFormula |> withBase   \" Depreciation_Beginning - Depreciation_Ending \" []\n        \n        AMOUNT                                  .id |> newFormula |> withBase   \" Net_Sales_by_Season.For[ Price?Full_Price ; Product?All_Products ] \" [ Account?(\"BDG.002.02.FPR\") ; Product   ?ND ]\n        AMOUNT                                  .id |> newFormula |> withBase   \" Net_Sales_by_Season.For[ Price?Mark_Down  ; Product?All_Products ] \" [ Account?(\"BDG.002.02.MKD\") ; Product   ?ND ]\n        AMOUNT                                  .id |> newFormula |> withBase   \" Purchases_Timing_Perc                                              \" [ Account?(\"BDG.005.04\"    ) ; Product   ?ND ]\n        AMOUNT                                  .id |> newFormula |> withBase   \" Markup                                                             \" [ Account?(\"BDG.011.EC\"    ) ; CostCenter?ND ]\n        AMOUNT                                  .id |> newFormula |> withBase   \" IF( isOutlet, NA,  Markup)                                         \" [ Account?(\"BDG.011.W\"     ) ; CostCenter?ND ]\n    ]\n    ","parent":{"$":0,"Item":"be49e291-252c-4064-a3d6-bc61b39895fa"},"predecessors":[{"$":0,"Item":"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"}],"id":{"$":0,"Item":"80056cda-4f3b-46ee-85a9-bd085fc10ea1"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Main","content":"let main() =\n    div [\n        style \"height: 100vh; width: 100% \"\n        layout().Render.Style(\"height: 100%; width: 100% \")\n        script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                ; ``type`` \"text/javascript\" ]\n        script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"     ; ``type`` \"text/javascript\" ]\n        link   [ href \"/fontello-9bad3f16/css/checkbox.css\"                                         ; rel \"stylesheet\" ]\n        link   [ href \"/EPFileX/codemirror/content/theme/rubyblue.css\" ; ``type`` \"text/css\"        ; rel \"stylesheet\" ]    \n        style  \"\"\" \n              color      : #333;\n              font-size  : small;\n              font-family: monospace;\n              line-height: 1.2;\n               \"\"\"\n        link [ href \"/fontello-9bad3f16/css/checkbox.css\" ; rel \"stylesheet\" ]\n        \n    ] \n\n//main() |> RunCode.RunNode().RunHtml","parent":{"$":0,"Item":"be49e291-252c-4064-a3d6-bc61b39895fa"},"predecessors":[{"$":0,"Item":"e01c4aa8-1574-4de8-8d1f-856c822592af"},{"$":0,"Item":"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"},{"$":0,"Item":"1f1aa135-fd74-42cc-b9a5-87f380c113a9"},{"$":0,"Item":"df220a82-0d24-4992-ba0c-4e043b9c596d"}],"id":{"$":0,"Item":"a603acee-c77c-4720-9158-0aa9b96c18be"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableWebSharper":"0"}},{"name":"RuleEditor","content":"#define FSS_SERVER\n#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net45\\Microsoft.Owin.Hosting.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net45\\Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net45\\Microsoft.Owin.StaticFiles.dll\"\n#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net45\\Microsoft.Owin.FileSystems.dll\"\n\nopen WebSharper.Sitelets\nopen WebSharper.UI.Html\n\n[< JavaScript false >]\nmodule server =\n    open WebSharper.UI.Server\n    open WebSharper.UI.Templating\n    \n    type EndPoint = | [< EndPoint \"/\" >] EP\n    \n    let content (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n        Content.Page(Title = \"Main Page\" \n                   , Body = [\n                       Html.client <@  main() |> renderDoc @> \n                       Doc.Verbatim (System.IO.File.ReadAllText TemplatesFileName)\n                     ])\n    \n    open global.Owin\n    open WebSharper.Owin\n    open Microsoft.Owin.Hosting\n    open Microsoft.Owin.StaticFiles\n    open Microsoft.Owin.FileSystems\n    open WebSharper.Owin.WebSocket\n    open WSMessagingBroker\n    \n    let url         = \"http://localhost:9040/\"\n    let epWebSocket = Endpoint.Create(url, \"/ws\", JsonEncoding.Readable)\n    let brokerAgent = Broker.BrokerAgent epWebSocket\n    //Broker.BrokerAgent.FssWebSocketO <- Some brokerAgent\n    [< EntryPoint >]\n    let Main args =\n        use server = \n            WebApp.Start(url, fun appB ->\n                appB.UseWebSharper(WebSharperOptions(ServerRootDirectory = \"website\"\n                                                   , Sitelet             = Some (Application.MultiPage content)\n                                                   , BinDirectory        = \".\"\n                                                   , Debug               = true))\n                    .UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(\"website\")))\n                    .UseWebSocket(epWebSocket, brokerAgent.Start, maxMessageSize = 1_000_000)\n                |> ignore\n            )\n        stdout.WriteLine(\"Starting, hit enter to finish\")\n        stdin.ReadLine() |> ignore\n        0\n    \n    ","parent":{"$":0,"Item":"be49e291-252c-4064-a3d6-bc61b39895fa"},"predecessors":[{"$":0,"Item":"e137b990-172b-4879-bc74-8650123b7a5d"},{"$":0,"Item":"a603acee-c77c-4720-9158-0aa9b96c18be"}],"id":{"$":0,"Item":"e8ed4b6d-8930-46e8-ada3-663f0d90fe13"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"compile & run RuleEditor","content":"open System.IO\nopen WSMessagingBroker\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.CompOptionsModule\nopen RunProcess\n\nWrap.wrapper {\n    let  options         = compileOptionsExeDebug \"FSSGlobal/WebSharper Code/Calculation Editor Code/RuleEditor\"\n                           + siteOptions + (opGenInternal /= \"showoptions\")\n    let  exeFile         = options?OutputFile\n    let  workDir         = options?Directory\n    let  site            = Path.GetFullPath(options?Website)\n    let! res             = FStationMessaging(\"Compile WebSharper\", FSharp).CompileSnippetW options\n    do   printfn           \"Starting %s\"     exeFile\n    let  url             = @\"http://localhost:9040/\"\n    let  parms           = sprintf \"%A %A\" site url \n    do   startProcessDir   exeFile parms workDir |> ignore\n    do   startProcess      url     \"\"            |> ignore\n    return res\n} |> Wrap.runSynchronouslyS true |> printfn \"%s\"\n","parent":{"$":0,"Item":"be49e291-252c-4064-a3d6-bc61b39895fa"},"predecessors":[{"$":0,"Item":"d9c4540a-85f5-4c62-91be-fcb2d60e9f17"}],"id":{"$":0,"Item":"bf6c3b8a-e25f-41ac-be85-fc2563b1da77"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableFSI":"0"}},{"name":"////Deserialize","content":"\n\nlet desArr f v = v |> ifUndef [||] |> Array.choose f\n\n[< Inline >]\nlet inline ifUndefT<'T> def v = if isUndefined v then def else sprintf \"{\\\"type\\\":%A}\" v?``type`` |> Json.Deserialize<'T>\n\nlet deserializeGuid f o = \n    if isUndefined o then\n        System.Guid(\"00000000-0000-0000-0000-000000000000\")\n    else\n        o?Item\n    |> f\n\nlet obj2Map o =\n    let dict = System.Collections.Generic.Dictionary<string, string>()\n    if isUndefined o then\n        dict\n    else\n        JS.GetFields o |> Array.map (fun (f, v) -> f, v :?> string ) |> Seq.iter dict.Add\n        dict\n\nlet deserializeDimension o =\n    printfn \"Dimension: %A\" o\n    try\n        if isUndefined o then None else\n        {\n           id            = o?id            |> deserializeGuid DimId\n           dimension     = o?dimension     |> ifUndef \"\"   \n           abbreviation  = o?abbreviation  |> ifUndef \"\"   \n           order         = o?order         |> ifUndef \"\"   \n           excludeCube   = o?excludeCube   |> ifUndef false\n           includeFreeze = o?includeFreeze |> ifUndef false    \n           dimType       = o?dimType       |> ifUndefT DtOther\n        } |> Some\n    with _ -> None\n\nlet deserializeFormula o = \n    try\n        if isUndefined o then None else\n        {\n           id         = o?id         |> deserializeGuid FormId\n           idCalc     = o?idCalc     |> deserializeGuid CalcId\n           formula    = o?formula    |> ifUndef \"\"\n           typeF      = o?typeF      |> ifUndef Base\n           order      = o?order      |> ifUndef \"\"\n           alsoActual = o?alsoActual |> ifUndef false\n        } |> Some\n    with _ -> None\n\nlet deserializeCalculation o = \n    try\n        if isUndefined o then None else\n        {\n           id        = o?id        |> deserializeGuid CalcId\n           name      = o?name      |> ifUndef \"\"\n           typeC     = o?typeC     |> ifUndef Input\n           order     = o?order     |> ifUndef \"\"\n           isText    = o?isText    |> ifUndef false\n           isBalance = o?isBalance |> ifUndef false\n           format    = o?format    |> ifUndef \"0,000\"\n        } |> Some\n    with _ -> None\n\nlet deserializeDestination o = \n    try\n        if isUndefined o then None else\n        {\n           idForm      = o?idForm       |> deserializeGuid FormId\n           idDim       = o?idDim        |> deserializeGuid DimId\n           destination = o?destination  |> ifUndef \"\"   \n        } |> Some\n    with _ -> None\n\nlet setModel models =\n    model.dimensions  .Set    ( models?dimensions   |> desArr deserializeDimension   )\n    model.calculations.Set    ( models?calculations |> desArr deserializeCalculation )\n    model.formulas    .Set    ( models?formulas     |> desArr deserializeFormula     )\n    model.destinations.Set    ( models?destinations |> desArr deserializeDestination )\n    model.calcDims    .Value <- models?calcDims     |> ifUndef Array.empty |> Array.map (fun (a,b) -> deserializeGuid CalcId a, deserializeGuid DimId b) |> Set\n    model.cubeDims    .Value <- models?cubeDims     |> ifUndef Array.empty |> Array.map (fun (a,b) -> deserializeGuid CubeId a, deserializeGuid DimId b) |> Set\n    model.globalDefs  .Value <- models?globalDefs   |> ifUndef \"\"\n    model.server      .Value <- models?server       |> ifUndef \"\"\n","parent":{"$":0,"Item":"be49e291-252c-4064-a3d6-bc61b39895fa"},"predecessors":[{"$":0,"Item":"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"}],"id":{"$":0,"Item":"f9904d88-58cb-4f2e-a9fc-a2e2a73808ec"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Fable Code","content":"","parent":{"$":0,"Item":"bf864f3c-1370-42f2-ac8a-565a604892e8"},"predecessors":[],"id":{"$":0,"Item":"ba90a7d3-7af6-4637-a92f-5d30657d63f2"},"expanded":false,"level":0,"levelCode":0,"properties":{"Theme":"paraiso-dark","DisableFSI":"1","DisableWebSharper":"1"}},{"name":"Layout","content":"module Layout =\n","parent":{"$":0,"Item":"ba90a7d3-7af6-4637-a92f-5d30657d63f2"},"predecessors":[],"id":{"$":0,"Item":"f936b296-080b-45ce-a242-f6eea88ec459"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Eval","content":"#r \"..\\packages\\Fable.Core\\lib\\netstandard1.6\\Fable.Core.dll\"\n\nopen Fable.Core\nopen Fable.Core.JsInterop\n\n[< Emit \"document.getElementById($0).shadowRoot.firstElementChild.firstElementChild.firstElementChild.contentWindow.eval($1) \" >]\nlet evalInContext (tnode:string) (code:string) : obj = 0 :> obj\n\n[< Emit \"eval($0) \" >]\nlet eval                         (code:string) : obj = 0 :> obj\n\nlet evalCode (nodeO: string option) code =\n    try \n        match nodeO with\n        | Some node -> evalInContext node code\n        | None      -> eval code\n        |> unbox<obj option> |> Option.iter (printfn \"%A\")\n    with e -> printfn \"Error: %s\" e.StackTrace\n\n","parent":{"$":0,"Item":"f936b296-080b-45ce-a242-f6eea88ec459"},"predecessors":[],"id":{"$":0,"Item":"67ac26db-54cb-46df-a1b8-c6e5856d4b1c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"HtmlNode","content":"type HtmlNodeFable =\n    | HtmlElementF    of name: string * children: HtmlNodeFable seq\n    | HtmlAttributeF  of name: string * value:    string\n    | HtmlAttributeOF of name: string * value:    string option\n    | HtmlTextF       of string\n    | HtmlEmptyF\n    | HtmlGuiPart     of string\n    | HtmlGuiCall     of name: string * action: string * parms: string[]\n\nlet inline htmlElement    name ch = HtmlElementF   (name, ch )\nlet inline htmlAttribute  name v  = HtmlAttributeF (name, v  )\nlet inline htmlAttributeO name v  = HtmlAttributeOF(name, v  )\nlet inline HtmlText       txt     = HtmlTextF       txt\n\nlet inline a           ch = htmlElement   \"a\"           ch\nlet inline ul          ch = htmlElement   \"ul\"          ch\nlet inline li          ch = htmlElement   \"li\"          ch\nlet inline br          ch = htmlElement   \"br\"          ch\nlet inline hr          ch = htmlElement   \"hr\"          ch\nlet inline h1          ch = htmlElement   \"h1\"          ch\nlet inline h2          ch = htmlElement   \"h2\"          ch\nlet inline h3          ch = htmlElement   \"h3\"          ch\nlet inline h4          ch = htmlElement   \"h4\"          ch\nlet inline h5          ch = htmlElement   \"h5\"          ch\nlet inline h6          ch = htmlElement   \"h6\"          ch\nlet inline div         ch = htmlElement   \"div\"         ch\nlet inline img         ch = htmlElement   \"img\"         ch\nlet inline span        ch = htmlElement   \"span\"        ch\nlet inline form        ch = htmlElement   \"form\"        ch\nlet inline table       ch = htmlElement   \"table\"       ch\nlet inline thead       ch = htmlElement   \"thead\"       ch\nlet inline th          ch = htmlElement   \"th\"          ch\nlet inline tr          ch = htmlElement   \"tr\"          ch\nlet inline td          ch = htmlElement   \"td\"          ch\nlet inline tbody       ch = htmlElement   \"tbody\"       ch\nlet inline label       ch = htmlElement   \"label\"       ch\nlet inline button      ch = htmlElement   \"button\"      ch\nlet inline script      sc = htmlElement   \"script\"      sc\nlet inline styleH      st = htmlElement   \"style\"       st\nlet inline fieldset    ch = htmlElement   \"fieldset\"    ch\nlet inline link        sc = htmlElement   \"link\"        sc\nlet inline iframe      at = htmlElement   \"iframe\"      at\nlet inline body        ch = htmlElement   \"body\"        ch\n\n\nlet inline target      v  = htmlAttribute  \"target\"      v\nlet inline href        v  = htmlAttribute  \"href\"        v\nlet inline hrefO       vO = htmlAttributeO \"href\"        vO\nlet inline rel         v  = htmlAttribute  \"rel\"         v\nlet inline charset     v  = htmlAttribute  \"charset\"     v\nlet inline src         v  = htmlAttribute  \"src\"         v\nlet inline ``class``   v  = htmlAttribute  \"class\"       v\nlet inline ``type``    v  = htmlAttribute  \"type\"        v\nlet inline width       v  = htmlAttribute  \"width\"       v\nlet inline title       v  = htmlAttribute  \"title\"       v\nlet inline Id          v  = htmlAttribute  \"id\"          v\nlet inline frameborder v  = htmlAttribute  \"frameborder\" v\nlet inline spellcheck  v  = htmlAttribute  \"spellcheck\"  v\nlet inline draggable   v  = htmlAttribute  \"draggable\"   v\nlet inline style       v  = htmlAttribute  \"style\"       v\nlet inline onclick     v  = htmlAttribute  \"onclick\"     v\n\nlet inline css         v  = styleH [ HtmlText v ] \n","parent":{"$":0,"Item":"f936b296-080b-45ce-a242-f6eea88ec459"},"predecessors":[],"id":{"$":0,"Item":"f142ff32-fb36-408b-86b6-c0a09b020136"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Layout ","content":"#r \"..\\packages\\Fable.Core\\lib\\netstandard1.6\\Fable.Core.dll\"\n#r \"..\\packages\\Fable.Import.Browser\\lib\\netstandard1.6\\Fable.Import.Browser.dll\"\n\nopen Fable.Core\nopen Fable.Core.JsInterop\n\nmodule Option =\n    let defaultValue v =\n        function\n        | Some x  -> x\n        | None    -> v\n    let defaultWith  f =\n        function\n        | Some x  -> x\n        | None    -> f()\n\ntype SectionType =\n    | StVariable\n    | StFixedPx\n    | StFixedPerc\n\ntype GuiPart = \n   | GuiRoot       of string\n   | GuiNode       of HtmlNodeFable\n   | GuiAction \n   | GuiSplit      of first: bool * secT: SectionType * vertical: bool * per:float * string * string * min: float * max: float\n   | GuiTabStrip   of top  : bool * string []\n   | GuiCall       of name: string * action: string * parms: obj[]\n\n\nlet actLoadFile       = \"actLoadFile\"\nlet actSaveFile       = \"actSaveFile\"\nlet actAddSnippet     = \"actAddSnippet\"\nlet actDeleteSnippet  = \"actDeleteSnippet\"\nlet actIndentSnippet  = \"actIndentSnippet\"\nlet actOutdentSnippet = \"actOutdentSnippet\"\nlet actGetFsCode      = \"actGetFsCode\"\nlet actEvalFsCode     = \"actEvalFsCode\"\nlet actEvalCode       = \"actEvalCode\"\nlet actRunFableFs     = \"actRunFableFs\"\nlet actRunFable       = \"actRunFable\"\nlet actRunWSNewTab    = \"actRunWSNewTab\"\nlet actRunWSHere      = \"actRunWSHere\"\nlet actRunWSIn        = \"actRunWSIn\"\nlet actParseCode      = \"actParseCode\"\nlet actCompileWS      = \"actCompileWS\"\nlet actFindDefinition = \"actFindDefinition\"\nlet titleX            = \"title\"            \nlet snippets          = \"snippets\"         \nlet code              = \"code\"           \nlet buttons           = \"buttons\"          \nlet menu              = \"menu\"             \nlet Output            = \"Output\"           \nlet Parser            = \"Parser\"           \nlet JavaScript        = \"JavaScript\"       \nlet FScode            = \"F# code\"          \nlet WSResult          = \"WS Result\"        \nlet Properties        = \"Properties\"  \n\nlet guiParts =\n    Map[\n       actLoadFile      , GuiAction \n       actSaveFile      , GuiAction \n       actAddSnippet    , GuiAction \n       actDeleteSnippet , GuiAction \n       actIndentSnippet , GuiAction \n       actOutdentSnippet, GuiAction \n       actGetFsCode     , GuiAction \n       actEvalCode      , GuiAction \n       actRunWSNewTab   , GuiAction \n       actRunWSHere     , GuiAction \n       actRunWSIn       , GuiAction \n       actParseCode     , GuiAction \n       actCompileWS     , GuiAction \n       actFindDefinition, GuiAction \n       titleX           , GuiNode <| HtmlText \"title\"       \n       snippets         , GuiNode <| HtmlText \"snippets\"    \n       code             , GuiNode <| HtmlText \"editor\"      \n       buttons          , GuiNode <| HtmlText \"buttons\"     \n       menu             , GuiNode <| HtmlText \"menu\"        \n       Output           , GuiNode <| HtmlText \"Output\"      \n       Parser           , GuiNode <| HtmlText \"Parser\"      \n       JavaScript       , GuiNode <| HtmlText \"JavaScript\"  \n       FScode           , GuiNode <| HtmlText \"F# code\"     \n       WSResult         , GuiNode <| HtmlText \"WS Result\"   \n       Properties       , GuiNode <| HtmlText \"Properties\"  \n    ]\n\nlet  gridNewBisect(first, secT, vertical, per, ch1, ch2, min, max) = \n    let spltH, spltV =\n        match secT with\n        | StVariable  -> \"\\n----------------------------------------\\n\", \"|\"\n        | StFixedPx\n        | StFixedPerc -> \"\\n\", \" \"\n    let splt = if vertical then spltV else spltH\n    sprintf \"%s%s%s\" ch1 splt ch2\n\nlet rec getNode name (parts: Map<string,GuiPart>) =\n    Map.tryFind name parts\n    |> Option.map(\n       function\n       | GuiRoot     root                                             -> \"\"\n       | GuiNode     node                                             -> \"some HtmlNode\"\n       | GuiAction                                                    -> sprintf \"Button: %s\" name\n       | GuiSplit   (first, secT , vertical, per, ch1, ch2, min, max) -> gridNewBisect(first, secT, vertical, per, getNode ch1 parts, getNode ch2 parts, min, max)\n       | GuiTabStrip(top  , nodes                                   ) -> nodes |> Seq.map (fun node -> getNode node parts) |> String.concat \", \" |> sprintf \"TabStrip: %s\"\n       | GuiCall    (name, call, parms)                               -> sprintf \"Button: %s\" name\n    )\n    |> Option.defaultWith (fun () -> sprintf \"GuiPart %s not found\" name) \n    \nlet rec processLayoutSteps (steps: (string * GuiPart) seq) (parts: Map<string, GuiPart>) =\n    steps\n    |> Seq.tryHead\n    |> Option.map (fun (name, guiPart) ->\n        guiPart\n        |> Map.add name <| parts\n        |> processLayoutSteps (steps |> Seq.skip 1)\n       )\n    |> Option.defaultValue parts\n    \nlet finishLayout parts steps  =\n    let name = steps |> Seq.last |> fst\n    processLayoutSteps steps parts\n    |> getNode name\n\nlet inline fixedHorSplitter  first px ch1 ch2         = GuiSplit(first, StFixedPx , false, px, ch1, ch2, 5.0, 95.0)\nlet inline fixedVerSplitter  first px ch1 ch2         = GuiSplit(first, StFixedPx , true , px, ch1, ch2, 5.0, 95.0)\nlet inline varHorSplitter          pc ch1 ch2 min max = GuiSplit(true , StVariable, false, pc, ch1, ch2, min,  max)\nlet inline varVerSplitter          pc ch1 ch2 min max = GuiSplit(true , StVariable, true , pc, ch1, ch2, min,  max)\n\nlet addLayoutJsonFable (v:string) = sprintf \"addLayoutJson('%s')\" (v.Replace(\"'\", \"''\")) |> evalCode None \nlet addLayout           s         = \n    let json = toJson s\n    printfn \"%s\"       json\n    addLayoutJsonFable json\n","parent":{"$":0,"Item":"f936b296-080b-45ce-a242-f6eea88ec459"},"predecessors":[{"$":0,"Item":"f142ff32-fb36-408b-86b6-c0a09b020136"},{"$":0,"Item":"67ac26db-54cb-46df-a1b8-c6e5856d4b1c"}],"id":{"$":0,"Item":"3078283c-3b72-4e35-b833-c4d801c30eb9"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"One TabStrip","content":"[\n    \"messagesB\"    , GuiTabStrip(     true ,  [| Output    \n                                                 Parser    \n                                                 JavaScript\n                                                 FScode   \n                                                 WSResult\n                                              |])\n    \"buttons\"      , GuiNode (h1 [ HtmlGuiPart actRunWSHere ])\n]             \n|> addLayout\n","parent":{"$":0,"Item":"f936b296-080b-45ce-a242-f6eea88ec459"},"predecessors":[{"$":0,"Item":"3078283c-3b72-4e35-b833-c4d801c30eb9"}],"id":{"$":0,"Item":"46aa9bde-8f66-44c6-a403-781508aae4c8"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Run WebSharper Here","content":"[\n    \"code_props\"   , varVerSplitter         100.0 \"title_code\"    \"messagesR\"     25.0 100.0\n    \"main_messages\", varHorSplitter          65.0 \"snippets_code\" \"messagesB\"     35.0 100.0             \n    \"buttons\"      , GuiNode (div [ HtmlGuiPart actRunWSHere ; HtmlGuiPart actSaveFile ; style \"text-align: center\" ])\n]             \n|> addLayout\n","parent":{"$":0,"Item":"f936b296-080b-45ce-a242-f6eea88ec459"},"predecessors":[{"$":0,"Item":"3078283c-3b72-4e35-b833-c4d801c30eb9"}],"id":{"$":0,"Item":"d1a99b64-a179-4ca4-aac0-354f5f824809"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Split TabStrip","content":"[\n    \"messagesB1\"   , GuiTabStrip(     true ,  [| \"Output\"    \n                                                 \"JavaScript\"\n                                                 \"F# code\"    |])\n    \"messagesB2\"   , GuiTabStrip(     true ,  [| \"Parser\"    \n                                                 \"WS Result\"  |])\n    \"messagesB\"    , varVerSplitter          55.0 \"messagesB1\"    \"messagesB2\"     0.0 100.0             \n]             \n|> addLayout\n","parent":{"$":0,"Item":"f936b296-080b-45ce-a242-f6eea88ec459"},"predecessors":[{"$":0,"Item":"3078283c-3b72-4e35-b833-c4d801c30eb9"}],"id":{"$":0,"Item":"7d5aded1-f858-444e-a5d4-0ee046381787"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"WebSharper","content":"let divider = div [ style \" width:9px; height:auto; display:inline-block;\" ]\n\n[\n    \"main_messages\", varHorSplitter          18.0 \"messagesB\"     \"snippets_code\"  0.0  75.0             \n    \"buttons\"      , GuiNode (div [ HtmlGuiPart actRunWSNewTab ; divider ; HtmlGuiPart actSaveFile ; style \"text-align: center\" ])\n]             \n|> addLayout\n","parent":{"$":0,"Item":"f936b296-080b-45ce-a242-f6eea88ec459"},"predecessors":[{"$":0,"Item":"3078283c-3b72-4e35-b833-c4d801c30eb9"}],"id":{"$":0,"Item":"f643d95a-d4cf-4375-acda-1713f207a8d5"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Tutorial","content":"[\n    \"code_props\"   , varVerSplitter         100.0 \"title_code\"    \"messagesR\"     25.0 100.0\n    \"main_messages\", varHorSplitter          65.0 \"snippets_code\" \"messagesB\"     35.0 100.0             \n    \"buttons\"      , GuiNode (div [ HtmlGuiPart actRunWSHere\n                                    style     \"text-align: center\" \n                                   // ``class`` \"btn-primary\"\n                                  ])\n]             \n|> addLayout\n","parent":{"$":0,"Item":"f936b296-080b-45ce-a242-f6eea88ec459"},"predecessors":[{"$":0,"Item":"3078283c-3b72-4e35-b833-c4d801c30eb9"}],"id":{"$":0,"Item":"5a29dd45-dea6-42f4-af00-961257b64362"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FSharpStation","content":"let divider = div [ style \" width:9px; height:auto; display:inline-block;\" ]\n\nlet buttonsH =\n    div [ \n          HtmlGuiPart actAddSnippet    \n          HtmlGuiPart actOutdentSnippet\n          HtmlGuiPart actIndentSnippet \n          span []       \n          HtmlGuiPart \"compileFSStation\"       \n          HtmlGuiPart \"NewTabFSStation\" \n\n          HtmlGuiPart actDeleteSnippet \n          HtmlGuiPart actFindDefinition\n          span []       \n          HtmlGuiPart actSaveFile      \n          HtmlGuiPart actGetFsCode     \n          HtmlGuiPart actParseCode     \n\n          style (\"\"\"\n              overflow: hidden;\n              display: grid;\n              grid-template-columns: repeat(6, 16.5%);\n              bxackground-color: #eee;\n              padding : 5px;\n              grid-gap: 5px;\n          \"\"\".Replace(\"\\n\", \" \"))\n        ]\n\n[\n    \"main_messages\"   , varHorSplitter          18.0 \"messagesB\"     \"snippets_code\"  0.0  75.0       \n    \"compileFSStation\", GuiCall (\"Compile & Run F# Station\", actEvalCode   , [| \"FSSGlobal/WebSharper Code/FSharpStation Code/compile & run FSharpStation\" |])\n    \"NewTabFSStation\" , GuiCall (\"F# Station in New Tab\"   , actRunWSNewTab, [| \"FSSGlobal/WebSharper Code/FSharpStation Code/Invoke FSharpStation\"        |])\n    buttons           , GuiNode buttonsH \n]             \n|> addLayout\n","parent":{"$":0,"Item":"f936b296-080b-45ce-a242-f6eea88ec459"},"predecessors":[{"$":0,"Item":"3078283c-3b72-4e35-b833-c4d801c30eb9"}],"id":{"$":0,"Item":"124f7c78-5725-431e-acbb-d715ac398c4f"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"OpenGarage","content":"let localimage (file: string) = img [ file.Replace('\\\\', '/') |> sprintf \"file:///%s\" |> src ] // not allowed to load local image\n\nlet image      (file: string) = img [ src file ; onclick \"alert([event.offsetX, event.offsetY])\" ; Id \"PhoneScreen\" ; style \"width: 95%\"] \nlet [< Emit \"Date.now()\" >] now() = 1\n\n[\n        \"extrabuttons\"      , div [ style \"text-align: center ; overflow: auto ; \" \n                                    HtmlGuiCall(\"Capture Screen\"  , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Refresh\"         , actRunFableFs, [||] )\n                                    image (sprintf \"/screen.png?time=%d\" <| now())\n                                    div [\n                                        HtmlGuiCall(\"Camera\"          , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"MENU\"            , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"HOME\"            , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"BACK\"            , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"run OpenGarage3\" , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"CHECK\"           , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"version\"         , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"devices\"         , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"killServer\"      , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"connectUSB\"      , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"AbeFi.connect\"   , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"OldHtc.connect\"  , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"activateWifi\"    , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"ls\"              , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"cat\"             , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"shell\"           , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"flash On\"        , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"flash Off\"       , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"checkScreenOn\"   , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"enableWifi\"      , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"supplicantWifi\"  , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"unlock\"          , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"activateWifi\"    , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"reboot\"          , actEvalFsCode, [||] )\n                                        \n                                        HtmlGuiCall(\"Screen lock\"     , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"Screen unlock\"   , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"Screen off\"      , actEvalFsCode, [||] )\n                                        \n                                    ]\n                                    css \" button.btn { margin: 2px; font-size: smaller; } \" \n                                  ] |> GuiNode \n        \"main_extra\"        , varVerSplitter          85.0 \"main_messages\" \"extrabuttons\"   50.0  100.0\n        \"main\"              , fixedHorSplitter true   50.0 \"menu\"          \"main_extra\"\n] |> addLayout\n\n \n //Fable.Import.Browser.document.getElementById(\"PhoneScreen\").getAttribute(\"src\")\n ","parent":{"$":0,"Item":"f936b296-080b-45ce-a242-f6eea88ec459"},"predecessors":[{"$":0,"Item":"3078283c-3b72-4e35-b833-c4d801c30eb9"}],"id":{"$":0,"Item":"8015b71a-e594-44d4-b9e8-b73fe12e39f4"},"expanded":true,"level":0,"levelCode":0,"properties":{"SayHello":"printfn \"Hello said.\""}},{"name":"Ping computers","content":"[\n        \"extrabuttons\"      , div [ style \"text-align: center ; overflow: auto ; \" \n                                    HtmlGuiCall(\"ALL\"           , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"localhost\"     , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"NeoRouter\"     , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Router1\"       , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Router2\"       , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"OOMA\"          , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"EXSi\"          , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Modem\"         , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"ABEHOME\"       , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"AbeRaspi\"      , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"OldHTC\"        , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"AbeWCam\"       , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"FILESERVER1\"   , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"AbeRainMachine\", actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Thermo-Abajo\"  , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Thermo-Arriba\" , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Google DNS\"    , actEvalFsCode, [||] )\n                                    css \" button.btn { margin: 2px; font-size: small; } \" \n                                  ] |> GuiNode \n        \"main_extra\"        , varVerSplitter          85.0 \"main_messages\" \"extrabuttons\"   50.0  100.0\n        \"main\"              , fixedHorSplitter true   50.0 \"menu\"          \"main_extra\"\n] |> addLayout\n\n","parent":{"$":0,"Item":"f936b296-080b-45ce-a242-f6eea88ec459"},"predecessors":[{"$":0,"Item":"3078283c-3b72-4e35-b833-c4d801c30eb9"}],"id":{"$":0,"Item":"0ed9daa7-abef-4d65-af8d-f3ed6f9aa692"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"[\n        \"extrabuttons\"      , div [ style \"text-align: center ; overflow: auto ; \" \n                                    HtmlGuiCall(\"ls -la\"        , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"activateDoor\"  , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"NeoRouter\"     , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Router1\"       , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Router2\"       , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"OOMA\"          , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"EXSi\"          , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Modem\"         , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"ABEHOME\"       , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"AbeRaspi\"      , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"OldHTC\"        , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"AbeWCam\"       , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"FILESERVER1\"   , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"AbeRainMachine\", actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Thermo-Abajo\"  , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Thermo-Arriba\" , actEvalFsCode, [||] )\n                                    css \" button.btn { margin: 2px; font-size: small; } \" \n                                  ] |> GuiNode \n        \"main_extra\"        , varVerSplitter          85.0 \"main_messages\" \"extrabuttons\"   50.0  100.0\n        \"main\"              , fixedHorSplitter true   50.0 \"menu\"          \"main_extra\"\n] |> addLayout\n\n","parent":{"$":0,"Item":"f936b296-080b-45ce-a242-f6eea88ec459"},"predecessors":[{"$":0,"Item":"3078283c-3b72-4e35-b833-c4d801c30eb9"}],"id":{"$":0,"Item":"016f7d49-ce7d-45e9-9f8b-57aed43dbba5"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Snippets","content":"module Snippets =\n","parent":{"$":0,"Item":"ba90a7d3-7af6-4637-a92f-5d30657d63f2"},"predecessors":[],"id":{"$":0,"Item":"b30f728e-eb7c-40d1-b4ac-596e372b4e84"},"expanded":false,"level":0,"levelCode":0,"properties":{}},{"name":"Fable calling WebSharper","content":"//[< Emit \"document.getElementById($0).shadowRoot.firstElementChild.firstElementChild.firstElementChild.contentWindow.eval($1)\" >]\n//let evalInContext (tnode:string) (code:string) = ()\n\n#r \"..\\packages\\Fable.Core\\lib\\netstandard1.6\\Fable.Core.dll\"\n\nmodule testFable =\n\n    open Fable.Core\n\n//    [< Emit \"document.getElementById($0).shadowRoot.firstElementChild.firstElementChild.firstElementChild.contentWindow.eval($1) \" >]\n    [< Emit \"eval($1) \" >]\n    let evalInContext (tnode:string) (code:string) : obj = 0 :> obj\n    \n    let evalCode code =\n        try \n            evalInContext \"TestNode\" code |> printfn \"%A\"\n        with e -> printfn \"Error: %s\" e.StackTrace\n        \n    evalCode \"FSSGlobal.FSharpStation.FableModule\"    \nlet IF(c,a,b) = 1\nlet LEFT(a,b) = 2\nlet B2 = 1\nlet B3 = 1\nlet x     =\n  IF(LEFT(B2,2)<>LEFT(B3,2),2,IF(LEFT(B2,3)<>LEFT(B3,3),3,IF(LEFT(B2,4)<>LEFT(B3,4),4,IF(LEFT(B2,5)<>LEFT(B3,5),5,IF(LEFT(B2,6)<>LEFT(B3,6),6,IF(LEFT(B2,7)<>LEFT(B3,7),7,IF(LEFT(B2,8)<>LEFT(B3,8),8,99)))))))\n    ","parent":{"$":0,"Item":"b30f728e-eb7c-40d1-b4ac-596e372b4e84"},"predecessors":[],"id":{"$":0,"Item":"c5973f54-8747-439f-8101-0dd00a216aff"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableFSI":"0"}},{"name":"Layout test","content":"#r \"..\\packages\\Fable.Core\\lib\\netstandard1.6\\Fable.Core.dll\"\n\nopen Fable.Core\nopen Fable.Core.JsInterop\n\nmodule Option =\n    let defaultValue v =\n        function\n        | Some x  -> x\n        | None    -> v\n    let defaultWith  f =\n        function\n        | Some x  -> x\n        | None    -> f()\n\ntype SectionType =\n    | StVariable\n    | StFixedPx\n    | StFixedPerc\n\ntype GuiPart = \n   | GuiNode     of string\n   | GuiAction \n   | GuiSplit    of first: bool * secT: SectionType * vertical: bool * per:float * string * string * min: float * max: float\n   | GuiTabStrip of top  : bool * string []\n\nlet guiParts =\n    Map [\n       \"actLoadFile      \", GuiAction \n       \"actSaveFile      \", GuiAction \n       \"actAddSnippet    \", GuiAction \n       \"actDeleteSnippet \", GuiAction \n       \"actIndentSnippet \", GuiAction \n       \"actOutdentSnippet\", GuiAction \n       \"actGetFsCode     \", GuiAction \n       \"actEvalCode      \", GuiAction \n       \"actRunWSNewTab   \", GuiAction \n       \"actRunWSHere     \", GuiAction \n       \"actRunWSIn       \", GuiAction \n       \"actParseCode     \", GuiAction \n       \"actCompileWS     \", GuiAction \n       \"actFindDefinition\", GuiAction \n       \"title\"            , GuiNode \"title\"       \n       \"snippets\"         , GuiNode \"snippets\"    \n       \"editor\"           , GuiNode \"editor\"      \n       \"buttons\"          , GuiNode \"buttons\"     \n       \"menu\"             , GuiNode \"menu\"        \n       \"Output\"           , GuiNode \"Output\"      \n       \"Parser\"           , GuiNode \"Parser\"      \n       \"JavaScript\"       , GuiNode \"JavaScript\"  \n       \"F# code\"          , GuiNode \"F# code\"     \n       \"WS Result\"        , GuiNode \"WS Result\"   \n       \"Properties\"       , GuiNode \"Properties\"  \n    ]\n\nlet  gridNewBisect(first, secT, vertical, per, ch1, ch2, min, max) = \n    let spltH, spltV =\n        match secT with\n        | StVariable  -> \"\\n----------------------------------------\\n\", \"|\"\n        | StFixedPx\n        | StFixedPerc -> \"\\n\", \" \"\n    let splt = if vertical then spltV else spltH\n    sprintf \"%s%s%s\" ch1 splt ch2\n\nlet rec getNode name (parts: Map<string,GuiPart>) =\n    Map.tryFind name parts\n    |> Option.map(\n       function\n       | GuiNode     node                                             -> node\n       | GuiAction                                                    -> sprintf \"Button: %s\" name\n       | GuiSplit   (first, secT , vertical, per, ch1, ch2, min, max) -> gridNewBisect(first, secT, vertical, per, getNode ch1 parts, getNode ch2 parts, min, max)\n       | GuiTabStrip(top  , nodes                                   ) -> nodes |> Seq.map (fun node -> getNode node parts) |> String.concat \", \" |> sprintf \"TabStrip: %s\"\n    )\n    |> Option.defaultWith (fun () -> sprintf \"GuiPart %s not found\" name) \n    \nlet rec processLayoutSteps (steps: (string * GuiPart) seq) (parts: Map<string, GuiPart>) =\n    steps\n    |> Seq.tryHead\n    |> Option.map (fun (name, guiPart) ->\n        guiPart\n        |> Map.add name <| parts\n        |> processLayoutSteps (steps |> Seq.skip 1)\n       )\n    |> Option.defaultValue parts\n    \nlet finishLayout parts steps  =\n    let name = steps |> Seq.last |> fst\n    processLayoutSteps steps parts\n    |> getNode name\n\nlet inline fixedHorSplitter  first px ch1 ch2         = GuiSplit(first, StFixedPx , false, px, ch1, ch2, 5.0, 95.0)\nlet inline varSplitter         ver pc ch1 ch2 min max = GuiSplit(true , StVariable, ver  , pc, ch1, ch2, min,  max)\n\nlet steps = \n    [\n        \"messagesR\"    , GuiTabStrip(     true ,  [| \"Properties\" |])\n        \"messagesB\"    , GuiTabStrip(     true ,  [| \"Output\"    \n                                                     \"Parser\"    \n                                                     \"JavaScript\"\n                                                     \"F# code\"   \n                                                     \"WS Result\"  |])\n        \"title_code\"   , fixedHorSplitter true  34.0 \"title\"         \"code\"\n        \"code_props\"   , varSplitter      true  85.0 \"title_code\"    \"messagesR\"     25.0 100.0\n        \"code_buttons\" , fixedHorSplitter false 80.0 \"code_props\"    \"buttons\"\n        \"snippets_code\", varSplitter      true  15.0 \"snippets\"      \"code_buttons\"   5.0  95.0\n        \"main_messages\", varSplitter      false 16.0 \"messagesB\"     \"snippets_code\"  5.0 80.0             \n        \"main_window\"  , fixedHorSplitter true  50.0 \"menu\"          \"main_messages\"\n    ]             \n\nlet layoutSteps = steps\n\nlet finalLayout = (finishLayout guiParts) layoutSteps \n\nprintfn \"%s\" finalLayout\n\nprintfn \"%s\" <| toJson steps\n\n//[< Emit \"document.getElementById($0).shadowRoot.firstElementChild.firstElementChild.firstElementChild.contentWindow.eval($1) \" >]\n[< Emit \"eval($1) \" >]\nlet evalInContext (tnode:string) (code:string) : obj = 0 :> obj\n    \nlet evalCode code =\n    try \n        evalInContext \"TestNode\" code |> printfn \"%A\"\n    with e -> printfn \"Error: %s\" e.StackTrace\n\n\nlet setLayoutJsonFable (v:string) = sprintf \"setLayoutJson('%s')\" (v.Replace(\"'\", \"''\")) |> evalCode |> printfn \"::%A\"\nlet setLayout           s          = toJson s |> setLayoutJsonFable\n//setLayout steps\n\n","parent":{"$":0,"Item":"b30f728e-eb7c-40d1-b4ac-596e372b4e84"},"predecessors":[],"id":{"$":0,"Item":"61378232-d27c-4c83-8214-d030f0573421"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"parenthesis","content":"let times2 v = v * 2 \n\nprintfn   \"this is a test %A %d\"   (times2)(3) \nprintfn   \"this is a test %A %d\"    times2 (3) \nprintfn   \"this is a test %A %d\"    times2  3\n\nprintfn   \"this is a test %A   \"   (times2  3) \nprintfn   \"this is a test %A   \" <| times2  3 \n//printfn \"this is a test %A   \"    times2( 3) \n\n4   + times2(5) - 33 |> printfn \"%A\"\n4   + times2 5  - 33 |> printfn \"%A\"\n4   + times2 5-33    |> printfn \"%A\"\n4   + times2(5)-33   |> printfn \"%A\"\n//4 + times2 5  -33  |> printfn \"%A\"\n//4 + times2 5  +33  |> printfn \"%A\"\n\n    ","parent":{"$":0,"Item":"b30f728e-eb7c-40d1-b4ac-596e372b4e84"},"predecessors":[],"id":{"$":0,"Item":"2c9efa31-479c-4c06-b74b-16102accf58b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"WebSharper Interop JS, Dom","content":"#r \"..\\packages\\Fable.Core\\lib\\netstandard1.6\\Fable.Core.dll\"\n\nopen Fable.Core\nopen Fable.Core.JsInterop\n\nmodule Dom =\n\n    type DomRect = {\n        top    : float\n        left   : float\n        width  : float\n        height : float\n    }\n      with\n        static member New(r) ={\n            top    = r.top   \n            left   = r.left  \n            width  = r.width \n            height = r.height\n        }\n        member inline this.Top                                                                           = this.top   \n        member inline this.Left                                                                          = this.left  \n        member inline this.Width                                                                         = this.width \n        member inline this.Height                                                                        = this.height\n\n    type Event() =\n        let a = 1\n      with\n        [< Emit \"$0.preventDefault()\"            >] member this.PreventDefault()                  = ()\n    \n    type MouseEvent() =    \n        inherit Event()    \n      with    \n        [< Emit \"$0.clientX\"                     >] member this.ClientX                           = 0.\n        [< Emit \"$0.clientY\"                     >] member this.ClientY                           = 0.\n    \n    [< AllowNullLiteral >]\n    type Node() =     \n        let a = 1    \n      with    \n        [< Emit \"$0.appendChild($1)\"             >] member this.AppendChild(ch:Node)                           = Node()\n        [< Emit \"$0.firstChild\"                  >] member this.FirstChild                                     = Node()\n        [< Emit \"$0.parentElement\"               >] member this.ParentElement                                  = Element()\n        [< Emit \"$0.parentNode\"                  >] member this.ParentNode                                     = Node()\n                        \n    and [< AllowNullLiteral >] Element() =     \n        inherit Node()\n        let a = 1    \n      with    \n        [< Emit \"$0.getBoundingClientRect()\"     >] member this.GetBoundingClientRect() : DomRect              = jsNative\n        [< Emit \"$0.setAttribute($1, $2)\"        >] member this.SetAttribute(name, value)                      = ()\n        [< Emit \"$0.shadowRoot\"                  >] member this.ShadowRoot                                     = Element()\n        [< Emit \"$0.attachShadow($1)\"            >] member this.AttachShadow(sh)                               = Element()\n        [< Emit \"$0.innerHTML\"                   >] member this.InnerHTML  with get ()                         = \"\"\n        [< Emit \"$0.innerHTML = $1\"              >] member this.InnerHTML  with set (v:string)                 = ()\n\n    type Document() =\n        let a = 1\n      with\n        [< Emit \"$0.createElement(      $1)\"     >] member this.CreateElement(   ev: string)                   = Element()\n        [< Emit \"$0.getElementById(     $1)\"     >] member this.GetElementById(id:string)                      = Element()\n        [< Emit \"$0.body\"                        >] member this.Body                                           = Element()\n\ntype Window() =\n    let a = 1\n  with\n    [< Emit \"$0.addEventListener(   $1, $2, $3)\" >] member this.AddEventListener(   ev: string, f, flag: bool) = ()\n    [< Emit \"$0.removeEventListener($1, $2, $3)\" >] member this.RemoveEventListener(ev: string, f, flag: bool) = ()\n\ntype JS() =\n    let a = 1\n  with\n    [< Emit \"window\"                             >] static member Window                                       = Window()\n    [< Emit \"document\"                           >] static member Document                                     = Dom.Document()\n    [< Emit \"setInterval($0, $1)\"                >] static member SetInterval f (t:int)                        = Dom.Document()\n    [< Emit \"alert($0)\"                          >] static member Alert v                                      = ()\n    [< Emit \"console.log($0)\"                    >] static member ConsoleLog v                                 = ()\n","parent":{"$":0,"Item":"b30f728e-eb7c-40d1-b4ac-596e372b4e84"},"predecessors":[],"id":{"$":0,"Item":"ac152670-fb8a-4549-9659-1b6ee81d64ef"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableFable":"1"}},{"name":"WebSharper Interop Doc, Attr, Var, View, Val","content":"#r \"..\\packages\\Fable.Core\\lib\\netstandard1.6\\Fable.Core.dll\"\n\nopen Fable.Core\nopen Fable.Core.JsInterop\n\nmodule Option =\n    let defaultValue v =\n        function\n        | Some x -> x\n        | None   -> v\n\ntype Attr() =\n    let a = 1\n\ntype Doc() = \n    let a = 1\n\ntype Elt() = \n    inherit Doc()\n    let a = 1\n\ntype IRef<'V> = {\n    initial : 'V\n} \n\ntype View<'V> =\n    | FromConst of      'V\n    | FromVar   of IRef<'V>\n    | FromView  of prior: View<obj> * vFunction : (obj -> View<'V>)\n\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule View =    \n    let [< Emit \"WebSharper.UI.Next.View.Const(    $0)\"     >] Const    (v : 'a            )                 = FromConst v\n    let [< Emit \"WebSharper.UI.Next.View.FromVar(  $0)\"     >] FromVar  (v : IRef<'a>      )                 = FromVar   v\n    let [< Emit \"WebSharper.UI.Next.View.Get(      $0, $1)\" >] Get      (f: 'a ->  unit    ) (vw : View<'a>) = ()\n    let [< Emit \"WebSharper.UI.Next.View.Bind(     $0, $1)\" >] Bind     (f: 'a ->  View<'b>) (vw : View<'a>) = FromView(FromConst (vw :> obj), fun o -> f (o :?> 'a))\n    let [< Emit \"WebSharper.UI.Next.View.Map(      $0, $1)\" >] Map      (f: 'a ->       'b ) (vw : View<'a>) = Bind (f >> Const) vw\n    let [< Emit \"WebSharper.UI.Next.View.MapCached($0, $1)\" >] MapCached(f: 'a ->       'b ) (vw : View<'a>) = Bind (f >> Const) vw\n//    let [< Emit \"WebSharper.UI.Next.View.MapAsync( $0, $1)\" >] MapAsync (f: 'a -> Async<'b>) (vw : View<'a>) = (fun v -> async { return! f v } |> Async.RunSynchronously) |> Map <| vw\n    let [< Emit \"WebSharper.UI.Next.View.Sink(     $0, $1)\" >] Sink     (f: 'a ->  unit    ) (vw : View<'a>) = Get f vw\n    \n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule Doc =\n    let [< Emit \"WebSharper.UI.Next.Doc.TextNode($0)\"        >] TextNode txt                     = Doc()\n    let [< Emit \"WebSharper.UI.Next.Doc.Run($0, $1)\"         >] Run     (el: Dom.Element) (node:Doc)  = ()\n    let [< Emit \"WebSharper.UI.Next.Doc.RunById($0, $1)\"     >] RunById (id: string) (node:Doc)  = ()\n    let [< Emit \"WebSharper.UI.Next.Doc.Empty()\"             >] Empty                            = Doc()\n    let [< Emit \"WebSharper.UI.Next.Doc.Element($0, $1, $2)\" >] Element0 a (b: Attr[]) (c:Doc[]) = Elt()\n    let [< Emit \"WebSharper.UI.Next.Doc.InputArea($0, $1)\"   >] InputArea0 (b: Attr[])  c        = Elt()\n    let [< Emit \"WebSharper.UI.Next.Doc.BindView($0, $1)\"    >] BindView f vw                    = Doc()\n    let Element a b c = Element0   a (b |> Seq.toArray) (c |> Seq.toArray)\n    let InputArea b c = InputArea0   (b |> Seq.toArray)  c\n    \n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule Var =\n    let [< Emit \"WebSharper.UI.Next.Var.Create$1($0)\" >] Create v = { initial = v }\n\ntype Doc with\n    [< Emit \"WebSharper.UI.Next.Doc.EmbedView($0)\"   >]\n    static member EmbedView (d:View<#Doc>)        = Doc()\n//    [< Emit \"WebSharper.UI.Next.Doc.EmbedView($0)\"   >]\n//    static member EmbedView (d:View<Elt>)         = Doc()\n\n\n[<NoComparison>]\ntype Val<'a> =\n    | Constant  of 'a\n    | DynamicV  of IRef<'a>\n    | Dynamic   of View<'a>\n  with member this.FooBar = 0\n  \ntype IRef<'V> with\n    [< Emit \"$0.RView()\"       >]\n    member this.View  = View.FromVar this\n    [< Emit \"$0.RVal()\"       >]\n    member this.Value with get ()      = this.initial\n    [< Emit \"$0.set_RVal($1)\" >]\n    member this.Value with set (v:'V)  = ()\n\nmodule Attr =\n    let [< Emit \"WebSharper.UI.Next.AttrProxy.Create(      $0, $1)\"     >] Create      (att:string)  v                          = Attr()\n    let [< Emit \"WebSharper.UI.Next.AttrModule.Dynamic(    $0, $1)\"     >] Dynamic     (att:string) (vw :View<_>)               = Attr()\n    let [< Emit \"WebSharper.UI.Next.AttrModule.DynamicPred($0, $1, $1)\" >] DynamicPred (att:string) (vw1:View<_>) (vw2:View<_>) = Attr()\n    let [< Emit \"WebSharper.UI.Next.AttrProxy.Handler($0,$1)\"           >] HandlerLinq a f                                      = Attr()\n    \nmodule on =\n    let click       f = Attr.HandlerLinq \"click\"       f\n    let mouseMove   f = Attr.HandlerLinq \"mousemove\"   f\n    let mouseDown   f = Attr.HandlerLinq \"mousedown\"   f\n    let mouseUp     f = Attr.HandlerLinq \"mouseup\"     f\n    let [< Emit \"WebSharper.UI.Next.AttrModule.OnAfterRender($0)\" >] afterRender f = Attr.HandlerLinq \"afterrender\" f\n    \nmodule attr =\n    let disabledDynPred pred view = Attr.DynamicPred \"disabled\" pred view\n\nmodule Input =\n    module Mouse =\n        [< Emit \"WebSharper.UI.Next.Input.Mouse.get_MousePressed()\" >]\n        let MousePressed = true \n\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule Val =\n    \n    let mapV : ('a -> 'b) -> Val<'a> -> Val<'b> =\n        fun    f             va      ->\n            match va with\n            | Constant  a -> f a                   |> Constant\n            | Dynamic  wa -> wa      |> View.Map f |> Dynamic \n            | DynamicV va -> va.View |> View.Map f |> Dynamic \n\n    let iterV : ('a -> unit) -> Val<'a> -> unit = //f v = toView v |> View.Get f\n        fun     f               va      ->\n            match va with\n            | Constant  a ->          f  a                  \n            | Dynamic  wa -> View.Get f wa \n            | DynamicV va ->          f va.Value \n\n    let toView v =\n        match v with\n        | Constant  a -> View.Const a\n        | Dynamic  wa -> wa\n        | DynamicV va -> va.View\n\n    let bindV : ('a -> Val<'b>) -> Val<'a> -> Val<'b> =\n        fun     f                  v       -> \n            match v with\n            | Constant  a -> f a\n            | Dynamic  wa -> wa      |> View.Bind (f >> toView) |> Dynamic \n            | DynamicV va -> va.View |> View.Bind (f >> toView) |> Dynamic \n\n    let inline map2V f = // : ('a -> 'b -> 'c) -> Val<'a> -> Val<'b> -> Val<'c> =\n        //fun     f                ->\n        let inline swap f a b = f b a\n        let inline fv vb = bindV (swap (f >> mapV) vb)\n        swap fv\n\n    let inline map3V f3 v1 v2 v3    = map2V f3 v1 v2    |> map2V (|>) v3\n    let inline map4V f3 v1 v2 v3 v4 = map3V f3 v1 v2 v3 |> map2V (|>) v4\n    \n    let tagDoc: ('a -> Doc) -> Val<'a> -> Doc =\n        fun     tag            va      ->\n            match va with\n            | Constant  a -> tag   a\n            | Dynamic  wa -> wa      |> View.Map tag |> Doc.EmbedView\n            | DynamicV va -> va.View |> View.Map tag |> Doc.EmbedView\n\n    let tagElt: ('a -> Elt) -> Val<'a> -> Doc =\n        fun     tag            va      ->\n            match va with\n            | Constant  a -> tag   a :> Doc\n            | Dynamic  wa -> wa      |> View.Map tag |> Doc.EmbedView\n            | DynamicV va -> va.View |> View.Map tag |> Doc.EmbedView\n\n    let attrVO att       vao     =\n            match vao with\n            | Constant (Some a)-> Attr.Create      att   a\n            | Constant  None   -> Attr.DynamicPred att  (View.Const false              ) (View.Const                      \"\"         )\n            | Dynamic       wa -> Attr.DynamicPred att  (View.Map Option.isSome wa     ) (View.Map   (Option.defaultValue \"\") wa     )\n            | DynamicV      va -> Attr.DynamicPred att  (View.Map Option.isSome va.View) (View.Map   (Option.defaultValue \"\") va.View)\n\n    let attrV att       va      =\n            match va with\n            | Constant  a -> Attr.Create  att   a\n            | Dynamic  wa -> Attr.Dynamic att  wa\n            | DynamicV va -> Attr.Dynamic att  va.View    \n\n    type HelperType = HelperType with\n        static member (&>) (HelperType, a :     string option   ) = Constant  a\n        static member (&>) (HelperType, a :     string          ) = Constant  a\n        static member (&>) (HelperType, a :     bool            ) = Constant  a\n        static member (&>) (HelperType, a :     int             ) = Constant  a\n        static member (&>) (HelperType, a :     float           ) = Constant  a\n        static member (&>) (HelperType, a :     Doc             ) = Constant  a\n        static member (&>) (HelperType, va: Val<string option>  ) =          va\n        static member (&>) (HelperType, va: Val<string       >  ) =          va\n        static member (&>) (HelperType, va: Val<bool         >  ) =          va\n        static member (&>) (HelperType, va: Val<int          >  ) =          va\n        static member (&>) (HelperType, va: Val<float        >  ) =          va\n        static member (&>) (HelperType, va: Val<Doc          >  ) =          va\n        static member (&>) (HelperType, va: Val<_            >  ) =          va\n        static member (&>) (HelperType, vr: IRef<_           >  ) = DynamicV vr\n        static member (&>) (HelperType, vw: View<_           >  ) = Dynamic  vw\n\n    [< Emit \"($0 in $1)\" >]\n    let In (a:string) b = true\n    \n    [< Emit \"($0 instanceof WebSharper.UI.Next.Doc)\" >]\n    let isDoc d = false\n\n    [< Emit \"(typeof $0 == 'function')\" >]\n    let isView d = false\n\n    [< Emit \"($0 instanceof WebSharper.UI.Next.Var)\" >]\n    let isVar  d = false\n\n    let toVal (o: obj) =\n        match o with\n        | :?      string   as t   -> Val.Constant t \n        | :?      int      as t   -> Val.Constant t |> unbox<Val<string>> \n        | :?      bool     as t   -> Val.Constant t |> unbox<Val<string>>  \n        | d    when isDoc     d   -> Val.Constant o |> unbox<Val<string>>  \n        | :? Val< string>  as v   ->              v        \n        | v    when isVar     v   -> Val.DynamicV (unbox<IRef<string>> v)\n        | v    when In \"RSet\" v   -> Val.DynamicV (unbox<IRef<string>> v)\n        | vw   when isView    vw  -> Val.Dynamic  (unbox<View<string>> vw)        \n        | _                       -> failwith <| sprintf \"Could not convert %A\" o\n      \n    [< Emit \"$0($1)\" >]\n    let inline fixitF f v = HelperType &> v\n    let inline fixit    v = fixitF toVal v\n    \n    let inline bindIRef0 (f: 'a->IRef<'b>) (view: View<'a>) = \n        let contentVar = Var.Create Unchecked.defaultof<'b>\n        let changingIRefO : IRef<'b> option ref = ref None\n        let contentVarChanged = ref 0L\n        let refVarChanged     = ref 0L\n    \n        contentVar.View \n        |> View.Sink (fun _ -> \n            !changingIRefO \n            |> Option.iter (fun r -> \n                if  !contentVarChanged  > !refVarChanged   then refVarChanged := !contentVarChanged\n                elif r.Value           <> contentVar.Value then refVarChanged := !refVarChanged       + 1L ; r.Value         <-  contentVar.Value\n               )\n           )\n    \n        view |> View.Bind (fun cur ->\n            let r = f cur\n            changingIRefO    := Some r\n            refVarChanged    := !contentVarChanged + 100L\n            contentVar.Value <- r.Value\n            r.View\n        ) |> View.Sink (fun _ -> \n            !changingIRefO \n            |> Option.iter (fun r -> \n                if  !refVarChanged  > !contentVarChanged then contentVarChanged := !refVarChanged\n                elif r.Value       <> contentVar.Value   then contentVarChanged := !contentVarChanged + 10L; contentVar.Value  <-  r.Value\n               )\n            )\n        contentVar\n        \n    let inline toDoc         v           = toView            (fixit v ) |> Doc.EmbedView\n    let inline bindIRef   f  v           = bindIRef0       f (fixit v   |> toView)\n    let inline iter       f  v           = iterV           f (fixit v )\n    let inline bind       f  v           = bindV           f (fixit v )\n    let inline map        f  v           = mapV            f (fixit v )\n    let inline map2       f  v1 v2       = map2V           f (fixit v1) (fixit v2)\n    let inline map3       f  v1 v2 v3    = map3V           f (fixit v1) (fixit v2) (fixit v3)\n    let inline map4       f  v1 v2 v3 v4 = map4V           f (fixit v1) (fixit v2) (fixit v3) (fixit v4)\n  \n    let inline iter2      f  v1 v2       = map2            f v1 v2       |> iterV id\n    let inline iter3      f  v1 v2 v3    = map3            f v1 v2 v3    |> iterV id\n    let inline iter4      f  v1 v2 v3 v4 = map4            f v1 v2 v3 v4 |> iterV id\n  \n    //let inline mapAsync   f  v           = View.MapAsync   f (fixit v |> toView) |> Dynamic\n    let inline sink       f  v           = View.Sink       f (fixit v |> toView) \n    let inline mapCached  f  v           = View.MapCached  f (      v |> toView) |> Dynamic\n\n    let inline consistent   (vl:Val<_>)  = \n        let prior      = ref <| Var.Create Unchecked.defaultof<_>\n        let setPrior v = if (!prior).Value <> v then (!prior).Value <- v \n        let vw         = toView vl\n        View.Sink setPrior vw\n        !prior |> DynamicV\n    \n","parent":{"$":0,"Item":"b30f728e-eb7c-40d1-b4ac-596e372b4e84"},"predecessors":[{"$":0,"Item":"ac152670-fb8a-4549-9659-1b6ee81d64ef"}],"id":{"$":0,"Item":"13151ce6-c10f-4773-b6fc-ef448af463e4"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Fable UI.Next 2","content":"[<NoComparison ; NoEquality>]\ntype HtmlNode =\n    | HtmlElement    of name: string * children: HtmlNode seq\n    | HtmlAttribute  of name: string * value:    Val<string>\n    | HtmlAttributeO of name: string * value:    Val<string option>\n    | HtmlText       of Val<string>\n    | HtmlEmpty\n    | HtmlElementV   of Val<HtmlNode>\n    | SomeDoc        of Doc\n    | SomeAttr       of Attr\n    \nlet addClassX    (classes:string) (add:string) = classes.Split ' ' |> Set.ofSeq |> Set.union  (Set.ofSeq <| add.Split ' ') |> String.concat \" \"\n//let removeClass (classes:string) (rem:string) = classes.Split ' ' |> Set.ofSeq |> Set.remove               rem            |> String.concat \" \"\n\n//let callAddClassX = addClassX \"a\" \"b\" // so that WebSharper.Collections.js is included\n\nlet inline chooseAttr node = \n    match node with\n    | HtmlAttribute (name, value   ) when name <> \"class\" && name <> \"style\" \n                                     -> Some <| Val.attrV    name value\n    | HtmlAttributeO(name, valueO  ) when name <> \"class\" && name <> \"style\" \n                                     -> Some <| Val.attrVO   name valueO\n    | SomeAttr             attr      -> Some <| attr\n    | _                              -> None\n\nlet chooseThisAttr this node =\n    match node with\n    | HtmlAttribute (att, value) when att = this -> Some value\n    | _                                          -> None\n\n\nlet concat s a b = a + s + b\n\nlet groupAttr name sep children = \n    children \n    |> Seq.choose (chooseThisAttr name)\n    |> (fun ss -> if ss |> Seq.isEmpty \n                  then None \n                  else ss |> Seq.reduce (Val.map2 <| concat sep ) |> Val.attrV name |> Some)\n\nlet inline getAttrsFromSeq children =\n    children \n    |> Seq.choose chooseAttr\n    |> Seq.append (List.choose id [ children |> groupAttr \"class\" \" \" ; children |> groupAttr \"style\" \"; \" ])\n\nlet rec chooseNode node =\n    match node with\n    | HtmlElement (name, children) -> Some <| (Doc.Element name (getAttrsFromSeq children) (children |> Seq.choose chooseNode) :> Doc)\n    | HtmlText     vtext           -> Some <| Val.tagDoc Doc.TextNode vtext\n    | SomeDoc      doc             -> Some <| doc\n    | HtmlElementV vnode           -> Some <| (vnode |> Val.toView |> Doc.BindView (chooseNode >> Option.defaultValue Doc.Empty))\n    | _                            -> None\n\nlet getAttrChildren attr =\n    Seq.tryPick (function \n                | HtmlAttribute(a, v) when a = attr -> Some v \n                | _                                 -> None)\n    >> Option.defaultValue (Constant \"\")\n\nlet rec mapHtmlElement (f:string -> seq<HtmlNode> -> string * HtmlNode seq) (element:HtmlNode) :HtmlNode =\n    match element with\n    | HtmlElement (name, children) -> f name  children                    |> HtmlElement\n    | HtmlElementV vnode           -> vnode |> Val.map (mapHtmlElement f) |> HtmlElementV\n    | _                            -> element\n\n//let getAttr attr element =\n//    match element with\n//    | HtmlElement(_, children) -> children\n//    | _                        -> seq []\n//    |> getAttrChildren attr\n//\n//let getClass = getAttr \"class\"\n//let getStyle = getAttr \"style\"\n\n//let replaceAttribute att (children: HtmlNode seq) newVal =\n//    HtmlAttribute(att, newVal)\n//    :: (children\n//        |> Seq.filter (function HtmlAttribute(old, _) when old = att -> false | _ -> true)\n//        |> Seq.toList\n//       )\n//\n//let replaceAtt att node newVal = mapHtmlElement (fun n ch -> n, replaceAttribute att ch newVal |> Seq.ofList) node\n\nlet inline htmlElement    name ch = HtmlElement   (name, ch           )\nlet inline htmlAttribute  name v  = HtmlAttribute (name, Val.fixit v  )\nlet inline htmlAttributeO name v  = HtmlAttributeO(name, Val.fixit v  )\nlet inline htmlText       txt     = HtmlText      (      Val.fixit txt)\nlet inline someElt        elt     = SomeDoc       (elt :> Doc         )    \n  \nlet inline addChildren    add (h:HtmlNode) = h |> mapHtmlElement (fun n ch -> n, Seq.append ch   add)\nlet inline insertChildren add (h:HtmlNode) = h |> mapHtmlElement (fun n ch -> n, Seq.append add  ch )\nlet inline addClass       c    h           = h |> addChildren [ htmlAttribute  \"class\" c ] \nlet inline addClassIf     c v              = addClass <| Val.map (fun b -> if b then c else \"\") (Val.fixit v)\n\ntype HtmlNode with\n    member inline this.toDoc = \n        match this with\n        | HtmlAttribute _\n        | HtmlEmpty       -> Doc.Empty\n        | _               -> chooseNode this |> Option.defaultValue Doc.Empty\n    // member inline   this.Class          clas = Val.fixit clas |> replaceAtt \"class\" this\n    member          this.AddChildren    add  = this |> addChildren    add\n    member          this.InsertChildren add  = this |> insertChildren add\n    member inline   this.AddClass       c    = this |> addClass       c\n\nlet renderDoc = chooseNode >> Option.defaultValue Doc.Empty\n    ","parent":{"$":0,"Item":"b30f728e-eb7c-40d1-b4ac-596e372b4e84"},"predecessors":[{"$":0,"Item":"13151ce6-c10f-4773-b6fc-ef448af463e4"}],"id":{"$":0,"Item":"b19dacf2-ac2a-4f05-9e43-a62bfc3c4bed"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Fable UI.Next 3","content":"let inline atr att v = Val.attrV  att (Val.fixit v)\nlet inline tag tag v = Val.tagDoc tag (Val.fixit v)\n\nlet inline _class       v = atr \"class\"       v\nlet inline _type        v = atr \"type\"        v\nlet inline _style       v = atr \"style\"       v\nlet inline _placeholder v = atr \"placeholder\" v\nlet inline textV        v = tag  Doc.TextNode v\n\nlet inline a           ch = htmlElement   \"a\"           ch\nlet inline ul          ch = htmlElement   \"ul\"          ch\nlet inline li          ch = htmlElement   \"li\"          ch\nlet inline br          ch = htmlElement   \"br\"          ch\nlet inline hr          ch = htmlElement   \"hr\"          ch\nlet inline h1          ch = htmlElement   \"h1\"          ch\nlet inline h2          ch = htmlElement   \"h2\"          ch\nlet inline h3          ch = htmlElement   \"h3\"          ch\nlet inline h4          ch = htmlElement   \"h4\"          ch\nlet inline h5          ch = htmlElement   \"h5\"          ch\nlet inline h6          ch = htmlElement   \"h6\"          ch\nlet inline div         ch = htmlElement   \"div\"         ch\nlet inline img         ch = htmlElement   \"img\"         ch\nlet inline span        ch = htmlElement   \"span\"        ch\nlet inline form        ch = htmlElement   \"form\"        ch\nlet inline table       ch = htmlElement   \"table\"       ch\nlet inline thead       ch = htmlElement   \"thead\"       ch\nlet inline th          ch = htmlElement   \"th\"          ch\nlet inline tr          ch = htmlElement   \"tr\"          ch\nlet inline td          ch = htmlElement   \"td\"          ch\nlet inline tbody       ch = htmlElement   \"tbody\"       ch\nlet inline label       ch = htmlElement   \"label\"       ch\nlet inline button      ch = htmlElement   \"button\"      ch\nlet inline script      sc = htmlElement   \"script\"      sc\nlet inline styleH      st = htmlElement   \"style\"       st\nlet inline fieldset    ch = htmlElement   \"fieldset\"    ch\nlet inline link        sc = htmlElement   \"link\"        sc\nlet inline iframe      at = htmlElement   \"iframe\"      at\nlet inline body        ch = htmlElement   \"body\"        ch\n\n\nlet inline target      v  = htmlAttribute  \"target\"      v\nlet inline href        v  = htmlAttribute  \"href\"        v\nlet inline hrefO       vO = htmlAttributeO \"href\"        vO\nlet inline rel         v  = htmlAttribute  \"rel\"         v\nlet inline charset     v  = htmlAttribute  \"charset\"     v\nlet inline src         v  = htmlAttribute  \"src\"         v\nlet inline ``class``   v  = htmlAttribute  \"class\"       v\nlet inline ``type``    v  = htmlAttribute  \"type\"        v\nlet inline width       v  = htmlAttribute  \"width\"       v\nlet inline title       v  = htmlAttribute  \"title\"       v\nlet inline Id          v  = htmlAttribute  \"id\"          v\nlet inline frameborder v  = htmlAttribute  \"frameborder\" v\nlet inline spellcheck  v  = htmlAttribute  \"spellcheck\"  v\nlet inline draggable   v  = htmlAttribute  \"draggable\"   v\nlet inline style       v  = htmlAttribute  \"style\"       v\n\nlet inline style1    n v  = style <| Val.map ((+) (n + \":\")) v\n\ntype HtmlNode with\n    member inline   this.Style          sty  = this.AddChildren([ style sty ])\n\nlet inline css         v  = styleH [ htmlText v ] \n\nlet inline classIf cls v = ``class`` <| Val.map (fun b -> if b then cls else \"\") (Val.fixit v)\n\nlet style2pairs (ss:string) : (string * string) [] =\n    ss.Split(';') \n    |> Array.map   (fun s -> s.Split(':') ) \n    |> Array.filter(fun d -> d.Length = 2 )\n    |> Array.map   (fun d -> d.[0].Trim(), d.[1].Trim() )\n\n//let string2Styles = style2pairs >> Array.map (fun (n, v) -> Attr.Style n v |> SomeAttr)\n\n//let composeDoc elt dtl dtlVal = dtlVal |> Val.toView |> Doc.BindView (Seq.append dtl >> elt >> renderDoc) |> SomeDoc\n\nlet inline bindHElem hElemF v  = Val.map hElemF  (Val.fixit v) |> HtmlElementV\n(*\nlet createIFrame f =\n    let cover = Var.Create true\n    div [ style           \"position: relative; overflow: hidden; height: 100%; width: 100%;\" \n          iframe \n            [ style       \"position: absolute; width:100%; height:100%;\"\n              frameborder \"0\"\n              SomeAttr <| on.afterRender f\n              SomeAttr <| on.mouseLeave (fun _ _ -> cover.Value <- true)\n            ]\n          div \n            [ style       \"position: absolute;\"\n              classIf     \"iframe-cover\" (Val.map id cover)               \n              SomeAttr <| on.mouseEnter (fun _ _ -> Input.Mouse.MousePressed \n                                                    |> View.Get (fun pressed -> if not pressed then cover.Value <- false))\n            ]          \n          styleH [ htmlText \".iframe-cover { top:0; left:0; right:0; bottom:0; background: blue; opacity: 0.04; z-index: 2; }\" ]\n        ]\n*)\n//[< Inline \"\"\"(!$v)\"\"\">]\nlet isUndefined v = true\n(*\nlet  findRootElement (e:Dom.Element) =\n    if isUndefined e.GetRootNode then JS.Document.Body\n    else\n        let root = e.GetRootNode()\n        if isUndefined root?body \n        then root.FirstChild :?> Dom.Element\n        else root?body  |> unbox<Dom.Element>\n*)\n\n[<NoComparison ; NoEquality>]\ntype Panel = {\n    _class   : Val<string>\n    _style   : Val<string>\n    title    : Val<string>\n    header   : HtmlNode seq\n    content  : HtmlNode seq\n    disabled : Val<bool>\n} with\n  static member  New   = { _class   = Val.fixit <| \"panel panel-default shadow\"\n                           _style   = Val.fixit <| \"text-align:center\" \n                           title    = Val.fixit <| \"Panel\"        \n                           header   =          [ htmlText \"Some text\"    ] \n                           content  =          [ htmlText \"Some Content\" ] \n                           disabled = Val.fixit <| Var.Create false\n                         }\n  member        this.Render          =  \n    fieldset [ //SomeAttr <| attr.disabledDynPred (View.Const \"\")  (this.disabled |> Val.toView)\n               div [ ``class`` this._class\n                     div (Seq.append\n                              [ ``class`` \"panel-heading\"\n                                label [ ``class``  \"panel-title text-center\" ; htmlText this.title ]\n                              ]\n                              this.header)\n\n                     div (Seq.append\n                              [ ``class`` \"panel-body\"\n                                style     this._style \n                              ]\n                              this.content)\n                   ] \n             ]\n  member inline this.Class       clas = { this with _class   = Val.fixit clas                                        }\n  member inline this.Style       sty  = { this with _style   = Val.fixit sty                                         }\n  member inline this.Title       txt  = { this with title    = Val.fixit txt                                         }\n  member inline this.Header      h    = { this with header   =       h                                           }\n  member inline this.Content     c    = { this with content  =       c                                           }\n  member inline this.Disabled    dis  = { this with disabled =       dis                                         }\n\n","parent":{"$":0,"Item":"b30f728e-eb7c-40d1-b4ac-596e372b4e84"},"predecessors":[{"$":0,"Item":"b19dacf2-ac2a-4f05-9e43-a62bfc3c4bed"}],"id":{"$":0,"Item":"82012458-72e3-453b-be38-9fc0b913fad8"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Template","content":"module Template =\n    let log f v = JS.ConsoleLog( sprintf f v); v \n\n    [<NoComparison ; NoEquality>]\n    type Panel = {\n        _class   : Val<string>\n        _style   : Val<string>\n        title    : Val<string>\n        header   : HtmlNode seq\n        content  : HtmlNode seq\n        disabled : Val<bool>\n    } with\n      static member  New   = { _class   = Val.fixit <| \"panel panel-default shadow\"\n                               _style   = Val.fixit <| \"text-align:center\" \n                               title    = Val.fixit <| \"Panel\"        \n                               header   =          [ htmlText \"Some text\"    ] \n                               content  =          [ htmlText \"Some Content\" ] \n                               disabled = Val.fixit <| Var.Create false\n                             }\n      member        this.Render          =  \n        fieldset [ SomeAttr <| attr.disabledDynPred (View.Const \"\")  (this.disabled |> Val.toView)\n                   div [ ``class`` this._class\n                         div (Seq.append\n                                  [ ``class`` \"panel-heading\"\n                                    label [ ``class``  \"panel-title text-center\" ; htmlText this.title ]\n                                  ]\n                                  this.header)\n    \n                         div (Seq.append\n                                  [ ``class`` \"panel-body\"\n                                    style     this._style \n                                  ]\n                                  this.content)\n                       ] \n                 ]\n      member inline this.Class       clas = { this with _class   = Val.fixit clas }\n      member inline this.Style       sty  = { this with _style   = Val.fixit sty  }\n      member inline this.Title       txt  = { this with title    = Val.fixit txt  }\n      member inline this.Header      h    = { this with header   =       h        }\n      member inline this.Content     c    = { this with content  =       c        }\n      member inline this.Disabled    dis  = { this with disabled =       dis      }\n\n\n    [<NoComparison ; NoEquality>]\n    type HtmlMeasure =\n    | Percentage of Val<float>\n    | Pixel      of Val<float>\n    \n    [<NoComparison ; NoEquality>]\n    type SplitterBar = {\n        value            : IRef<float>\n        min              : Val<float>\n        max              : Val<float>\n        vertical         : Val<bool>\n        node             : HtmlNode\n        children         : HtmlNode seq\n        after            : bool\n        mutable dragging : bool\n        mutable startVer : bool \n        mutable startP   : float \n        mutable start    : float \n        mutable size     : float \n        mutable domElem  : Dom.Element option\n    }\n    with\n        static member New(var) = \n            {\n                value    = var\n                min      = Val.fixit   5.0\n                max      = Val.fixit  95.0\n                vertical = Val.fixit  true  \n                node     = div [ ``class`` \"Splitter\" ]\n                children = []\n                after    = true\n                dragging = false\n                startVer = true\n                startP   = 0.0\n                start    = 0.0\n                size     = 0.0\n                domElem  = None\n            }\n        static member New(value)    = SplitterBar.New(Var.Create value)\n        member        this.Var      = this.value\n        member        this.GetValue = this.value |> Val.map2 max this.min |> Val.map2 min this.max\n        member        this.Render   =\n            let mouseCoord (ev: Dom.MouseEvent) = if this.startVer then float ev.ClientX else float ev.ClientY\n            let size () : float =\n                match this.domElem with\n                | None    -> 100.0\n                | Some el -> \n                 el.ParentElement.GetBoundingClientRect() \n                 |> fun r -> \n                     match this.startVer, this.after with\n                     | true , true  ->  r.Width  \n                     | true , false -> -r.Width \n                     | false, true  ->  r.Height\n                     | false, false -> -r.Height\n                 |> log \"size %A\"\n            let drag (ev: Dom.Event) =\n                ev :?> Dom.MouseEvent\n                |> mouseCoord                                                                //|> log \"mouseCoord: %A\"\n                |> fun m   -> (m - this.start) * 100.0 / this.size + this.startP             //|> log \"Value: %A\"\n                |> fun v   -> this.value.Value <- v \n               \n            let rec finishDragging (_: Dom.Event) =\n                if this.dragging then\n                    this.dragging <- false\n                    JS.Window.RemoveEventListener(\"mousemove\", drag          , false) \n                    JS.Window.RemoveEventListener(\"mouseup\"  , finishDragging, false) \n                    //printfn \"mouseup\"\n            let startDragging _ (ev: Dom.MouseEvent) =\n                if not this.dragging then\n                    Val.map2 (fun startP dirV ->\n                        this.dragging <- true\n                        this.startVer <- dirV\n                        this.startP   <- startP\n                        this.start    <- mouseCoord ev\n                        this.size     <- size()\n                        JS.Window.AddEventListener(\"mousemove\", drag          , false) \n                        JS.Window.AddEventListener(\"mouseup\"  , finishDragging, false) \n                        ev.PreventDefault()\n                    ) this.GetValue this.vertical\n                    |> Val.iter id\n            this.node\n              .AddChildren(\n              [\n                ``class`` <| Val.map (fun ver -> if ver then \"Vertical\" else \"Horizontal\") this.vertical \n                SomeAttr  <| on.mouseDown startDragging\n                SomeAttr  <| on.afterRender (fun el -> log \"afterRender %A\" (); this.domElem <- Some el)\n                css \"\n                    .Splitter.Vertical   { cursor: col-resize; background-color: #eef ; width : 5px ; margin-left:-7px; }\n                    .Splitter.Horizontal { cursor: row-resize; background-color: #eef ; height: 5px ; margin-top :-7px; }\n                \"\n              ])\n              .AddChildren this.children\n        member inline this.Value       v =   this.value.Value <- v  ; this\n        member inline this.Node     node = { this with node         = node                        }\n        member inline this.Min         v = { this with min          = Val.fixit v                 }\n        member inline this.Max         v = { this with max          = Val.fixit v                 }\n        member inline this.VerticalV   v = { this with vertical     = Val.fixit v                 }\n        member inline this.HorizontalV v = { this with vertical     = Val.fixit v |> Val.map not  }\n        member inline this.Vertical   () = { this with vertical     = Val.fixit true              }\n        member inline this.Horizontal () = { this with vertical     = Val.fixit false             }\n        member inline this.Before        = { this with after        =           false             }\n        member inline this.After         = { this with after        =           true              }\n        member inline this.Children   ch = { this with children     = ch                          }\n        \n    \n    let [< Emit \"try { return !!(ResizeObserver) } catch(e) { return false }\" >] implementedResizeObserver() = false\n    let [< Emit \"new ResizeObserver($0)\" >] newResizeObserver (f: unit->unit) = jsNative    \n    let [< Emit \"$0.observe($1)\"         >] RObserve ro (el:Dom.Element)      = jsNative\n    \n    let mutable observers : obj list = []\n\n    let rec isValidElement (el:Dom.Element) = \n        let r = el.GetBoundingClientRect()\n        (r.Top, r.Left, r.Width, r.Height) <> (0., 0., 0., 0.)\n\n    let addResizeObserver f el =\n        if implementedResizeObserver() then\n            let ro =  newResizeObserver f\n            observers <- ro::observers\n            RObserve ro el\n        else \n            JS.SetInterval f 110 |> ignore\n//            async {\n//                while isValidElement el do\n//                    do! Async.Sleep 110\n//                    f()\n//            } |> Async.Start\n            \n    [<NoComparison ; NoEquality>]\n    type Area =\n    | Auto     of SplitterBar\n    | Fixed    of HtmlMeasure\n    | Splitter of SplitterBar\n    \n    type SectionType =\n    | StVariable\n    | StFixedPx\n    | StFixedPerc\n    \n    [<NoComparison ; NoEquality>]\n    type Grid = {\n        padding       : float\n        gap           : float\n        content       : (string option * HtmlNode) []\n        cols          : Area []\n        rows          : Area []\n        width         : IRef<float>\n        height        : IRef<float>\n        lastSplitter  : (int * bool) option\n    }\n    with\n        static member New = {\n           padding       = 9.0\n           gap           = 9.0\n           cols          = [| |]\n           rows          = [| |]\n           content       = [| |]\n           width         = Var.Create 1000.0\n           height        = Var.Create  100.0\n           lastSplitter  = None\n        }\n        member this.NewSplitter  (f: float)  col =\n            let spl = SplitterBar.New(f)\n            if col then\n                { this with lastSplitter = Some (this.cols.Length, col) ; cols = Array.append this.cols  [| spl              |> Splitter |] }\n            else \n                { this with lastSplitter = Some (this.rows.Length, col) ; rows = Array.append this.rows  [| spl.Horizontal() |> Splitter |] }\n        member inline this.ColFixedPx   f              = { this with cols    = Array.append this.cols    [| Pixel     (Val.fixit f)              |> Fixed    |] }\n        member inline this.ColFixed     f              = { this with cols    = Array.append this.cols    [| Percentage(Val.fixit f)              |> Fixed    |] }\n        member inline this.ColVariableS(s:SplitterBar) = { this with cols    = Array.append this.cols    [| s                                    |> Splitter |] }\n        member inline this.ColVariable (f:float)       = this.NewSplitter f true\n        member inline this.ColAuto     (f:float)       = { this with cols    = Array.append this.cols    [| SplitterBar.New(     f)              |> Auto     |] }\n        member inline this.RowFixedPx   f              = { this with rows    = Array.append this.rows    [| Pixel     (Val.fixit f)              |> Fixed    |] }\n        member inline this.RowFixed     f              = { this with rows    = Array.append this.rows    [| Percentage(Val.fixit f)              |> Fixed    |] }\n        member inline this.RowVariableS(s:SplitterBar) = { this with rows    = Array.append this.rows    [| s                                    |> Splitter |] }\n        member inline this.RowVariable (f:float)       = this.NewSplitter f false\n        member inline this.RowAuto     (f:float)       = { this with rows    = Array.append this.rows    [| SplitterBar.New(     f).Horizontal() |> Auto     |] }\n        member        this.Content (area, html)        = { this with content = Array.append this.content [| Some area, html                                  |] }\n        member        this.Content0       html         = { this with content = Array.append this.content [| None     , html                                  |] }\n        member inline this.Padding      f              = { this with padding = f                                                                                }\n        member inline this.Gap          f              = { this with gap     = f                                                                                }\n        member this.changeSplitter f =\n            this.lastSplitter\n            |> Option.iter (fun (pos, col) ->\n                if col then\n                    match this.cols.[pos] with\n                    | Splitter spl -> this.cols.[pos] <- Splitter <| f spl \n                    | _            -> ()\n                else \n                    match this.rows.[pos] with\n                    | Splitter spl -> this.rows.[pos] <- Splitter <| f spl \n                    | _            -> ()\n            )\n            this\n        member        this.Before                = this.changeSplitter (fun spl -> spl.Before     )\n        member inline this.Max                 v = this.changeSplitter (fun spl -> spl.Max       v)\n        member inline this.Min                 v = this.changeSplitter (fun spl -> spl.Min       v)\n        member inline this.Children           ch = this.changeSplitter (fun spl -> spl.Children ch)\n        member this.style    (areas:Area[]) size =\n            if areas.Length = 0 then Val.Constant \"100%\" else\n            let pcs, pxs = \n                areas \n                |> Seq.fold (fun (pcs, pxs) a ->\n                    match a with\n                    | Auto              spl -> (                          pcs,                pxs)          \n                    | Splitter          spl -> (Val.map2 (+) spl.GetValue pcs,                pxs) \n                    | Fixed (Percentage v)  -> (Val.map2 (+) v            pcs,                pxs)\n                    | Fixed (Pixel      v)  -> (                          pcs, Val.map2 (+) v pxs)\n                ) (Val.Constant 0.0, Val.Constant 0.0)\n            let finalPerc = Val.map2 (fun v size -> (size - this.padding * 2. - this.gap * ((float areas.Length) - 1.) - v) / (size - this.padding * 2.)) pxs size\n            let autoPct   = Val.map  ((-) 100.0)  pcs \n            let perc   pc = Val.map2 (fun finalPerc pc -> finalPerc * pc |> max 0.0 |> sprintf \"%f%%\") finalPerc pc\n            let pixel  px = Val.map  (fun           px ->             px |> max 0.0 |> sprintf \"%fpx\")           px\n            areas\n            |> Seq.foldBack (fun a state ->\n                match a with\n                |  Auto              spl -> perc  autoPct          \n                |  Splitter          spl -> perc  spl.GetValue\n                |  Fixed (Percentage v)  -> perc  v\n                |  Fixed (Pixel      v)  -> pixel v\n                |> Val.map2(fun state v -> v::state) state\n               )  <| (Val.Constant [])\n            |> Val.map (String.concat \" \")\n        member this.styles() =\n            [ style1 \"grid-template-columns\" <| this.style this.cols this.width\n              style1 \"grid-template-rows\"    <| this.style this.rows this.height\n            ]\n        member this.GridTemplate() =\n            [ \n                yield!\n                    this.content\n                    |> Seq.map (fun (area, html) ->\n                        match area with\n                        | None   -> html\n                        | Some a -> html.AddChildren([ style <| sprintf \"grid-area: %s; dispxlay: grid\" a ])\n                       )\n                yield!\n                    this.cols\n                    |> Seq.indexed\n                    |> Seq.choose (function\n                        | i, Auto     spl -> None           \n                        | i, Splitter spl -> Some <| spl.Render.InsertChildren( \n                                                [ style1 \"grid-column\" (string (i + if spl.after then 2 else 1))\n                                                  style1 \"grid-row\"    (sprintf \"1 / %d\" (this.rows.Length + 1)) ] ) \n                        | i, Fixed    _   -> None\n                   )\n                yield!\n                    this.rows\n                    |> Seq.indexed\n                    |> Seq.choose (function\n                        | i, Auto     spl -> None           \n                        | i, Splitter spl -> Some <| spl.Render.InsertChildren( \n                                                [ style1 \"grid-row\"    (string (i + if spl.after then 2 else 1))\n                                                  style1 \"grid-column\" (sprintf \"1 / %d\" (this.cols.Length + 1)) ] ) \n                        | i, Fixed    _   -> None\n                   )\n                yield! this.styles() \n                yield style    <| sprintf \"display: grid; grid-gap: %fpx; padding: %fpx; box-sizing: border-box\" this.gap this.padding \n                yield SomeAttr <| on.afterRender(fun (el:Dom.Element) -> \n                    let setVar (vr:IRef<_>) vl = if vr.Value <> vl then vr.Value <- vl \n                    let setDimensions () =\n                        el.GetBoundingClientRect()\n                        |> fun r ->  \n                            setVar this.width  r.Width\n                            setVar this.height r.Height\n                    do  setDimensions()\n                    addResizeObserver setDimensions el\n                  ) \n            ]\n        member this.Render =\n            div <| this.GridTemplate()\n        static member inline NewBisect(first, secT, ver, per:float, ch1, ch2) =\n            let sect, auto, areas = \n                if ver then match secT with\n                            | StVariable  -> fun (g:Grid) -> g.ColVariable per\n                            | StFixedPx   -> fun (g:Grid) -> g.ColFixedPx  per\n                            | StFixedPerc -> fun (g:Grid) -> g.ColFixed    per\n                           ,                (fun (g:Grid) -> g.ColAuto 50.0)\n                           ,                 fun (g:Grid) -> g.Content0( style \"grid-template-areas: 'one   two' \" )\n                       else match secT with\n                            | StVariable  -> fun (g:Grid) -> g.RowVariable per\n                            | StFixedPx   -> fun (g:Grid) -> g.RowFixedPx  per\n                            | StFixedPerc -> fun (g:Grid) -> g.RowFixed    per\n                           ,                (fun (g:Grid) -> g.RowAuto 50.0)\n                           ,                 fun (g:Grid) -> g.Content0( style \"grid-template-areas: 'one' 'two' \" )\n            Grid.New.Content(\"one\", ch1)\n                    .Content(\"two\", ch2).Padding(0.0)\n            |> areas\n            |> (if first then sect >> auto\n                         else auto >> sect)\n                         ","parent":{"$":0,"Item":"b30f728e-eb7c-40d1-b4ac-596e372b4e84"},"predecessors":[{"$":0,"Item":"ac152670-fb8a-4549-9659-1b6ee81d64ef"},{"$":0,"Item":"82012458-72e3-453b-be38-9fc0b913fad8"}],"id":{"$":0,"Item":"da5508bb-2f38-4096-bd2b-1015d26e131b"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableFable":"1"}},{"name":"","content":"\ntype Elem =\n    | Div      of Elem list\n    | HtmlText of string\n    | Style    of string\n    \nlet div      = Div\nlet htmlText = HtmlText\nlet style    = Style\n\ntype Grid = {\n    something : string\n}\nwith     \n    static member New = { something = \"New\" } \n    member this.ColFixed    n = { this with something = this.something |> sprintf \"%s.ColFixed(%f)\"    <| n      }\n    member this.ColVariable n = { this with something = this.something |> sprintf \"%s.ColVariable(%f)\" <| n      }\n    member this.ColAuto     n = { this with something = this.something |> sprintf \"%s.ColAuto(%f)\"     <| n      }\n    member this.RowFixed    n = { this with something = this.something |> sprintf \"%s.RowFixed(%f)\"    <| n      }\n    member this.RowVariable n = { this with something = this.something |> sprintf \"%s.RowVariable(%f)\" <| n      }\n    member this.RowAuto     n = { this with something = this.something |> sprintf \"%s.RowAuto(%f)\"     <| n      }\n    member this.Before        = { this with something = this.something |> sprintf \"%s.Before\"                    }\n    member this.Max         n = { this with something = this.something |> sprintf \"%s.Max(%f)\"         <| n      }\n    member this.Content     c = { this with something = this.something |> sprintf \"%s.Content(%A)\"     <| c      }\n    member this.Content(p, c) = { this with something = this.something |> sprintf \"%s.Content(%s, %A)\" <| p <| c }\n\nlet sc1 = 30.0\nlet sr1 = 30.0\n\nlet grid =\n  Grid.New\n    .ColFixed(8.0).ColVariable(sc1).ColAuto(16.0).ColVariable(50.0).Before.Max(54.) //Val.map ((-) 84.0) sc1.GetValue)\n    .RowFixed(8.0).RowVariable(sr1).RowAuto(16.0).RowVariable(50.0).Before.Max(54.) //Val.map ((-) 84.0) sr1.GetValue)\n    .Content(         div [ htmlText \"Div11\" ; style \"background-color: lightblue\"  ])\n    .Content(\"1 / 2\", div [ htmlText \"Div12\" ; style \"background-color: lightgreen\" ])\n    .Content(\"1 / 3\", div [ htmlText \"Div13\" ; style \"background-color: pink\"       ])\n    .Content(\"1 / 4\", div [ htmlText \"Div14\" ; style \"background-color: magenta\"    ])\n    .Content(\"2 / 1\", div [ htmlText \"Div21\" ; style \"background-color: lightblue\"  ])\n    .Content(\"2 / 2\", div [ htmlText \"Div22\" ; style \"background-color: lightblue\"  ])\n    .Content(\"3 / 3\", div [ htmlText \"Div33\" ; style \"background-color: pink\"       ])\n    .Content(\"4 / 4\", div [ htmlText \"Div44\" ; style \"background-color: magenta\"    ])\n\ngrid\n|> printfn \"%A\" ","parent":{"$":0,"Item":"b30f728e-eb7c-40d1-b4ac-596e372b4e84"},"predecessors":[],"id":{"$":0,"Item":"6f21cac6-796b-4cec-9242-3133e24a9f98"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"RunCode","content":"module RunCode =\n    type RunNode(nodeName, ?clearNode: bool) =\n      let bClearNode    = defaultArg clearNode true\n      let createNode() =\n          let e = JS.Document.CreateElement \"div\"\n          e?style <- \"height: 100%; width: 100%;\"\n          e\n      let createBaseNode () =\n          let el = JS.Document.CreateElement \"div\"\n          el.SetAttribute(\"id\", nodeName)\n          JS.Document.Body.AppendChild el |> ignore\n          el\n      let baseNode = \n          match JS.Document.GetElementById nodeName with\n          | null -> createBaseNode()\n          | node -> node\n      let runNode =\n          let shadowRootInit = createObj [ \"mode\" ==> \"open\" ]\n          match baseNode.ShadowRoot with\n          | null -> let p = createNode()\n                    baseNode.AttachShadow(shadowRootInit).AppendChild p |> ignore\n                    let e = createNode()\n                    p.AppendChild e |> ignore\n                    e\n          | root -> root.FirstChild :?> Dom.Element\n      do if bClearNode then runNode.InnerHTML <- \"\"\n    with\n      new(?clearNode: bool) = RunNode(\"TestNode\", ?clearNode = clearNode)\n      member this.RunNode   = runNode\n      member this.AddBootstrap =\n        JS.Document.CreateElement \"div\"\n        |> fun el -> \n            el.InnerHTML <- \n              @\"<script src='http://code.jquery.com/jquery-3.1.1.min.js' type='text/javascript' charset='UTF-8'></script>\n                <script src='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js' type='text/javascript' charset='UTF-8'></script>\n                <link type='text/css' rel='stylesheet' href='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css'>\n                <link type='text/css' rel='stylesheet' href='/EPFileX/css/main.css'>\n               \"\n            runNode.ParentNode.AppendChild el |> ignore\n        this\n      member inline this.RunDoc doc = doc :> Doc |> Doc.Run this.RunNode\n      member inline this.RunHtml node = node |> renderDoc |> this.RunDoc\n      member this.ShowHtmlResult res =\n        this.AddBootstrap |> ignore\n        div [ ``class`` \"container\"\n              Template.Panel.New\n                .Title(\"Result:\")\n                .Header([])\n                .Content([ h3 res ; style \"font-family:monospace;\" ])\n                .Render\n         ] |> this.RunHtml\n      member this.ShowHtmlResult res = this.ShowHtmlResult [res]\n    ","parent":{"$":0,"Item":"b30f728e-eb7c-40d1-b4ac-596e372b4e84"},"predecessors":[{"$":0,"Item":"da5508bb-2f38-4096-bd2b-1015d26e131b"},{"$":0,"Item":"13151ce6-c10f-4773-b6fc-ef448af463e4"},{"$":0,"Item":"ac152670-fb8a-4549-9659-1b6ee81d64ef"}],"id":{"$":0,"Item":"bdeadbd2-e1a4-41b7-87ab-f61643b0f5be"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Demo Button","content":"module JS =\n    let [< Emit \"alert($0)\" >] Alert v = ()\n    \nmodule Template =\n    [<NoComparison ; NoEquality>]\n    type Button = {\n        _class  : Val<string>\n        _type   : Val<string>\n        style   : Val<string>\n        text    : Val<string>\n        onClick : Dom.Element -> Dom.MouseEvent -> unit\n        disabled: Val<bool>\n        id      : string\n    } with\n      static member inline New txt = \n          { _class   = Val.fixit \"btn\" \n            _type    = Val.fixit \"button\" \n            style    = Val.fixit \"\"\n            text     = Val.fixit txt\n            onClick  = fun _ _ -> ()\n            disabled = Val.fixit false\n            id       = \"\"\n          }\n      member        this.Render     =         \n        button [ ``type``  <| this._type\n                 ``class`` <| this._class\n                 Id        <| this.id  \n                 style     <| this.style\n//                 SomeAttr  <| attr.disabledDynPred (View.Const \"\") (this.disabled |> Val.toView)\n                 SomeAttr  <| on.click <@ this.onClick @>\n                 HtmlText  <| this.text \n               ] \n        |> renderDoc |> SomeDoc\n      member inline this.Id          id   = { this with id       = id             }\n      member inline this.Class       clas = { this with _class   = Val.fixit clas }\n      member inline this.Type        typ  = { this with _type    = Val.fixit typ  }\n      member inline this.Style       sty  = { this with style    = Val.fixit sty  }\n      member inline this.Text        txt  = { this with text     = Val.fixit txt  }\n      member inline this.Disabled    dis  = { this with disabled = Val.fixit dis  }\n      member inline this.OnClick     f    = { this with onClick  = f              }\n\nTemplate.Button\n   .New(    \"Press me!\"                         )\n   .OnClick(fun _ _ -> JS.Alert \"Button pressed\")\n   .Style(  \"font-size: 48px\"                   )\n   .Render\n|> renderDoc\n|> Doc.RunById \"TestNode\" \n   \n","parent":{"$":0,"Item":"b30f728e-eb7c-40d1-b4ac-596e372b4e84"},"predecessors":[{"$":0,"Item":"82012458-72e3-453b-be38-9fc0b913fad8"}],"id":{"$":0,"Item":"2ed09262-d6f2-4b9d-a035-6d1c9cf9bc3f"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Test Mouse","content":"printfn \"Running\"\n\n\nlet panel1 res =\n    Panel.New\n      .Title(Val.map (fun pressed -> if pressed then \"PRESSED\" else \"---\") Input.Mouse.MousePressed)\n      .Header([])\n      .Content([ h3 [ htmlText <| sprintf \"%A\" res ; style \"font-family:monospace;\"] ])\n      .Render\n\ndiv [ ``class`` \"container\"\n      panel1 <| 7 * 7\n      div [ ``class`` \"container\"\n            div [ ``class`` \"container\"\n                  panel1 <| 7 * 8\n\n                ]\n          ]\n    ]\n|> renderDoc\n|> Doc.RunById \"TestNode\" \n\nprintfn \"Ran\"\n","parent":{"$":0,"Item":"b30f728e-eb7c-40d1-b4ac-596e372b4e84"},"predecessors":[{"$":0,"Item":"82012458-72e3-453b-be38-9fc0b913fad8"}],"id":{"$":0,"Item":"f56e40da-45c8-4844-9bb3-b713a1e90248"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Demo TextArea","content":"module Template =\n    [<NoComparison ; NoEquality>]\n    type TextArea = {\n        _class      : Val<string>\n        placeholder : Val<string>\n        title       : Val<string>\n        spellcheck  : Val<bool>\n        id          : string\n        var         : IRef<string>\n    } with\n      static member  New(var) = { _class      = Val.fixit \"form-control\"\n                                  placeholder = Val.fixit \"Enter text:\"\n                                  title       = Val.fixit \"\"\n                                  spellcheck  = Val.fixit false\n                                  id          = \"\"\n                                  var         = var \n                                }\n      static member  New(v)   = TextArea.New(Var.Create v)\n      member        this.RenderWith  more  =    \n        Doc.InputArea\n            ([ \n              _class              this._class\n              //attr.id             this.id  \n              atr \"spellcheck\" <| Val.map (fun spl -> if spl then \"true\" else \"false\") this.spellcheck\n              atr \"title\"         this.title\n              atr \"style\"        \"height: 100%;  width: 100%; box-sizing: border-box; \"\n              _placeholder        this.placeholder \n             ] @ more)\n            this.var\n        |> someElt \n        |> Seq.singleton \n        |> Seq.toArray\n        //|> Seq.append [ style \"height: 100%;  width: 100%; box-sizing: border-box; \" ] \n        |> div\n      member        this.Render           = this.RenderWith []    \n      member inline this.Class       clas = { this with _class      = Val.fixit clas }\n      member inline this.Placeholder plc  = { this with placeholder = Val.fixit plc  }\n      member inline this.Title       ttl  = { this with title       = Val.fixit ttl  }\n      member inline this.Spellcheck  spl  = { this with spellcheck  = spl            }\n      member inline this.Id          id   = { this with id          = id             }\n      member inline this.SetVar      v    = { this with var         = v              }\n      member inline this.Var              = this.var\n  \n\nlet inp = Template.TextArea.New(\"Type Something...\").Placeholder(\"Output:\"    ).Title(\"Output\"                   )\nprintfn \"Runnning\"\n\nlet text = htmlText inp.Var\n\nh3 [\n  inp.Render\n  text\n  htmlElement \"h2\" [ text ]\n  h1 [ text ]\n] \n:: []\n|> div\n|> renderDoc\n|> Doc.RunById \"TestNode\" \n\nprintfn \"Ran\"\n","parent":{"$":0,"Item":"b30f728e-eb7c-40d1-b4ac-596e372b4e84"},"predecessors":[{"$":0,"Item":"82012458-72e3-453b-be38-9fc0b913fad8"}],"id":{"$":0,"Item":"211f2565-8bc1-434c-8470-dd629f82bb57"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Demo SplitterBar","content":"let styleT   p =\n  sprintf \"\"\"\n.SplitterArea {\n    display: grid;\n    grid-template-columns: %f%% %f%%;\n    grid-template-areas:   \"left right\";\n    background-color: #41414d;\n    color: #444;\n    height: 50px;\n    width: 1000px;\n    grid-gap: 9px;\n    padding : 9px;\n}\n\n.SplitterArea > :nth-child(1){  grid-area: left  ; overflow: hidden; background-color: lightgreen; }\n.SplitterArea > :nth-child(2){  grid-area: right ; overflow: hidden; background-color: lightblue ; }\n\n.Splitter { \n    grid-column     :    2      ;\n    grid-row        :  1/2      ;\n    width           :    5px    ; \n    margin-left     :   -7px    ; \n    border          :    0px    ; \n    padding         :    0px    ;\n    cursor          : col-resize;\n  \tbackground-color: #eef      ; \n}   \"\"\"  (p * 0.99) (0.99 * (100.0 - p))\n\nlet min        = Var.Create 25.0 //Template.Input.New(\"25.0\").Prefix(htmlText \"Min:  \")\nlet max        = Var.Create 75.0 //Template.Input.New(\"75.0\").Prefix(htmlText \"Max:  \")\nlet value      = Var.Create 40.0 //Template.Input.New(\"40.0\").Prefix(htmlText \"Value:\")\nlet splitter   = Template.SplitterBar.New(value)//(value.Var.Lens (fun s -> float s) (fun prev f -> sprintf \"%f\" <| (f * 10. |> Math.Round |> float ) / 10. ) )\n                     .Min(min)\n                     .Max(max)\n\nprintfn \"Demo SplitterBar\"\n\nlet bar =\n    div [\n      ``class`` \"SplitterArea\"\n      div    [ htmlText <| Val.map (             sprintf \"LEFT  %f\")  splitter.GetValue ]\n      div    [ htmlText <| Val.map (((-)100.) >>(sprintf \"RIGHT %f\")) splitter.GetValue ]\n      styleH [ htmlText <| Val.map styleT                             splitter.GetValue ]\n      splitter.Render\n    ]\n    \ndiv [\n  bar\n  div [ htmlText <| Val.map (sprintf \"Min: %f\") min   ] // .Render\n  div [ htmlText <| Val.map (sprintf \"Max: %f\") max   ] // .Render\n  div [ htmlText <| Val.map (sprintf \"Val: %f\") value ] // .Render\n]\n|> RunCode.RunNode().AddBootstrap.RunHtml//PlusFree\n","parent":{"$":0,"Item":"b30f728e-eb7c-40d1-b4ac-596e372b4e84"},"predecessors":[{"$":0,"Item":"bdeadbd2-e1a4-41b7-87ab-f61643b0f5be"},{"$":0,"Item":"da5508bb-2f38-4096-bd2b-1015d26e131b"}],"id":{"$":0,"Item":"f7841b2d-7812-4d81-b3bf-81f8f813be2e"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Demo Grid","content":"\n            \n    \nopen Template\n        \nlet sc1 = SplitterBar.New(30.0)\nlet sr1 = SplitterBar.New(30.0).Horizontal()\n\nlet inline content1 v     (g: Grid) = g.Content(v   )\nlet inline content2 (a,b) (g: Grid) = g.Content(a, b)\nlet inline render         (g: Grid)         = g.Render\n\nlet inline fixedHorSplitter1 px ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", ch1)\n                       .Content(\"two\", ch2).Padding(0.0)\n    grid.RowFixedPx(px).RowAuto(50.0).Content0( style \"grid-template-areas: 'one' 'two' \" ).Render\n\nlet inline fixedHorSplitter2 px ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", ch1)\n                       .Content(\"two\", ch2).Padding(0.0)\n    grid.RowAuto(50.0).RowFixedPx(px).Content0( style \"grid-template-areas: 'one' 'two' \" ).Render\n\nlet div22 =\n        fixedHorSplitter2 80.0    \n            <| (fixedHorSplitter1 34.0 \n                <| div [ htmlText \"Fixed34px\" ; style \"background-color: lightblue\"  ]\n                <| div [ htmlText \"Variable \" ; style \"background-color: lightgreen\" ])\n            <| div [ htmlText \"Fixed80px\" ; style \"background-color: magenta\"    ]\n\nlet grid0 =\n    Grid.New\n      .ColFixed(8.0).ColVariableS(sc1).ColAuto(16.0).ColVariable(50.0).Before.Max(Val.map ((-) 84.0) sc1.GetValue)\nlet grid1 =\n    grid0\n      .RowFixed(8.0).RowVariableS(sr1).RowAuto(16.0).RowVariable(50.0).Before.Max(Val.map ((-) 84.0) sr1.GetValue)\nlet grid2 =\n    grid1\n      .Content0(        div [ htmlText \"Div11\" ; style \"background-color: lightblue\"  ])\n      .Content(\"1 / 2\", div [ htmlText \"Div12\" ; style \"background-color: lightgreen\" ])\n      .Content(\"1 / 3\", div [ htmlText \"Div13\" ; style \"background-color: pink\"       ])\n      .Content(\"1 / 4\", div [ htmlText \"Div14\" ; style \"background-color: magenta\"    ])\nlet grid =\n    grid2\n      .Content(\"2 / 1\", div [ htmlText \"Div21\" ; style \"background-color: lightblue\"  ])\n      .Content(\"2 / 2\", div22                                                          )\n      .Content(\"3 / 3\", div [ htmlText \"Div33\" ; style \"background-color: pink\"       ])\n      .Content(\"4 / 4\", div [ htmlText \"Div44\" ; style \"background-color: magenta\"    ])\n\nprintfn \"Demo Grid\"\n\ngrid.Render\n|> fun el -> el.AddChildren [ style \"height: 600px\" ]\n|> RunCode.RunNode().ShowHtmlResult\n","parent":{"$":0,"Item":"b30f728e-eb7c-40d1-b4ac-596e372b4e84"},"predecessors":[{"$":0,"Item":"bdeadbd2-e1a4-41b7-87ab-f61643b0f5be"},{"$":0,"Item":"ac152670-fb8a-4549-9659-1b6ee81d64ef"},{"$":0,"Item":"82012458-72e3-453b-be38-9fc0b913fad8"}],"id":{"$":0,"Item":"af851ad2-7069-4b5e-b682-9e2d148138de"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"JavaScript","content":"require([\"exports\", \"fable-core/Symbol\", \"fable-core/Util\", \"fable-core/String\", \"fable-core/Seq\", \"fable-core/Set\", \"fable-core/Comparer\", \"fable-core/CurriedLambda\", \"fable-core/List\", \"fable-core/Array\"], function (exports, _Symbol2, _Util, _String, _Seq, _Set, _Comparer, _CurriedLambda, _List, _Array2) {\n  \"use strict\"; try { exports = exports || {}; } catch (err) {}\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.grid = exports.grid2 = exports.grid1 = exports.grid0 = exports.div22 = exports.sr1 = exports.sc1 = exports.RunCode = exports.Template = exports.Panel = exports.renderDoc = exports.HtmlNode = exports.ValModule = exports.attr = exports.on = exports.Val = exports.DocModule = exports.View = exports.IRef = exports.Elt = exports.Doc = exports.Attr = exports.Option = exports.JS = exports.Window = exports.Dom = undefined;\n  exports.addClassX = addClassX;\n  exports.chooseThisAttr = chooseThisAttr;\n  exports.concat = concat;\n  exports.groupAttr = groupAttr;\n  exports.chooseNode = chooseNode;\n  exports.getAttrChildren = getAttrChildren;\n  exports.mapHtmlElement = mapHtmlElement;\n  exports.style2pairs = style2pairs;\n  exports.isUndefined = isUndefined;\n\n  var _Symbol3 = _interopRequireDefault(_Symbol2);\n\n  var _Comparer2 = _interopRequireDefault(_Comparer);\n\n  var _CurriedLambda2 = _interopRequireDefault(_CurriedLambda);\n\n  var _List2 = _interopRequireDefault(_List);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  const Dom = exports.Dom = function (__exports) {\n    const DomRect = __exports.DomRect = class DomRect {\n      constructor(top, left, width, height) {\n        this.top = top;\n        this.left = left;\n        this.width = width;\n        this.height = height;\n      }\n\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Dom.DomRect\",\n          interfaces: [\"FSharpRecord\", \"System.IEquatable\", \"System.IComparable\"],\n          properties: {\n            top: \"number\",\n            left: \"number\",\n            width: \"number\",\n            height: \"number\"\n          }\n        };\n      }\n\n      Equals(other) {\n        return (0, _Util.equalsRecords)(this, other);\n      }\n\n      CompareTo(other) {\n        return (0, _Util.compareRecords)(this, other) | 0;\n      }\n\n      get Top() {\n        return this.top;\n      }\n\n      get Left() {\n        return this.left;\n      }\n\n      get Width() {\n        return this.width;\n      }\n\n      get Height() {\n        return this.height;\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Dom.DomRect\", DomRect);\n\n    const _Event = __exports.Event = class _Event {\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Dom.Event\",\n          properties: {}\n        };\n      }\n\n      constructor() {}\n\n    };\n\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Dom.Event\", _Event);\n    const MouseEvent = __exports.MouseEvent = class MouseEvent extends _Event {\n      [_Symbol3.default.reflection]() {\n        return (0, _Util.extendInfo)(MouseEvent, {\n          type: \"FSSGlobal.Snippets.Dom.MouseEvent\",\n          interfaces: [],\n          properties: {\n            ClientX: \"number\",\n            ClientY: \"number\"\n          }\n        });\n      }\n\n      constructor() {\n        super();\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Dom.MouseEvent\", MouseEvent);\n\n    const _Node = __exports.Node = class _Node {\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Dom.Node\",\n          nullable: true,\n          properties: {\n            FirstChild: _Node,\n            ParentElement: _Element,\n            ParentNode: _Node\n          }\n        };\n      }\n\n      constructor() {}\n\n    };\n\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Dom.Node\", _Node);\n\n    const _Element = __exports.Element = class _Element extends _Node {\n      [_Symbol3.default.reflection]() {\n        return (0, _Util.extendInfo)(_Element, {\n          type: \"FSSGlobal.Snippets.Dom.Element\",\n          nullable: true,\n          interfaces: [],\n          properties: {\n            InnerHTML: \"string\",\n            ShadowRoot: _Element\n          }\n        });\n      }\n\n      constructor() {\n        super();\n      }\n\n    };\n\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Dom.Element\", _Element);\n\n    const _Document = __exports.Document = class _Document {\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Dom.Document\",\n          properties: {\n            Body: _Element\n          }\n        };\n      }\n\n      constructor() {}\n\n    };\n\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Dom.Document\", _Document);\n    return __exports;\n  }({});\n\n  class _Window {\n    [_Symbol3.default.reflection]() {\n      return {\n        type: \"FSSGlobal.Snippets.Window\",\n        properties: {}\n      };\n    }\n\n    constructor() {}\n\n  }\n\n  exports.Window = _Window;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Window\", _Window);\n\n  class JS {\n    [_Symbol3.default.reflection]() {\n      return {\n        type: \"FSSGlobal.Snippets.JS\",\n        properties: {\n          Document: Dom.Document,\n          Window: _Window\n        }\n      };\n    }\n\n    constructor() {}\n\n  }\n\n  exports.JS = JS;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.JS\", JS);\n\n  const Option = exports.Option = function (__exports) {\n    const defaultValue = __exports.defaultValue = function (v, _arg1) {\n      if (_arg1 == null) {\n        return v;\n      } else {\n        return _arg1;\n      }\n    };\n\n    return __exports;\n  }({});\n\n  class _Attr {\n    [_Symbol3.default.reflection]() {\n      return {\n        type: \"FSSGlobal.Snippets.Attr\",\n        properties: {}\n      };\n    }\n\n    constructor() {}\n\n  }\n\n  exports.Attr = _Attr;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Attr\", _Attr);\n\n  class Doc {\n    [_Symbol3.default.reflection]() {\n      return {\n        type: \"FSSGlobal.Snippets.Doc\",\n        properties: {}\n      };\n    }\n\n    constructor() {}\n\n  }\n\n  exports.Doc = Doc;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Doc\", Doc);\n\n  class Elt extends Doc {\n    [_Symbol3.default.reflection]() {\n      return (0, _Util.extendInfo)(Elt, {\n        type: \"FSSGlobal.Snippets.Elt\",\n        interfaces: [],\n        properties: {}\n      });\n    }\n\n    constructor() {\n      super();\n    }\n\n  }\n\n  exports.Elt = Elt;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Elt\", Elt);\n\n  class IRef {\n    constructor(initial) {\n      this.initial = initial;\n    }\n\n    [_Symbol3.default.reflection]() {\n      return {\n        type: \"FSSGlobal.Snippets.IRef\",\n        interfaces: [\"FSharpRecord\", \"System.IEquatable\", \"System.IComparable\"],\n        properties: {\n          initial: (0, _Util.GenericParam)(\"V\")\n        }\n      };\n    }\n\n    Equals(other) {\n      return (0, _Util.equalsRecords)(this, other);\n    }\n\n    CompareTo(other) {\n      return (0, _Util.compareRecords)(this, other) | 0;\n    }\n\n  }\n\n  exports.IRef = IRef;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.IRef\", IRef);\n\n  class View {\n    constructor(tag, data) {\n      this.tag = tag;\n      this.data = data;\n    }\n\n    [_Symbol3.default.reflection]() {\n      return {\n        type: \"FSSGlobal.Snippets.View\",\n        interfaces: [\"FSharpUnion\"],\n        cases: [[\"FromConst\", (0, _Util.GenericParam)(\"V\")], [\"FromVar\", (0, _Util.makeGeneric)(IRef, {\n          V: (0, _Util.GenericParam)(\"V\")\n        })], [\"FromView\", (0, _Util.makeGeneric)(View, {\n          V: _Util.Any\n        }), (0, _Util.Function)([_Util.Any, (0, _Util.makeGeneric)(View, {\n          V: (0, _Util.GenericParam)(\"V\")\n        })])]]\n      };\n    }\n\n  }\n\n  exports.View = View;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.View\", View);\n\n  const DocModule = exports.DocModule = function (__exports) {\n    const _Element_1 = __exports.Element = function (a, b, c) {\n      return WebSharper.UI.Next.Doc.Element(a, Array.from(b), Array.from(c));\n    };\n\n    const InputArea = __exports.InputArea = function (b, c) {\n      return WebSharper.UI.Next.Doc.InputArea(Array.from(b), c);\n    };\n\n    return __exports;\n  }({});\n\n  class Val {\n    constructor(tag, data) {\n      this.tag = tag;\n      this.data = data;\n    }\n\n    [_Symbol3.default.reflection]() {\n      return {\n        type: \"FSSGlobal.Snippets.Val\",\n        interfaces: [\"FSharpUnion\"],\n        cases: [[\"Constant\", (0, _Util.GenericParam)(\"a\")], [\"DynamicV\", (0, _Util.makeGeneric)(IRef, {\n          V: (0, _Util.GenericParam)(\"a\")\n        })], [\"Dynamic\", (0, _Util.makeGeneric)(View, {\n          V: (0, _Util.GenericParam)(\"a\")\n        })]]\n      };\n    }\n\n    get FooBar() {\n      return 0;\n    }\n\n  }\n\n  exports.Val = Val;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Val\", Val);\n\n  const on = exports.on = function (__exports) {\n    const click = __exports.click = function (f) {\n      return WebSharper.UI.Next.AttrProxy.Handler(\"click\", f);\n    };\n\n    const mouseMove = __exports.mouseMove = function (f) {\n      return WebSharper.UI.Next.AttrProxy.Handler(\"mouseMove\", f);\n    };\n\n    const mouseDown = __exports.mouseDown = function (f) {\n      return WebSharper.UI.Next.AttrProxy.Handler(\"mouseDown\", f);\n    };\n\n    const mouseUp = __exports.mouseUp = function (f) {\n      return WebSharper.UI.Next.AttrProxy.Handler(\"mouseUp\", f);\n    };\n\n    const afterRender = __exports.afterRender = function (f) {\n      return WebSharper.UI.Next.AttrProxy.Handler(\"afterRender\", f);\n    };\n\n    return __exports;\n  }({});\n\n  const attr = exports.attr = function (__exports) {\n    const disabledDynPred = __exports.disabledDynPred = function (pred, view) {\n      return WebSharper.UI.Next.AttrModule.DynamicPred(\"disabled\", pred, pred);\n    };\n\n    return __exports;\n  }({});\n\n  const ValModule = exports.ValModule = function (__exports) {\n    const mapV = __exports.mapV = function (f, va) {\n      if (va.tag === 2) {\n        return new Val(2, function (vw) {\n          return WebSharper.UI.Next.View.Map(f, vw);\n        }(va.data));\n      } else if (va.tag === 1) {\n        return new Val(2, function (vw_1) {\n          return WebSharper.UI.Next.View.Map(f, vw_1);\n        }(va.data.RView()));\n      } else {\n        return new Val(0, f(va.data));\n      }\n    };\n\n    const iterV = __exports.iterV = function (f, va) {\n      if (va.tag === 2) {\n        WebSharper.UI.Next.View.Get(f, va.data);\n      } else if (va.tag === 1) {\n        f(va.data.RVal());\n      } else {\n        f(va.data);\n      }\n    };\n\n    const toView = __exports.toView = function (v) {\n      if (v.tag === 2) {\n        return v.data;\n      } else if (v.tag === 1) {\n        return v.data.RView();\n      } else {\n        return WebSharper.UI.Next.View.Const(v.data);\n      }\n    };\n\n    const bindV = __exports.bindV = function (f, v) {\n      if (v.tag === 2) {\n        return new Val(2, WebSharper.UI.Next.View.Bind($var1 => function (v_1) {\n          return toView(v_1);\n        }(f($var1)), v.data));\n      } else if (v.tag === 1) {\n        return new Val(2, WebSharper.UI.Next.View.Bind($var2 => function (v_2) {\n          return toView(v_2);\n        }(f($var2)), v.data.RView()));\n      } else {\n        return f(v.data);\n      }\n    };\n\n    const tagDoc = __exports.tagDoc = function (tag, va) {\n      if (va.tag === 2) {\n        return WebSharper.UI.Next.Doc.EmbedView(function (vw) {\n          return WebSharper.UI.Next.View.Map(tag, vw);\n        }(va.data));\n      } else if (va.tag === 1) {\n        return WebSharper.UI.Next.Doc.EmbedView(function (vw_1) {\n          return WebSharper.UI.Next.View.Map(tag, vw_1);\n        }(va.data.RView()));\n      } else {\n        return tag(va.data);\n      }\n    };\n\n    const tagElt = __exports.tagElt = function (tag, va) {\n      if (va.tag === 2) {\n        return WebSharper.UI.Next.Doc.EmbedView(function (vw) {\n          return WebSharper.UI.Next.View.Map(tag, vw);\n        }(va.data));\n      } else if (va.tag === 1) {\n        return WebSharper.UI.Next.Doc.EmbedView(function (vw_1) {\n          return WebSharper.UI.Next.View.Map(tag, vw_1);\n        }(va.data.RView()));\n      } else {\n        return tag(va.data);\n      }\n    };\n\n    const attrVO = __exports.attrVO = function (att, vao) {\n      if (vao.tag === 2) {\n        return WebSharper.UI.Next.AttrModule.DynamicPred(att, \"WebSharper.UI.Next.View.Map(      $0, $1)\", WebSharper.UI.Next.View.Map(function (option) {\n          return option != null;\n        }, vao.data));\n      } else if (vao.tag === 1) {\n        return WebSharper.UI.Next.AttrModule.DynamicPred(att, \"WebSharper.UI.Next.View.Map(      $0, $1)\", WebSharper.UI.Next.View.Map(function (option_1) {\n          return option_1 != null;\n        }, vao.data.RView()));\n      } else if (vao.data == null) {\n        return WebSharper.UI.Next.AttrModule.DynamicPred(att, \"WebSharper.UI.Next.View.Const(    $0)\", WebSharper.UI.Next.View.Const(false));\n      } else {\n        return WebSharper.UI.Next.AttrProxy.Create(att, vao.data);\n      }\n    };\n\n    const attrV = __exports.attrV = function (att, va) {\n      if (va.tag === 2) {\n        return WebSharper.UI.Next.AttrModule.Dynamic(att, va.data);\n      } else if (va.tag === 1) {\n        return WebSharper.UI.Next.AttrModule.Dynamic(att, va.data.RView());\n      } else {\n        return WebSharper.UI.Next.AttrProxy.Create(att, va.data);\n      }\n    };\n\n    const HelperType = __exports.HelperType = class HelperType {\n      constructor(tag, data) {\n        this.tag = tag;\n        this.data = data;\n      }\n\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.ValModule.HelperType\",\n          interfaces: [\"FSharpUnion\", \"System.IEquatable\", \"System.IComparable\"],\n          cases: [[\"HelperType\"]]\n        };\n      }\n\n      Equals(other) {\n        return this === other || this.tag === other.tag && (0, _Util.equals)(this.data, other.data);\n      }\n\n      CompareTo(other) {\n        return (0, _Util.compareUnions)(this, other) | 0;\n      }\n\n      static op_AmpGreater_0(_arg1, a) {\n        return new Val(0, a);\n      }\n\n      static op_AmpGreater_1(_arg2, a) {\n        return new Val(0, a);\n      }\n\n      static op_AmpGreater_2(_arg3, a) {\n        return new Val(0, a);\n      }\n\n      static op_AmpGreater_3(_arg4, a) {\n        return new Val(0, a);\n      }\n\n      static op_AmpGreater_4(_arg5, a) {\n        return new Val(0, a);\n      }\n\n      static op_AmpGreater_5(_arg6, a) {\n        return new Val(0, a);\n      }\n\n      static op_AmpGreater_6(_arg7, va) {\n        return va;\n      }\n\n      static op_AmpGreater_7(_arg8, va) {\n        return va;\n      }\n\n      static op_AmpGreater_8(_arg9, va) {\n        return va;\n      }\n\n      static op_AmpGreater_9(_arg10, va) {\n        return va;\n      }\n\n      static op_AmpGreater_10(_arg11, va) {\n        return va;\n      }\n\n      static op_AmpGreater_11(_arg12, va) {\n        return va;\n      }\n\n      static op_AmpGreater_12(_arg13, va) {\n        return va;\n      }\n\n      static op_AmpGreater_13(_arg14, vr) {\n        return new Val(1, vr);\n      }\n\n      static op_AmpGreater_14(_arg15, vw) {\n        return new Val(2, vw);\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.ValModule.HelperType\", HelperType);\n\n    const toVal = __exports.toVal = function (o) {\n      if (typeof o === \"string\") {\n        return new Val(0, o);\n      } else if (typeof o === \"number\") {\n        return new Val(0, o);\n      } else if (typeof o === \"boolean\") {\n        return new Val(0, o);\n      } else if (o instanceof WebSharper.UI.Next.Doc) {\n        return new Val(0, o);\n      } else if (o instanceof Val) {\n        return o;\n      } else if (o instanceof WebSharper.UI.Next.Var) {\n        return new Val(1, o);\n      } else if (\"RSet\" in o) {\n        return new Val(1, o);\n      } else if (typeof o == 'function') {\n        return new Val(2, o);\n      } else {\n        throw new Error((0, _String.toText)((0, _String.printf)(\"Could not convert %A\"))(o));\n      }\n    };\n\n    return __exports;\n  }({});\n\n  class HtmlNode {\n    constructor(tag, data) {\n      this.tag = tag;\n      this.data = data;\n    }\n\n    [_Symbol3.default.reflection]() {\n      return {\n        type: \"FSSGlobal.Snippets.HtmlNode\",\n        interfaces: [\"FSharpUnion\"],\n        cases: [[\"HtmlElement\", \"string\", (0, _Util.Interface)(\"System.Collections.Generic.IEnumerable\")], [\"HtmlAttribute\", \"string\", (0, _Util.makeGeneric)(Val, {\n          a: \"string\"\n        })], [\"HtmlAttributeO\", \"string\", (0, _Util.makeGeneric)(Val, {\n          a: (0, _Util.Option)(\"string\")\n        })], [\"HtmlText\", (0, _Util.makeGeneric)(Val, {\n          a: \"string\"\n        })], [\"HtmlEmpty\"], [\"HtmlElementV\", (0, _Util.makeGeneric)(Val, {\n          a: HtmlNode\n        })], [\"SomeDoc\", Doc], [\"SomeAttr\", _Attr]]\n      };\n    }\n\n    AddChildren(add) {\n      return (h => mapHtmlElement((n, ch) => [n, (0, _Seq.append)(ch, add)], h))(this);\n    }\n\n    InsertChildren(add) {\n      return (h => mapHtmlElement((n, ch) => [n, (0, _Seq.append)(add, ch)], h))(this);\n    }\n\n  }\n\n  exports.HtmlNode = HtmlNode;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.HtmlNode\", HtmlNode);\n\n  function addClassX(classes, add) {\n    return (0, _String.join)(\" \", (0, _Set.union)((0, _Set.create)((0, _String.split)(add, \" \"), new _Comparer2.default(_Util.comparePrimitives)), (0, _Set.create)((0, _String.split)(classes, \" \"), new _Comparer2.default(_Util.comparePrimitives))));\n  }\n\n  function chooseThisAttr(_this, node) {\n    const $var3 = node.tag === 1 ? node.data[0] === _this ? [0, node.data[0], node.data[1]] : [1] : [1];\n\n    switch ($var3[0]) {\n      case 0:\n        return (0, _Util.some)($var3[2]);\n\n      case 1:\n        return null;\n    }\n  }\n\n  function concat(s, a, b) {\n    return a + s + b;\n  }\n\n  function groupAttr(name, sep, children) {\n    return function (ss) {\n      return (0, _Seq.isEmpty)(ss) ? null : (0, _Util.some)(function (va) {\n        return ValModule.attrV(name, va);\n      }((0, _Seq.reduce)(($var14, $var15) => function (f, v1, v2) {\n        return (($var12, $var13) => function (f_4, a_1, b_1) {\n          return f_4(b_1, a_1);\n        }((0, _CurriedLambda2.default)(function (vb) {\n          const f_3 = $var9 => {\n            return function (f_2, a, b) {\n              return f_2(b, a);\n            }(($var10, $var11) => ($var8 => ($var6 => $var7 => function (f_1, va_1) {\n              return ValModule.mapV(f_1, va_1);\n            }($var6, $var7))(($var4 => $var5 => f($var4, $var5))($var8)))($var10)($var11), vb, $var9);\n          };\n\n          return function (v) {\n            return ValModule.bindV(f_3, v);\n          };\n        }), $var12, $var13))(function (o) {\n          return ValModule.toVal(o);\n        }(v1), function (o_1) {\n          return ValModule.toVal(o_1);\n        }(v2));\n      }(function (a_2, b_2) {\n        return concat(sep, a_2, b_2);\n      }, $var14, $var15), ss)));\n    }((0, _Seq.choose)(function (node) {\n      return chooseThisAttr(name, node);\n    }, children));\n  }\n\n  function chooseNode(node) {\n    switch (node.tag) {\n      case 0:\n        return (0, _Util.some)(DocModule.Element(node.data[0], (0, _Seq.append)((0, _List.choose)(function (x) {\n          return x;\n        }, (0, _List.ofArray)([groupAttr(\"class\", \" \", node.data[1]), groupAttr(\"style\", \"; \", node.data[1])])), function (source) {\n          return (0, _Seq.choose)(function (node_1) {\n            const $var16 = node_1.tag === 1 ? (node_1.data[0] !== \"class\" ? node_1.data[0] !== \"style\" : false) ? [0, node_1.data[0], node_1.data[1]] : [1] : [1];\n\n            switch ($var16[0]) {\n              case 0:\n                return (0, _Util.some)(ValModule.attrV($var16[1], $var16[2]));\n\n              case 1:\n                const $var17 = node_1.tag === 2 ? (node_1.data[0] !== \"class\" ? node_1.data[0] !== \"style\" : false) ? [0, node_1.data[0], node_1.data[1]] : [1] : [1];\n\n                switch ($var17[0]) {\n                  case 0:\n                    return (0, _Util.some)(ValModule.attrVO($var17[1], $var17[2]));\n\n                  case 1:\n                    if (node_1.tag === 7) {\n                      return (0, _Util.some)(node_1.data);\n                    } else {\n                      return null;\n                    }\n\n                }\n\n            }\n          }, source);\n        }(node.data[1])), (0, _Seq.choose)(function (node_2) {\n          return chooseNode(node_2);\n        }, node.data[1])));\n\n      case 3:\n        return (0, _Util.some)(ValModule.tagDoc(function (txt) {\n          return WebSharper.UI.Next.Doc.TextNode(txt);\n        }, node.data));\n\n      case 6:\n        return (0, _Util.some)(node.data);\n\n      case 5:\n        return (0, _Util.some)(WebSharper.UI.Next.Doc.BindView($var18 => function (_arg1) {\n          return Option.defaultValue(WebSharper.UI.Next.Doc.Empty(), _arg1);\n        }(function (node_3) {\n          return chooseNode(node_3);\n        }($var18)), ValModule.toView(node.data)));\n\n      default:\n        return null;\n    }\n  }\n\n  function getAttrChildren(attr_1) {\n    return $var19 => Option.defaultValue(new Val(0, \"\"), (0, _Seq.tryPick)(function (_arg1) {\n      const $var20 = _arg1.tag === 1 ? _arg1.data[0] === attr_1 ? [0, _arg1.data[0], _arg1.data[1]] : [1] : [1];\n\n      switch ($var20[0]) {\n        case 0:\n          return (0, _Util.some)($var20[2]);\n\n        case 1:\n          return null;\n      }\n    }, $var19));\n  }\n\n  function mapHtmlElement(f, element) {\n    if (element.tag === 0) {\n      return function (tupledArg) {\n        return new HtmlNode(0, [tupledArg[0], tupledArg[1]]);\n      }(f(element.data[0], element.data[1]));\n    } else if (element.tag === 5) {\n      return new HtmlNode(5, ValModule.mapV(function (element_1) {\n        return mapHtmlElement(f, element_1);\n      }, function (o) {\n        return ValModule.toVal(o);\n      }(element.data)));\n    } else {\n      return element;\n    }\n  }\n\n  const renderDoc = exports.renderDoc = $var21 => function (_arg1) {\n    return Option.defaultValue(WebSharper.UI.Next.Doc.Empty(), _arg1);\n  }(function (node) {\n    return chooseNode(node);\n  }($var21));\n\n  function style2pairs(ss) {\n    return (0, _Array2.map)(function (d) {\n      return [(0, _String.trim)(d[0], \"both\"), (0, _String.trim)(d[1], \"both\")];\n    }, (0, _Array2.map)(function (s) {\n      return (0, _String.split)(s, \":\");\n    }, (0, _String.split)(ss, \";\"), Array).filter(function (d_1) {\n      return d_1.length === 2;\n    }), Array);\n  }\n\n  function isUndefined(v) {\n    return true;\n  }\n\n  class Panel {\n    constructor(_class, _style, title, header, content, disabled) {\n      this._class = _class;\n      this._style = _style;\n      this.title = title;\n      this.header = header;\n      this.content = content;\n      this.disabled = disabled;\n    }\n\n    [_Symbol3.default.reflection]() {\n      return {\n        type: \"FSSGlobal.Snippets.Panel\",\n        interfaces: [\"FSharpRecord\"],\n        properties: {\n          _class: (0, _Util.makeGeneric)(Val, {\n            a: \"string\"\n          }),\n          _style: (0, _Util.makeGeneric)(Val, {\n            a: \"string\"\n          }),\n          title: (0, _Util.makeGeneric)(Val, {\n            a: \"string\"\n          }),\n          header: (0, _Util.Interface)(\"System.Collections.Generic.IEnumerable\"),\n          content: (0, _Util.Interface)(\"System.Collections.Generic.IEnumerable\"),\n          disabled: (0, _Util.makeGeneric)(Val, {\n            a: \"boolean\"\n          })\n        }\n      };\n    }\n\n    static get New() {\n      return new Panel(function (o) {\n        return ValModule.toVal(o);\n      }(\"panel panel-default shadow\"), function (o_1) {\n        return ValModule.toVal(o_1);\n      }(\"text-align:center\"), function (o_2) {\n        return ValModule.toVal(o_2);\n      }(\"Panel\"), (0, _List.ofArray)([new HtmlNode(3, function (o_3) {\n        return ValModule.toVal(o_3);\n      }(\"Some text\"))]), (0, _List.ofArray)([new HtmlNode(3, function (o_4) {\n        return ValModule.toVal(o_4);\n      }(\"Some Content\"))]), function (o_5) {\n        return ValModule.toVal(o_5);\n      }(WebSharper.UI.Next.Var.Create$1(false)));\n    }\n\n    get Render() {\n      return new HtmlNode(0, [\"fieldset\", (0, _List.ofArray)([new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(1, [\"class\", (o => ValModule.toVal(o))(this._class)]), new HtmlNode(0, [\"div\", (0, _Seq.append)((0, _List.ofArray)([new HtmlNode(1, [\"class\", (o_1 => ValModule.toVal(o_1))(\"panel-heading\")]), new HtmlNode(0, [\"label\", (0, _List.ofArray)([new HtmlNode(1, [\"class\", (o_2 => ValModule.toVal(o_2))(\"panel-title text-center\")]), new HtmlNode(3, (o_3 => ValModule.toVal(o_3))(this.title))])])]), this.header)]), new HtmlNode(0, [\"div\", (0, _Seq.append)((0, _List.ofArray)([new HtmlNode(1, [\"class\", (o_4 => ValModule.toVal(o_4))(\"panel-body\")]), new HtmlNode(1, [\"style\", (o_5 => ValModule.toVal(o_5))(this._style)])]), this.content)])])])])]);\n    }\n\n  }\n\n  exports.Panel = Panel;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Panel\", Panel);\n\n  const Template = exports.Template = function (__exports) {\n    const Panel = __exports.Panel = class Panel {\n      constructor(_class, _style, title, header, content, disabled) {\n        this._class = _class;\n        this._style = _style;\n        this.title = title;\n        this.header = header;\n        this.content = content;\n        this.disabled = disabled;\n      }\n\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Template.Panel\",\n          interfaces: [\"FSharpRecord\"],\n          properties: {\n            _class: (0, _Util.makeGeneric)(Val, {\n              a: \"string\"\n            }),\n            _style: (0, _Util.makeGeneric)(Val, {\n              a: \"string\"\n            }),\n            title: (0, _Util.makeGeneric)(Val, {\n              a: \"string\"\n            }),\n            header: (0, _Util.Interface)(\"System.Collections.Generic.IEnumerable\"),\n            content: (0, _Util.Interface)(\"System.Collections.Generic.IEnumerable\"),\n            disabled: (0, _Util.makeGeneric)(Val, {\n              a: \"boolean\"\n            })\n          }\n        };\n      }\n\n      static get New() {\n        return new Panel(function (o) {\n          return ValModule.toVal(o);\n        }(\"panel panel-default shadow\"), function (o_1) {\n          return ValModule.toVal(o_1);\n        }(\"text-align:center\"), function (o_2) {\n          return ValModule.toVal(o_2);\n        }(\"Panel\"), (0, _List.ofArray)([new HtmlNode(3, function (o_3) {\n          return ValModule.toVal(o_3);\n        }(\"Some text\"))]), (0, _List.ofArray)([new HtmlNode(3, function (o_4) {\n          return ValModule.toVal(o_4);\n        }(\"Some Content\"))]), function (o_5) {\n          return ValModule.toVal(o_5);\n        }(WebSharper.UI.Next.Var.Create$1(false)));\n      }\n\n      get Render() {\n        return new HtmlNode(0, [\"fieldset\", (0, _List.ofArray)([new HtmlNode(7, attr.disabledDynPred(WebSharper.UI.Next.View.Const(\"\"), ValModule.toView(this.disabled))), new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(1, [\"class\", (o => ValModule.toVal(o))(this._class)]), new HtmlNode(0, [\"div\", (0, _Seq.append)((0, _List.ofArray)([new HtmlNode(1, [\"class\", (o_1 => ValModule.toVal(o_1))(\"panel-heading\")]), new HtmlNode(0, [\"label\", (0, _List.ofArray)([new HtmlNode(1, [\"class\", (o_2 => ValModule.toVal(o_2))(\"panel-title text-center\")]), new HtmlNode(3, (o_3 => ValModule.toVal(o_3))(this.title))])])]), this.header)]), new HtmlNode(0, [\"div\", (0, _Seq.append)((0, _List.ofArray)([new HtmlNode(1, [\"class\", (o_4 => ValModule.toVal(o_4))(\"panel-body\")]), new HtmlNode(1, [\"style\", (o_5 => ValModule.toVal(o_5))(this._style)])]), this.content)])])])])]);\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Template.Panel\", Panel);\n    const HtmlMeasure = __exports.HtmlMeasure = class HtmlMeasure {\n      constructor(tag, data) {\n        this.tag = tag;\n        this.data = data;\n      }\n\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Template.HtmlMeasure\",\n          interfaces: [\"FSharpUnion\"],\n          cases: [[\"Percentage\", (0, _Util.makeGeneric)(Val, {\n            a: \"number\"\n          })], [\"Pixel\", (0, _Util.makeGeneric)(Val, {\n            a: \"number\"\n          })]]\n        };\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Template.HtmlMeasure\", HtmlMeasure);\n    const SplitterBar = __exports.SplitterBar = class SplitterBar {\n      constructor(value, min, max, vertical, node, children, after, dragging, startVer, startP, start, size, domElem) {\n        this.value = value;\n        this.min = min;\n        this.max = max;\n        this.vertical = vertical;\n        this.node = node;\n        this.children = children;\n        this.after = after;\n        this.dragging = dragging;\n        this.startVer = startVer;\n        this.startP = startP;\n        this.start = start;\n        this.size = size;\n        this.domElem = domElem;\n      }\n\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Template.SplitterBar\",\n          interfaces: [\"FSharpRecord\"],\n          properties: {\n            value: (0, _Util.makeGeneric)(IRef, {\n              V: \"number\"\n            }),\n            min: (0, _Util.makeGeneric)(Val, {\n              a: \"number\"\n            }),\n            max: (0, _Util.makeGeneric)(Val, {\n              a: \"number\"\n            }),\n            vertical: (0, _Util.makeGeneric)(Val, {\n              a: \"boolean\"\n            }),\n            node: HtmlNode,\n            children: (0, _Util.Interface)(\"System.Collections.Generic.IEnumerable\"),\n            after: \"boolean\",\n            dragging: \"boolean\",\n            startVer: \"boolean\",\n            startP: \"number\",\n            start: \"number\",\n            size: \"number\",\n            domElem: (0, _Util.Option)(Dom.Element)\n          }\n        };\n      }\n\n      static New_0(_var) {\n        return new SplitterBar(_var, function (o) {\n          return ValModule.toVal(o);\n        }(5), function (o_1) {\n          return ValModule.toVal(o_1);\n        }(95), function (o_2) {\n          return ValModule.toVal(o_2);\n        }(true), new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(1, [\"class\", function (o_3) {\n          return ValModule.toVal(o_3);\n        }(\"Splitter\")])])]), new _List2.default(), true, false, true, 0, 0, 0, null);\n      }\n\n      static New_1(value) {\n        return SplitterBar.New_0(WebSharper.UI.Next.Var.Create$1(value));\n      }\n\n      get Var() {\n        return this.value;\n      }\n\n      get GetValue() {\n        return (($var40, $var41) => ((f_7, a_3, b_3) => f_7(b_3, a_3))((0, _CurriedLambda2.default)(vb_1 => {\n          const f_6 = $var37 => {\n            return ((f_5, a_2, b_2) => f_5(b_2, a_2))(($var38, $var39) => ($var36 => ($var34 => $var35 => ((f_4, va_1) => ValModule.mapV(f_4, va_1))($var34, $var35))(($var32 => $var33 => ((e1, e2) => e1 < e2 ? e1 : e2)($var32, $var33))($var36)))($var38)($var39), vb_1, $var37);\n          };\n\n          return v_1 => ValModule.bindV(f_6, v_1);\n        }, this), $var40, $var41))((o_2 => ValModule.toVal(o_2))(this.max), (o_3 => ValModule.toVal(o_3))((($var30, $var31) => ((f_3, a_1, b_1) => f_3(b_1, a_1))((0, _CurriedLambda2.default)(vb => {\n          const f_2 = $var27 => {\n            return ((f_1, a, b) => f_1(b, a))(($var28, $var29) => ($var26 => ($var24 => $var25 => ((f, va) => ValModule.mapV(f, va))($var24, $var25))(($var22 => $var23 => ((e1_1, e2_1) => e1_1 > e2_1 ? e1_1 : e2_1)($var22, $var23))($var26)))($var28)($var29), vb, $var27);\n          };\n\n          return v => ValModule.bindV(f_2, v);\n        }, this), $var30, $var31))((o => ValModule.toVal(o))(this.min), (o_1 => ValModule.toVal(o_1))(this.value))));\n      }\n\n      get Render() {\n        const mouseCoord = ev => {\n          if (this.startVer) {\n            return ev.clientX;\n          } else {\n            return ev.clientY;\n          }\n        };\n\n        const size = () => {\n          const matchValue = this.domElem;\n\n          if (matchValue != null) {\n            return (r => {\n              const matchValue_1 = [this.startVer, this.after];\n\n              if (matchValue_1[0]) {\n                if (matchValue_1[1]) {\n                  return r.Width;\n                } else {\n                  return -r.Width;\n                }\n              } else if (matchValue_1[1]) {\n                return r.Height;\n              } else {\n                return -r.Height;\n              }\n            })(matchValue.parentElement.getBoundingClientRect());\n          } else {\n            return 100;\n          }\n        };\n\n        const drag = ev_1 => {\n          (v => {\n            this.value.set_RVal(v);\n          })((m => (m - this.start) * 100 / this.size + this.startP)(mouseCoord(ev_1)));\n        };\n\n        const finishDragging = _arg1 => {\n          if (this.dragging) {\n            this.dragging = false;\n            window.removeEventListener(\"mousemove\", drag, false);\n            window.removeEventListener(\"mouseup\", finishDragging, false);\n          }\n        };\n\n        const startDragging = (_arg2, ev_2) => {\n          if (!this.dragging) {\n            ValModule.iterV(() => {}, (o_2 => ValModule.toVal(o_2))((($var50, $var51) => ((f_3, a_1, b_1) => f_3(b_1, a_1))((0, _CurriedLambda2.default)(vb => {\n              const f_2 = $var47 => {\n                return ((f_1, a, b) => f_1(b, a))(($var48, $var49) => ($var46 => ($var44 => $var45 => ((f, va) => ValModule.mapV(f, va))($var44, $var45))(($var42 => $var43 => {\n                  ((startP, dirV) => {\n                    this.dragging = true;\n                    this.startVer = dirV;\n                    this.startP = startP;\n                    this.start = mouseCoord(ev_2);\n                    this.size = size();\n                    window.addEventListener(\"mousemove\", drag, false);\n                    window.addEventListener(\"mouseup\", finishDragging, false);\n                    ev_2.preventDefault;\n                  })($var42, $var43);\n                })($var46)))($var48)($var49), vb, $var47);\n              };\n\n              return v_1 => ValModule.bindV(f_2, v_1);\n            }, this), $var50, $var51))((o => ValModule.toVal(o))(this.GetValue), (o_1 => ValModule.toVal(o_1))(this.vertical))));\n          }\n        };\n\n        return this.node.AddChildren((0, _List.ofArray)([new HtmlNode(1, [\"class\", (o_4 => ValModule.toVal(o_4))(ValModule.mapV(ver => ver ? \"Vertical\" : \"Horizontal\", (o_3 => ValModule.toVal(o_3))(this.vertical)))]), new HtmlNode(7, on.mouseDown((0, _CurriedLambda2.default)(startDragging))), new HtmlNode(7, on.afterRender(el => {\n          this.domElem = (0, _Util.some)(el);\n        })), new HtmlNode(0, [\"style\", (0, _List.ofArray)([new HtmlNode(3, (o_5 => ValModule.toVal(o_5))(\"\\n                          .Splitter.Vertical   { cursor: col-resize; background-color: #eef ; width : 5px ; margin-left:-7px; }\\n                          .Splitter.Horizontal { cursor: row-resize; background-color: #eef ; height: 5px ; margin-top :-7px; }\\n                      \"))])])])).AddChildren(this.children);\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Template.SplitterBar\", SplitterBar);\n    let observers = __exports.observers = (0, _Util.createAtom)(new _List2.default());\n\n    const isValidElement = __exports.isValidElement = function (el) {\n      const r = el.getBoundingClientRect();\n      return !(0, _Util.equals)([r.Top, r.Left, r.Width, r.Height], [0, 0, 0, 0]);\n    };\n\n    const addResizeObserver = __exports.addResizeObserver = function (f, el) {\n      if (!!ResizeObserver) {\n        const ro = new ResizeObserver(f);\n        observers(new _List2.default(ro, observers()));\n        ro.observe(el);\n      } else {\n        (function (arg00, arg10) {\n          return setInterval(arg00, arg10);\n        })(f, 110);\n      }\n    };\n\n    const Area = __exports.Area = class Area {\n      constructor(tag, data) {\n        this.tag = tag;\n        this.data = data;\n      }\n\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Template.Area\",\n          interfaces: [\"FSharpUnion\"],\n          cases: [[\"Auto\", SplitterBar], [\"Fixed\", HtmlMeasure], [\"Splitter\", SplitterBar]]\n        };\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Template.Area\", Area);\n    const SectionType = __exports.SectionType = class SectionType {\n      constructor(tag, data) {\n        this.tag = tag;\n        this.data = data;\n      }\n\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Template.SectionType\",\n          interfaces: [\"FSharpUnion\", \"System.IEquatable\", \"System.IComparable\"],\n          cases: [[\"StVariable\"], [\"StFixedPx\"], [\"StFixedPerc\"]]\n        };\n      }\n\n      Equals(other) {\n        return this === other || this.tag === other.tag && (0, _Util.equals)(this.data, other.data);\n      }\n\n      CompareTo(other) {\n        return (0, _Util.compareUnions)(this, other) | 0;\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Template.SectionType\", SectionType);\n    const Grid = __exports.Grid = class Grid {\n      constructor(padding, gap, content, cols, rows, width, height, lastSplitter) {\n        this.padding = padding;\n        this.gap = gap;\n        this.content = content;\n        this.cols = cols;\n        this.rows = rows;\n        this.width = width;\n        this.height = height;\n        this.lastSplitter = lastSplitter;\n      }\n\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Template.Grid\",\n          interfaces: [\"FSharpRecord\"],\n          properties: {\n            padding: \"number\",\n            gap: \"number\",\n            content: (0, _Util.Array)((0, _Util.Tuple)([(0, _Util.Option)(\"string\"), HtmlNode])),\n            cols: (0, _Util.Array)(Area),\n            rows: (0, _Util.Array)(Area),\n            width: (0, _Util.makeGeneric)(IRef, {\n              V: \"number\"\n            }),\n            height: (0, _Util.makeGeneric)(IRef, {\n              V: \"number\"\n            }),\n            lastSplitter: (0, _Util.Option)((0, _Util.Tuple)([\"number\", \"boolean\"]))\n          }\n        };\n      }\n\n      static get New() {\n        const cols = [];\n        const rows = [];\n        return new Grid(9, 9, [], cols, rows, WebSharper.UI.Next.Var.Create$1(1000), WebSharper.UI.Next.Var.Create$1(100), null);\n      }\n\n      NewSplitter(f, col) {\n        const spl = SplitterBar.New_1(f);\n\n        if (col) {\n          const lastSplitter = (0, _Util.some)([this.cols.length, col]);\n          const cols = this.cols.concat([new Area(2, spl)]);\n          return new Grid(this.padding, this.gap, this.content, cols, this.rows, this.width, this.height, lastSplitter);\n        } else {\n          const lastSplitter_1 = (0, _Util.some)([this.rows.length, col]);\n          const rows = this.rows.concat([new Area(2, (() => {\n            const vertical = (o => ValModule.toVal(o))(false);\n\n            return new SplitterBar(spl.value, spl.min, spl.max, vertical, spl.node, spl.children, spl.after, spl.dragging, spl.startVer, spl.startP, spl.start, spl.size, spl.domElem);\n          })())]);\n          return new Grid(this.padding, this.gap, this.content, this.cols, rows, this.width, this.height, lastSplitter_1);\n        }\n      }\n\n      Content(area, html) {\n        const content = this.content.concat([[(0, _Util.some)(area), html]]);\n        return new Grid(this.padding, this.gap, content, this.cols, this.rows, this.width, this.height, this.lastSplitter);\n      }\n\n      Content0(html) {\n        const content = this.content.concat([[null, html]]);\n        return new Grid(this.padding, this.gap, content, this.cols, this.rows, this.width, this.height, this.lastSplitter);\n      }\n\n      changeSplitter(f) {\n        (0, _Seq.iterate)(tupledArg => {\n          if (tupledArg[1]) {\n            const matchValue = this.cols[tupledArg[0]];\n\n            if (matchValue.tag === 2) {\n              this.cols[tupledArg[0]] = new Area(2, f(matchValue.data));\n            }\n          } else {\n            const matchValue_1 = this.rows[tupledArg[0]];\n\n            if (matchValue_1.tag === 2) {\n              this.rows[tupledArg[0]] = new Area(2, f(matchValue_1.data));\n            }\n          }\n        }, (0, _Util.defaultArg)(this.lastSplitter, [], $var52 => [$var52]));\n        return this;\n      }\n\n      get Before() {\n        return this.changeSplitter(spl => new SplitterBar(spl.value, spl.min, spl.max, spl.vertical, spl.node, spl.children, false, spl.dragging, spl.startVer, spl.startP, spl.start, spl.size, spl.domElem));\n      }\n\n      style(areas, size) {\n        if (areas.length === 0) {\n          return new Val(0, \"100%\");\n        } else {\n          const patternInput = (() => {\n            const folder = (tupledArg, a) => {\n              if (a.tag === 2) {\n                return [(($var61, $var62) => ((f_3, a_2, b_1) => f_3(b_1, a_2))((0, _CurriedLambda2.default)(vb => {\n                  const f_2 = $var58 => {\n                    return ((f_1, a_1, b) => f_1(b, a_1))(($var59, $var60) => ($var57 => ($var55 => $var56 => ((f, va) => ValModule.mapV(f, va))($var55, $var56))(($var53 => $var54 => ((x, y) => x + y)($var53, $var54))($var57)))($var59)($var60), vb, $var58);\n                  };\n\n                  return v => ValModule.bindV(f_2, v);\n                }, this), $var61, $var62))((o => ValModule.toVal(o))(a.data.GetValue), (o_1 => ValModule.toVal(o_1))(tupledArg[0])), tupledArg[1]];\n              } else if (a.tag === 1) {\n                if (a.data.tag === 1) {\n                  return [tupledArg[0], (($var71, $var72) => ((f_7, a_4, b_3) => f_7(b_3, a_4))((0, _CurriedLambda2.default)(vb_1 => {\n                    const f_6 = $var68 => {\n                      return ((f_5, a_3, b_2) => f_5(b_2, a_3))(($var69, $var70) => ($var67 => ($var65 => $var66 => ((f_4, va_1) => ValModule.mapV(f_4, va_1))($var65, $var66))(($var63 => $var64 => ((x_1, y_1) => x_1 + y_1)($var63, $var64))($var67)))($var69)($var70), vb_1, $var68);\n                    };\n\n                    return v_1 => ValModule.bindV(f_6, v_1);\n                  }, this), $var71, $var72))((o_2 => ValModule.toVal(o_2))(a.data.data), (o_3 => ValModule.toVal(o_3))(tupledArg[1]))];\n                } else {\n                  return [(($var81, $var82) => ((f_11, a_6, b_5) => f_11(b_5, a_6))((0, _CurriedLambda2.default)(vb_2 => {\n                    const f_10 = $var78 => {\n                      return ((f_9, a_5, b_4) => f_9(b_4, a_5))(($var79, $var80) => ($var77 => ($var75 => $var76 => ((f_8, va_2) => ValModule.mapV(f_8, va_2))($var75, $var76))(($var73 => $var74 => ((x_2, y_2) => x_2 + y_2)($var73, $var74))($var77)))($var79)($var80), vb_2, $var78);\n                    };\n\n                    return v_2 => ValModule.bindV(f_10, v_2);\n                  }, this), $var81, $var82))((o_4 => ValModule.toVal(o_4))(a.data.data), (o_5 => ValModule.toVal(o_5))(tupledArg[0])), tupledArg[1]];\n                }\n              } else {\n                return [tupledArg[0], tupledArg[1]];\n              }\n            };\n\n            const arg = [new Val(0, 0), new Val(0, 0)];\n            return source => (0, _Seq.fold)(folder, [arg[0], arg[1]], source);\n          })()(areas);\n\n          const finalPerc = (($var91, $var92) => ((f_15, a_8, b_7) => f_15(b_7, a_8))((0, _CurriedLambda2.default)(vb_3 => {\n            const f_14 = $var88 => {\n              return ((f_13, a_7, b_6) => f_13(b_6, a_7))(($var89, $var90) => ($var87 => ($var85 => $var86 => ((f_12, va_3) => ValModule.mapV(f_12, va_3))($var85, $var86))(($var83 => $var84 => ((v_3, size_1) => (size_1 - this.padding * 2 - this.gap * (areas.length - 1) - v_3) / (size_1 - this.padding * 2))($var83, $var84))($var87)))($var89)($var90), vb_3, $var88);\n            };\n\n            return v_4 => ValModule.bindV(f_14, v_4);\n          }, this), $var91, $var92))((o_6 => ValModule.toVal(o_6))(patternInput[1]), (o_7 => ValModule.toVal(o_7))(size));\n\n          const autoPct = ValModule.mapV(y_3 => 100 - y_3, (o_8 => ValModule.toVal(o_8))(patternInput[0]));\n\n          const perc = pc => {\n            return (($var101, $var102) => ((f_19, a_10, b_9) => f_19(b_9, a_10))((0, _CurriedLambda2.default)(vb_4 => {\n              const f_18 = $var98 => {\n                return ((f_17, a_9, b_8) => f_17(b_8, a_9))(($var99, $var100) => ($var97 => ($var95 => $var96 => ((f_16, va_4) => ValModule.mapV(f_16, va_4))($var95, $var96))(($var93 => $var94 => ((finalPerc_1, pc_1) => (0, _String.toText)((0, _String.printf)(\"%f%%\"))(0 > finalPerc_1 * pc_1 ? 0 : finalPerc_1 * pc_1))($var93, $var94))($var97)))($var99)($var100), vb_4, $var98);\n              };\n\n              return v_5 => ValModule.bindV(f_18, v_5);\n            }, this), $var101, $var102))((o_9 => ValModule.toVal(o_9))(finalPerc), (o_10 => ValModule.toVal(o_10))(pc));\n          };\n\n          const pixel = px => {\n            return ValModule.mapV(px_1 => (0, _String.toText)((0, _String.printf)(\"%fpx\"))(0 > px_1 ? 0 : px_1), (o_11 => ValModule.toVal(o_11))(px));\n          };\n\n          return ValModule.mapV(strings => (0, _String.join)(\" \", strings), (o_14 => ValModule.toVal(o_14))(($var113 => (() => {\n            const folder_1 = (a_11, state) => {\n              return (() => {\n                const f_20 = (state_1, v_6) => {\n                  return new _List2.default(v_6, state_1);\n                };\n\n                return v2 => (($var111, $var112) => ((f_24, a_13, b_11) => f_24(b_11, a_13))((0, _CurriedLambda2.default)(vb_5 => {\n                  const f_23 = $var108 => {\n                    return ((f_22, a_12, b_10) => f_22(b_10, a_12))(($var109, $var110) => ($var107 => ($var105 => $var106 => ((f_21, va_5) => ValModule.mapV(f_21, va_5))($var105, $var106))(($var103 => $var104 => f_20($var103, $var104))($var107)))($var109)($var110), vb_5, $var108);\n                  };\n\n                  return v_7 => ValModule.bindV(f_23, v_7);\n                }, this), $var111, $var112))((o_12 => ValModule.toVal(o_12))(state), (o_13 => ValModule.toVal(o_13))(v2));\n              })()(a_11.tag === 2 ? perc(a_11.data.GetValue) : a_11.tag === 1 ? a_11.data.tag === 1 ? pixel(a_11.data.data) : perc(a_11.data.data) : perc(autoPct));\n            };\n\n            return (source_1, state_2) => (0, _Seq.foldBack)(folder_1, source_1, state_2);\n          })()(areas, $var113))(new Val(0, new _List2.default()))));\n        }\n      }\n\n      styles() {\n        return (0, _List.ofArray)([new HtmlNode(1, [\"style\", (o_1 => ValModule.toVal(o_1))(ValModule.mapV((() => {\n          const x = \"grid-template-columns:\";\n          return y => x + y;\n        })(), (o => ValModule.toVal(o))(((arg00, arg10) => this.style(arg00, arg10))(this.cols, this.width))))]), new HtmlNode(1, [\"style\", (o_3 => ValModule.toVal(o_3))(ValModule.mapV((() => {\n          const x_1 = \"grid-template-rows:\";\n          return y_1 => x_1 + y_1;\n        })(), (o_2 => ValModule.toVal(o_2))(((arg00_1, arg10_1) => this.style(arg00_1, arg10_1))(this.rows, this.height))))])]);\n      }\n\n      GridTemplate() {\n        return (0, _Seq.toList)((0, _Seq.delay)(() => (0, _Seq.append)((0, _Seq.map)(tupledArg => tupledArg[0] != null ? tupledArg[1].AddChildren((0, _List.ofArray)([new HtmlNode(1, [\"style\", (o => ValModule.toVal(o))((0, _String.toText)((0, _String.printf)(\"grid-area: %s; dispxlay: grid\"))(tupledArg[0]))])])) : tupledArg[1], this.content), (0, _Seq.delay)(() => (0, _Seq.append)((0, _Seq.choose)(_arg1 => {\n          if (_arg1[1].tag === 2) {\n            const spl = _arg1[1].data;\n            return (0, _Util.some)(spl.Render.InsertChildren((0, _List.ofArray)([new HtmlNode(1, [\"style\", (o_2 => ValModule.toVal(o_2))(ValModule.mapV((() => {\n              const x = \"grid-column:\";\n              return y => x + y;\n            })(), (o_1 => ValModule.toVal(o_1))((_arg1[0] + (spl.after ? 2 : 1)).toString())))]), new HtmlNode(1, [\"style\", (o_4 => ValModule.toVal(o_4))(ValModule.mapV((() => {\n              const x_1 = \"grid-row:\";\n              return y_1 => x_1 + y_1;\n            })(), (o_3 => ValModule.toVal(o_3))((0, _String.toText)((0, _String.printf)(\"1 / %d\"))(this.rows.length + 1))))])])));\n          } else if (_arg1[1].tag === 1) {\n            return null;\n          } else {\n            const spl_1 = _arg1[1].data;\n            return null;\n          }\n        }, (0, _Seq.indexed)(this.cols)), (0, _Seq.delay)(() => (0, _Seq.append)((0, _Seq.choose)(_arg2 => {\n          if (_arg2[1].tag === 2) {\n            const spl_2 = _arg2[1].data;\n            return (0, _Util.some)(spl_2.Render.InsertChildren((0, _List.ofArray)([new HtmlNode(1, [\"style\", (o_6 => ValModule.toVal(o_6))(ValModule.mapV((() => {\n              const x_2 = \"grid-row:\";\n              return y_2 => x_2 + y_2;\n            })(), (o_5 => ValModule.toVal(o_5))((_arg2[0] + (spl_2.after ? 2 : 1)).toString())))]), new HtmlNode(1, [\"style\", (o_8 => ValModule.toVal(o_8))(ValModule.mapV((() => {\n              const x_3 = \"grid-column:\";\n              return y_3 => x_3 + y_3;\n            })(), (o_7 => ValModule.toVal(o_7))((0, _String.toText)((0, _String.printf)(\"1 / %d\"))(this.cols.length + 1))))])])));\n          } else if (_arg2[1].tag === 1) {\n            return null;\n          } else {\n            const spl_3 = _arg2[1].data;\n            return null;\n          }\n        }, (0, _Seq.indexed)(this.rows)), (0, _Seq.delay)(() => (0, _Seq.append)(this.styles(), (0, _Seq.delay)(() => (0, _Seq.append)((0, _Seq.singleton)(new HtmlNode(1, [\"style\", (o_9 => ValModule.toVal(o_9))((0, _String.toText)((0, _String.printf)(\"display: grid; grid-gap: %fpx; padding: %fpx; box-sizing: border-box\"))(this.gap, this.padding))])), (0, _Seq.delay)(() => (0, _Seq.singleton)(new HtmlNode(7, on.afterRender(el => {\n          const setVar = (vr, vl) => {\n            if (!(0, _Util.equals)(vr.RVal(), vl)) {\n              vr.set_RVal(vl);\n            }\n          };\n\n          const setDimensions = () => {\n            (r => {\n              setVar(this.width, r.Width);\n              setVar(this.height, r.Height);\n            })(el.getBoundingClientRect());\n          };\n\n          setDimensions();\n          addResizeObserver(setDimensions, el);\n        })))))))))))))));\n      }\n\n      get Render() {\n        return new HtmlNode(0, [\"div\", this.GridTemplate()]);\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Template.Grid\", Grid);\n    return __exports;\n  }({});\n\n  const RunCode = exports.RunCode = function (__exports) {\n    const RunNode = __exports.RunNode = class RunNode {\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.RunCode.RunNode\",\n          properties: {\n            AddBootstrap: RunNode,\n            RunNode: Dom.Element\n          }\n        };\n      }\n\n      constructor(nodeName, clearNode) {\n        this.nodeName = nodeName;\n        const bClearNode = clearNode != null ? clearNode : true;\n        let baseNode;\n        const matchValue = document.getElementById(this.nodeName);\n\n        if (matchValue == null) {\n          baseNode = this.createBaseNode();\n        } else {\n          baseNode = matchValue;\n        }\n\n        const shadowRootInit = {\n          mode: \"open\"\n        };\n        const matchValue_1 = baseNode.shadowRoot;\n\n        if (matchValue_1 == null) {\n          const p = this.createNode();\n          baseNode.attachShadow(shadowRootInit).appendChild(p);\n          const e = this.createNode();\n          p.appendChild(e);\n          this.runNode = e;\n        } else {\n          this.runNode = matchValue_1.firstChild;\n        }\n\n        if (bClearNode) {\n          this.runNode.innerHTML = \"\";\n        }\n      }\n\n      static [\".ctor\"](clearNode) {\n        return new RunNode(\"TestNode\", clearNode);\n      }\n\n      get RunNode() {\n        return this.runNode;\n      }\n\n      get AddBootstrap() {\n        (el => {\n          el.innerHTML = \"<script src='http://code.jquery.com/jquery-3.1.1.min.js' type='text/javascript' charset='UTF-8'></script>\\n                      <script src='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js' type='text/javascript' charset='UTF-8'></script>\\n                      <link type='text/css' rel='stylesheet' href='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css'>\\n                      <link type='text/css' rel='stylesheet' href='/EPFileX/css/main.css'>\\n                     \";\n          this.runNode.parentNode.appendChild(el);\n        })(document.createElement(\"div\"));\n\n        return this;\n      }\n\n      createNode() {\n        const e = document.createElement(\"div\");\n        e.style = \"height: 100%; width: 100%;\";\n        return e;\n      }\n\n      createBaseNode() {\n        const el = document.createElement(\"div\");\n        el.setAttribute(\"id\", this.nodeName);\n        document.body.appendChild(el);\n        return el;\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.RunCode.RunNode\", RunNode);\n    return __exports;\n  }({});\n\n  const sc1 = exports.sc1 = Template.SplitterBar.New_1(30);\n\n  const sr1 = exports.sr1 = (() => {\n    const vertical = (o => ValModule.toVal(o))(false);\n\n    return new Template.SplitterBar(Template.SplitterBar.New_1(30).value, Template.SplitterBar.New_1(30).min, Template.SplitterBar.New_1(30).max, vertical, Template.SplitterBar.New_1(30).node, Template.SplitterBar.New_1(30).children, Template.SplitterBar.New_1(30).after, Template.SplitterBar.New_1(30).dragging, Template.SplitterBar.New_1(30).startVer, Template.SplitterBar.New_1(30).startP, Template.SplitterBar.New_1(30).start, Template.SplitterBar.New_1(30).size, Template.SplitterBar.New_1(30).domElem);\n  })();\n\n  const div22 = exports.div22 = ($var115 => function (ch1, ch2) {\n    const grid = new Template.Grid(0, Template.Grid.New.Content(\"one\", ch1).Content(\"two\", ch2).gap, Template.Grid.New.Content(\"one\", ch1).Content(\"two\", ch2).content, Template.Grid.New.Content(\"one\", ch1).Content(\"two\", ch2).cols, Template.Grid.New.Content(\"one\", ch1).Content(\"two\", ch2).rows, Template.Grid.New.Content(\"one\", ch1).Content(\"two\", ch2).width, Template.Grid.New.Content(\"one\", ch1).Content(\"two\", ch2).height, Template.Grid.New.Content(\"one\", ch1).Content(\"two\", ch2).lastSplitter);\n    return (() => {\n      const rows_1 = (() => {\n        const rows = grid.rows.concat([new Template.Area(0, (() => {\n          const vertical = (o => ValModule.toVal(o))(false);\n\n          return new Template.SplitterBar(Template.SplitterBar.New_1(50).value, Template.SplitterBar.New_1(50).min, Template.SplitterBar.New_1(50).max, vertical, Template.SplitterBar.New_1(50).node, Template.SplitterBar.New_1(50).children, Template.SplitterBar.New_1(50).after, Template.SplitterBar.New_1(50).dragging, Template.SplitterBar.New_1(50).startVer, Template.SplitterBar.New_1(50).startP, Template.SplitterBar.New_1(50).start, Template.SplitterBar.New_1(50).size, Template.SplitterBar.New_1(50).domElem);\n        })())]);\n        return new Template.Grid(grid.padding, grid.gap, grid.content, grid.cols, rows, grid.width, grid.height, grid.lastSplitter);\n      })().rows.concat([new Template.Area(1, new Template.HtmlMeasure(1, (o_1 => ValModule.toVal(o_1))(80)))]);\n\n      return new Template.Grid((() => {\n        const rows = grid.rows.concat([new Template.Area(0, (() => {\n          const vertical = (o => ValModule.toVal(o))(false);\n\n          return new Template.SplitterBar(Template.SplitterBar.New_1(50).value, Template.SplitterBar.New_1(50).min, Template.SplitterBar.New_1(50).max, vertical, Template.SplitterBar.New_1(50).node, Template.SplitterBar.New_1(50).children, Template.SplitterBar.New_1(50).after, Template.SplitterBar.New_1(50).dragging, Template.SplitterBar.New_1(50).startVer, Template.SplitterBar.New_1(50).startP, Template.SplitterBar.New_1(50).start, Template.SplitterBar.New_1(50).size, Template.SplitterBar.New_1(50).domElem);\n        })())]);\n        return new Template.Grid(grid.padding, grid.gap, grid.content, grid.cols, rows, grid.width, grid.height, grid.lastSplitter);\n      })().padding, (() => {\n        const rows = grid.rows.concat([new Template.Area(0, (() => {\n          const vertical = (o => ValModule.toVal(o))(false);\n\n          return new Template.SplitterBar(Template.SplitterBar.New_1(50).value, Template.SplitterBar.New_1(50).min, Template.SplitterBar.New_1(50).max, vertical, Template.SplitterBar.New_1(50).node, Template.SplitterBar.New_1(50).children, Template.SplitterBar.New_1(50).after, Template.SplitterBar.New_1(50).dragging, Template.SplitterBar.New_1(50).startVer, Template.SplitterBar.New_1(50).startP, Template.SplitterBar.New_1(50).start, Template.SplitterBar.New_1(50).size, Template.SplitterBar.New_1(50).domElem);\n        })())]);\n        return new Template.Grid(grid.padding, grid.gap, grid.content, grid.cols, rows, grid.width, grid.height, grid.lastSplitter);\n      })().gap, (() => {\n        const rows = grid.rows.concat([new Template.Area(0, (() => {\n          const vertical = (o => ValModule.toVal(o))(false);\n\n          return new Template.SplitterBar(Template.SplitterBar.New_1(50).value, Template.SplitterBar.New_1(50).min, Template.SplitterBar.New_1(50).max, vertical, Template.SplitterBar.New_1(50).node, Template.SplitterBar.New_1(50).children, Template.SplitterBar.New_1(50).after, Template.SplitterBar.New_1(50).dragging, Template.SplitterBar.New_1(50).startVer, Template.SplitterBar.New_1(50).startP, Template.SplitterBar.New_1(50).start, Template.SplitterBar.New_1(50).size, Template.SplitterBar.New_1(50).domElem);\n        })())]);\n        return new Template.Grid(grid.padding, grid.gap, grid.content, grid.cols, rows, grid.width, grid.height, grid.lastSplitter);\n      })().content, (() => {\n        const rows = grid.rows.concat([new Template.Area(0, (() => {\n          const vertical = (o => ValModule.toVal(o))(false);\n\n          return new Template.SplitterBar(Template.SplitterBar.New_1(50).value, Template.SplitterBar.New_1(50).min, Template.SplitterBar.New_1(50).max, vertical, Template.SplitterBar.New_1(50).node, Template.SplitterBar.New_1(50).children, Template.SplitterBar.New_1(50).after, Template.SplitterBar.New_1(50).dragging, Template.SplitterBar.New_1(50).startVer, Template.SplitterBar.New_1(50).startP, Template.SplitterBar.New_1(50).start, Template.SplitterBar.New_1(50).size, Template.SplitterBar.New_1(50).domElem);\n        })())]);\n        return new Template.Grid(grid.padding, grid.gap, grid.content, grid.cols, rows, grid.width, grid.height, grid.lastSplitter);\n      })().cols, rows_1, (() => {\n        const rows = grid.rows.concat([new Template.Area(0, (() => {\n          const vertical = (o => ValModule.toVal(o))(false);\n\n          return new Template.SplitterBar(Template.SplitterBar.New_1(50).value, Template.SplitterBar.New_1(50).min, Template.SplitterBar.New_1(50).max, vertical, Template.SplitterBar.New_1(50).node, Template.SplitterBar.New_1(50).children, Template.SplitterBar.New_1(50).after, Template.SplitterBar.New_1(50).dragging, Template.SplitterBar.New_1(50).startVer, Template.SplitterBar.New_1(50).startP, Template.SplitterBar.New_1(50).start, Template.SplitterBar.New_1(50).size, Template.SplitterBar.New_1(50).domElem);\n        })())]);\n        return new Template.Grid(grid.padding, grid.gap, grid.content, grid.cols, rows, grid.width, grid.height, grid.lastSplitter);\n      })().width, (() => {\n        const rows = grid.rows.concat([new Template.Area(0, (() => {\n          const vertical = (o => ValModule.toVal(o))(false);\n\n          return new Template.SplitterBar(Template.SplitterBar.New_1(50).value, Template.SplitterBar.New_1(50).min, Template.SplitterBar.New_1(50).max, vertical, Template.SplitterBar.New_1(50).node, Template.SplitterBar.New_1(50).children, Template.SplitterBar.New_1(50).after, Template.SplitterBar.New_1(50).dragging, Template.SplitterBar.New_1(50).startVer, Template.SplitterBar.New_1(50).startP, Template.SplitterBar.New_1(50).start, Template.SplitterBar.New_1(50).size, Template.SplitterBar.New_1(50).domElem);\n        })())]);\n        return new Template.Grid(grid.padding, grid.gap, grid.content, grid.cols, rows, grid.width, grid.height, grid.lastSplitter);\n      })().height, (() => {\n        const rows = grid.rows.concat([new Template.Area(0, (() => {\n          const vertical = (o => ValModule.toVal(o))(false);\n\n          return new Template.SplitterBar(Template.SplitterBar.New_1(50).value, Template.SplitterBar.New_1(50).min, Template.SplitterBar.New_1(50).max, vertical, Template.SplitterBar.New_1(50).node, Template.SplitterBar.New_1(50).children, Template.SplitterBar.New_1(50).after, Template.SplitterBar.New_1(50).dragging, Template.SplitterBar.New_1(50).startVer, Template.SplitterBar.New_1(50).startP, Template.SplitterBar.New_1(50).start, Template.SplitterBar.New_1(50).size, Template.SplitterBar.New_1(50).domElem);\n        })())]);\n        return new Template.Grid(grid.padding, grid.gap, grid.content, grid.cols, rows, grid.width, grid.height, grid.lastSplitter);\n      })().lastSplitter);\n    })().Content0(new HtmlNode(1, [\"style\", function (o_2) {\n      return ValModule.toVal(o_2);\n    }(\"grid-template-areas: 'one' 'two' \")])).Render;\n  }(($var114 => function (ch1_1, ch2_1) {\n    const grid_1 = new Template.Grid(0, Template.Grid.New.Content(\"one\", ch1_1).Content(\"two\", ch2_1).gap, Template.Grid.New.Content(\"one\", ch1_1).Content(\"two\", ch2_1).content, Template.Grid.New.Content(\"one\", ch1_1).Content(\"two\", ch2_1).cols, Template.Grid.New.Content(\"one\", ch1_1).Content(\"two\", ch2_1).rows, Template.Grid.New.Content(\"one\", ch1_1).Content(\"two\", ch2_1).width, Template.Grid.New.Content(\"one\", ch1_1).Content(\"two\", ch2_1).height, Template.Grid.New.Content(\"one\", ch1_1).Content(\"two\", ch2_1).lastSplitter);\n    return (() => {\n      const rows_3 = (() => {\n        const rows_2 = grid_1.rows.concat([new Template.Area(1, new Template.HtmlMeasure(1, (o_3 => ValModule.toVal(o_3))(34)))]);\n        return new Template.Grid(grid_1.padding, grid_1.gap, grid_1.content, grid_1.cols, rows_2, grid_1.width, grid_1.height, grid_1.lastSplitter);\n      })().rows.concat([new Template.Area(0, (() => {\n        const vertical_1 = (o_4 => ValModule.toVal(o_4))(false);\n\n        return new Template.SplitterBar(Template.SplitterBar.New_1(50).value, Template.SplitterBar.New_1(50).min, Template.SplitterBar.New_1(50).max, vertical_1, Template.SplitterBar.New_1(50).node, Template.SplitterBar.New_1(50).children, Template.SplitterBar.New_1(50).after, Template.SplitterBar.New_1(50).dragging, Template.SplitterBar.New_1(50).startVer, Template.SplitterBar.New_1(50).startP, Template.SplitterBar.New_1(50).start, Template.SplitterBar.New_1(50).size, Template.SplitterBar.New_1(50).domElem);\n      })())]);\n\n      return new Template.Grid((() => {\n        const rows_2 = grid_1.rows.concat([new Template.Area(1, new Template.HtmlMeasure(1, (o_3 => ValModule.toVal(o_3))(34)))]);\n        return new Template.Grid(grid_1.padding, grid_1.gap, grid_1.content, grid_1.cols, rows_2, grid_1.width, grid_1.height, grid_1.lastSplitter);\n      })().padding, (() => {\n        const rows_2 = grid_1.rows.concat([new Template.Area(1, new Template.HtmlMeasure(1, (o_3 => ValModule.toVal(o_3))(34)))]);\n        return new Template.Grid(grid_1.padding, grid_1.gap, grid_1.content, grid_1.cols, rows_2, grid_1.width, grid_1.height, grid_1.lastSplitter);\n      })().gap, (() => {\n        const rows_2 = grid_1.rows.concat([new Template.Area(1, new Template.HtmlMeasure(1, (o_3 => ValModule.toVal(o_3))(34)))]);\n        return new Template.Grid(grid_1.padding, grid_1.gap, grid_1.content, grid_1.cols, rows_2, grid_1.width, grid_1.height, grid_1.lastSplitter);\n      })().content, (() => {\n        const rows_2 = grid_1.rows.concat([new Template.Area(1, new Template.HtmlMeasure(1, (o_3 => ValModule.toVal(o_3))(34)))]);\n        return new Template.Grid(grid_1.padding, grid_1.gap, grid_1.content, grid_1.cols, rows_2, grid_1.width, grid_1.height, grid_1.lastSplitter);\n      })().cols, rows_3, (() => {\n        const rows_2 = grid_1.rows.concat([new Template.Area(1, new Template.HtmlMeasure(1, (o_3 => ValModule.toVal(o_3))(34)))]);\n        return new Template.Grid(grid_1.padding, grid_1.gap, grid_1.content, grid_1.cols, rows_2, grid_1.width, grid_1.height, grid_1.lastSplitter);\n      })().width, (() => {\n        const rows_2 = grid_1.rows.concat([new Template.Area(1, new Template.HtmlMeasure(1, (o_3 => ValModule.toVal(o_3))(34)))]);\n        return new Template.Grid(grid_1.padding, grid_1.gap, grid_1.content, grid_1.cols, rows_2, grid_1.width, grid_1.height, grid_1.lastSplitter);\n      })().height, (() => {\n        const rows_2 = grid_1.rows.concat([new Template.Area(1, new Template.HtmlMeasure(1, (o_3 => ValModule.toVal(o_3))(34)))]);\n        return new Template.Grid(grid_1.padding, grid_1.gap, grid_1.content, grid_1.cols, rows_2, grid_1.width, grid_1.height, grid_1.lastSplitter);\n      })().lastSplitter);\n    })().Content0(new HtmlNode(1, [\"style\", function (o_5) {\n      return ValModule.toVal(o_5);\n    }(\"grid-template-areas: 'one' 'two' \")])).Render;\n  }(new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o_6) {\n    return ValModule.toVal(o_6);\n  }(\"Fixed34px\")), new HtmlNode(1, [\"style\", function (o_7) {\n    return ValModule.toVal(o_7);\n  }(\"background-color: lightblue\")])])]), $var114))(new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o_8) {\n    return ValModule.toVal(o_8);\n  }(\"Variable \")), new HtmlNode(1, [\"style\", function (o_9) {\n    return ValModule.toVal(o_9);\n  }(\"background-color: lightgreen\")])])])), $var115))(new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o_10) {\n    return ValModule.toVal(o_10);\n  }(\"Fixed80px\")), new HtmlNode(1, [\"style\", function (o_11) {\n    return ValModule.toVal(o_11);\n  }(\"background-color: magenta\")])])]));\n\n  const grid0 = exports.grid0 = ((arg00, arg10) => (() => {\n    const cols_2 = (() => {\n      const cols_1 = (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().cols.concat([new Template.Area(2, sc1)]);\n\n      return new Template.Grid((() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().padding, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().gap, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().content, cols_1, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().rows, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().width, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().height, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().lastSplitter);\n    })().cols.concat([new Template.Area(0, Template.SplitterBar.New_1(16))]);\n\n    return new Template.Grid((() => {\n      const cols_1 = (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().cols.concat([new Template.Area(2, sc1)]);\n\n      return new Template.Grid((() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().padding, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().gap, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().content, cols_1, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().rows, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().width, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().height, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().lastSplitter);\n    })().padding, (() => {\n      const cols_1 = (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().cols.concat([new Template.Area(2, sc1)]);\n\n      return new Template.Grid((() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().padding, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().gap, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().content, cols_1, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().rows, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().width, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().height, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().lastSplitter);\n    })().gap, (() => {\n      const cols_1 = (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().cols.concat([new Template.Area(2, sc1)]);\n\n      return new Template.Grid((() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().padding, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().gap, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().content, cols_1, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().rows, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().width, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().height, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().lastSplitter);\n    })().content, cols_2, (() => {\n      const cols_1 = (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().cols.concat([new Template.Area(2, sc1)]);\n\n      return new Template.Grid((() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().padding, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().gap, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().content, cols_1, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().rows, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().width, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().height, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().lastSplitter);\n    })().rows, (() => {\n      const cols_1 = (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().cols.concat([new Template.Area(2, sc1)]);\n\n      return new Template.Grid((() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().padding, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().gap, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().content, cols_1, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().rows, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().width, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().height, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().lastSplitter);\n    })().width, (() => {\n      const cols_1 = (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().cols.concat([new Template.Area(2, sc1)]);\n\n      return new Template.Grid((() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().padding, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().gap, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().content, cols_1, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().rows, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().width, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().height, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().lastSplitter);\n    })().height, (() => {\n      const cols_1 = (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().cols.concat([new Template.Area(2, sc1)]);\n\n      return new Template.Grid((() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().padding, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().gap, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().content, cols_1, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().rows, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().width, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().height, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().lastSplitter);\n    })().lastSplitter);\n  })().NewSplitter(arg00, arg10))(50, true).Before.changeSplitter(spl => {\n    const max = (o_2 => ValModule.toVal(o_2))(ValModule.mapV(function (y) {\n      return 84 - y;\n    }, function (o_1) {\n      return ValModule.toVal(o_1);\n    }(sc1.GetValue)));\n\n    return new Template.SplitterBar(spl.value, spl.min, max, spl.vertical, spl.node, spl.children, spl.after, spl.dragging, spl.startVer, spl.startP, spl.start, spl.size, spl.domElem);\n  });\n\n  const grid1 = exports.grid1 = ((arg00, arg10) => (() => {\n    const rows_2 = (() => {\n      const rows_1 = (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().rows.concat([new Template.Area(2, sr1)]);\n\n      return new Template.Grid((() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().padding, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().gap, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().content, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().cols, rows_1, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().width, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().height, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().lastSplitter);\n    })().rows.concat([new Template.Area(0, (() => {\n      const vertical = (o_1 => ValModule.toVal(o_1))(false);\n\n      return new Template.SplitterBar(Template.SplitterBar.New_1(16).value, Template.SplitterBar.New_1(16).min, Template.SplitterBar.New_1(16).max, vertical, Template.SplitterBar.New_1(16).node, Template.SplitterBar.New_1(16).children, Template.SplitterBar.New_1(16).after, Template.SplitterBar.New_1(16).dragging, Template.SplitterBar.New_1(16).startVer, Template.SplitterBar.New_1(16).startP, Template.SplitterBar.New_1(16).start, Template.SplitterBar.New_1(16).size, Template.SplitterBar.New_1(16).domElem);\n    })())]);\n\n    return new Template.Grid((() => {\n      const rows_1 = (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().rows.concat([new Template.Area(2, sr1)]);\n\n      return new Template.Grid((() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().padding, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().gap, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().content, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().cols, rows_1, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().width, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().height, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().lastSplitter);\n    })().padding, (() => {\n      const rows_1 = (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().rows.concat([new Template.Area(2, sr1)]);\n\n      return new Template.Grid((() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().padding, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().gap, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().content, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().cols, rows_1, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().width, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().height, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().lastSplitter);\n    })().gap, (() => {\n      const rows_1 = (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().rows.concat([new Template.Area(2, sr1)]);\n\n      return new Template.Grid((() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().padding, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().gap, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().content, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().cols, rows_1, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().width, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().height, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().lastSplitter);\n    })().content, (() => {\n      const rows_1 = (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().rows.concat([new Template.Area(2, sr1)]);\n\n      return new Template.Grid((() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().padding, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().gap, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().content, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().cols, rows_1, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().width, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().height, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().lastSplitter);\n    })().cols, rows_2, (() => {\n      const rows_1 = (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().rows.concat([new Template.Area(2, sr1)]);\n\n      return new Template.Grid((() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().padding, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().gap, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().content, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().cols, rows_1, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().width, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().height, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().lastSplitter);\n    })().width, (() => {\n      const rows_1 = (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().rows.concat([new Template.Area(2, sr1)]);\n\n      return new Template.Grid((() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().padding, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().gap, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().content, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().cols, rows_1, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().width, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().height, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().lastSplitter);\n    })().height, (() => {\n      const rows_1 = (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().rows.concat([new Template.Area(2, sr1)]);\n\n      return new Template.Grid((() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().padding, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().gap, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().content, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().cols, rows_1, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().width, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().height, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().lastSplitter);\n    })().lastSplitter);\n  })().NewSplitter(arg00, arg10))(50, false).Before.changeSplitter(spl => {\n    const max = (o_3 => ValModule.toVal(o_3))(ValModule.mapV(function (y) {\n      return 84 - y;\n    }, function (o_2) {\n      return ValModule.toVal(o_2);\n    }(sr1.GetValue)));\n\n    return new Template.SplitterBar(spl.value, spl.min, max, spl.vertical, spl.node, spl.children, spl.after, spl.dragging, spl.startVer, spl.startP, spl.start, spl.size, spl.domElem);\n  });\n\n  const grid2 = exports.grid2 = grid1.Content0(new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o) {\n    return ValModule.toVal(o);\n  }(\"Div11\")), new HtmlNode(1, [\"style\", function (o_1) {\n    return ValModule.toVal(o_1);\n  }(\"background-color: lightblue\")])])])).Content(\"1 / 2\", new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o_2) {\n    return ValModule.toVal(o_2);\n  }(\"Div12\")), new HtmlNode(1, [\"style\", function (o_3) {\n    return ValModule.toVal(o_3);\n  }(\"background-color: lightgreen\")])])])).Content(\"1 / 3\", new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o_4) {\n    return ValModule.toVal(o_4);\n  }(\"Div13\")), new HtmlNode(1, [\"style\", function (o_5) {\n    return ValModule.toVal(o_5);\n  }(\"background-color: pink\")])])])).Content(\"1 / 4\", new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o_6) {\n    return ValModule.toVal(o_6);\n  }(\"Div14\")), new HtmlNode(1, [\"style\", function (o_7) {\n    return ValModule.toVal(o_7);\n  }(\"background-color: magenta\")])])]));\n  const grid = exports.grid = grid2.Content(\"2 / 1\", new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o) {\n    return ValModule.toVal(o);\n  }(\"Div21\")), new HtmlNode(1, [\"style\", function (o_1) {\n    return ValModule.toVal(o_1);\n  }(\"background-color: lightblue\")])])])).Content(\"2 / 2\", div22).Content(\"3 / 3\", new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o_2) {\n    return ValModule.toVal(o_2);\n  }(\"Div33\")), new HtmlNode(1, [\"style\", function (o_3) {\n    return ValModule.toVal(o_3);\n  }(\"background-color: pink\")])])])).Content(\"4 / 4\", new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o_4) {\n    return ValModule.toVal(o_4);\n  }(\"Div44\")), new HtmlNode(1, [\"style\", function (o_5) {\n    return ValModule.toVal(o_5);\n  }(\"background-color: magenta\")])])]));\n  (() => {\n    const objectArg = RunCode.RunNode[\".ctor\"]();\n    return function (arg00) {\n      objectArg.AddBootstrap;\n\n      (arg00_1 => {\n        (arg00_2 => {\n          WebSharper.UI.Next.Doc.Run(objectArg.RunNode, arg00_2);\n        })(renderDoc(arg00_1));\n      })(new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(1, [\"class\", (o => ValModule.toVal(o))(\"container\")]), new Template.Panel(new Template.Panel((() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._class, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._style, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().title, new _List2.default(), (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().content, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().disabled)._class, new Template.Panel((() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._class, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._style, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().title, new _List2.default(), (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().content, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().disabled)._style, new Template.Panel((() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._class, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._style, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().title, new _List2.default(), (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().content, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().disabled).title, new Template.Panel((() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._class, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._style, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().title, new _List2.default(), (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().content, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().disabled).header, (0, _List.ofArray)([new HtmlNode(0, [\"h3\", arg00]), new HtmlNode(1, [\"style\", (o_2 => ValModule.toVal(o_2))(\"font-family:monospace;\")])]), new Template.Panel((() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._class, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._style, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().title, new _List2.default(), (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().content, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().disabled).disabled).Render])]));\n    };\n  })()(function (el) {\n    return el.AddChildren((0, _List.ofArray)([new HtmlNode(1, [\"style\", function (o_3) {\n      return ValModule.toVal(o_3);\n    }(\"height: 600px\")])]));\n  }(grid.Render));\n});","parent":{"$":0,"Item":"b30f728e-eb7c-40d1-b4ac-596e372b4e84"},"predecessors":[],"id":{"$":0,"Item":"a12aaea2-fcec-4a6e-9f94-b76e1054bbef"},"expanded":true,"level":0,"levelCode":0,"properties":{"Mode":"javascript","DisableParse":"1"}},{"name":"Tests","content":"#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule Tests =","parent":{"$":0,"Item":"ba90a7d3-7af6-4637-a92f-5d30657d63f2"},"predecessors":[],"id":{"$":0,"Item":"5c2c508d-5c37-489f-a539-90b0b13e1e45"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableFSI":"0","DisableWebSharper":"0"}},{"name":"inline errors","content":"\n\nlet counter =\n    let mutable i = 0\n    fun () ->\n        i <- i + 1\n        i\n    \ntype Type = {\n    a     : int\n    b     : int\n    c     : int\n    d     : int\n    count : int\n}\n  with\n    static member New(n) = {\n        a     = n\n        b     = n * 2\n        c     = n * 3\n        d     = n * 4\n        count = counter()  // <== should only be called twice\n      }\n      \n    member        this.MethodN (v:bool) = { this with a = this.a * if v then 2 else 3 }\n    member inline this.MethodI (v:bool) = { this with a = this.a * if v then 2 else 3 }\n    member        this.MethodN ()       = { this with a = this.a * 10                 }\n    member inline this.MethodI ()       = { this with a = this.a * 10                 }\n\nType.New(5).MethodN(false).MethodN(true).MethodN()\n|> printfn \"not inline: %A\"\n    \nType.New(5).MethodI(false).MethodI(true).MethodI()\n|> printfn \"inline: %A\"\n\n#define WEBSHARPER \n","parent":{"$":0,"Item":"5c2c508d-5c37-489f-a539-90b0b13e1e45"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"5a35850e-b3e7-40ad-b844-73516566a80f"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"F# STATION TUTORIALS","content":"// go to 1. Hello World\n#nowarn \"20\"\n#nowarn \"52\"\n#nowarn \"1178\"\n#nowarn \"3180\"\n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\nmodule Tutorials =\n","parent":{"$":0,"Item":"bf864f3c-1370-42f2-ac8a-565a604892e8"},"predecessors":[],"id":{"$":0,"Item":"3e6eb5de-d69e-4fcd-a472-d326d673ae52"},"expanded":false,"level":0,"levelCode":0,"properties":{"CSS":".CodeMirror span.cm-comment {\nbackground : white;\nfont-style : normal;\nfont-weight: 600;\ncolor      : black;\nfont-size  : 20px;  \n}","Theme":"neat","DisableFSI":"1","Layout":"[[\"code_props\",{\"GuiSplit\":[true,\"StVariable\",true,100,\"title_code\",\"messagesR\",25,100]}],[\"main_messages\",{\"GuiSplit\":[true,\"StVariable\",false,65,\"snippets_code\",\"messagesB\",35,100]}],[\"buttons\",{\"GuiNode\":{\"HtmlElementF\":[\"div\",[{\"HtmlGuiPart\":\"actRunWSHere\"},{\"HtmlAttributeF\":[\"style\",\"text-align: center\"]}]]}}]]","DisableFable":"1"}},{"name":"1.1 Hello World WebSharper","content":"\"Hello World!\"                                // Mandatory Hello World example\n|> RunCode.RunNode().AddBootstrap.ShowResult  // <=== ShowResult shows any value as a text in an html pane  \n\n\n\n// Click on \"Run WebSharper\" button below to run example\n// Simple, right?\n\n\n// Intellisense:\n// Double click once on ShowResult to see a tooltip\n\n\n\"\"\"\n\nRun WebSharper can show the result in a new browser tab or in the \"WS Result\" tab below\nDisable pop up blocker for this page\n\n\"\"\"","parent":{"$":0,"Item":"3e6eb5de-d69e-4fcd-a472-d326d673ae52"},"predecessors":[{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"}],"id":{"$":0,"Item":"fde83d46-bd7c-48e4-80f4-647639de87b9"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"1.1 Hello World Fable","content":"\"Hello World!\"                                // Mandatory Hello World example\n|> printfn \"%A\"                               // <=== What is printed out shows in the Output pane below \n\n\n\n// Click on \"Run Fable\" button below to run example\n// Simple, right?\n\n\"\"\"\n\n\"Run FSI\" and \"Run Fable\" show in the Output pane what is printed out with printfn\n\"Run FSI\" is deactivated over the web, but it works when installed locally\n\nFable was recently added to F# Station and so the integration is still very experimental\nand it is not fully operating.\n\n\n\"\"\"","parent":{"$":0,"Item":"3e6eb5de-d69e-4fcd-a472-d326d673ae52"},"predecessors":[],"id":{"$":0,"Item":"9657d144-25d9-4d2d-907a-af0245e13f8c"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableFable":"0","DisableWebSharper":"1","Layout":"[[\"code_props\",{\"GuiSplit\":[true,\"StVariable\",true,100,\"title_code\",\"messagesR\",25,100]}],[\"main_messages\",{\"GuiSplit\":[true,\"StVariable\",false,65,\"snippets_code\",\"messagesB\",35,100]}],[\"buttons\",{\"GuiNode\":{\"HtmlElementF\":[\"div\",[{\"HtmlGuiPart\":\"actRunFable\"},{\"HtmlAttributeF\":[\"style\",\"text-align: center\"]}]]}}]]"}},{"name":"2. Working with Predecessors","content":"// Expand me and go to: \"2.3 Many Hellos\"","parent":{"$":0,"Item":"3e6eb5de-d69e-4fcd-a472-d326d673ae52"},"predecessors":[{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"}],"id":{"$":0,"Item":"7df1af66-2085-4125-aa78-ce48ecbe8838"},"expanded":true,"level":0,"levelCode":0,"properties":{"NoIndent":"1","DisableParse":"1"}},{"name":"2.1 countTo","content":"let countTo n = [| 1..n |]\n\n\n\"\"\"\n\nParent snippets are automatically predecessors too\n\n\n\"\"\"","parent":{"$":0,"Item":"7df1af66-2085-4125-aa78-ce48ecbe8838"},"predecessors":[],"id":{"$":0,"Item":"a9437ce3-e291-46e8-ab1b-6879efee4b53"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"2.2 sayItManyTimes","content":"let sayItManyTimes s n = \n    countTo n                            // <=== countTo is defined above\n    |> Array.map (sprintf \"%s %A\" s)\n\n\n\"\"\"\n\nThis snippet has a direct predecessor: \"2.1 countTo\"\n\n\n\"\"\"","parent":{"$":0,"Item":"7df1af66-2085-4125-aa78-ce48ecbe8838"},"predecessors":[{"$":0,"Item":"a9437ce3-e291-46e8-ab1b-6879efee4b53"}],"id":{"$":0,"Item":"6ec1d5bf-6a84-471a-89aa-d9e9f8ffd141"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"2.3 Many Hellos","content":"// Working with predecessors\n\nsayItManyTimes \"Hello\" 10                     // \"sayItManyTimes\" is defined in the prior snippet\n|> RunCode.RunNode().AddBootstrap.ShowResult \n\n\n\"\"\" \nClick on \"Run WebSharper\" button below to run example\n\n\nBy using the predecessor mechanism a bunch of code is added with this snippet.\nAll predecessors direct and indirect are highlighted in blue on the left.\nDirect predecessors are marked with an X on the right side of the snippet list.\nTry toggling the direct predecessor 2.2\n\nThe parent of a snippet is automatically a predecessor.\nBy default children snippets code is indented, except when NoIndent property is used.\n\nONLY the highlighted snippets are included in the final code.\n\nTo see the F# code generated, select the \"F# code\" tab below.\n(click on \"Get F# Code\" if it is empty)\n\nThe F# code is translated into JavaScript by WebSharper\nSelect the \"JavaScript\" tab to see the translated JS Code\n(click on \"Run WebSharper\" or \"Compile WebSharper\" if it is empty)\n\n\"\"\"\n// Intellisense:\n// ShowResult is defined somewhere else, to find it\n// click on it and then use <Find Definition> button\n\n","parent":{"$":0,"Item":"7df1af66-2085-4125-aa78-ce48ecbe8838"},"predecessors":[{"$":0,"Item":"6ec1d5bf-6a84-471a-89aa-d9e9f8ffd141"}],"id":{"$":0,"Item":"c93f1a5c-0145-4456-b71b-78923fc8a4f7"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"3. Using Html","content":"div [                                              // an Html tag:  <div>\n    htmlText \"Many Hellos!\"                        // some text\n    ul [                                           // more tags:    <ul> <li>\n        for hello in sayItManyTimes \"Hello\" 10 do\n            yield li [ htmlText hello ]\n    ]\n]\n|> RunCode.RunNode().AddBootstrap.ShowHtmlResult   // \"ShowHtmlResult\" displays Html instead of plain text\n\n\n\"\"\"\n\nThis is a simplified version of the WebSharper syntax.\nSubtags and attributes are combined in the same sequence.\n\n\n\"\"\"","parent":{"$":0,"Item":"3e6eb5de-d69e-4fcd-a472-d326d673ae52"},"predecessors":[{"$":0,"Item":"6ec1d5bf-6a84-471a-89aa-d9e9f8ffd141"}],"id":{"$":0,"Item":"9c57f2d5-6e05-410c-8262-1f0573cf7c8e"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"4. Html Attributes","content":"div [                                              \n    style \"background: beige; color: red\"          // an attribute: \"style\"\n    h1 [ htmlText \"Many Hellos!\" ]\n    style \"font-style: italic; font-family: Times\" // and another one!\n    ul [\n        for hello in sayItManyTimes \"Hello\" 10 do\n            yield li [\n                    style    \"color: blue\"\n                    htmlText hello \n                  ]\n        yield style \"font-style: normal\"\n    ]\n    style \"text-align: center\"                    // attributes can be in any order\n]\n|> RunCode.RunNode().AddBootstrap.RunHtml         // \"RunHtml\" also displays Html but not in a pane\n\n\"\"\"\n\nMultiple \"style\" and \"class\" attributes are combined automatically.\n\n\n\"\"\"\n\n// Intellisense: Ctrl-Space for autocomplete\n// try it: place cursor right after \"AddBootstrap.\" and press ctrl-space\n\n","parent":{"$":0,"Item":"3e6eb5de-d69e-4fcd-a472-d326d673ae52"},"predecessors":[{"$":0,"Item":"6ec1d5bf-6a84-471a-89aa-d9e9f8ffd141"}],"id":{"$":0,"Item":"4d7c9a6a-9610-49df-9e97-1292a0608074"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"5. Calculated Attributes","content":"let fontSize i = sprintf \"font-size: %dpx\" ((i + 1) * 3) // <== a nice formula to calculate font size\n\ndiv [                                              \n    style \"background: beige; color: red\"         \n    h1 [ htmlText \"Many Hellos!\" ]\n    style \"font-style: italic; font-family: Times\"\n    ul [\n        for i, hello in sayItManyTimes \"Hello\" 10 |> Seq.indexed do\n            yield \n                li [\n                    style    \"color: blue\"\n                    style <| fontSize i                    // <=== applied here, as a static style\n                    htmlText hello \n                ]\n        yield style \"font-style: normal\"\n    ]\n    style \"text-align: center\"   \n]\n|> RunCode.RunNode().AddBootstrap.RunHtml   ","parent":{"$":0,"Item":"3e6eb5de-d69e-4fcd-a472-d326d673ae52"},"predecessors":[{"$":0,"Item":"6ec1d5bf-6a84-471a-89aa-d9e9f8ffd141"}],"id":{"$":0,"Item":"f5d15bec-c4fa-4a62-998d-24a91c4981a2"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"6. Using Templates and Variables","content":"let multiplier = Template.Input.New(\"3\")                                          // a Template for text input\n                         .Placeholder(\"Enter multiplier:\")                        // with some nice predefined features\n                         .Prefix(\"Multiplier:\")\n\nlet fontSizeVal i = \n    multiplier.Var                                                                // Use UI.Next Var from the template object\n    |> Val.map (fun m -> sprintf \"font-size: %dpx\" ((i + 1) * int m))             // <=== not static anymore, this one is dynamic!\n\ndiv [\n    multiplier.Render                                                             // Render text input into HtmlNode type\n    div [                                              \n        style \"background: beige; color: red\"         \n        h1 [ htmlText <| Val.map (sprintf \"Many Hellos! x %spx\") multiplier.Var ] // <=== a dynamic text\n        style \"font-style: italic; font-family: Times\"\n        ul [\n            for i, hello in sayItManyTimes \"Hello\" 10 |> Seq.indexed do\n                yield \n                    li [\n                        style    \"color: blue\"\n                        style <| fontSizeVal i                                     // <=== apply dynamic style\n                        htmlText hello \n                    ]\n            yield style \"font-style: normal\"\n        ]\n        style \"text-align: center\"   \n    ]\n]\n|> RunCode.RunNode().AddBootstrap.RunHtml   \n\n\"\"\"\n\n\nThe Val type is a wrapper class that unifies WebSharper's UI.Next Var, View and constant values for a simpler syntax.\n\n\n\"\"\"","parent":{"$":0,"Item":"3e6eb5de-d69e-4fcd-a472-d326d673ae52"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"6ec1d5bf-6a84-471a-89aa-d9e9f8ffd141"}],"id":{"$":0,"Item":"cdb3cc85-46be-44a5-9a92-599f080e01e2"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"7. Work in progress","content":"FSharpStation.FSharpStationClient \"\"\n|> RunCode.RunNode().AddBootstrap.RunDoc    // Run WebSharper (preferrably in New Browser)\n\n\"\"\"\n\nYes, the tutorial is short. This is a work in progress.\nBut there are more interesting Snippets inside \"WebSharper Code\", go check them out.\n\nPeople usually complain that examples in tutorials are only Mickey Mouse versions \nbut \"F# Station\" is fully coded in F# Station. \nI mean the code is all here including client and server sides, \nfeel free to explore and discover.\n\nEven though it is client-server it isn't intended to be used over the Web,\n\"Run FSI\" uses FSI which gives full access to the server computer which is dangerous.\nThat is why \"Run FSI\" is disabled over the web.\n\n\"Run Fable\" was recently added, still in development.\n\nTo get the full power of F# Station install locally in your computer.\n\n\"\"\" // To install locally goto: https://github.com/amieres/FSharpStation \n","parent":{"$":0,"Item":"3e6eb5de-d69e-4fcd-a472-d326d673ae52"},"predecessors":[{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"}],"id":{"$":0,"Item":"b3f2df8c-b6d9-46e2-b09a-a6550b02d5a6"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"ACTIONS","content":"module Actions =","predecessors":[],"id":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"expanded":false,"level":0,"levelCode":0,"properties":{"Theme":"rubyblue","DisableParse":"1","DisableWebSharper":"1","DisableFable":"1"}},{"name":"SAVE FSharpStation.js","content":"FSSGlobal.FsStationShared.FsStationClient(\"SAVE CodeEditor\")\n    .SaveSnippetJS @\"website\\EPFileX\" \"FSSGlobal/WebSharper Code/FSharpStation Code/FSharpStation\"\n","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"}],"id":{"$":0,"Item":"07a3e5d2-a793-49cf-bb87-88a98c5d9c7d"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"SAVE FSharpStation.fsx","content":"FSSGlobal.FsStationShared.FsStationClient(\"SAVE CodeEditor\")\n    .SaveSnippetFsx @\"..\\bin\\website\\EPFileX\" \"FSSGlobal/WebSharper Code/FSharpStation Code/FSharpStation\"","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"}],"id":{"$":0,"Item":"56b4fb1e-909e-4b83-b312-8993751d0685"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"SAVE FsJson File","content":"FSSGlobal.FsStationShared.FsStationClient(\"SAVE CodeEditor\")\n    .SaveWholeFile @\"..\\..\" \"CodeEditor\"","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"}],"id":{"$":0,"Item":"df25d045-936b-4f0e-9a22-429cd4f8848a"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"DO Saves","content":"// Click Evaluate F#","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"07a3e5d2-a793-49cf-bb87-88a98c5d9c7d"},{"$":0,"Item":"56b4fb1e-909e-4b83-b312-8993751d0685"},{"$":0,"Item":"df25d045-936b-4f0e-9a22-429cd4f8848a"}],"id":{"$":0,"Item":"e307def4-b29d-4abf-9ec6-8744c0b8d75a"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"Compile Modules","content":"#define COMPILING\nopen FSSGlobal.WSMessagingBroker // open's need to be here\nopen FSSGlobal.Useful\nopen FSSGlobal.UsefulDotNet.CompOptionsModule\n\nlet fsStation = FStationMessaging(\"Compile Modules\")\n[\n\n","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"d9c4540a-85f5-4c62-91be-fcb2d60e9f17"}],"id":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"\"FSSGlobal/F# Code/FsTranslator/FsTranslator\"        |> compileOptionsExeDebug\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"b89801cc-5412-4025-bd88-c6ec0624a970"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"Prop"}},{"name":"","content":"\"FSSGlobal/F# Code/FsStationShared/SelfHostedServer\" |> compileOptionsExeDebug\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"2db6dbb4-6c03-4c3d-990f-abfb997e9855"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"1"}},{"name":"","content":"(\"FSSGlobal/F# Code/UsefulDotNet/RemotingDll\"        |> compileOptionsDllDebug)\n  + opGenWSharper /= \"ws:library\" \n  + opDirectory   /= \"Compiled/RemotingDll2\"\n  + wsProjectOptions\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"8deb7606-0602-4a16-83b4-4528985f267e"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"1"}},{"name":"","content":"(\"FSSGlobal/WebSharper Code/Template/AllTemplates\"   |> compileOptionsDllDebug)\n  + opGenWSharper /= \"ws:library\" \n  + wsProjectOptions\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"7b5a4715-f440-41ed-aad3-47930c2f259d"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"\"FSSGlobal/F# Code/FSAutoComplete/FSAutoCompleteDll\" |> compileOptionsDllDebug\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"53c32bfe-219e-4ff1-8913-adbc067b40d4"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"1"}},{"name":"","content":"\"FSSGlobal/F# Code/CalculationModel/CalculationModelDll\" |> compileOptionsDllDebug","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"2f153bcc-4e41-479b-8275-09f4446d22d7"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"\"FSSGlobal/F# Code/Snippets/Calculate primes\"        |> compileOptionsWinExeDebug","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"7196e914-b38c-489b-a119-c980432ac41b"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"1"}},{"name":"Compile selected modules","content":"// select the module(s) to compile\n\n] |> Seq.iter (id \n        >> swap (+) [ opGenInternal /= \"showoptions\" ] \n        //>> swap (+) [ opGenFSharp2  /= \"standalone\"  ] \n        >> fsStation.CompileSnippetW \n        >> Wrap.runSynchronouslyS true\n        >> printfn \"%s\"\n     )\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[{"$":0,"Item":"2f153bcc-4e41-479b-8275-09f4446d22d7"}],"id":{"$":0,"Item":"d39e3783-fb76-4963-b9fe-2da76c4b2a86"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"DO/check all ACTIONS","content":"// Just Select as predecessors all the actions you want to execute \n// and then click on Evaluate F#\n","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"5e8209e0-9203-4fe0-8289-fb4579b24038"},{"$":0,"Item":"d39e3783-fb76-4963-b9fe-2da76c4b2a86"},{"$":0,"Item":"c8c93861-321c-4d73-beb0-2fef0052bc7b"},{"$":0,"Item":"e307def4-b29d-4abf-9ec6-8744c0b8d75a"},{"$":0,"Item":"c578e375-e299-4450-957e-1596e7af2007"},{"$":0,"Item":"24394c61-747d-41ff-816e-c70e46573bb7"},{"$":0,"Item":"d5d1c9fc-856e-44fd-aa74-9a8e88c3818f"}],"id":{"$":0,"Item":"64f180f8-8781-4630-9239-b5610a6329b6"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"FSI ZONE","content":"open FSSGlobal.Useful\n\nlet vals = [1 .. 10]\nlet print v = printfn \"%A\" v\n\nprint vals\n\nlet vals2 = vals |> List.map Result.succeed\n\nprint vals2\n\nlet vals3 = vals2 |> Result.Seq.sequenceM\n\nprint vals3","predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"c2fd97dd-907f-4c2e-ae68-d80f2b8caf3c"},"expanded":true,"level":0,"levelCode":0,"properties":{"Theme":"mbo","DisableFSI":"0","DisableWebSharper":"1","DisableParse":"0"}},{"name":"FSI 2","content":"\ntype SemigroupBuilder< 'T>(op: 'T->'T->'T) =\n    member inline __.Yield v       = v\n    member inline __.YieldFrom vs  = vs\n    member inline __.Combine(a, b) = op a b\n    member inline __.Delay(v)      = v()\nlet inline semigroup op = SemigroupBuilder op\n\nsemigroup (+) {\n    yield 7\n    yield 12\n}\n|> printfn \"%A\"\n\nlet concatStr (a:string) b = a + b\n\nsemigroup concatStr {\n    yield \"7\"\n    yield \"12\"\n}\n|> printfn \"%A\"\n\nsemigroup List.append {\n    yield [7]\n    yield [12]\n}\n|> printfn \"%A\"\n\nsemigroup ( * ) {\n    yield 7\n    yield 12\n}\n|> printfn \"%A\"\n\ntype MonoidBuilder<'T>(op, zero: 'T) =\n    inherit SemigroupBuilder<'T>(op)\n    member inline __.Zero()       = zero\nlet inline monoid op zero = MonoidBuilder(op, zero)\n\nmonoid (+) 0 {\n    if false then\n        yield 7\n        yield 12\n} |> printfn \"%A\"\n\nmonoid concatStr \"\" {\n    if false then\n        yield \"7\"\n        yield \"12\"\n} |> printfn \"%A\"\n\nmonoid List.append [] {\n    if false then\n        yield [7]\n        yield [12]\n} |> printfn \"%A\"\n\nmonoid ( * ) 1 {\n    if false then\n        yield 7\n        yield 12\n} |> printfn \"%A\"\n\nlet rec range (mon:MonoidBuilder<_>) n = mon { \n    yield n\n    if n < 100 then yield! range mon (n + 1) \n} \n\nrange (monoid ( + ) 0) 97 |> printfn \"%A\"\nrange (monoid ( * ) 1) 97 |> printfn \"%A\"\n\n[97 .. 100] |> Seq.sum |> printfn \"%A\"\n[97 .. 100] |> Seq.fold (fun a v -> a * v) 1 |> printfn \"%A\"\n\n\n","predecessors":[],"id":{"$":0,"Item":"f5c6e00d-1589-46a4-bfc6-d3c3b58b689d"},"expanded":true,"level":0,"levelCode":0,"properties":{"Theme":"mbo","DisableFSI":"0","DisableWebSharper":"1","DisableParse":"0"}},{"name":"","content":"PENDING:\nPARSING:\n- Improve parsing to allow autocomplete and tooltip without having to wait for completion of current parsing\n- Cancel current parsing running if new request arrives, instead of waiting. Avoid queueing of parsing requests\n- Errors: Sometimes, parsing value is not reflected in editor.\n- Errors: Sometimes, parsing is not performed on latest editor value\n\n- Add option to actEvalFsCode to allow to run a different snippet than the current one. \n    This is to be able to invoke from the snippet that needs to be enacted upon.\n    The current snippet should be a parameter that could be somehow passed to the running snippet.\n- When switching from snippet with LayoutJS (Javascript) to Layout (Json) it does not work\n- Implement \"make\" functionality for code dependency\n- Fable errors line numbers represent file line number not snippet line number\n- Add version counter for F# Station and display it\n- When compiling FSharpStation:\nWebSharper warning: Failed to load return type 'FSSGlobal.FSAutoComplete+CommandResponse+Kind, FSAutoCompleteDll' \nto verify encoding to JSON. at FSSGlobal.FSAutoComplete.sendMessageRpc\n- Highlight snippets with errors\n- Add global search \n- back/forward browser functionality button (using #address preferrably)\n- add # routing to get to specific snippets\n- Keep count/ increase pending Http requests to avoid blocking the server\n- Intellisense\n    - Function Helps\n    - Parameters\n- ERRORS:   \n    - Load File when there is previously loaded (and selected snippet) fails with websharper error\n    - There is a lot of FOUC when changing layout (has been reduced)\n    - Bootstrap bleeds into WS Result\n    - TypeError: Cannot read property 'appendChild' of undefined\n    - FSAutoCompleteIntermediaryClient does not work with Demo CodeMirror\n\n\n        - Allow non text entries: like images, documents, links(text?) and other resources, maybe using 64 encoding\n        - Also it could be used as input for some code (although not too clear on how to do this, it may require serving the data as a web file)\n            - To store it in server it would make sense to split the snippets as entry in a DB so the server would not need to read a whole file\n              just to serve a snippet\n- Create website load/upload/invoke/precompiled code\n- The editor could have dual mode: server DB and local file\n    - For a website definition it would need to track read/write access to snippets\n\n\n- Implement Tab(s) & Application deployment including configurable editor(s)\n- Block non local use of Evaluate F# (unless logged in and with permission)\n- add HTTPS\n- Give it a web site look\n\nSOLVED:\n    - Errors in the last line of Snippets do not show in the snippet \n- Give it an icon that says F# Station\n    - Fix Communications issue (kind of fixed there is a discrepancy between 60 seconds timeout and 100 seconds timeout resulting in 40 dead seconds)\n    - Add Snippet hides children\n- Flush FsiExe MailBoxProcessor if 5 messages are waiting / or add a button for flushing\n- Allow plugable Add in commands\n- change how FSI communication works so that output is updated in real time\n- Have the buttons somehow test if the right version of the code is in FSI memory and if not call it before\n- Implement button calls for layout update from the layout themselvs and the \"computers\" snippet\n    - Fable fails first time with: require not defined (hopefully solved)\n    - CodeMirror shows incomplete when there are layout changes\n   -There is a little of FOUC when chaging theme\n            - Some snippet could be generated from others: for instance as js from F#, the snippet maintains the dependence and could also maintain the ages\n              and know when a snippet needs to be regenerated.\n        - Allow other modes for some entries: MarkDown, html, etc. \n        - That way different type of content could be integrated into code with different techniques for merging: css, html, javascript, c#, MarkDown and others\n- Have non indenting nested elements just for folder organization    \n    - it could be a flag in the name/code\n    - it could be an external attribute, like MIME type/subtype \n    - it could be related to the other type of content considered for the future\n- Use properties to enable/disable actions like Non Indent code\n- Download/Open .fsjson from Website\n- Eliminate fixit2 hack hardcoded namespace dependency\n    - Warnings in Websharper generated JavaScript are commented out this way: \\/* *\\/\n    - Buttons are hidden when pane too small\n- Use properties to enable/disable actions like Compile WS, Run WS, Evaluate F#, Parse F#\n    - Incomplete Parse when typing fast\n- Transfer server code to FSharpStation\n- Keep scroll at same level after redrawing list of snippets\n- FsTranslator loads from scratch every time, change it so it stays in memory as an agent\n- FsTranslator accumulates assemblies in memory - separate into an executable so it can be cleaned up\n- Speed up snippet list interaction: used ResetableMemoize\n- Speed up code construction for reparse\n- Separate parsing and compilation errors from output and other message windows like javascript, and F# and others\n- Click on Error Message jumps to location\n- Intellisense\n    - Jump to definition\n    - Autocompletion\n    - Code tips\n    - Make tooltips pop-up not Alert\n    - Error highlight\n- Reissue FSharpStation awaitRequestFor\n- Create splitter template: grid template with splitters included\n- Change the title so that it says F# Station\n- Implement command start: webserver + editor\n- Think how to mix WebSharper and no WebSharper code without duplicating: they can be shared and use #define WEBSHARPER to add [< JavaScript >]\n- Get rid of undefined message when running JS and maybe show possible result value\n- Get rid of no output warning when Evaluating FS and say Done!\n- Store last state in local storage:  splitter position/ execute/ file name/ dirty state\n- Create non-Javascript invocation (pure .Net F#) version for only local use.\n- Capture Asynchronous exceptions\n- Detect dirty state and not allow Load/close before saving\n    - Download ( Save as ...) with automatic extension\n- make Choose File and Load one action and one button\n- Limit undo to the current field\n- Error:\nCompiling...\nRunning...\nFailed!\nTypeError: Cannot read property 'appendChild' of undefined  // it was due to the busy CPU taking longer than 300ms to load. Changed to 600ms.\n- ERRORS:    \n    - Jump to top of document when fast editing. Fixed it with some clever counters but it feels as if there should be a better way maybe using Event and FRP\n","predecessors":[],"id":{"$":0,"Item":"b4b48226-deb9-44da-98de-e2bf5b7cd889"},"expanded":true,"level":0,"levelCode":0,"properties":{"Mode":"none","DisableParse":"1"}},{"name":"FSNew","content":"module FSNew =","predecessors":[],"id":{"$":0,"Item":"e83d0347-89ba-4fbf-8bd0-02723299e948"},"expanded":false,"level":0,"levelCode":0,"properties":{}},{"name":"Useful","content":"module Useful =","parent":{"$":0,"Item":"e83d0347-89ba-4fbf-8bd0-02723299e948"},"predecessors":[],"id":{"$":0,"Item":"46b53936-0e96-4e86-a196-9b76399a1d68"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"swap","content":"\nlet inline swap f a b = f b a\nlet inline __   f a b = f b a\n\n","parent":{"$":0,"Item":"46b53936-0e96-4e86-a196-9b76399a1d68"},"predecessors":[],"id":{"$":0,"Item":"a7f4f5f0-13eb-40fd-afd9-c4521f505e2d"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"extract, now, Async, String","content":"let extract n (s:string) = s.Substring(0, min n s.Length)\n\n#if WEBSHARPER\n[< Inline \"(function (n) { return n.getFullYear() + '-' +(n.getMonth() + 1) + '-' +  n.getDate() + ' '+n.getHours()+ ':'+n.getMinutes()+ ':'+n.getSeconds()+ ':'+n.getMilliseconds() })(new Date(Date.now()))\" >]\n#endif\nlet nowStamp() = \n    let t = System.DateTime.UtcNow // in two steps to avoid Warning: The value has been copied to ensure the original is not mutated\n    t.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n\nmodule Async =\n    let map f va = \n        async { \n            let! a = va\n            return f a \n        } \n    let iter f va = \n        async { \n            let! a = va\n            do f a \n        } \n\n    let Return x = async.Return x\n\n    let apply fAsync xAsync = async {\n        let! fChild = Async.StartChild fAsync\n        let! xChild = Async.StartChild xAsync\n        let! f = fChild\n        let! x = xChild \n        return f x \n        }\n\n    let bind f va = async.Bind(va, f)\n    let sleepThen f milliseconds =\n        async {\n            do! Async.Sleep milliseconds\n            do  f()\n        }\n\nmodule KeyVal =\n    //let inline getEnumerator dict = (^a : (member get_Enumerator : _) (dict, ()))\n    let inline tryGetValue key (dict) =\n        dict \n        :> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<_, _>> \n        |> Seq.tryPick (fun kp -> if kp.Key = key then Some kp.Value else None)\n\n\nmodule String =\n    let splitByChar (c: char) (s: string) = s.Split c\n    let trim                  (s: string) = s.Trim()\n    let append     (a: string)(b: string) =  a + b\n    \n    ","parent":{"$":0,"Item":"46b53936-0e96-4e86-a196-9b76399a1d68"},"predecessors":[],"id":{"$":0,"Item":"414d2960-2447-4fef-9c37-b1b7098d8355"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"XResult","content":"\ntype Message<'M> = \n    | Error     of string\n    | Warning   of string\n    | Message   of 'M\n    | Exception of System.Exception\n    with \n    override msg.ToString() =\n        match msg with\n        | Error     m -> m         |> sprintf \"Error    : %s\"\n        | Warning   m -> m         |> sprintf \"Warning  : %s\"\n        | Message   m -> m         |> sprintf \"%O\"\n        | Exception m -> m.Message |> sprintf \"Exception: %s\"\n\ntype XResult<'TValue, 'TMessage> = XResult  of 'TValue option * Message<'TMessage> []     \n\nmodule XResult =\n    let inline succeed                x     = XResult (Some x, [|  |])\n    let inline succeedWithMsg      m  x     = XResult (Some x, [|m |])\n    let inline succeedWithMsgs     ms x     = XResult (Some x,   ms  )\n    let inline fail                m        = XResult (None  , [|m |])\n    let inline failWithMsgs        ms       = XResult (None  ,   ms  )\n    let inline failException             e  = e |> Exception |> fail\n    let inline Return              x        = succeed x\n                                                                                    /// map without try protection\n    let inline map0      f (XResult(o, ms)) =       XResult(o |> Option.map f, ms)\n                                                                                    /// map with try protection in case of exceptions\n    let inline map       f (XResult(o, ms)) = try   XResult(o |> Option.map f, ms)\n                                              with  e -> failException e\n    let inline mapErr    f (XResult(o, ms)) = XResult (o                ,   ms |> Array.map f)\n    let inline mapMsg    f (XResult(o, ms)) = XResult (o                ,   ms |> Array.map f)\n    let inline mapMsgs   f (XResult(o, ms)) = XResult (o                ,   ms |>           f)\n    let inline getOption   (XResult(o, _ )) =         o                   \n    let inline getMsgs     (XResult(_, ms)) =                             ms\n    let inline mergeMsgs              ms r  = r |> mapMsgs   (Array.append ms)\n    let inline combine     (XResult(o, ms)) (rb: unit -> XResult<_,_>) = o |> Option.map (fun _ -> rb() |> mergeMsgs ms) |> Option.defaultValue (XResult(None, ms))\n    let inline join arr                     =\n        match arr with\n        | XResult(None                 , ms ) -> XResult(None, ms                  ) \n        | XResult(Some(XResult(b, ms1)), ms2) -> XResult(b   , Array.append ms2 ms1) \n                                                                                    /// bind with no try protection\n    let inline bind0     f  ar             = map0 f ar |> join \n                                                                                    /// bind with try protection in case of exceptions\n    let inline bind      f  ar             = map  f ar |> join \n                                                                                    /// apply with try protection in case of exceptions\n    let internal applyMap mapF (XResult(fO, fMs)) aR =\n        match fO with\n        | None   -> aR |> getMsgs |> Array.append fMs |> failWithMsgs\n        | Some f -> aR |> mapF f\n                                                                                    /// apply with try protection in case of exceptions\n    let inline apply0    fR aR = applyMap map0 fR aR\n                                                                                    /// apply with try protection in case of exceptions\n    let inline apply     fR aR = applyMap map  fR aR\n\n    let (|Success|Failure|) =\n        function \n        | XResult(Some x, ms) -> Success (x, ms) \n        | XResult(None  , ms) -> Failure     ms  \n\n//    let successTee f result =                           // given an RopResult, call a unit function on the success branch\n//        let fSuccess (x,msgs) =                         // and pass thru the result\n//            f (x,msgs)\n//            Success (x,msgs) \n//        either fSuccess Failure result\n//\n//    let fFailure2 f errs = \n//        f errs\n//        Failure errs \n//    let failureTee f result =                           /// given an RopResult, call a unit function on the failure branch\n//        either Success (fFailure2 f) result\n//\n//    let mapMessagesR f result =                         /// given an RopResult, map the messages to a different error type\n//        match result with \n//        | Success (x,msgs) -> \n//            let msgs' = List.map f msgs\n//            Success (x, msgs')\n//        | Failure errors -> \n//            let errors' = List.map f errors \n//            Failure errors' \n//\n//    let valueOrDefault f result =                       /// given an RopResult, in the success case, return the value.\n//        match result with                               /// In the failure case, determine the value to return by \n//        | Success (x,_) -> x                            /// applying a function to the errors in the failure case\n//        | Failure errors -> f errors\n//\n//    let failIfNone message = function                   /// lift an option to a RopResult.\n//        | Some x -> succeed x                           /// Return Success if Some\n//        | None -> fail message                          /// or the given message if None\n//\n//    let failIfNoneR message = function                  /// given an RopResult option, return it\n//        | Some rop -> rop                               /// or the given message if None\n//        | None -> fail message \n\n\n///            tryCall: (exn -> Result<'b>) ->  ('a -> Result<'b>) -> 'a -> Result<'b> =\n\n    type ropBuilder0() =\n        member inline this.Return     (x)                       = succeed x\n        member inline this.ReturnFrom (x)                       = x\n        member        this.Bind       (w , r )                  = bind0 r w\n        member inline this.Zero       ()                        = succeed ()\n        member inline this.Delay      (f)                       = f\n        member inline this.Combine    (a, b)                    = combine a b\n        member inline this.Run        (f)                       = f()\n        member this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind0 (fun () -> whileLoop guard body)\n                else Return   ()\n            whileLoop guard body\n        member this.TryWith(body, handler) =\n            try this.ReturnFrom(body())\n            with e -> handler e\n        member this.TryFinally(body, compensation) =\n            try this.ReturnFrom(body())\n            finally compensation()\n        member this.Using(disposable:#System.IDisposable, body) =\n            let body' = fun () -> body disposable\n            this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))              \n    /// computational expression without try protection\n    let xresult0 = ropBuilder0()\n\n    type ropBuilder() =\n        member inline this.Return     (x)                       = succeed x\n        member inline this.ReturnFrom (x)                       = x\n        member inline this.Bind       (w, r )                   = bind r w\n        member inline this.Zero       ()                        = succeed ()\n        member inline this.Delay      (f)                       = f\n        member inline this.Combine    (a, b)                    = combine a b\n        member inline this.Run        (f)                       = f()\n        member inline this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else Return   ()\n            whileLoop guard body\n        member inline this.TryWith(body, handler) =\n            try this.ReturnFrom(body())\n            with e -> handler e\n        member inline this.TryFinally(body, compensation) =\n            try this.ReturnFrom(body())\n            finally compensation()\n        member inline this.Using(disposable:#System.IDisposable, body) =\n            let body' = fun () -> body disposable\n            this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n        member inline this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))              \n\n    /// computational expression with try protection\n    let xresult = ropBuilder()\n    \n//    let fromChoice context c =  context?????\n    let fromChoice c =\n        match c with | Choice1Of2 v -> succeed v\n                     | Choice2Of2 e -> fail    e\n\n    let fromOption m =\n        function | None   -> fail    m\n                 | Some v -> succeed v\n\n    let toOption   (XResult(o, _ )) = o\n    let toOptionMs (XResult(o, ms)) = o, ms\n\n    let tryProtection() = succeed ()\n\n    let failIfFalse m v = if v then succeed () else m |> fail \n    let failIfTrue  m v = if v then m |> fail  else succeed () \n            \n    let ifError   def (XResult(o, _ )) = o |> Option.defaultValue            def\n    let withError f   (XResult(o, ms)) = o |> Option.defaultWith  (fun () -> f ms)\n\n//    let processMessages mtype (msgs: PossibleMessages list) =\n//        msgs\n//        |> List.iter (fun o -> WebSharper.JavaScript.JS.Alert     <| mtype + \": \" + (sprintf \"%A\" o)\n//                               WebSharper.JavaScript.Console.Log o)\n//\n//    let notifyMessages R =\n//        match R with | Success (_, m) -> processMessages \"N\" m\n//                     | Failure     m  -> processMessages \"E\" m\n//\n//    let messagesDo f =\n//        function | Success (_, ms) -> f false ms\n//                 | Failure     ms  -> f true  ms\n\n    let seqCheck s = \n        s \n        |> (fun elems -> match      elems |> Seq.exists(function | Failure _    -> true    | _ -> false) with\n                         | true  -> elems |> Seq.pick  (function | Failure ms   -> Some ms | _ -> None ) |> failWithMsgs\n                         | false -> elems |> Seq.map   (function | XResult(vO,_)-> vO.Value            ) |> succeed\n        )\n\n    let msgs2String   (ms: Message<_> []) = ms |> Array.map (sprintf \"%O\")\n    let getMessages      (XResult(_, ms)) = ms |> msgs2String |> String.concat \"\\n\"\n//    let countMessages (ms: ErrMsg []) =\n//        if ms = [||] then \"\" else\n//        let errors   = ms |> Array.filter(fun m -> m.IsWarning |> not)\n//        let warnings = ms |> Array.filter(fun m -> m.IsWarning       )\n//        match errors.Length, warnings.Length with\n//        | 0, 0 -> sprintf \"%s\"\n//        | 1, 0 -> sprintf \"%s\"\n//        | 0, 1 -> sprintf \"%s\"\n//        | 1, 1 -> sprintf \"1 error, 1 warning\\n%s\"\n//        | e, 0 -> sprintf \"%d errors\\n%s\" e\n//        | 0, w -> sprintf \"%d warnings\\n%s\" w\n//        | e, w -> sprintf \"%d errors, %d warnings\\n%s\" e w\n//        <| getMessages ms\n\n    let result2String (XResult(vO, ms)) =\n        Array.append [| vO |> Option.defaultValue \"Failed: \" |] (Array.map (sprintf \"%A\") ms)\n        |> String.concat \"\\n\"\n\n[< AutoOpen >]\nmodule XResultAutoOpen =\n    let xresult = XResult.xresult\n","parent":{"$":0,"Item":"46b53936-0e96-4e86-a196-9b76399a1d68"},"predecessors":[{"$":0,"Item":"a7f4f5f0-13eb-40fd-afd9-c4521f505e2d"}],"id":{"$":0,"Item":"c7c27124-cfb8-4516-89ce-fb351d991fdb"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"XAsync","content":"\ntype XAsync< 'T, 'M> = XAsync of Async<XResult< 'T, 'M>>\n\nmodule XAsync =\n    open XResult\n    \n    let inline Return v = succeed v |> Async.Return |> XAsync\n                                                                                    /// map with no try protection\n    let inline map0 f  (XAsync vRA ) = Async.map (XResult.map0 f) vRA |> XAsync\n                                                                                    /// map with try protection in case of exceptions\n    let inline map  f  (XAsync vRA ) = Async.map (XResult.map  f) vRA |> XAsync\n    let inline join    (XAsync vXRA) =\n        async {\n            let!  vXR = vXRA\n            match vXR with\n            | XResult(None            , ms) -> return XResult.failWithMsgs ms\n            | XResult(Some(XAsync vXA), ms) -> let!   vX = vXA\n                                               return vX                 |> XResult.mergeMsgs ms\n        } |> XAsync\n                                                                                    /// bind with no try protection \n    let inline bind0  f  vX = vX |> map0 f |> join\n                                                                                    /// bind with try protection in case of exceptions\n    let inline bind   f  vX = vX |> map  f |> join\n                                                                                    /// apply with no try protection\n    let inline apply0 fX vX = fX |> bind0 (swap map0 vX)\n                                                                                    /// apply with try protection in case of exceptions\n    let inline applyx fX vX = fX |> bind  (swap map  vX)\n\n                                                                                    /// apply with try protection in case of exceptions\n    let inline apply (XAsync fRA) (XAsync vRA) = \n        async {\n            let! fChild = Async.StartChild fRA\n            let! vChild = Async.StartChild vRA\n            let! fR     = fChild\n            let! vR     = vChild \n            return XResult.apply fR vR \n        } |> XAsync\n\n    let rec whileLoop guard body =\n        if guard() then body() |> bind0 (fun () -> whileLoop guard body)\n        else Return   ()\n\n//    let inline getAsyncR (wb: Wrap<'T>) =\n//        match wb with\n//        | WAsync      va  -> async {\n//                               let! v = va\n//                               return      succeed                           v}\n//        | WSome       v   -> async.Return (succeed                           v)\n//        | WNone           -> async.Return (Result.fail       errOptionIsNone  )\n//        | WResult     v   -> async.Return                                    v\n//        | WAsyncR     vra -> vra\n//        \n//        \n    let toAsyncResult (XAsync vRA) = vRA\n    let inline toAsyncWithDefault f x = toAsyncResult x |> Async.map (XResult.withError f)\n//    let inline getAsync              w = \n//\n    let toAsync            x = toAsyncWithDefault (fun ms -> ms |> Seq.map (sprintf \"%A\") |> String.concat \"\\n\" |> exn |> raise) x\n//    let toAsyncOption      w = getAsyncR w |> Async.map Result.toOption\n//    let toAsyncOptionMs    w = getAsyncR w |> Async.map Result.toOptionMs\n//    let toAsyncWithDefault w = getAsyncWithDefault w\n//\n////    let call wb = wb |> getR Rop.notifyMessages\n//    let startV (processVal: ('t option * string) ->unit) (w: Wrap<'t>) =\n//        w\n//        |> getAsyncR\n//        |> fun asy -> Async.StartWithContinuations\n//                        (asy \n//                       , Result.mapMsgs Result.getMessages  >> processVal\n//                       , sprintf \"%O\" >> (fun m -> None, m) >> processVal\n//                       , sprintf \"%O\" >> (fun m -> None, m) >> processVal)\n//                       \n//    let start (printMsg: string->unit) (w: Wrap<unit>) = \n//        startV (function\n//                | Some (), msgs ->               msgs |> printMsg \n//                | None   , msgs -> \"Failed!\\n\" + msgs |> printMsg) w\n//\n//    let wrapper2Async (f: 'a -> Wrap<'b>) a : Async<Result<'b>> =\n//        let wb = tryCall f a\n//        match wb with\n//        | WNone                   \n//        | WSome   _               -> wb |> wb2arb [||]\n//        | WResult (Result(_, ms)) -> wb |> wb2arb ms\n//        | WAsync  ab              -> async { let!   b = ab\n//                                             return succeed b }\n//        | WAsyncR arb             -> arb\n//\n//    let addMsgs errOptionIsNone ms wb =\n//        if ms = [||] then wb else\n//        match wb with\n//        | WSome            v       -> WResult (succeedWithMsgs                        v ms)\n//        | WNone                    -> WResult (fail errOptionIsNone |> Result.mergeMsgs ms)\n//        | WResult r                -> WResult (r                    |> Result.mergeMsgs ms)\n//        | WAsync           va      -> async {\n//                                        let! v = va\n//                                        return succeedWithMsgs v ms\n//                                      } |> WAsyncR\n//        | WAsyncR          vra     -> async {\n//                                        let! vr = vra\n//                                        return vr                    |> Result.mergeMsgs ms\n//                                      } |> WAsyncR\n//\n    let inline combine (XAsync vRA ) (wX: unit -> XAsync<_, _>) =\n        async { \n            let!  vR = vRA\n            match vR with\n            | Failure    ms -> return failWithMsgs ms\n            | Success(_, ms)-> let!   wR = wX() |> toAsyncResult\n                               return wR        |> mergeMsgs ms\n        } |> XAsync\n        \n    type Builder() =\n        member inline this.Bind (wrapped: XAsync< 'v, 'M> , restOfCExpr: 'v -> XAsync<'w, 'M>) = wrapped                                |> bind restOfCExpr \n        member inline this.Bind (wrapped: Async<  'v    > , restOfCExpr: 'v -> XAsync<'w, 'M>) = wrapped |> Async.map succeed |> XAsync |> bind restOfCExpr  \n        member inline this.Bind (wrapped: XResult<'v, 'M> , restOfCExpr: 'v -> XAsync<'w, 'M>) = wrapped |> Async.Return      |> XAsync |> bind restOfCExpr \n        member inline this.Zero         ( ) = Return   ()\n        member inline this.Return       (x) = Return   x\n        member inline this.ReturnFrom   (w) = w\n        member inline this.Delay        (f) = f\n        member inline this.Run(f) = f()\n        member inline this.Combine   (a, b) = combine a b\n        member inline this.While(guard, body) = \n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else Return   ()\n            whileLoop guard body\n        member inline this.TryWith(body, handler) =\n            async {\n                let! r = body() |> toAsyncResult |> Async.Catch \n                return\n                    match r with\n                    | Choice1Of2 v -> v\n                    | Choice2Of2 e -> handler e\n            } |> XAsync\n        member inline this.TryFinally(body, compensation) =\n            async {\n                let! r1 = body() |> toAsyncResult |> Async.Catch \n                let _r2 = compensation()     \n                return\n                    match r1 with\n                    | Choice1Of2 v -> v\n                    | Choice2Of2 e -> raise e\n            } |> XAsync\n        member inline this.Using(disposable:#System.IDisposable, body) =\n            let body' = fun () -> body disposable\n            this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n        member inline this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))            \n\n    let xasync = Builder()\n    \n//\n//    let getResult callback (wb: Wrap<'T>) =\n//        match wb with\n//        | WSome        s  -> s               |> succeed                                              |> callback\n//        | WNone           -> errOptionIsNone |> fail                                                 |> callback\n//        | WResult      rb -> rb                                                                      |> callback\n//        | WAsync       ab -> Async.StartWithContinuations(ab , (fun v   -> succeed v                 |> callback), \n//                                                               (fun exc -> failException exc |> fail |> callback), \n//                                                                fun can -> failException can |> fail |> callback)\n//        | WAsyncR     arb -> Async.StartWithContinuations(arb,                                          callback , \n//                                                               (fun exc -> failException exc |> fail |> callback), \n//                                                                fun can -> failException can |> fail |> callback)\n//\n//\n#if WEBSHARPER\n    [< Inline \"console.log('runSynchronously should not be used in Javascript')\" >]                       \n#endif\n    let runSynchronouslyR x =\n        x\n        |> toAsyncResult\n        |> Async.RunSynchronously\n#if WEBSHARPER\n    [< Inline \"console.log('runSynchronously should not be used in Javascript')\" >]                       \n#endif\n    let runSynchronously x =\n        x\n        |> toAsync\n        |> Async.RunSynchronously\n//    let runSynchronouslyO count (w: Wrap<_>) =\n//        w\n//        |> runSynchronouslyR\n//        |> (Result.mapMsgs (if count then Result.countMessages else Result.getMessages))\n//    let runSynchronouslyS count (w: Wrap<_>) =\n//        w\n//        |> runSynchronouslyO count\n//        |> function\n//           | Some r, msgs -> sprintf \"%O\\n%s\" r    msgs\n//           | None  , msgs -> sprintf \"Failed!\\n%s\" msgs\n//           \ntype XAsync<'T, 'M> with\n    static member Start           (w:XAsync<_,_>,           ?cancToken) = Async.Start           (XAsync.toAsync       w,                                ?cancellationToken= cancToken)\n    static member StartAsTask     (w:XAsync<_,_>, ?options, ?cancToken) = Async.StartAsTask     (XAsync.toAsync       w, ?taskCreationOptions= options, ?cancellationToken= cancToken)\n    static member StartAsTaskR    (w:XAsync<_,_>, ?options, ?cancToken) = Async.StartAsTask     (XAsync.toAsyncResult w, ?taskCreationOptions= options, ?cancellationToken= cancToken)\n#if WEBSHARPER\n    [< Inline \"console.log('RunSynchronouslyR should not be used in Javascript')\" >]                       \n#endif\n    static member RunSynchronouslyR(w:XAsync<_,_>, ?timeout, ?cancToken) = Async.RunSynchronously(XAsync.toAsyncResult w, ?timeout            = timeout, ?cancellationToken= cancToken)\n#if WEBSHARPER\n    [< Inline \"console.log('RunSynchronously should not be used in Javascript')\" >]                       \n#endif\n    static member RunSynchronously( w:XAsync<_,_>, ?timeout, ?cancToken) = Async.RunSynchronously(XAsync.toAsync  w, ?timeout            = timeout, ?cancellationToken= cancToken)\n//\n\n[< AutoOpen >]\nmodule XAsyncAutoOpen =\n    let xasync = XAsync.xasync\n","parent":{"$":0,"Item":"46b53936-0e96-4e86-a196-9b76399a1d68"},"predecessors":[{"$":0,"Item":"414d2960-2447-4fef-9c37-b1b7098d8355"},{"$":0,"Item":"c7c27124-cfb8-4516-89ce-fb351d991fdb"}],"id":{"$":0,"Item":"e8de7075-496c-4b12-a801-91db57db3fa4"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"List traverse & sequence","content":"module List =\n    let cons head tail = head :: tail\n\n    module XAsync =\n        /// Map an AsyncResult producing function over a list to get a new AsyncResult\n        /// using monadic style\n        /// ('a -> XAsync<'b>) -> 'a list -> XAsync<'b list>\n        let rec traverseM f list =\n            let (>>=) v f = XAsync.bind f v\n            let retn      = XAsync.Return  \n            let initState = retn []\n            let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n            List.foldBack folder list initState \n        /// Transform a \"list<XAsync>\" into a \"XAsync<list>\"\n        /// and collect the results using bind.\n        let inline sequenceM x = traverseM id x\n        \n        /// Map an AsyncResult producing function over a list to get a new AsyncResult\n        /// using applicative style\n        /// ('a -> XAsync<'b>) -> 'a list -> XAsync<'b list>\n        let rec traverseA f list =\n            let (<*>)     = XAsync.apply\n            let retn      = XAsync.Return  \n            let initState = retn []\n            let folder head tail = retn cons <*> f head <*> tail\n            List.foldBack folder list initState \n        /// Transform a \"list<XAsync>\" into a \"XAsync<list>\"\n        /// and collect the results using bind.\n        let inline sequenceA x = traverseA id x\n    \n    module XResult =\n        /// Map an AsyncResult producing function over a list to get a new AsyncResult\n        /// using monadic style\n        /// ('a -> XResult<'b>) -> 'a list -> XResult<'b list>\n        let rec traverseM f list =\n            let (>>=) v f = XResult.bind f v\n            let retn      = XResult.Return  \n            let initState = retn []\n            let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n            List.foldBack folder list initState \n        /// Transform a \"list<XResult>\" into a \"XResult<list>\"\n        /// and collect the results using bind.\n        let inline sequenceM x = traverseM id x\n    \n        /// Map a Result producing function over a list to get a new Result \n        /// using applicative style\n        /// ('a -> Result<'b>) -> 'a list -> Result<'b list>\n        let rec traverseA f list =\n            let (<*>)     = XResult.apply\n            let retn      = XResult.Return\n            let initState = retn []\n            let folder head tail = retn cons <*> f head <*> tail\n            List.foldBack folder list initState\n        /// Transform a \"list<Result>\" into a \"Result<list>\" \n        /// and collect the results using apply.\n        let inline sequenceA x = traverseA id x\n    \n    module Async =\n        /// Map an AsyncResult producing function over a list to get a new AsyncResult\n        /// using monadic style\n        /// ('a -> Async<'b>) -> 'a list -> Async<'b list>\n        let rec traverseM f list =\n            let (>>=) v f = Async.bind f v\n            let retn      = Async.Return  \n            let initState = retn []\n            let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n            List.foldBack folder list initState \n        /// Transform a \"list<Async>\" into a \"Async<list>\"\n        /// and collect the results using bind.\n        let inline sequenceM x = traverseM id x\n    \n        /// Map an AsyncResult producing function over a list to get a new AsyncResult\n        /// using applicative style\n        /// ('a -> Async<'b>) -> 'a list -> XAsync<'b list>\n        let rec traverseA f list =\n            let (<*>)     = Async.apply\n            let retn      = Async.Return  \n            let initState = retn []\n            let folder head tail = retn cons <*> f head <*> tail\n            List.foldBack folder list initState \n        /// Transform a \"list<Async>\" into a \"Async<list>\"\n        /// and collect the results using bind.\n        let inline sequenceA x = traverseA id x\n    \n    ","parent":{"$":0,"Item":"46b53936-0e96-4e86-a196-9b76399a1d68"},"predecessors":[{"$":0,"Item":"e8de7075-496c-4b12-a801-91db57db3fa4"}],"id":{"$":0,"Item":"4ec1bd8a-6593-4b48-92c7-c68f5fe601f8"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"dprintfn, oprintfn, printoutfn","content":"let dprintfn       fmt = fmt |> Printf.ksprintf ignore //(fun s -> printfn \"%s\"  s)\nlet printoutfn out fmt = fmt |> Printf.ksprintf (fun s -> s + \"\\n\" |> out)\n//let printoutf  out fmt = Printf.kprintf                        out  fmt\nlet print    v = printfn \"%A\" v\nlet mapPrint v = print        v; v\n","parent":{"$":0,"Item":"46b53936-0e96-4e86-a196-9b76399a1d68"},"predecessors":[],"id":{"$":0,"Item":"a1c1eae6-9927-45aa-868e-93ac25ec764a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"update Monad","content":"\ntype UpdateMonad<'TState, 'TUpdate, 'T> = UM of ('TState -> 'TUpdate * 'T)\n\nmodule UpdateM =\n    /// Represents an update monad - given a state, produce \n    /// value and an update that can be applied to the state\n    \n    let inline unit<    ^U when ^U:(static member Unit   : unit    -> ^U )> ()  = \n                               (^U:(static member Unit   : unit    -> ^U )  ()  ) \n    let inline combine< ^U when ^U:(static member Combine: ^U * ^U -> ^U )> a  b = \n                               (^U:(static member Combine: ^U * ^U -> ^U ) (a, b)) \n    let inline apply<'S,^U when ^U:(static member Apply  : 'S * ^U -> 'S )> s  a = \n                               (^U:(static member Apply  : ^S * ^U -> ^S ) (s, a)) \n\n    let inline (++) a b = combine a b\n\n    let inline rtn v = UM (fun _ -> (unit(),v))\n    let inline bind f (UM u1f) =  \n        UM (fun s -> \n          let (u1, x ) = u1f s\n          let (UM u2f) = f   x\n          let (u2, y ) = u2f (apply s u1)\n          (u1 ++ u2, y))\n\n    let inline map f m = bind (f >> rtn) m\n\n    type UpdateBuilder() = \n      member inline x.Return(v) : UpdateMonad<'S, 'U, 'T> = rtn v\n      member inline x.Bind(u, f) = bind f u\n      member inline x.Zero() = x.Return(())    \n      member inline x.Delay(f) = x.Bind(x.Zero(), f)\n      member inline x.Combine(c1, c2) = x.Bind(c1, fun () -> c2)\n      member inline x.ReturnFrom(m : UpdateMonad<'S, 'P, 'T>) = m\n      member inline x.Using(r,f) = UM(fun s -> use rr = r in let (UM g) = f rr in g s)\n      member inline x.For(sq:seq<'V>, f:'V -> UpdateMonad<'S, 'P, unit>) = \n        let rec loop (en:System.Collections.Generic.IEnumerator<_>) = \n          if en.MoveNext() then x.Bind(f en.Current, fun _ -> loop en)\n          else x.Zero()\n        x.Using(sq.GetEnumerator(), loop)\n      member inline x.While(t, f:unit -> UpdateMonad<'S, 'P, unit>) =\n        let rec loop () = if t() then x.Bind(f(), loop)\n                                 else x.Zero()\n        loop()\n\n    type ReaderUpdate = \n      | NoUpdate\n      static member inline Unit()                      = NoUpdate\n      static member inline Combine(NoUpdate, NoUpdate) = NoUpdate\n      static member inline Apply(s, NoUpdate)          = s\n\n    let inline read()           = UM (fun s -> NoUpdate, s)\n    let inline readRun s (UM f) = f s |> snd\n\n    /// Updates of writer monad form a list\n    type WriterUpdate< ^TLog> = \n      | Log of list< ^TLog>\n      static member inline Unit()                = Log []\n      static member inline Combine(Log a, Log b) = Log(List.append a b)    /// Combines two logs (operation of the monoid)\n      static member inline Apply((), _)          = ()                      /// Applying updates to state does not affect the state\n    \n    let inline write  v = UM (fun s -> (Log [v], ()))                      /// Writes the specified value to the log \n    let inline writeRun (UM f) = match f () with (Log l, v) -> l, v\n\n    /// Wraps a state of type 'T\n    type StateState<'T> = State of 'T\n    \n    /// Represents updates on state of type 'T\n    type StateUpdate<'T> = \n      | SetNop\n      | Set of 'T \n      static member inline Unit()        = SetNop\n      static member inline Combine(a, b) = match b with | Set _ -> b       | _ -> a\n      static member inline Apply  (c, p) = match p with | Set n -> State n | _ -> c \n\n    let inline set    s        = UM (fun _         -> (Set s ,()) )\n    let inline get   ()        = UM (fun (State s) -> (SetNop, s) )\n    let inline setRun s (UM f) = f (State s) |> snd      \n\n    type ReaderWriterUpdate< ^TLog> = \n      | Log of list< ^TLog>\n      static member inline Unit   ()             = Log []\n      static member inline Combine(Log a, Log b) = Log(List.append a b)\n      static member inline Apply  (s, Log _)     = s\n\n    let inline readRW       ()       = UM (fun s -> Log [ ], s)\n    let inline writeRW      v        = UM (fun s -> Log [v], s)\n    let inline readWriteRun s (UM f) = match f s with (Log l, v) -> l, v\n\n[< AutoOpen >]\nmodule UpdateMBuilder =\n    /// Instance of the computation builder\n    /// that defines the update { .. } block\n    let update = UpdateM.UpdateBuilder()      \n          \n          ","parent":{"$":0,"Item":"46b53936-0e96-4e86-a196-9b76399a1d68"},"predecessors":[],"id":{"$":0,"Item":"cbde8669-d188-4274-b4ef-129dd359c6be"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"imperative","content":"type ImperativeResult<'T> = \n  | ImpValue of 'T\n  | ImpJump  of int * bool\n  | ImpNone \n  \ntype Imperative<'T> = unit -> ImperativeResult<'T>\n\ntype ImperativeBuilder() = \n  member x.Return (v)     :  Imperative<_>                 = (fun () -> ImpValue v)\n  member x.Zero   ()                                       = (fun () -> ImpNone   )\n  member x.Delay  (f:unit -> Imperative<_>)                = (fun () -> f()()     )\n  member x.Combine(a, b)                                   = (fun () -> match a() with \n                                                                        | ImpNone -> b()\n                                                                        | res     -> res\n                                                              )\n  member x.CombineLoop(a, b)                               = (fun () -> match a() with \n                                                                        | ImpValue v         -> ImpValue v\n                                                                        | ImpJump( 0, false) -> ImpNone\n                                                                        | ImpJump( 0, true )\n                                                                        | ImpNone            -> b() \n                                                                        | ImpJump(depth, b)  -> ImpJump(depth - 1, b)\n                                                             )\n  member x.Run    (imp)                                    = match imp() with \n                                                             | ImpValue v                       -> v\n                                                             | ImpJump  _                       -> failwith \"invalid use of break/continue outside a loop!\"\n                                                             | _ when typeof<'T> = typeof<unit> -> Unchecked.defaultof<'T>\n                                                             | ImpNone                          -> failwith \"nothing returned!\"\n  member x.For    (inp:seq<_>, f)                          = let rec loop(en:System.Collections.Generic.IEnumerator<_>) = \n                                                               if not(en.MoveNext()) then x.Zero() else\n                                                                 x.CombineLoop(f(en.Current), x.Delay(fun () -> loop(en)))\n                                                             loop(inp.GetEnumerator())\n  member x.While  (gd, body)                               = let rec loop() =\n                                                               if not(gd()) then x.Zero() else\n                                                                 x.CombineLoop(body, x.Delay(fun () -> loop()))\n                                                             loop()\n  member x.Bind(v:Imperative<unit>, f:unit->Imperative<_>) = (fun () -> match v() with\n                                                                        | ImpJump(depth, kind) -> ImpJump(depth, kind)\n                                                                        | _ -> f()() \n                                                             )\nlet imperative  = new ImperativeBuilder()\nlet break'      = (fun () -> ImpJump(0, false))\nlet continue'   = (fun () -> ImpJump(0, true ))\nlet breakn    n = (fun () -> ImpJump(n, false))\nlet continuen n = (fun () -> ImpJump(n, true ))","parent":{"$":0,"Item":"46b53936-0e96-4e86-a196-9b76399a1d68"},"predecessors":[],"id":{"$":0,"Item":"86c4e893-d144-41b0-bd3e-4934423ff808"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"treeZiper","content":"","parent":{"$":0,"Item":"46b53936-0e96-4e86-a196-9b76399a1d68"},"predecessors":[],"id":{"$":0,"Item":"895519c3-573d-4f22-a320-192c99fd8105"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"unindent, unindentStr, indent","content":"let unindent (s:string) =\n    let lines = s.Split '\\n'\n    let n     = lines.[1] |> Seq.tryFindIndex ((<>) ' ') |> Option.defaultValue 0\n    lines \n    |> Seq.map (fun l -> l.Substring n)\n    |> Seq.filter (fun s -> s.StartsWith \"# 1 \" |> not)\n\nlet unindentStr = unindent >> String.concat \"\\n\"\n\nlet indent n (s:string) =\n    s.Split '\\n'\n    |> Seq.map ((+) (String.replicate n \" \"))","parent":{"$":0,"Item":"46b53936-0e96-4e86-a196-9b76399a1d68"},"predecessors":[],"id":{"$":0,"Item":"6674933a-4097-4b6c-83ea-074828955729"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Tests","content":"#r @\"..\\packages\\Unquote\\lib\\net45\\Unquote.dll\"\nmodule Tests =","parent":{"$":0,"Item":"e83d0347-89ba-4fbf-8bd0-02723299e948"},"predecessors":[],"id":{"$":0,"Item":"9ca8f090-0191-4e47-96ee-a3b4785c45e2"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableFSI":"1"}},{"name":"TapRunner","content":"#r @\"..\\packages\\NUnit\\lib\\nunit.framework.dll\"\n/// Test Anything Protocol (TAP) NUnit runner by Phillip Trelford\nmodule Tap =\n\n    open System\n    open System.Collections\n    open System.Reflection\n    open NUnit.Framework\n    \n    type Args = obj[]\n    type ExpectedResult = obj option\n    type ExpectedException = Type option\n    type Timeout = int option\n    type Test = Test of MethodInfo * Args * ExpectedResult * ExpectedException * Timeout\n    \n    let internal getCustomAttribute<'TAttribute when 'TAttribute :> Attribute> (mi:MethodInfo) = \n       mi.GetCustomAttribute(typeof<'TAttribute>, true) :?> 'TAttribute\n    \n    module internal SourceData =\n    \n       let (|SourceProperty|_|) (name,t:Type) =\n          let pi = t.GetProperty(name)\n          if pi <> null then Some(pi.GetGetMethod()) else None\n    \n       let (|SourceMethod|_|) (name,t:Type) =\n          let mi = t.GetMethod(name)\n          if mi <> null then Some(mi) else None\n    \n       let getSourceData (instance:obj, instanceType) (sourceName,sourceType:Type) =\n          match (sourceName,sourceType) with\n          | SourceProperty mi | SourceMethod mi->\n             let instance = \n                if instanceType <> sourceType \n                then Activator.CreateInstance(sourceType) \n                else instance\n             let result = mi.Invoke(instance, [||]) \n             result :?> IEnumerable\n          | _ -> invalidOp \"Expecting property or method\"\n    \n    module internal ParameterData =\n    \n       open SourceData\n    \n       module internal List =\n          let rec combinations = function\n          | [] -> [[]]\n          | hs :: tss ->\n             [for h in hs do\n                for ts in combinations tss ->\n                   h :: ts]\n    \n       let tryGetCustomAttribute<'TAttribute when 'TAttribute :> Attribute> (pi:ParameterInfo) =\n          match pi.GetCustomAttribute(typeof<'TAttribute>, true) with\n          | :? 'TAttribute as attr -> Some attr\n          | _ -> None\n    \n       let (|Random|_|) = tryGetCustomAttribute<RandomAttribute>\n       let (|Range|_|) = tryGetCustomAttribute<RangeAttribute>\n       let (|Values|_|) = tryGetCustomAttribute<ValuesAttribute>\n       let (|ValueSource|_|) = tryGetCustomAttribute<ValueSourceAttribute>\n    \n       let getParameterData instance (pi:ParameterInfo) =\n          match pi with\n          | Random rand -> [for x in rand.GetData(pi) -> x]\n          | Range range -> [for x in range.GetData(pi) -> x]\n          | Values values -> [for x in values.GetData(pi) -> x]\n          | ValueSource source ->\n             let data = getSourceData instance (source.SourceName, source.SourceType)\n             [for x in data -> x]\n          | _ -> invalidOp \"Expecting values\"\n    \n    module internal TestGeneration =\n    \n       open SourceData\n       open ParameterData\n    \n       let (|Ignore|_|) (mi:MethodInfo) =\n          if getCustomAttribute<IgnoreAttribute>(mi) <> null then Some() else None\n    \n       let (|TestCases|_|) (mi:MethodInfo) =\n          let cases = mi.GetCustomAttributes(typeof<TestCaseAttribute>, true)\n          if cases.Length > 0 then Some(cases |> Seq.cast<TestCaseAttribute>)\n          else None\n    \n       let (|TestCaseSource|_|) (mi:MethodInfo) =\n          let source = getCustomAttribute<TestCaseSourceAttribute>(mi)\n          if source <> null then\n             let sourceType = \n                if source.SourceType <> null then source.SourceType else mi.DeclaringType\n             Some(source.SourceName, sourceType)\n          else None\n    \n       let (|VanillaTest|_|) (mi:MethodInfo) =\n          if getCustomAttribute<TestAttribute>(mi) <> null then Some() else None\n    \n       let tryGetExpectedException (mi:MethodInfo) =\n          let attr = getCustomAttribute<ExpectedExceptionAttribute>(mi)\n          if attr <> null then Some attr.ExpectedException else None\n    \n       let (|Timeout|_|) (mi:MethodInfo) =\n          let attr = getCustomAttribute<TimeoutAttribute>(mi)\n          if attr <> null then Some (attr.Properties.[\"Timeout\"] :?> int) else None\n    \n       let (|MaxTime|_|) (mi:MethodInfo) =\n          let attr = getCustomAttribute<MaxTimeAttribute>(mi)\n          if attr <> null then Some (attr.Properties.[\"MaxTime\"] :?> int) else None\n    \n       let tryGetTimeout = function Timeout ms | MaxTime ms -> Some ms | _ -> None\n      \n       let fromCases (mi:MethodInfo) (cases:TestCaseAttribute seq) =\n          let ex = tryGetExpectedException(mi)\n          let timeout = tryGetTimeout mi\n          [|for case in cases ->\n             let expected = if case.HasExpectedResult then Some case.ExpectedResult else None\n             let ex = if case.ExpectedException <> null then Some(case.ExpectedException) else ex\n             Test(mi, case.Arguments, expected, ex, timeout)\n          |]\n    \n       let fromData instance (mi:MethodInfo) (data:IEnumerable) =\n          let ex = tryGetExpectedException mi\n          let timeout = tryGetTimeout mi\n          [|for item in data ->\n             match item with\n             | :? TestCaseData as case ->\n                let expected = if case.HasExpectedResult then Some(case.Result) else None\n                let ex = if case.ExpectedException <> null then Some(case.ExpectedException) else ex\n                Test(mi, case.Arguments, expected, ex, timeout) \n             | :? (obj[]) as args -> Test(mi, args, None, ex, timeout)\n             | arg -> Test(mi, [|arg|], None, ex, timeout)\n          |]\n    \n       let fromValues instance (mi:MethodInfo) =\n          let ex = tryGetExpectedException mi\n          let timeout = tryGetTimeout mi\n          [| let ps = mi.GetParameters()\n             let argValues = [for pi in ps -> getParameterData instance pi]\n             match List.combinations argValues with\n             | [] -> yield Test(mi, [||], None, ex, timeout)\n             | xs -> yield! [for args in xs -> Test(mi, List.toArray args, None, ex, timeout)]\n          |]\n    \n       let generateTests instance (mi:MethodInfo) =\n          let instance = instance, mi.DeclaringType\n          match mi with\n          | Ignore -> [||]\n          | TestCases cases -> fromCases mi cases\n          | TestCaseSource source -> getSourceData instance source |> fromData instance mi\n          | VanillaTest -> fromValues instance mi\n          | _ -> [||]\n    \n    module internal TestRunner =\n    \n       let runTest instance (Test(mi,args,expected,exType,timeout)) = \n          try\n             let actual = \n                match timeout with\n                | Some ms -> Async.RunSynchronously(async { return mi.Invoke(instance,args) }, ms)\n                | None -> mi.Invoke(instance,args)\n             match expected with\n             | Some expected -> Assert.AreEqual(expected, actual)\n             | None -> ()\n             None\n          with ex ->        \n            match ex.InnerException with\n            | :? SuccessException -> None\n            | ex ->\n                match exType with         \n                | Some t when t = ex.GetType() -> None\n                | _ -> Some ex\n    \n       let color c =\n          let previous = Console.ForegroundColor\n          Console.ForegroundColor <- c\n          { new System.IDisposable with \n             member __.Dispose() = Console.ForegroundColor <- previous\n          }\n    \n       let showResult number (Test(mi,args,_,_,_)) error =\n          let name =\n             mi.Name + \n                if args.Length > 0 then \"(\" + String.Join(\",\", args) + \")\"\n                else \"\"\n          match error with\n          | None ->\n             using (color ConsoleColor.Green) <| fun _ ->\n                printfn \"ok %d - %s\" number name\n          | Some e ->\n             using (color ConsoleColor.Red) <| fun _ ->\n                printfn \"not ok %d - %s\" number name\n                printfn \"  %A\" e\n    \n       let runTests instance (setUp,tearDown) (tests:Test[]) =\n          printfn \"1..%d\" tests.Length\n          tests |> Array.iteri (fun i test ->\n             let result =\n                try setUp (); runTest instance test\n                finally tearDown ()\n             result |> showResult (i+1) test \n          )\n    \n    let Run (testType:Type) =\n       let constr = testType.GetConstructor([||])\n       let instance = if constr <> null then constr.Invoke([||]) else null\n       let methods = testType.GetMethods()\n       let tests = [|for mi in methods do yield! TestGeneration.generateTests instance mi|]\n      \n       let methodsWithAttribute attr =\n          methods |> Array.filter (fun mi -> mi.GetCustomAttribute(attr, true) <> null)\n    \n       let runMethods (methods:MethodInfo[]) = \n          methods |> Array.iter (fun mi -> mi.Invoke(instance,[||]) |> ignore)\n    \n       let setUps = methodsWithAttribute typeof<SetUpAttribute>\n       let tearDowns = methodsWithAttribute typeof<SetUpAttribute>\n       let setUp () = setUps |> runMethods\n       let tearDown () = tearDowns |> runMethods\n    \n       methodsWithAttribute typeof<TestFixtureSetUpAttribute> |> runMethods\n       TestRunner.runTests instance (setUp, tearDown) tests\n       methodsWithAttribute typeof<TestFixtureTearDownAttribute> |> runMethods","parent":{"$":0,"Item":"9ca8f090-0191-4e47-96ee-a3b4785c45e2"},"predecessors":[],"id":{"$":0,"Item":"2795dea6-7cd5-43f6-b530-fe56935a3964"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"code for Testing","content":"open NUnit.Framework\nopen Swensen.Unquote\n\n\nlet stdout = System.Text.StringBuilder()\nlet out (s:string) = stdout.Append s |> ignore\nlet runStdOutCall func parm =\n    stdout.Clear() |> ignore\n    func parm, stdout.ToString()\n\nlet runStdOut f =\n    runStdOutCall f ()\n    |> snd\n    \ntype Marker = interface end    \n\n","parent":{"$":0,"Item":"9ca8f090-0191-4e47-96ee-a3b4785c45e2"},"predecessors":[{"$":0,"Item":"73ddcc57-6d46-4f49-b4f3-e397aa3d3963"},{"$":0,"Item":"2795dea6-7cd5-43f6-b530-fe56935a3964"}],"id":{"$":0,"Item":"ee67a428-8d29-4f66-96f0-e0d94d85698b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"XResult","content":"open Useful\n\nlet asyncIf () =\n    async {\n        let a = 1\n        if a = 1 then\n            let r = 3\n            ()\n        ()\n    }\n\nlet resultIf () =\n    xresult {\n        let a = 1\n        if a = 1 then\n            let r = 3\n            ()\n        ()\n    }\n\nlet hello i =\n    printoutfn out \"before \"\n    async {\n        printoutfn out \"wrap \"\n        let! h =  async { printoutfn out \"Hello1 %d\" i } \n        return i + 1\n    }\n    \nlet whileR() = \n    let mutable i = 0\n    xresult {\n        let! a = XResult.succeed 2\n        while (printoutfn out \"<%d>\" i ; i <= a) do\n            printoutfn out \"%d: \" i\n            let! z = hello i |> Async.RunSynchronously |> XResult.succeed\n            i <- z\n            printoutfn out \" z = %d\" z\n    } |> ignore\n\n\n    \nlet helloA i =\n    printoutfn out \"before \"\n    async {\n        printoutfn out \"async \"\n        do! async { printoutfn out \"HelloA %d\" i }\n        return i + 1\n    }\n\nlet whileA() = \n    let mutable i = 0\n    async {\n        let! a = async { return 2 }\n        while (printoutfn out \"<%d>\" i ; i <= a) do\n            printoutfn out \"%d: \" i\n            let! z = hello i \n            i <- z\n            printoutfn out \" z = %d\" z\n        ()\n    } |> Async.RunSynchronously\n\nlet forR() = \n    xresult {\n        let! a = XResult.succeed 2\n        for i = 0 to a do\n            printoutfn out \"%d: \" i\n            let! z = hello i |> Async.RunSynchronously |> XResult.succeed\n            printoutfn out \" z = %d\" z\n    } |> ignore\n    \nlet forA() = \n    async {\n        let! a = async { return 2 }\n        for i = 0 to a do\n            printoutfn out \"%d: \" i\n            let! z = hello i \n            printoutfn out \" z = %d\" z\n        ()\n    } |> Async.RunSynchronously\n\nlet [<Test>] ``whileA  must be diffrt. than \"\"`` () = runStdOut whileA  <>! \"\"     \nlet [<Test>] ``whileR  must be equal to whileA`` () = runStdOut whileR   =! runStdOut whileA     \nlet [<Test>] ``forR    must be equal to forA``   () = runStdOut forR     =! runStdOut forA     \n   ","parent":{"$":0,"Item":"9ca8f090-0191-4e47-96ee-a3b4785c45e2"},"predecessors":[{"$":0,"Item":"ee67a428-8d29-4f66-96f0-e0d94d85698b"},{"$":0,"Item":"a1c1eae6-9927-45aa-868e-93ac25ec764a"},{"$":0,"Item":"c7c27124-cfb8-4516-89ce-fb351d991fdb"}],"id":{"$":0,"Item":"e8866bb4-926b-4330-a0ab-051f89661640"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"XAsync","content":"let xasyncIf () =\n    xasync {\n        let a = 1\n        if a = 1 then\n            let r = 3\n            ()\n        ()\n    }\n\nlet hello2 i =\n    printoutfn out \"before \"\n    xasync {\n        printoutfn out \"wrap \"\n        let hA  =  async { printoutfn out \"Hello1 %d\" i } \n        let! h  =  hA\n        return i + 1\n    }\n\nlet helllo i =\n    xasync {\n        let h = hello i\n        return! h\n    }\n\nlet helo i =\n    xasync {\n        do! xasync { return () }\n        return i\n    }\n\nlet whileW() = \n    let mutable i = 0\n    xasync {\n        let! aR  = async { return XResult.succeed 2 } \n        let! a = aR\n        while (printoutfn out \"<%d>\" i ; i <= a) do\n            printoutfn out \"%d: \" i\n            let! z = hello2 i\n            i <- z\n            printoutfn out \" z = %d\" z\n        return! XAsync.Return   ()\n    } |> XAsync.runSynchronously\n\nlet whileWW() =\n    let mutable i = 0\n    let aAR = async { return XResult.succeed 2 }\n    aAR |> Async.map XResult.succeed |> XAsync |> XAsync.bind (fun aR ->\n        aR |> Async.Return |> XAsync |> XAsync.bind (fun a ->\n            let pred () = printoutfn out \"<%d>\" i ; i <= a \n            let body = fun () ->\n                printoutfn out \"%d: \" i\n                let zW = hello i\n                zW |> Async.map XResult.succeed |> XAsync |> XAsync.bind (fun z ->\n                    i <- z\n                    printoutfn out \" z = %d\" i\n                    XAsync.Return   ()\n                )\n            let r = XAsync.whileLoop pred body\n            r\n        )\n    ) |> XAsync.runSynchronously\n    \n    \nlet forW() = \n    xasync {\n        let! aR = async { return XResult.succeed 2 }\n        let! a = aR\n        for i = 0 to a do\n            printoutfn out \"%d: \" i\n            let! z = hello i\n            printoutfn out \" z = %d\" z\n        return! XAsync.Return   ()\n    } |> XAsync.runSynchronously\n    \nlet [<Test>] ``whileWW must be equal to whileA`` () = runStdOut whileWW  =! runStdOut whileA \nlet [<Test>] ``whileW  must be equal to whileA`` () = runStdOut whileW   =! runStdOut whileA \nlet [<Test>] ``forW    must be equal to forA``   () = runStdOut forW     =! runStdOut forA\n\n   ","parent":{"$":0,"Item":"9ca8f090-0191-4e47-96ee-a3b4785c45e2"},"predecessors":[{"$":0,"Item":"e8de7075-496c-4b12-a801-91db57db3fa4"},{"$":0,"Item":"e8866bb4-926b-4330-a0ab-051f89661640"}],"id":{"$":0,"Item":"fc2c1396-c30c-487e-a16d-62bdea734490"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"update Monad","content":"open Useful\n\nlet inline (|>>) a f = a |> UpdateM.map  f \nlet inline (>>=) m f = m |> UpdateM.bind f \nlet inline (>=>) g f = g >> UpdateM.bind f\nlet inline tee   g f v = g v |>> (fun _ -> f v)\nlet inline (>->) g f = tee g f\n\n/// Returns state + 1\nlet demo1 = update { \n    let! v = UpdateM.read()\n    return v + 1\n}\n  \n/// Returns the result of demo1 + 1\nlet demo2 = update { \n    let! v = demo1\n    return v + 1 |> sprintf \"value = %d\"\n}\n\n// Run it with state     40 \nlet res2 = demo2 |> UpdateM.readRun 40\n\nlet greeter         = UpdateM.read() |> UpdateM.map (fun  n         -> \"hello, \" + n + \"!\")\nlet calc (s:string) = UpdateM.read() |> UpdateM.map (fun (n:string) -> s.Length - n.Length)\nlet resr            = (greeter >>= calc) |> UpdateM.readRun \"leon\"\n\nmodule Reader =    // another implementation taken from https://gist.github.com/leon737/6056653\n    type Reader<'v> = Reader of 'v\n    let Return v = Reader v\n    let runReader mx d = match mx with | Reader v -> v d\n    let Bind      mx f = match mx with | Reader v -> Reader (fun z -> (v z) |> f |> runReader <| z)\n    let (>>=)          = Bind\n    \n    let greeter         = Return (fun n          -> \"hello, \" + n + \"!\") \n    let calc (s:string) = Return (fun (n:string) -> s.Length - n.Length)\n    let configOrGlobalStateOrEnvironment = \"leon\"\n    let resr = runReader (greeter >>= calc) configOrGlobalStateOrEnvironment\n\n/// Writes '20' to the log and returns \"world\"\nlet demo3 = update {\n    do! UpdateM.write 20\n    return \"world\" \n}\n  \n/// Calls 'demo3' and then writes 10 to the log\nlet demo4 = update {\n    do! UpdateM.write 30\n    let! w = demo3\n    do! UpdateM.write 10\n    return \"Hello \" + w \n}\n\n/// Returns \"Hello world\" with 20 and 10 in the log\nlet res4 = demo4 |> UpdateM.writeRun\n\nlet        half         x   = x / 2\nlet inline half_        x _ = half x\nlet        halfMessage  x   = sprintf \"I just halved %d ! \" x\nlet inline halfMessageW x   = halfMessage x |> UpdateM.write\n\nlet half1 x =  update  {\n    do!    halfMessageW x\n    return half         x\n}\nlet resw1   = half1 8 >>= half1 |> UpdateM.writeRun\n\nlet half2 x = halfMessageW x |>> half_ x\nlet quart2  = half2 >=> half2\nlet resw2   = quart2 8 |> UpdateM.writeRun\n\nmodule Writer =     // another implementation taken from https://gist.github.com/leon737/6056653\n    type Writer<'d, 'v> = Writer of 'd * 'v\n    let Tell d f = f [ d ]\n    let Return  v      = fun d ->      Writer(d,v)\n    let Join    d mx   = match mx with Writer(x,v) -> Writer(d @ x, v)\n    let Bind      mx f = match mx with Writer(d,v) -> f v |> Join d\n    let runWriter mx   = match mx with Writer(d,v) -> d,v\n    let (>>=) = Bind\n\n    let half      x = Tell ( sprintf \"I just halved %d ! \" x ) <| Return ( x / 2 )\n    let resw        = half 8 >>= half |> runWriter\n    \n/// Increments the state by one\nlet demo5 = update { \n  let! v = UpdateM.get()\n  do!      UpdateM.set (v + 1) \n}\n\n/// Call 'demo5' repeatedly in a loop\n/// and then return the final state\nlet demo6 = update {\n  for i in 1 .. 10 do \n    do! demo5\n  return! UpdateM.get()\n}\n\n// Run the sample with initial state 0\nlet res6 = demo6 |> UpdateM.setRun 0\n\ntype RWMonad<'a, 'S> = UpdateMonad<'S,UpdateM.ReaderWriterUpdate<string>,'a>\n\nlet halfRWf  = halfMessage      >>  UpdateM.writeRW >-> half  \nlet quartRWf = halfRWf          >=> halfRWf\nlet quartRW  = UpdateM.readRW() >>= quartRWf\nlet resRw    = quartRW          |>  UpdateM.readWriteRun 8\n\nlet resRw1a  =\n    UpdateM.readRW()\n    >>= halfRWf\n    >>= halfRWf\n    |>  UpdateM.readWriteRun 8\n\nlet halfRWf1 = tee (halfMessage >> UpdateM.writeRW) half\n\nlet resRw1b  =\n    UpdateM.readRW()\n    |> UpdateM.bind halfRWf1\n    |> UpdateM.bind halfRWf1\n    |> UpdateM.readWriteRun 8\n\nlet halfRWf2 x : RWMonad<_,_> = update {\n    let    v   = half        x\n    let    msg = halfMessage x\n    do!          UpdateM.writeRW msg |>> ignore\n    return v\n}\n\nlet halfRWf3 x : RWMonad<_,_> = update {\n    do!    UpdateM.writeRW (halfMessage x) |>> ignore\n    return half        x\n}\n\nlet halfRW : RWMonad<_,_> = update {\n    let! x = UpdateM.readRW()\n    return!  halfRWf2 x\n}\nlet quartRW2 : RWMonad<_,_> = update {\n    let! y = halfRW\n    return!  halfRWf2 y\n}\nlet quartRW3 : RWMonad<_,_> = halfRW >>= halfRWf2\nlet quartRWs : RWMonad<_,_> = quartRW2 |>> string\nlet resRw2    = quartRW2 |>  UpdateM.readWriteRun 8\n\nlet [<Test>] ``res2    must be equal to \"value = 42\"``           () = res2   =! \"value = 42\"\nlet [<Test>] ``resr    must be equal to Reader.resr (8)``        () = resr   =! Reader.resr\nlet [<Test>] ``res4    must be equal to ([20,10] \"Hello world\")``() = res4   =! ([30; 20; 10], \"Hello world\")\nlet [<Test>] ``resw1   must be equal to Writer.resw \"``          () = resw1  =! Writer.resw\nlet [<Test>] ``resw2   must be equal to Writer.resw \"``          () = resw2  =! Writer.resw\nlet [<Test>] ``res6    must be equal to 10``                     () = res6   =! 10\nlet [<Test>] ``resRw   must be equal to Writer.resw``            () = resRw  =! Writer.resw\nlet [<Test>] ``resRw2  must be equal to Writer.resw``            () = resRw2 =! Writer.resw\n\n ","parent":{"$":0,"Item":"9ca8f090-0191-4e47-96ee-a3b4785c45e2"},"predecessors":[{"$":0,"Item":"ee67a428-8d29-4f66-96f0-e0d94d85698b"},{"$":0,"Item":"cbde8669-d188-4274-b4ef-129dd359c6be"}],"id":{"$":0,"Item":"ad8af4ea-2ff7-4b3c-ab63-4364625732d7"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableFSI":"0"}},{"name":"imperative","content":"open Useful\n\nlet test(b) = imperative {\n    if b then \n        return 0\n    printoutfn out \"after return!\"\n    return 1 \n}\n\nlet validateName(arg:string) = imperative {\n    if  arg     = null                                                     then return false\n    let idx     = arg.IndexOf(\" \")\n    if  idx     = -1                                                       then return false\n    let name    = arg.Substring(0, idx)\n    let surname = arg.Substring(idx + 1, arg.Length - idx - 1)\n    if  surname.Length < 1               || name.Length < 1                then return false\n    if  System.Char.IsLower(surname.[0]) || System.Char.IsLower(name.[0])  then return false\n    return true \n}\n\nlet readFirstName (stream: System.IO.StreamReader) = imperative {\n    while true do\n        let name = stream.ReadLine().Trim()\n        if (validateName(name)) then return name\n        printoutfn out \"That's not a valid name! Try again...\" \n}\n\nlet checkNames () =\n    \"\"\"calvin\n       Calvin and Hodges\n       Calvin Coolidge\n    \"\"\"\n    |> System.Text.Encoding.UTF8.GetBytes\n    |> (fun content -> new System.IO.MemoryStream(content))\n    |> swap using (fun stream -> \n         new System.IO.StreamReader(stream)\n         |> swap using readFirstName\n         |> printoutfn out \"%A\"\n    )\n\nlet exists f inp = imperative {\n    for v in inp do \n        if f(v) then return true\n    return false \n}\n\nlet checkFor3 () = [ 1 .. 10 ] |> exists (fun v -> v % 3 = 0)\n\nlet odds() = imperative { \n    for x in 1 .. 5 do \n        if (x % 2 = 0) then do! continue'\n        printoutfn out \"number = %d\" x \n}\n\nlet count3 () = imperative { \n    let x = ref 1\n    while true do\n      if (!x % 4 = 0) then do! break'\n      printoutfn out \"number = %d\" !x\n      x := !x + 1 \n}\n\nlet [<Test>] ``test true                     must be 0``               () = runStdOutCall test true       =! (0, \"\")\nlet [<Test>] ``test false                    must be 1``               () = runStdOutCall test false      =! (1, \"after return!\\n\")\nlet [<Test>] ``validateName null             must be false``           () = validateName null             =! false\nlet [<Test>] ``validateName \"Tomas\"          must be false``           () = validateName \"Tomas\"          =! false\nlet [<Test>] ``validateName \"Tomas Petricek\" must be true``            () = validateName \"Tomas Petricek\" =! true\nlet [<Test>] ``checkNames                    must be Calvin Coolidge`` () = runStdOut checkNames          =! \"That's not a valid name! Try again...\\nThat's not a valid name! Try again...\\n\\\"Calvin Coolidge\\\"\\n\"\nlet [<Test>] ``checkFor3                     must be true``            () = checkFor3()                   =! true\nlet [<Test>] ``odds                          must be 1 3 5``           () = runStdOut odds                =! \"number = 1\\nnumber = 3\\nnumber = 5\\n\"\nlet [<Test>] ``count3                        must be 1 2 3``           () = runStdOut count3              =! \"number = 1\\nnumber = 2\\nnumber = 3\\n\"\n","parent":{"$":0,"Item":"9ca8f090-0191-4e47-96ee-a3b4785c45e2"},"predecessors":[{"$":0,"Item":"a1c1eae6-9927-45aa-868e-93ac25ec764a"},{"$":0,"Item":"ee67a428-8d29-4f66-96f0-e0d94d85698b"},{"$":0,"Item":"a7f4f5f0-13eb-40fd-afd9-c4521f505e2d"},{"$":0,"Item":"86c4e893-d144-41b0-bd3e-4934423ff808"}],"id":{"$":0,"Item":"b9e34ae3-bbec-447c-9964-30284318d122"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableFSI":"0"}},{"name":"semigroup monoid","content":"\ntype SemigroupBuilder<'P, 'T>(map: 'P -> 'T, op: 'T->'T->'T) =\n    member inline __.Yield     (v      :'P) : 'T = map v\n    member inline __.YieldFrom (vs     :'T) : 'T = vs\n    member inline __.Combine   (a:'T, b:'T) : 'T = op a b\n    member inline __.Delay      df               = df()\nlet inline semigroup (map, op, _) = SemigroupBuilder(map, op)\n\nlet concatStr (a:string) b = a + b\n\nlet defAdd    = id            , (+)        , 0  \nlet defProd   = id            , (*)        , 1  \nlet defString = string        , concatStr  , \"\"        \nlet defList   = List.singleton, List.append, []         \n\nsemigroup defAdd {\n    yield 7\n    yield 12\n} |> printfn \"%A\"\n\nsemigroup defProd {\n    yield 7\n    yield 12\n} |> printfn \"%A\"\n\nsemigroup defString {\n    yield 7\n    yield 12\n} |> printfn \"%A\"\n\nsemigroup defList {\n    yield 7\n    yield 12\n} |> printfn \"%A\"\n\ntype MonoidBuilder<'P, 'T>(map, op, zero: 'T) =\n    inherit SemigroupBuilder<'P, 'T>(map, op)\n    member inline __.Zero()       = zero\nlet inline monoid (map, op, zero) = MonoidBuilder(map, op, zero)\n\nmonoid defAdd {\n    if false then\n        yield 7\n        yield 12\n} |> printfn \"%A\"\n\nmonoid defProd {\n    if false then\n        yield 7\n        yield 12\n} |> printfn \"%A\"\n\nmonoid defString {\n    if false then\n        yield 7\n        yield 12\n} |> printfn \"%A\"\n\nmonoid defList {\n    if false then\n        yield 7\n        yield 12\n} |> printfn \"%A\"\n\nlet rec range (mon:MonoidBuilder<_,_>) n = mon { \n    yield n\n    if n < 100 then yield! range mon (n + 1) \n} \n\nrange (monoid defAdd   ) 97 |> printfn \"%A\"\nrange (monoid defProd  ) 97 |> printfn \"%A\"\nrange (monoid defString) 97 |> printfn \"%A\"\nrange (monoid defList  ) 97 |> printfn \"%A\"\n\n//let [<Test>] ``test true                     must be 0``               () = runStdOutCall test true       =! (0, \"\")\n","parent":{"$":0,"Item":"9ca8f090-0191-4e47-96ee-a3b4785c45e2"},"predecessors":[{"$":0,"Item":"ee67a428-8d29-4f66-96f0-e0d94d85698b"}],"id":{"$":0,"Item":"2c535c48-caf0-4422-adf0-76f80b0714c2"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableFSI":"0"}},{"name":"Run tests","content":"// You can select which test to run just by making them predecessors of this snippet\n\nTap.Run typeof<Marker>.DeclaringType    // run tests in module\n\n","parent":{"$":0,"Item":"9ca8f090-0191-4e47-96ee-a3b4785c45e2"},"predecessors":[{"$":0,"Item":"ad8af4ea-2ff7-4b3c-ab63-4364625732d7"},{"$":0,"Item":"4ec1bd8a-6593-4b48-92c7-c68f5fe601f8"}],"id":{"$":0,"Item":"ddb549cd-9ddc-4a2b-9d6a-6e02ed8a86c9"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableFSI":"0"}},{"name":"Snipets","content":"module Snipets =","parent":{"$":0,"Item":"e83d0347-89ba-4fbf-8bd0-02723299e948"},"predecessors":[],"id":{"$":0,"Item":"f3d0eaa1-b96a-41d1-83a2-19a84001e217"},"expanded":false,"level":0,"levelCode":0,"properties":{}},{"name":"fsharpforfunandprofit","content":"","parent":{"$":0,"Item":"f3d0eaa1-b96a-41d1-83a2-19a84001e217"},"predecessors":[],"id":{"$":0,"Item":"c5930fca-5baf-4b35-9193-18c08fafae39"},"expanded":false,"level":0,"levelCode":0,"properties":{}},{"name":"Sequence XAsync","content":"open Useful\n\n/// Do countN repetitions of the function f and print the time per run\nlet time countN label f  = \n\n    let stopwatch = System.Diagnostics.Stopwatch()\n    \n    // do a full GC at the start but not thereafter\n    // allow garbage to collect for each iteration\n    System.GC.Collect()  \n\n    printfn \"=======================\"         \n    printfn \"%s\" label \n    printfn \"=======================\"         \n    \n    let mutable totalMs = 0L\n\n    for iteration in [1..countN] do\n        stopwatch.Restart() \n        f()\n        stopwatch.Stop() \n        printfn \"#%2i elapsed:%6ims \" iteration stopwatch.ElapsedMilliseconds \n        totalMs <- totalMs + stopwatch.ElapsedMilliseconds\n\n    let avgTimePerRun = totalMs / int64 countN\n    sprintf \"%s: Average time per run:%6ims \" label avgTimePerRun \n    \nlet goodSites = [\n    \"http://google.com\"\n    \"http://bbc.co.uk\"\n    \"http://fsharp.org\"\n    \"http://microsoft.com\"\n    ]\n\nlet badSites = [\n    \"http://bad.example.com\"\n    \"http://verybad.example.com\"\n    \"http://example.com/nopage\"\n    \"http://veryverybad.example.com\"\n    ]\n\n// define a millisecond Unit of Measure\ntype [<Measure>] ms\n\n/// Custom implementation of WebClient with settable timeout\ntype WebClientWithTimeout(timeout:int<ms>) =\n    inherit System.Net.WebClient()\n\n    override this.GetWebRequest(address) =\n        let result = base.GetWebRequest(address)\n        result.Timeout <- int timeout \n        result\n\n// The content of a downloaded page \ntype UriContent = \n    UriContent of System.Uri * string\n\n// The content size of a downloaded page \ntype UriContentSize = \n    UriContentSize of System.Uri * int\n    \n/// Get the contents of the page at the given Uri\n/// Uri -> Async<Result<UriContent>>\nlet getUriContent (uri:System.Uri) = \n    async {\n        use client = new WebClientWithTimeout(1000<ms>) // 1 sec timeout\n        try\n            printfn \" [%s] Started ...\" uri.Host\n            let! html = client.AsyncDownloadString(uri) \n            printfn \" [%s] ... finished\" uri.Host\n            let uriContent = UriContent (uri, html)\n            return uriContent |> XResult.succeedWithMsg (Message <| sprintf \" [%s] ... Loaded!\" uri.Host)\n        with\n        | ex -> \n            printfn \" [%s] ... exception\" uri.Host\n            let err = sprintf \"[%s] %A\" uri.Host ex.Message |> Error\n            return XResult.fail err\n    } |> XAsync\n\n/// Make a UriContentSize from a UriContent\n/// UriContent -> Result<UriContentSize>\nlet makeContentSize (UriContent (uri, html)) = \n    if System.String.IsNullOrEmpty(html) then\n        XResult.fail (Error \"empty page\")\n    else\n        let uriContentSize = UriContentSize (uri, html.Length)\n        XResult.succeed uriContentSize \n\n/// Get the size of the contents of the page at the given Uri\n/// Uri -> Async<Result<UriContentSize>>\nlet getUriContentSize uri =\n    getUriContent uri \n    |> XAsync.bind (makeContentSize >> Async.Return >> XAsync)\n\n/// Get the largest UriContentSize from a list\n/// UriContentSize list -> UriContentSize\nlet maxContentSize list = \n    let contentSize (UriContentSize (_, len)) = len  // extract the len field from a UriContentSize \n    list |> List.maxBy contentSize                   // use maxBy to find the largest  \n\nlet largestPageSizeA urls = \n    urls\n    |> List.map (fun s -> System.Uri(s))   \n    |> List.map getUriContentSize\n    |> List.XAsync.sequenceA\n    |> XAsync.map maxContentSize\n\nlet largestPageSizeM urls = \n    urls\n    |> List.map (fun s -> System.Uri(s))   \n    |> List.map getUriContentSize\n    |> List.XAsync.sequenceM\n    |> XAsync.map maxContentSize\n\nlet showContentSizeResult result =\n    let messages = result |> XResult.getMessages\n    match result with\n    | XResult.Success (UriContentSize (uri, len), _) -> printfn \"SUCCESS: [%s] Content size is %i \\n%s\" uri.Host len messages\n    | XResult.Failure errs            -> printfn \"FAILURE: %s\" messages\n\nlet run f sites () = \n    f sites\n    |> XAsync.runSynchronouslyR\n    |> showContentSizeResult \n\n[\n    time 1 \"largestPageSizeA_Good\" <| run largestPageSizeA goodSites\n    time 1 \"largestPageSizeA_Bad \" <| run largestPageSizeA badSites\n    time 1 \"largestPageSizeM_Good\" <| run largestPageSizeM goodSites\n    time 1 \"largestPageSizeM_Bad \" <| run largestPageSizeM badSites\n] \n|> String.concat \"\\n\" \n|> printfn \"%s\"\n","parent":{"$":0,"Item":"c5930fca-5baf-4b35-9193-18c08fafae39"},"predecessors":[{"$":0,"Item":"4ec1bd8a-6593-4b48-92c7-c68f5fe601f8"}],"id":{"$":0,"Item":"7fbfd6ae-e6b6-4182-9c5a-09e5b549cf0e"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableFSI":"0"}},{"name":"Sequence Async XResult","content":"open Useful\n\n/// Do countN repetitions of the function f and print the time per run\nlet time countN label f  = \n\n    let stopwatch = System.Diagnostics.Stopwatch()\n    \n    // do a full GC at the start but not thereafter\n    // allow garbage to collect for each iteration\n    System.GC.Collect()  \n\n    printfn \"=======================\"         \n    printfn \"%s\" label \n    printfn \"=======================\"         \n    \n    let mutable totalMs = 0L\n\n    for iteration in [1..countN] do\n        stopwatch.Restart() \n        f()\n        stopwatch.Stop() \n        printfn \"#%2i elapsed:%6ims \" iteration stopwatch.ElapsedMilliseconds \n        totalMs <- totalMs + stopwatch.ElapsedMilliseconds\n\n    let avgTimePerRun = totalMs / int64 countN\n    sprintf \"%s: Average time per run:%6ims \" label avgTimePerRun \n    \nlet goodSites = [\n    \"http://google.com\"\n    \"http://bbc.co.uk\"\n    \"http://fsharp.org\"\n    \"http://microsoft.com\"\n    ]\n\nlet badSites = [\n    \"http://example.com/nopage\"\n    \"http://bad.example.com\"\n    \"http://verybad.example.com\"\n    \"http://veryverybad.example.com\"\n    ]\n\n// define a millisecond Unit of Measure\ntype [<Measure>] ms\n\n/// Custom implementation of WebClient with settable timeout\ntype WebClientWithTimeout(timeout:int<ms>) =\n    inherit System.Net.WebClient()\n\n    override this.GetWebRequest(address) =\n        let result = base.GetWebRequest(address)\n        result.Timeout <- int timeout \n        result\n\n// The content of a downloaded page \ntype UriContent = \n    UriContent of System.Uri * string\n\n// The content size of a downloaded page \ntype UriContentSize = \n    UriContentSize of System.Uri * int\n    \n/// Get the contents of the page at the given Uri\n/// Uri -> Async<Result<UriContent>>\nlet getUriContent (uri:System.Uri) = \n    async {\n        use client = new WebClientWithTimeout(1000<ms>) // 1 sec timeout\n        try\n            printfn \" [%s] Started ...\" uri.Host\n            let! html = client.AsyncDownloadString(uri) \n            printfn \" [%s] ... finished\" uri.Host\n            let uriContent = UriContent (uri, html)\n            return uriContent |> XResult.succeedWithMsg (Message <| sprintf \" [%s] ... Loaded!\" uri.Host)\n        with\n        | ex -> \n            printfn \" [%s] ... exception\" uri.Host\n            let err = sprintf \"[%s] %A\" uri.Host ex.Message |> Error\n            return XResult.fail err\n    }\n\n/// Make a UriContentSize from a UriContent\n/// UriContent -> Result<UriContentSize>\nlet makeContentSize (UriContent (uri, html)) = \n    if System.String.IsNullOrEmpty(html) then\n        XResult.fail (Error \"empty page\")\n    else\n        let uriContentSize = UriContentSize (uri, html.Length)\n        XResult.succeed uriContentSize \n\n/// Get the size of the contents of the page at the given Uri\n/// Uri -> Async<Result<UriContentSize>>\nlet getUriContentSize uri =\n    getUriContent uri \n    |> Async.map (XResult.bind makeContentSize)\n\n/// Get the largest UriContentSize from a list\n/// UriContentSize list -> UriContentSize\nlet maxContentSize list = \n    let contentSize (UriContentSize (_, len)) = len  // extract the len field from a UriContentSize \n    list |> List.maxBy contentSize                   // use maxBy to find the largest  \n\nlet largestPageSizeA urls = \n    urls\n    |> List.map (fun s -> System.Uri(s))   \n    |> List.map getUriContentSize\n    |> List.Async.sequenceA\n    |> Async.map List.XResult.sequenceA\n    |> Async.map (XResult.map maxContentSize)\n\nlet largestPageSizeM urls = \n    urls\n    |> List.map (fun s -> System.Uri(s))   \n    |> List.map getUriContentSize\n    |> List.Async.sequenceM\n    |> Async.map List.XResult.sequenceM\n    |> Async.map (XResult.map maxContentSize)\n\nlet showContentSizeResult result =\n    let messages = result |> XResult.getMessages\n    match result with\n    | XResult.Success (UriContentSize (uri, len), _) -> printfn \"SUCCESS: [%s] Content size is %i \\n%s\" uri.Host len messages\n    | XResult.Failure errs            -> printfn \"FAILURE: %s\" messages\n\nlet run f sites () = \n    f sites\n    |> Async.RunSynchronously\n    |> showContentSizeResult \n    \n[\n    time 1 \"largestPageSizeA_Good\" <| run largestPageSizeA goodSites\n    time 1 \"largestPageSizeA_Bad \" <| run largestPageSizeA badSites\n    time 1 \"largestPageSizeM_Good\" <| run largestPageSizeM goodSites\n    time 1 \"largestPageSizeM_Bad \" <| run largestPageSizeM badSites\n] \n|> String.concat \"\\n\" \n|> printfn \"%s\"\n","parent":{"$":0,"Item":"c5930fca-5baf-4b35-9193-18c08fafae39"},"predecessors":[{"$":0,"Item":"4ec1bd8a-6593-4b48-92c7-c68f5fe601f8"}],"id":{"$":0,"Item":"8c857791-9ed8-4970-abbb-172bbd126089"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableFSI":"0"}},{"name":"T.Petricek","content":"","parent":{"$":0,"Item":"f3d0eaa1-b96a-41d1-83a2-19a84001e217"},"predecessors":[],"id":{"$":0,"Item":"c667dd47-3780-4c6b-8e4e-87881d142a33"},"expanded":false,"level":0,"levelCode":0,"properties":{}},{"name":"Tree Zipper","content":"type Tree<'T> = \n  | Node of Tree<'T> * Tree<'T>\n  | Leaf of 'T\n  override x.ToString() = match x with\n                          | Node(l, r) -> sprintf \"(%O, %O)\" l r\n                          | Leaf v     -> sprintf \"%O\" v\n\ntype Path<'T> = \n  | Top \n  | Left  of Path<'T> * Tree<'T>\n  | Right of Path<'T> * Tree<'T>\n  override x.ToString() = match x with\n                          | Left (p, t) -> sprintf \"L(%O, %O)\" p t\n                          | Right(p, t) -> sprintf \"R(%O, %O)\" p t\n                          | Top         -> \"T\"\n\ntype TreeZipper<'T> = \n  | TZ of Tree<'T> * Path<'T>\n  override x.ToString() = match x with TZ(t, p) -> sprintf \"%O [%O]\" t p\n  \n/// Navigates to the left sub-tree\nlet left = function\n  | TZ(Leaf _, _) -> failwith \"cannot go left\"\n  | TZ(Node(l, r), p) -> TZ(l, Left(p, r))\n\n/// Navigates to the right sub-tree\nlet right = function\n  | TZ(Leaf _, _) -> failwith \"cannot go right\"\n  | TZ(Node(l, r), p) -> TZ(r, Right(p, l))\n\n/// Gets the value at the current position\nlet current = function\n  | TZ(Leaf x, _) -> x\n  | _ -> failwith \"cannot get current\"\n\n/// Navigate to the parent node\nlet up = function\n  | TZ(l, Left(p, r))\n  | TZ(r, Right(p, l)) -> TZ(Node(l, r), p)\n  | TZ(_, Top) -> failwith \"cannot go up\"\n\n/// Navigate to the root of the tree\nlet rec top = function\n  | TZ(_, Top) as t -> t\n  | tz -> top (up tz)\n  \n/// Build tree zipper with singleton tree\nlet unit v = TZ(Leaf v, Top)\n\n/// Transform leaves in the current sub-tree of 'treeZip'\n/// into other trees using the provided function 'f'\nlet bindSub f treeZip = \n  let rec bindT = function\n    | Leaf x -> let (TZ(t, _)) = top (f x) in t\n    | Node(l, r) -> Node(bindT l, bindT r)\n  let (TZ(current, path)) = treeZip\n  TZ(bindT current, path)\n  \ntype TreeZipperBuilder() = \n    member x.For(tz:TreeZipper<'T>, f) : TreeZipper<'T>             = bindSub f tz\n    member x.Yield                                               v  = unit v\n    [<CustomOperation(\"left\"   , MaintainsVariableSpace=true )>]\n    member x.Left                                                tz = left tz\n    [<CustomOperation(\"right\"  , MaintainsVariableSpace=true )>]\n    member x.Right                                               tz = right tz\n    [<CustomOperation(\"up\"     , MaintainsVariableSpace=true )>]\n    member x.Up                                                  tz = up tz\n    [<CustomOperation(\"top\"    , MaintainsVariableSpace=true )>]\n    member x.Top                                                 tz = top tz\n    [<CustomOperation(\"current\", MaintainsVariableSpace=false)>]\n    member x.Current                                             tz = current tz\n    [<CustomOperation(\"map\"    , MaintainsVariableSpace=true)>]\n    member x.Select( tz, [<ProjectionParameter>] f)                 = bindSub (f >> unit) tz\n\nlet tree = TreeZipperBuilder()\n\nlet branches = \n  Node( Node(Leaf 1, Leaf 3), \n        Node(Leaf 7, Node(Leaf 12, Leaf 20)) )\n\nlet sample = TZ(branches, Top)\nprintfn \"%O\" sample \n\nsample |> right |> right |> left //|> current\n|> printfn \"%O\"\n\ntree { \n    for x in sample do\n    yield x * 2 \n} |> printfn \"%O\"\n\ntree { \n    for x in sample do\n    right\n    right\n    left\n    current \n} |> printfn \"%O\"\n\ntree {\n    for x in sample do\n    left\n    map (x * 2)\n    top\n    right\n    map (x / 2) \n    top \n} |> printfn \"%O\"\n","parent":{"$":0,"Item":"c667dd47-3780-4c6b-8e4e-87881d142a33"},"predecessors":[],"id":{"$":0,"Item":"7f16b1da-3e90-4824-a4b5-c0b57365a99e"},"expanded":true,"level":0,"levelCode":0,"properties":{}}]