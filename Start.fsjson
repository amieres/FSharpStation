[{"name":"READ ME! ","content":"- NO! DON'T READ ME! GO ON DIRECTLY TO THE TUTORIALS BELOW!!!!!\n\n\n\n- Organize your code in snippets group them by theme, keep them all in one place, all your projects big and small\n- Use snippet predecessors to assemble your solution\n- Create one big code infrastructure that can be reused and refined over and over.\n- Code, try, test, compile, run your code\n- Intellisense (for now):\n    - Tooltips (double-click or F2)\n    - Error highlighting\n    - Auto completion (ctrl-space)\n    - Find Definition\n- Run it immediately with almost zero scaffolding\n- Produce JavaScript using Websharper and run it in your browser immediately\n- Dependencies are equivalent to `#load \"<file.fsx>\"` or include directives\n\n- Evaluate F# does not return the last value calculated, only what is printed to the output\n\n- Parse F# is necessary when changing the predecessors\n\n- F# Station is intended to be used locally not through the Internet\n- Evaluate F# is disabled when not used locally","predecessors":[],"id":{"$":0,"Item":"bc0d0abf-9c94-48bb-b46e-92e5d539b172"},"expanded":true,"level":0,"levelCode":0,"properties":{"Mode":"none","DisableParse":"1"}},{"name":"FSSGlobal","content":"#nowarn \"1182\"\n#nowarn \"40\"\n#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\bin\\FSharp.Core.dll\"\n#if INTERACTIVE\n//#I @\"../WebServer/bin\"\nmodule FSSGlobal   =\n#else\nnamespace FSSGlobal\n#endif\n","predecessors":[],"id":{"$":0,"Item":"bf864f3c-1370-42f2-ac8a-565a604892e8"},"expanded":true,"level":0,"levelCode":0,"properties":{"Theme":"rubyblue"}},{"name":"F# Code","content":"// Code to be evaluated using FSI: `Evaluate F#`","parent":{"$":0,"Item":"bf864f3c-1370-42f2-ac8a-565a604892e8"},"predecessors":[],"id":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableWebSharper":"1","NoIndent":"1"}},{"name":"open WebSharper","content":"#if WEBSHARPER\n#I @\"..\\packages\\Zafir\\lib\\net40\"\n\n#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Core.JavaScript.dll\"\n#r @\"WebSharper.Collections.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.JQuery.dll\"\n#r @\"WebSharper.JavaScript.dll\"\n#r @\"WebSharper.Web.dll\"\n#r @\"WebSharper.Sitelets.dll\"\n#r @\"..\\packages\\Zafir.UI.Next\\lib\\net40\\WebSharper.UI.Next.dll\"\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI.Next\nopen WebSharper.UI.Next.Client\ntype on   = WebSharper.UI.Next.Html.on\ntype attr = WebSharper.UI.Next.Html.attr\n#endif","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Useful","content":"#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule Useful =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"Result, Wrap","content":"open System\n#nowarn \"1178\"\n#if WEBSHARPER\n[<JavaScript>]\n#endif\nmodule Option =\n    let defaultValue v =\n        function\n        | Some x -> x\n        | None   -> v\n\n    let defaultWith f =\n        function\n        | Some x -> x\n        | None   -> f()\n\n    let call v = \n        function\n        | None   -> None\n        | Some f -> f v |> Some\n\n    let iterF v = \n        function\n        | None   -> ()\n        | Some f -> f v\n\n    let iterFO vO fO = \n        match vO, fO with\n        | Some v, Some f -> f v\n        | _     , _      -> ()\n\n    let apply vO fO =\n        match vO, fO with\n        | Some v, Some f -> f v |> Some\n        | _     , _      -> None\n\n    let modify modifier = Option.map (fun f -> modifier f) >> defaultValue id\n      \n\n//#nowarn \"25\"\ntype ErrMsg = \n    abstract member ErrMsg   : string\n    abstract member IsWarning: bool\n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\ntype ExceptionThrown(exn:Exception) =\n    interface ErrMsg with\n        member this.ErrMsg   : string = sprintf \"%A\" exn\n        member this.IsWarning: bool   = false\n    override this.ToString() = (this :> ErrMsg).ErrMsg\n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\ntype ErrOptionIsNone() =\n    interface ErrMsg with\n        member this.ErrMsg   : string = \"Option is None\"\n        member this.IsWarning: bool   = false\n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\ntype ErrSimple(msg, warning) =\n    interface ErrMsg with\n        member this.ErrMsg   : string = msg\n        member this.IsWarning: bool   = warning\n    override this.ToString() = (this :> ErrMsg).ErrMsg\n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\ntype Result<'TSuccess> = Result of 'TSuccess option * ErrMsg list     \n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\nmodule Result =\n    let inline succeed             x       = Result (Some x           , [  ]             )\n    let inline succeedWithMsg      x  m    = Result (Some x           , [m ]             )\n    let inline succeedWithMsgs     x  ms   = Result (Some x           ,  ms              )\n    let inline fail                   m    = Result (None             , [m ]             )\n    let inline failWithMsgs           ms   = Result (None             ,  ms              )\n    let inline map       f (Result(o, ms)) = Result (o |> Option.map f,  ms              )\n    let inline mapMsg    f (Result(o, ms)) =        (o                ,  ms |> List.map f)\n    let inline mapMsgs   f (Result(o, ms)) =        (o                ,  ms |>          f)\n    let inline getOption   (Result(o, _ )) =         o                   \n    let inline getMsgs     (Result(_, ms)) =                             ms\n    let inline mergeMsgs              ms r = Result (r |> mapMsgs   ((@) ms) )\n    let inline combine     (Result(_, ms)) = mergeMsgs ms\n    let inline bind      f (Result(o, ms)) = \n        match o with\n        | Some x   -> match f x with Result(o2, ms2) -> Result(o2, ms @ ms2)\n        | None     -> Result(None, ms)\n    let inline apply (Result(fO, fMs))  (Result(o , ms)) = \n        match fO, o with\n        | Some f, Some x -> Result(f x |> Some, fMs @ ms)\n        | _              -> Result(None       , fMs @ ms)\n\n\n    let (|Success|Failure|) =\n        function \n        | Result(Some x, ms) -> Success (x, ms) \n        | Result(None  , ms) -> Failure     ms  \n\n    let x = function\n              | Success (x, ms) -> \"yes\"\n              | Failure     ms  -> \"No\"\n\n//    let successTee f result =                           // given an RopResult, call a unit function on the success branch\n//        let fSuccess (x,msgs) =                         // and pass thru the result\n//            f (x,msgs)\n//            Success (x,msgs) \n//        either fSuccess Failure result\n//\n//    let fFailure2 f errs = \n//        f errs\n//        Failure errs \n//    let failureTee f result =                           /// given an RopResult, call a unit function on the failure branch\n//        either Success (fFailure2 f) result\n//\n//    let mapMessagesR f result =                         /// given an RopResult, map the messages to a different error type\n//        match result with \n//        | Success (x,msgs) -> \n//            let msgs' = List.map f msgs\n//            Success (x, msgs')\n//        | Failure errors -> \n//            let errors' = List.map f errors \n//            Failure errors' \n//\n//    let valueOrDefault f result =                       /// given an RopResult, in the success case, return the value.\n//        match result with                               /// In the failure case, determine the value to return by \n//        | Success (x,_) -> x                            /// applying a function to the errors in the failure case\n//        | Failure errors -> f errors\n//\n//    let failIfNone message = function                   /// lift an option to a RopResult.\n//        | Some x -> succeed x                           /// Return Success if Some\n//        | None -> fail message                          /// or the given message if None\n//\n//    let failIfNoneR message = function                  /// given an RopResult option, return it\n//        | Some rop -> rop                               /// or the given message if None\n//        | None -> fail message \n\n    let failException e = ExceptionThrown(e) :> ErrMsg\n\n///            tryCall: (exn -> Result<'b>) ->  ('a -> Result<'b>) -> 'a -> Result<'b> =\n    let inline tryCall (f:'a -> Result<'b>) (v:'a) : Result<'b> = try f v with e -> failException e |> fail\n\n    type ropBuilder() =\n        member inline this.Return     (x)                       = succeed x\n        member inline this.ReturnFrom (x)                       = x\n        member        this.Bind       (w:Result<'a>, r: 'a -> Result<'b>) = bind (tryCall r) w\n        member inline this.Using      (disposable, restOfCExpr) = using disposable restOfCExpr\n        member inline this.Zero       ()                        = succeed ()\n        member inline this.Delay      (f)                       = f()\n        member inline this.Combine    (a, b)                    = combine a b\n//        member this.Run        (f)                       = f\n//        member this.While(guard, body) =\n//            if not (guard()) \n//            then this.Zero() \n//            else this.Bind( body(), fun () -> \n//                this.While(guard, body))  \n//        member this.For(sequence:seq<_>, body) =\n//            this.Using(sequence.GetEnumerator(),fun enum -> \n//                this.While(enum.MoveNext, \n//                    this.Delay(fun () -> body enum.Current)))\n\n    let result = ropBuilder()\n//    let inline flow_ () = new ropBuilder ()\n\n    let fromChoice context c =\n        match c with | Choice1Of2 v -> succeed v\n                     | Choice2Of2 e -> fail    e\n\n    let fromOption m =\n        function | None   -> fail    m\n                 | Some v -> succeed v\n\n    let toOption (Result(o, _)) = o\n\n    let tryProtection() : Result<unit> = succeed ()\n\n    let failIfFalse m v : Result<unit>  = if v then succeed () else m |> fail \n    let failIfTrue  m v : Result<unit>  = if v then m |> fail  else succeed () \n            \n    let ifError   def (Result(o, _ )) = o |> Option.defaultValue            def\n    let withError f   (Result(o, ms)) = o |> Option.defaultWith  (fun () -> f ms)\n\n//    let processMessages mtype (msgs: PossibleMessages list) =\n//        msgs\n//        |> List.iter (fun o -> WebSharper.JavaScript.JS.Alert     <| mtype + \": \" + (sprintf \"%A\" o)\n//                               WebSharper.JavaScript.Console.Log o)\n//\n//    let notifyMessages R =\n//        match R with | Success (_, m) -> processMessages \"N\" m\n//                     | Failure     m  -> processMessages \"E\" m\n//\n//    let messagesDo f =\n//        function | Success (_, ms) -> f false ms\n//                 | Failure     ms  -> f true  ms\n\n    let seqCheck s = \n        s \n        |> (fun elems -> match      elems |> Seq.exists(function | Failure _    -> true    | _ -> false) with\n                         | true  -> elems |> Seq.pick  (function | Failure ms   -> Some ms | _ -> None ) |> failWithMsgs\n                         | false -> elems |> Seq.map   (function | Result (vO,_)-> vO.Value            ) |> succeed\n        )\n\n    let getMessages   (ms: ErrMsg list) = ms |> List.map (fun m -> m.ErrMsg) |> String.concat \"\\n\"\n    let countMessages (ms: ErrMsg list) =\n        if ms = [] then \"\" else\n        let errors   = ms |> List.filter(fun m -> m.IsWarning |> not)\n        let warnings = ms |> List.filter(fun m -> m.IsWarning       )\n        match errors.Length, warnings.Length with\n        | 0, 0 -> sprintf \"%s\"\n        | 1, 0 -> sprintf \"%s\"\n        | 0, 1 -> sprintf \"%s\"\n        | 1, 1 -> sprintf \"1 error, 1 warning\\n%s\"\n        | e, 0 -> sprintf \"%d errors\\n%s\" e\n        | 0, w -> sprintf \"%d warnings\\n%s\" w\n        | e, w -> sprintf \"%d errors, %d warnings\\n%s\" e w\n        <| getMessages ms\n \nopen Result\n\ntype Wrap<'T> =\n| WResult of Result<'T>\n| WAsync  of Async<'T>\n| WAsyncR of Async<Result<'T>>\n| WSimple of 'T\n| WOption of 'T option\n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\nmodule Wrap =\n    let errOptionIsNone = ErrOptionIsNone() :> ErrMsg\n\n    let wb2arb ms = \n        function\n        | WAsync       ab  -> async { let!   b = ab\n                                      return succeedWithMsgs b                   ms }\n        | WAsyncR     arb  -> async { let!   rb = arb                               \n                                      return rb |> mergeMsgs                     ms }\n        | WResult      rb  -> async { return rb |> mergeMsgs                     ms }\n        | WSimple       b                                                           \n        | WOption (Some b) -> async { return succeedWithMsgs b                   ms }\n        | WOption None     -> async { return failWithMsgs      (errOptionIsNone::ms)}\n\n    let tryCall (f: 'a -> Wrap<'b>) (a:'a) = \n        try f a \n        with e -> failException e |> fail |> WResult\n\n    let bind (f: 'a -> Wrap<'b>) (wa: Wrap<'a>) :Wrap<'b> =\n        match wa with\n        | WSimple         a       \n        | WOption(Some    a)       \n        | WResult(Success(a, [])) -> tryCall f a\n        | WOption None            -> None            |> WOption\n        | WResult(Failure    ms ) -> failWithMsgs ms |> WResult \n        | WResult(Success(a, ms)) -> tryCall f a\n                                     |> function\n                                     | WSimple         b              \n                                     | WOption(Some    b     ) -> succeedWithMsgs b  ms             |> WResult \n                                     | WOption None            -> failWithMsgs (errOptionIsNone::ms)|> WResult\n                                     | WResult(Success(b, [])) -> succeedWithMsgs b  ms             |> WResult \n                                     | WResult(Success(b, m2)) -> succeedWithMsgs b (ms @ m2)       |> WResult \n                                     | WResult(Failure    m2)  -> failWithMsgs      (ms @ m2)       |> WResult \n                                     | WAsync  ab              -> async { let!  b = ab\n                                                                          return succeedWithMsgs b ms\n                                                                  } |> WAsyncR\n                                     | WAsyncR arb             -> async { let! rb = arb\n                                                                          return mergeMsgs ms rb\n                                                                  } |> WAsyncR\n        | WAsync         aa       -> async {\n                                         let! a  = aa\n                                         return! tryCall f a |> wb2arb []\n                                     } |> WAsyncR\n        | WAsyncR       ara       -> async {\n                                         let! ar  = ara\n                                         let  arb = match ar with\n                                                    | Success(a, ms) -> tryCall f a |> wb2arb ms\n                                                    | Failure    ms  -> async { return failWithMsgs ms }\n                                         return! arb\n                                     } |> WAsyncR\n    let Return = WSimple \n    let map  (f: 'a -> 'b  ) = bind (f >> Return)     \n\n    let wrapper2Async (f: 'a -> Wrap<'b>) a : Async<Result<'b>> =\n        let wb = tryCall f a\n        match wb with\n        | WSimple _\n        | WOption _               -> wb |> wb2arb []\n        | WResult (Result(_, ms)) -> wb |> wb2arb ms\n        | WAsync  ab              -> async { let!   b = ab\n                                             return succeed b }\n        | WAsyncR arb              -> arb\n\n    let addMsgs errOptionIsNone ms wb =\n        if ms = [] then wb else\n        match wb with\n        | WSimple          v       \n        | WOption (Some    v)      -> WResult (succeedWithMsgs                        v ms)\n        | WOption (None     )      -> WResult (fail errOptionIsNone |> Result.mergeMsgs ms)\n        | WResult r                -> WResult (r                    |> Result.mergeMsgs ms)\n        | WAsync           va      -> async {\n                                        let! v = va\n                                        return succeedWithMsgs v ms\n                                      } |> WAsyncR\n        | WAsyncR          vra     -> async {\n                                        let! vr = vra\n                                        return vr                    |> Result.mergeMsgs ms\n                                      } |> WAsyncR\n\n    let combine errOptionIsNone wa wb =\n        match wa with\n        | WSimple          _\n        | WOption (Some    _)\n        | WResult (Result (_, []))\n        | WAsync           _       -> wb\n        | WAsyncR          _       -> wb\n        | WOption (None     )      -> wb |> addMsgs errOptionIsNone [errOptionIsNone]\n        | WResult (Result(_, ms))  -> wb |> addMsgs errOptionIsNone ms\n\n    type Builder() =\n//        member        this.Bind (wrapped: Async<Result<'a>>, restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WAsyncR |> bind restOfCExpr //<< cannot differentiate from next \n        member        this.Bind (wrapped: Wrap<'a>         , restOfCExpr: 'a -> Wrap<'b>) = wrapped            |> bind restOfCExpr \n        member        this.Bind (wrapped: Async<'a>        , restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WAsync  |> bind restOfCExpr  \n        member        this.Bind (wrapped: Result<'a>       , restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WResult |> bind restOfCExpr \n        member        this.Bind (wrapped: 'a option        , restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WOption |> bind restOfCExpr \n        member inline this.Zero         ()  = WSimple ()\n        member inline this.Return       (x) = WSimple x\n        member inline this.ReturnFrom   (w) = w\n//        member inline this.ReturnFrom   (w) = WAsync  w\n//        member inline this.ReturnFrom   (w) = WResult w\n//        member inline this.ReturnFrom   (w) = WOption w        \n        member inline this.Delay        (f) = f()\n        member        this.Combine   (a, b) = combine errOptionIsNone a b\n        member        this.Using (resource, body: 'a -> Wrap<'b>) =\n            async.Using(resource, wrapper2Async body) |> WAsyncR\n                    \n    let wrapper = Builder()\n\n    let getResult callback (wb: Wrap<'T>) =\n        match wb with\n        | WSimple      s  -> s               |> succeed                                      |> callback\n        | WOption(Some s) -> s               |> succeed                                      |> callback\n        | WOption None    -> errOptionIsNone |> fail                                         |> callback\n        | WResult      rb -> rb                                                              |> callback\n        | WAsync       ab -> Async.StartWithContinuations(ab , (fun v   -> succeed v         |> callback), \n                                                               (fun exc -> failException exc |> fail |> callback), \n                                                                fun can -> failException can |> fail |> callback)\n        | WAsyncR     arb -> Async.StartWithContinuations(arb,                                          callback , \n                                                               (fun exc -> failException exc |> fail |> callback), \n                                                                fun can -> failException can |> fail |> callback)\n\n    let inline getAsyncR (wb: Wrap<'T>) =\n        match wb with\n        | WAsync      va  -> async {\n                               let! v = va\n                               return      succeed                           v}\n        | WSimple     v   -> async.Return (succeed                           v)\n        | WOption     v   -> async.Return (Result.fromOption errOptionIsNone v)\n        | WResult     v   -> async.Return                                    v\n        | WAsyncR     vra -> vra\n        \n    let inline getAsyncWithDefault f (wb: Wrap<'T>) = \n        async {\n            let!   vR = getAsyncR wb\n            return vR |> Result.withError f\n        }\n\n    let inline getAsync w =\n        match w with\n        | WAsync      va  ->              va\n        | WSimple     v   -> async.Return v\n        | WOption     vo  -> async {\n                                return\n                                    match vo with \n                                    | Some v         -> v\n                                    | None           -> raise (exn(getMessages [errOptionIsNone]))\n                             }\n        | WResult     vr  -> async {\n                                return\n                                    match vr with \n                                    | Success (v, _) -> v\n                                    | Failure ms     -> raise (exn(getMessages ms))\n                             }\n        | WAsyncR     vra -> async {\n                                let! vr = vra\n                                return\n                                    match vr with \n                                    | Success (v, _) -> v\n                                    | Failure ms     -> raise (exn(getMessages ms))\n                             }\n//    let call wb = wb |> getR Rop.notifyMessages\n    let startV (processVal: ('t option * string) ->unit) (w: Wrap<'t>) =\n        w\n        |> getAsyncR\n        |> fun asy -> Async.StartWithContinuations\n                        (asy \n                       , Result.mapMsgs Result.getMessages  >> processVal\n                       , sprintf \"%A\" >> (fun m -> None, m) >> processVal\n                       , sprintf \"%A\" >> (fun m -> None, m) >> processVal)\n                       \n    let start (printMsg: string->unit) (w: Wrap<unit>) = \n        startV (function\n                | Some (), msgs ->               msgs |> printMsg \n                | None   , msgs -> \"Failed!\\n\" + msgs |> printMsg) w\n\n#if WEBSHARPER\n    [< Inline \"console.log('runSynchronously should not be used in Javascript')\" >]                       \n#endif\n    let runSynchronouslyR (w: Wrap<_>) =\n        w\n        |> getAsyncR\n        |> Async.RunSynchronously\n    let runSynchronouslyO count (w: Wrap<_>) =\n        w\n        |> runSynchronouslyR\n        |> (Result.mapMsgs (if count then Result.countMessages else Result.getMessages))\n    let runSynchronouslyS count (w: Wrap<_>) =\n        w\n        |> runSynchronouslyO count\n        |> function\n           | Some r, msgs -> sprintf \"%O\\n%s\" r    msgs\n           | None  , msgs -> sprintf \"Failed!\\n%s\" msgs\n           \n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\ntype Wrap<'T> with\n    static member Start           (w:Wrap<_   >,           ?cancToken) = Async.Start           (Wrap.getAsync  w,                                ?cancellationToken= cancToken)\n    static member StartAsTask     (w:Wrap<'T  >, ?options, ?cancToken) = Async.StartAsTask     (Wrap.getAsyncR w, ?taskCreationOptions= options, ?cancellationToken= cancToken)\n#if WEBSHARPER\n    [< Inline \"console.log('RunSynchronously should not be used in Javascript')\" >]                       \n#endif\n    static member RunSynchronously(w:Wrap<'T  >, ?timeout, ?cancToken) = Async.RunSynchronously(Wrap.getAsyncR w, ?timeout            = timeout, ?cancellationToken= cancToken)\n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"extract, now, Async","content":"let extract n (s:string) = s.Substring(0, min n s.Length)\n\n#if WEBSHARPER\n[< Inline \"(function (n) { return n.getFullYear() + '-' +(n.getMonth() + 1) + '-' +  n.getDate() + ' '+n.getHours()+ ':'+n.getMinutes()+ ':'+n.getSeconds()+ ':'+n.getMilliseconds() })(new Date(Date.now()))\" >]\n#endif\nlet nowStamp() = System.DateTime.UtcNow.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n\nmodule Async =\n    let map f va = \n        async { \n            let! a = va\n            return f a \n        } ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"7a655466-e218-4121-a7b6-f9c70a922e07"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"parseInt","content":"let tryParseWith tryParseFunc = tryParseFunc >> function\n        | true, v    -> Some v\n        | false, _   -> None\n\nlet parseDate   = tryParseWith System.DateTime.TryParse\nlet parseInt    = tryParseWith System.Int32   .TryParse\nlet parseSingle = tryParseWith System.Single  .TryParse\nlet parseDouble = tryParseWith System.Double  .TryParse\n// etc.\n\n// active patterns for try-parsing strings\nlet (|Date  |_|) = parseDate\nlet (|Int   |_|) = parseInt\nlet (|Single|_|) = parseSingle\nlet (|Double|_|) = parseDouble","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"af2b60c6-a99f-433d-b938-f59fefe66c01"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"REGEX","content":"#if WEBSHARPER\n\nlet (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n    if value = null then None else\n    try \n        match JavaScript.String(value).Match(RegExp(expr, opt)) with\n        | null         -> None\n        | [| |]        -> None\n        | m            -> Some m\n    with e -> None\n#endif\n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"swap","content":"let inline swap f a b = f b a\n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"657c8f34-c917-4659-825d-c9ead206efcf"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"memoize","content":"#if WEBSHARPER\n[< Inline >]\n#endif\nlet memoize f = \n    let cache = System.Collections.Generic.Dictionary<_, _>()\n    fun x -> \n        let mutable res = Unchecked.defaultof<_>\n        let ok = cache.TryGetValue(x, &res)\n        if ok then res \n        else let res = f x\n             cache.[x] <- res\n             res\n             \ntype ResetableMemoize(f) =             \n    let cache = System.Collections.Generic.Dictionary<_, _>()\n    member this.ClearCache() = cache.Clear()\n    #if WEBSHARPER\n    [< Inline >]\n    #endif\n    member this.Call x =\n        let mutable res = Unchecked.defaultof<_>\n        let ok = cache.TryGetValue(x, &res)\n        if ok then res \n        else let res = f x\n             cache.[x] <- res\n             res\n    ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"8efdcd5a-95c4-4212-9c75-1ebedce83dd8"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"separateDirectives","content":"type PreproDirective =\n| PrepoR      of string\n| PrepoDefine of string\n| PrepoLoad   of string\n| PrepoLine   of string //* int\n| PrepoNoWarn of string\n| PrepoI      of string\n| PrepoIf     of string\n| PrepoElse   \n| PrepoEndIf\n| PrepoLight  of bool\n| PrepoOther  of string\n| NoPrepo\n\nlet separatePrepros removePrepoLine (code:string[]) =\n    let  quoted (line:string) = line.Trim().Split([| \"\\\"\"       |], System.StringSplitOptions.RemoveEmptyEntries) |> Seq.tryLast |> Option.defaultValue line\n    let  define (line:string) = line.Trim().Split([| \"#define \" |], System.StringSplitOptions.RemoveEmptyEntries) |> Seq.tryHead |> Option.defaultValue \"\"\n    let  comment = ((+)\"//\") \n    let  preL    = if removePrepoLine then comment else id \n    let  prepro (line:string) = match true with \n                                | true when line.StartsWith(\"#define\") -> (comment line, line |> define |> PrepoDefine)\n                                | true when line.StartsWith(\"#r\"     ) -> (comment line, line |> quoted |> PrepoR     )\n                                | true when line.StartsWith(\"#load\"  ) -> (comment line, line |> quoted |> PrepoLoad  )\n                                | true when line.StartsWith(\"#nowarn\") -> (comment line, line |> quoted |> PrepoNoWarn)\n                                | true when line.StartsWith(\"# \"     ) -> (preL    line, line |> quoted |> PrepoLine  )\n                                | true when line.StartsWith(\"#line\"  ) -> (preL    line, line |> quoted |> PrepoLine  )\n                                | true when line.StartsWith(\"#I\"     ) -> (comment line, line |> quoted |> PrepoI     )\n                                | true when line.StartsWith(\"#if\"    ) -> (        line, line           |> PrepoIf    )\n                                | true when line.StartsWith(\"#else\"  ) -> (        line,                   PrepoElse  )\n                                | true when line.StartsWith(\"#endif\" ) -> (        line,                   PrepoEndIf )\n                                | true when line.StartsWith(\"#light\" ) -> (        line, false          |> PrepoLight )\n                                | true when line.StartsWith(\"#\"      ) -> (comment line, line           |> PrepoOther )\n                                | _                                    -> (        line,                   NoPrepo    ) \n    code |> Array.map prepro\n    \nlet separateDirectives (fsNass:(string * PreproDirective) seq) =\n    let  assembs  = fsNass |> Seq.choose (snd >> (function | PrepoR assemb -> Some assemb | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  defines  = fsNass |> Seq.choose (snd >> (function | PrepoDefine d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  prepoIs  = fsNass |> Seq.choose (snd >> (function | PrepoI      d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  nowarns  = fsNass |> Seq.choose (snd >> (function | PrepoNoWarn d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  code     = fsNass |> Seq.map     fst                                                                           |> Seq.toArray\n    code, assembs, defines, prepoIs, nowarns\n\n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"ace1fc12-3dfb-4db8-80c9-5bde1e7d0597"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Save File","content":"open System.IO\n\nlet backupFile file = \n    try File.Delete(      file + \".bak\") with _ -> ()\n    try File.Copy  (file, file + \".bak\") with _ -> ()\n\nlet inline saveFile (file:string) (content: string) =\n    Wrap.wrapper {\n        do! Result.tryProtection()\n        backupFile file\n        File.WriteAllText(file, content)\n    } \n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"let doSTA act =\n    let thread = System.Threading.Thread(System.Threading.ThreadStart act)\n    thread.SetApartmentState(System.Threading.ApartmentState.STA)\n    thread.Start()\n    \nlet sCopy       txt = \n    doSTA (fun () -> System.Windows.Forms.Clipboard.SetText txt)\n    sprintf \"Copied to clipboard: %s... (%d characters)\\n\\n\" <| txt.[..min (txt.Length - 1) 100 ] <| txt.Length \n    \nlet Copy        txt = \n    sCopy txt\n    |> printf \"%s\"\n    \nlet Paste f        = doSTA (fun () -> f System.Windows.Forms.Clipboard.GetText)   ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"c7e56d1e-aea8-483a-a99a-23b7e056de0d"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"type ActionBar","content":"open System\nopen System.Text\nopen System.Drawing\nopen System.Windows.Forms\nopen System.ComponentModel\n\ntype GrowLabel (maxHeight:int) =\n  inherit Label() \n  let mutable mGrowing  = false\n  do base.AutoSize     <- false\n  member this.resizeLabel() =\n    if mGrowing then () else\n    try \n      mGrowing <- true\n      let sz       = new Size(base.Width, Int32.MaxValue)\n      let sz2      = TextRenderer.MeasureText(base.Text, base.Font, sz, TextFormatFlags.WordBreak)\n      base.Height <- min sz2.Height maxHeight\n    finally\n      mGrowing <- false\n  override this.OnTextChanged( e) = \n    base.OnTextChanged e\n    this.resizeLabel()\n  override this.OnFontChanged( e) =\n    base.OnFontChanged e\n    this.resizeLabel()\n  override this.OnSizeChanged( e) =\n    base.OnSizeChanged e\n    this.resizeLabel()\n\ntype ActionBar(actions:(string * (unit -> string)) seq) =\n    let label1 = new GrowLabel (Text = \"\", Width = 300, maxHeight = 100)\n    let newButton (txt:string) act =\n        let width = 300\n        if txt.StartsWith \"---\" || txt.StartsWith \"===\" then\n            let lbl = new Label(Text = txt, Width = width)\n            lbl :> Control\n        else\n            let btn = new Button(Text = txt, Width = width)\n            btn.Click.Add act\n            btn :> Control\n    \n    let form = new Form(Text = \"Select Action:\", Width = 400, Height = 800)\n    let panel1 = new Panel(Dock = DockStyle.Fill)\n    do  actions \n        |> Seq.map (fun (txt, f) -> newButton txt (fun _ -> label1.Text <- sprintf \"Processing %s ...\" txt\n                                                            form.Refresh()\n                                                            label1.Text <- f() ))\n        |> Seq.append [ label1 :> Control ]\n        |> Seq.toArray\n        |> panel1.Controls.AddRange\n        let reposition () =\n            panel1.Controls\n            |> Seq.cast\n            |> Seq.fold (fun (height, width) (cts: Control) -> \n                cts.Left <- 20 \n                cts.Top  <- height + 5\n                (height + cts.Height + 5, (max width cts.Width)) ) (0, 0)\n            |> (fun (height, width) -> form.Height <- height + 50 ; form.Width <- width + 50)\n        reposition ()\n        label1.Resize.Add (fun _ -> reposition () )\n        panel1.DockPadding.All <- 10\n        form.Controls.Add(panel1)\n        form.Activated.AddHandler(System.EventHandler (fun _ _ -> form.TopMost <- true(*; form.TopMost <- false*) ))\n        async {\n          do Application.Run(form) \n        } |> Async.Start\n       ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"16f618b6-0483-44dc-9c54-550f4f5b725d"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"UsefulDotNet","content":"module UsefulDotNet =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"Regex, Regexs","content":"#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\nopen System.Text.RegularExpressions\n\nlet (|Regex|_|) pattern input =\n    if input = null then None else\n    try \n        let m = Regex.Match(input, pattern)\n        if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])\n        else None\n    with e -> None\n\nlet (|Regexs|) pattern input =\n    if input = null then [| |] else\n    try \n        let ms = Regex.Matches(input, pattern)\n        [| for m in ms do yield m.Value |] \n    with e -> [| |]\n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[],"id":{"$":0,"Item":"7646acbc-2c28-4159-98b1-2365d19fc97c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"fSharpError2TranspilerError","content":"open Microsoft.FSharp.Compiler.SourceCodeServices\nopen Microsoft.FSharp.Compiler\nopen Useful\n\ntype FSharpErrors =\n    | WarningFSharp                 of string\n    | ErrFSharp                     of string\nwith interface ErrMsg with\n        member this.ErrMsg    = sprintf \"%A\"this\n        member this.IsWarning = match this with | WarningFSharp _ -> true | _ -> false\n\nlet getIndentFile input =\n    match input with\n    | Regex \"^\\\\((\\\\d+)\\\\)\\\\s(.*)$\" [_ ; indent ; file] -> int indent, file\n    | _                                                 -> 0         , input\n   \nlet fSharpError2TranspilerError (error : FSharpErrorInfo) =\n    let indent, file = System.IO.Path.GetFileNameWithoutExtension error.FileName |> getIndentFile  \n    sprintf \"%s (%d,%d) - (%d,%d) %s %d: %s\" \n       file \n       error.StartLineAlternate (error.StartColumn - indent) \n       error.EndLineAlternate   (error.EndColumn   - indent) \n       error.Subcategory error.ErrorNumber error.Message\n    |> (if   error.Severity = FSharpErrorSeverity.Error  \n        then ErrFSharp     \n        else WarningFSharp\n       )\n    :> ErrMsg\n    \n    ","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"7646acbc-2c28-4159-98b1-2365d19fc97c"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"9becc68c-9cc2-4f29-82df-e510d10226db"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"ResourceAgent","content":"open Useful\n\ntype ResourceAgent<'T, 'C when 'C : equality>(restartAfter:int, ctor: 'C option ->'T, ?cleanup, ?isAlive, ?configuration: 'C) =\n    let mutable configuration = configuration\n    let mutable resource = ctor configuration\n    let respawn() =\n        cleanup |> Option.iter (fun clean -> clean resource) \n        resource <- ctor configuration\n    let agent    = \n        MailboxProcessor.Start(fun inbox ->\n            async {\n               while true do\n                 try\n                     for i in 1 .. restartAfter do\n                         let! config, work = inbox.Receive()\n                         isAlive |> Option.iter (fun alive -> if not (alive resource) then respawn())\n                         if config <> configuration then\n                            configuration <- config\n                            respawn()\n                         do!  work resource\n                     respawn()\n                 with _ -> respawn() \n            }\n        )\n    do agent.Error.AddHandler <| Handler (fun _ _ -> respawn())\n    member x.Process (work:'T -> Wrap<'a>, ?config) =\n        agent.PostAndAsyncReply\n            (fun reply ->\n                 (config, fun resource ->\n                          async {\n                               let! res = work resource |> Wrap.getAsyncR\n                               reply.Reply res\n                          } \n                 )\n            )\n    interface System.IDisposable with\n        member this.Dispose () =\n            try cleanup |> Option.iter (fun clean -> clean resource) with _ -> ()\n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"f930dc48-39e8-453c-8c77-18a2cd73637a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"TempFileName","content":"type TempFileName(fn) =\n    new () = new TempFileName(System.IO.Path.GetTempFileName())\n    member this.Name = fn\n    interface System.IDisposable with\n        member this.Dispose() = if System.IO.File.Exists fn then System.IO.File.Delete fn\n        \n        ","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[],"id":{"$":0,"Item":"4137cad8-fd64-426e-98de-16a92a56388d"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"runProcess","content":"open System.Diagnostics\nopen System.Text\nopen Useful\n\nlet runProcess p ops =\n    let procStart   = ProcessStartInfo(p, ops)\n    let proc        = new Process()\n    proc.StartInfo <- procStart\n    proc.Start() \n\ntype ShellExError =\n    | ShellExitCode              of int\n    | ShellOutput                of string\n    | ShellErrors                of string\n    | ShellFailWithMessage       of string\n    | ShellFinishedWithNoMessage \n    | ShellDidNotStart \n    | ShellCrashed               of string\nwith interface ErrMsg with\n        member this.ErrMsg    = \n            match this with \n            | ShellFailWithMessage msg   -> msg  \n            | ShellFinishedWithNoMessage -> \"warning - No output\"\n            | ShellOutput          msg   -> msg\n            | ShellCrashed         msg   -> \"Crashed \" + msg\n            | msg                        -> sprintf \"%A\" msg\n        member this.IsWarning =\n            match this with \n            | ShellFinishedWithNoMessage\n            | ShellOutput _              -> true\n            | _                          -> false \n\n\ntype ShellEx(startInfo: ProcessStartInfo) =\n    let proc                              = new Process()\n    let bufferOutput                      = new StringBuilder()\n    let bufferError                       = new StringBuilder()\n    let consume (sb: StringBuilder)       = \n        let v = sb.ToString()\n        sb.Clear() |> ignore\n        v\n    do  startInfo.RedirectStandardInput  <- true\n        startInfo.RedirectStandardOutput <- true\n        startInfo.RedirectStandardError  <- true\n        startInfo.UseShellExecute        <- false\n        proc.StartInfo                   <- startInfo\n        proc.EnableRaisingEvents         <- true\n        proc.OutputDataReceived.AddHandler(DataReceivedEventHandler(fun sender args -> try bufferOutput.Append(args.Data + \"\\n\") |> ignore with _ -> () ))\n        proc.ErrorDataReceived .AddHandler(DataReceivedEventHandler(fun sender args -> try bufferError .Append(args.Data + \"\\n\") |> ignore with _ -> () ))\n//        proc.Exited            .AddHandler(System.EventHandler     (fun sender args -> try proc.Close()                                    with _ -> () ))\n    new (program, args) =             \n        let startInfo                         = new ProcessStartInfo()\n        do  startInfo.FileName               <- program\n            startInfo.Arguments              <- args\n        new ShellEx(startInfo)\n    member this.Start() = \n        let r = proc.Start() \n        proc.BeginOutputReadLine()\n        proc.BeginErrorReadLine ()\n        r\n    member this.StartAndWait() =\n        let started = this.Start()\n        proc.WaitForExit()\n        let    output  = (consume bufferOutput).Trim()\n        let    error   = (consume bufferError ).Trim()\n        (output, error, if proc.HasExited then proc.ExitCode else -99999)\n    member this.StartAndWaitR() =\n        let out, errs, exit = this.StartAndWait()\n        if exit <> 0\n        then Result.failWithMsgs\n                [ if out  <> \"\"              then yield ErrSimple (\"stdout: \" + out           , true ) :> ErrMsg\n                  if errs <> \"\"              then yield ErrSimple (errs                       , false) :> ErrMsg\n                  if errs  = \"\" || exit <> 1 then yield ErrSimple (sprintf \"ExitCode: %d\" exit, false) :> ErrMsg\n                ]\n        else Result.succeedWithMsgs out \n                [ if errs <> \"\"              then yield ErrSimple (errs                       , false) :> ErrMsg ]\n    member this.Send(txt: string)   = proc.StandardInput.WriteLine txt\n    member this.Output  ()          = consume bufferOutput\n    member this.Error   ()          = consume bufferError\n    member this.Response(out:string, err:string)  = \n        match out.Trim(), err.Trim() with\n//        | \"\"  , \"\"  -> None\n        | good, \"\"  -> Some( Result.succeed        good                             )\n        | \"\"  , bad -> Some( Result.fail                <| ShellFailWithMessage bad )\n        | good, bad -> Some( Result.succeedWithMsg good <| ShellFailWithMessage bad )\n    member this.Response()          = this.Response(this.Output(), this.Error())\n    member this.SendAndWait(send, wait, ?onError) =\n        let eventWait = \n            if defaultArg onError false then proc.ErrorDataReceived else proc.OutputDataReceived\n            |> Event.choose (fun evArgs -> try evArgs.Data |> (fun v -> if v.Contains wait then Some <| Result.succeed v else None) with _ -> None)\n        let eventAll = Event.merge eventWait  (Event.map (fun _ -> Result.fail <| ShellCrashed startInfo.FileName) proc.Exited)\n        Wrap.wrapper {\n            do! Result.tryProtection()\n            async { \n                do!    Async.Sleep 20 \n                this.Send send        } |> Async.Start\n            let!   waitedR = Async.AwaitEvent eventAll\n            let!   waited  = waitedR\n            do!    Async.Sleep 200\n            let!   res =\n                   if defaultArg onError false then \n                       this.Response(this.Output(), this.Error() |> fun msg -> msg.Split([| waited |], System.StringSplitOptions.None) |> Array.head)\n                   else this.Response()\n                   |> Option.defaultWith (fun () -> Result.succeedWithMsg \"\" ShellFinishedWithNoMessage)\n            return res\n        }\n    member this.HasExited = try proc.HasExited with _ -> true\n    interface System.IDisposable with\n        member this.Dispose () =\n            try proc.Kill   () with _ -> ()\n            try proc.Close  () with _ -> ()\n            try proc.Dispose() with _ -> ()\n\n\nlet runProcess2 p ops =\n    let procStart   = ProcessStartInfo(p, ops)\n    let shell       = new ShellEx(procStart)\n    shell.StartAndWaitR() \n\n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"copyIfMust","content":"open System.IO\n\nlet copyIfNotExistsToFile from dest =\n    let fit = FileInfo dest\n    if not fit.Exists then\n        File.Copy(from, dest, true )\n\nlet copyIfMustToFile from dest =\n    let fit = FileInfo dest\n    let must = \n        match fit.Exists with \n        | false -> true\n        | true  ->\n            let fif = FileInfo dest\n            fif.Length <> fit.Length || fif.LastWriteTime <> fit.LastWriteTime\n    if must then\n        File.Copy(from, dest, true )\n\nlet copyIfMustToDir from destDir =\n    let dest = Path.Combine(destDir, Path.GetFileName(from))\n    copyIfMustToFile from dest\n    ","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[],"id":{"$":0,"Item":"ab5ab0ca-eb45-4851-affe-4690bb75d055"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Path.Combine","content":"let inline (+/+) a b = System.IO.Path.Combine(a, b)","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[],"id":{"$":0,"Item":"15cf771f-22b1-4796-8e34-6c16f35d6506"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CompOptions","content":"module CompOptionsModule = // needs to be in a module so (?) operator does not collide with websharper\n    \n    type CompOptionClass = \n        | OpFSharp\n        | OpWebSharper\n        | OpInternal\n    \n    type CompOption = \n        {\n            name   : string\n            unique : bool\n            opClass: CompOptionClass  \n            prefix : string\n        }\n    with\n        static member (/=) (op: CompOption, v: CompOptionValue) = op,           v\n        static member (/=) (op: CompOption, v                 ) = op, OpVText   v\n        static member (/=) (op: CompOption, v                 ) = op, OpVTextOF v\n    \n    and CompOptionValue =\n        | OpVText   of                string\n        | OpVTextOF of (CompOptions -> string)\n    with \n        member this.Value ops = \n            match this with\n            | OpVText   v  -> v\n            | OpVTextOF fo -> fo ops\n    \n    and CompOptions = CompOptions of (CompOption * CompOptionValue) []\n    with\n        member this.Pairs             =  this |> function CompOptions ops ->  ops\n        member this.Exists   f        =  this.Pairs |> Array.exists f \n        member this.Find     name     =  this.Pairs |> Array.find (fun (opT, opV) -> name = opT.name)\n        member this.FindV    name     = (this.Find name |> snd).Value this\n        member this.Contains co       =  this.Exists (fun (opT, opV) -> co   = opT                           )\n        member this.Contains v        =  this.Exists (fun (opT, opV) -> v    = opT.prefix + (opV.Value this) )\n        member this.Get      f        =  this.Pairs |> Array.filter f |> Array.map (fun (opT, opV) ->        opT.prefix + (opV.Value this) )\n        static member FSharpOptions   = fun ({opClass=cls}, _) -> cls = OpFSharp\n        static member WSharperOptions = fun ({opClass=cls}, _) -> cls = OpFSharp || cls = OpWebSharper\n        static member (?) (ops: CompOptions, name: string) = ops.FindV name\n        static member (+) (os1: CompOptions, a2: (CompOption * CompOptionValue) seq) = \n            match os1 with \n            | CompOptions a1 -> \n                a1\n                |> Array.filter (fun (opT, _) -> (not opT.unique) || (a2 |> Seq.exists (fst >> (=) opT) |> not) )\n                |> Seq.append <| a2\n                |> Seq.toArray\n                |> CompOptions\n        static member (+) (ops: CompOptions, o:   CompOption * CompOptionValue      ) = ops + [| o |]\n        static member (+) (os1: CompOptions, os2: CompOptions                       ) = match os2 with | CompOptions a2 -> os1 + a2\n    \n    let (?) (ops:CompOptions) name = ops.FindV name\n    \n    let opSnippet     = { name = \"Snippet\"     ; unique = true  ; opClass = OpInternal   ; prefix = \"++snippet:\"   }\n    let opDirectory   = { name = \"Directory\"   ; unique = true  ; opClass = OpInternal   ; prefix = \"++directory:\" }\n    let opName        = { name = \"Name\"        ; unique = true  ; opClass = OpInternal   ; prefix = \"++name:\"      }\n    let opExtension   = { name = \"Extension\"   ; unique = true  ; opClass = OpInternal   ; prefix = \"++extension:\" }\n    let opFileName    = { name = \"Filename\"    ; unique = true  ; opClass = OpInternal   ; prefix = \"++filename:\"  }\n    let opConfig      = { name = \"Config\"      ; unique = true  ; opClass = OpInternal   ; prefix = \"++config:\"    }\n    let opGenInternal = { name = \"GenInternal\" ; unique = false ; opClass = OpInternal   ; prefix = \"++\"           }\n    let opWebSharper  = { name = \"WebSharper\"  ; unique = true  ; opClass = OpInternal   ; prefix = \"++websharper:\"}\n        \n    let opIOption     = { name = \"IOption\"     ; unique = false ; opClass = OpFSharp     ; prefix = \"-I:\"          }\n    let opReference   = { name = \"Reference\"   ; unique = false ; opClass = OpFSharp     ; prefix = \"-r:\"          }\n    let opSource      = { name = \"Source\"      ; unique = false ; opClass = OpFSharp     ; prefix = \"\"             }\n    let opTarget      = { name = \"Target\"      ; unique = true  ; opClass = OpFSharp     ; prefix = \"--target:\"    }\n    let opOutput      = { name = \"Output\"      ; unique = true  ; opClass = OpFSharp     ; prefix = \"-o:\"          }\n    let opDebug       = { name = \"Debug\"       ; unique = true  ; opClass = OpFSharp     ; prefix = \"--debug:\"     }\n    let opDefine      = { name = \"Define\"      ; unique = false ; opClass = OpFSharp     ; prefix = \"--define:\"    }\n    let opGenFSharp1  = { name = \"GenFSharp1\"  ; unique = false ; opClass = OpFSharp     ; prefix = \"-\"            }\n    let opGenFSharp2  = { name = \"GenFSharp2\"  ; unique = false ; opClass = OpFSharp     ; prefix = \"--\"           }\n    \n    let opWebSite     = { name = \"Website\"     ; unique = true  ; opClass = OpWebSharper ; prefix = \"--wsoutput:\"  }\n    let opGenWSharper = { name = \"GenWSharper\" ; unique = false ; opClass = OpWebSharper ; prefix = \"--\"           }\n    \n    let dllOptions     = CompOptions [| opTarget      /= \"library\"                                                                     |]  \n    let exeOptions     = CompOptions [| opTarget      /= \"exe\"     ; opGenInternal /= \"copyassemblies\" ; opGenInternal /= \"copyconfig\" |]\n    let winExeOptions  = CompOptions [| opTarget      /= \"winexe\"  ; opGenInternal /= \"copyassemblies\" ; opGenInternal /= \"copyconfig\" |]\n    \n    let genericOptions = \n      CompOptions\n        [|\n           opSnippet     /= \"Test\"\n           opName        /= fun os -> (os?Snippet : string).Split('/') |> Array.last\n           opDirectory   /= fun os -> \"Compiled\" +/+ os?Name\n           opExtension   /= fun os -> match os?Target with | \"library\" -> \"dll\" | _ -> \"exe\"\n           opFileName    /= fun os -> os?Directory +/+ os?Name + \".fs\"\n           opSource      /= fun os -> os?Filename\n           opOutput      /= fun os -> System.IO.Path.ChangeExtension(os?Source, os?Extension)\n           opConfig      /= fun os -> os?Output + \".config\"\n           opWebSharper  /= fun os -> if (os:CompOptions).Exists (fun (opT, opV) -> opT.opClass = OpWebSharper) then \"1\" else \"0\"\n        |]\n        \n    let siteOptions =\n      CompOptions\n        [|\n           opGenWSharper /= \"ws:Site\"\n           opWebSite     /= fun os -> os?Directory +/+ \"website\"\n           opGenWSharper /= fun os -> sprintf \"project:%s\"  os?Name\n        |] \n     \n    let wsProjectOptions =\n      CompOptions\n        [|\n           opGenWSharper /= fun os -> sprintf \"project:%s\"  os?Name\n        |] \n     \n    let debugOptions = \n      CompOptions\n        [|\n           opGenFSharp1  /= \"g\"\n           opDebug       /= \"full\"\n           opDefine      /= \"DEBUG\"\n           opDefine      /= \"TRACE\"\n           opGenFSharp2  /= \"optimize-\"\n           opGenFSharp2  /= \"tailcalls-\"\n        |]\n    \n    let otherOptions =\n      CompOptions\n        [|\n           //@\"--noframework\"\n           opGenFSharp2  /= \"warn:3\"\n           opGenFSharp2  /= \"warnaserror:76\"\n           opGenFSharp2  /= \"vserrors\"\n           opGenFSharp2  /= \"utf8output\"\n           opGenFSharp2  /= \"fullpaths\"\n           opGenFSharp2  /= \"flaterrors\"\n           opGenFSharp2  /= \"subsystemversion:6.00\"\n           opGenFSharp2  /= \"highentropyva+\"\n           opGenInternal /= \"removelinedirectives\"\n        |]\n    \n    let compileOptionsDll (snp:string) = \n        genericOptions\n        + dllOptions\n        + otherOptions\n        + opSnippet     /= snp\n        \n    let compileOptionsDllDebug (snp:string) = compileOptionsDll snp + debugOptions        \n    let compileOptionsExeDebug    snp = compileOptionsDllDebug snp + exeOptions   \n    let compileOptionsWinExeDebug snp = compileOptionsDllDebug snp + winExeOptions\n        \n    let prepOptions (options:CompOptions) (code : string [], assembs : string [], defines : string [], prepoIs : string [], nowarns : string []) =\n        let  code2 =\n           [\n              yield! nowarns |> Seq.distinct |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\")\n              yield! code \n           ] |> String.concat \"\\n\"\n        let  fileName = options?Filename\n        do   System.IO.File.WriteAllText(fileName, code2)\n        let  options2 = \n             options  + [|\n                           yield! prepoIs |> Array.map ((/=) opIOption  ) \n                           yield! assembs |> Array.map ((/=) opReference)\n                           yield! defines |> Array.map ((/=) opDefine   )\n                           if options.Contains \"++staticlinkall\" then \n                               yield! assembs |> Array.map (System.IO.Path.GetFileNameWithoutExtension >> ((+) \"staticlink:\") >> ((/=) opGenFSharp2 ))         \n                        |]\n        if options.Contains \"++copyassemblies\" then \n            assembs |> Array.iter (fun f -> System.IO.Path.GetDirectoryName(fileName) |> copyIfMustToDir f)      \n        if options2.Contains \"++showoptions\"    then printfn \"%s\" (options2.Get (fun _ -> true) |> String.concat \"\\n\")               \n        options2\n    \n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"ab5ab0ca-eb45-4851-affe-4690bb75d055"},{"$":0,"Item":"15cf771f-22b1-4796-8e34-6c16f35d6506"}],"id":{"$":0,"Item":"ef053bdf-997b-49c8-a401-1611a568bd8a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"RemotingDll","content":"#r @\"..\\packages\\FSharp.Data\\lib\\net40\\FSharp.Data.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net40\\FSharp.Data.DesignTime.dll\"\n\n#define WEBSHARPER\n#define FSS_SERVER\n\nopen System\nopen System.Net\nopen System.Text\nopen System.IO\nopen WebSharper\n//open WebSharper.Remoting\n//open WebSharper.JavaScript\n\n#if FSS_SERVER\nlet sendRequestRpcEP     = \"RemotingDll:FSSGlobal.UsefulDotNet.sendRequest:-426626804\"\nlet awaitRequestForRpcEP = \"RemotingDll:FSSGlobal.UsefulDotNet.awaitRequestFor:-439983525\"\nlet replyToRpcEP         = \"RemotingDll:FSSGlobal.UsefulDotNet.replyTo:-1092841374\"\n#else\nlet sendRequestRpcEP     = \"Remote:CIPHERPrototype.Messaging.sendRequest:1096816393\"\nlet awaitRequestForRpcEP = \"Remote:CIPHERPrototype.Messaging.awaitRequestFor:278590570\"\nlet replyToRpcEP         = \"Remote:CIPHERPrototype.Messaging.replyTo:-1092841374\"\n#endif\n\n\n#if WEBSHARPER\n[< JavaScript >]\n#endif\nmodule Messaging =\n    type AddressId = AddressId of string\n    \n    type Request = {\n        toId              : AddressId\n        fromId            : AddressId\n        content           : string\n        mutable messageId : Guid option\n    }\n    \n    type MBMessage =\n    | Listener of AddressId * (Request->unit) * (exn->unit) * (OperationCanceledException->unit)\n    | Request  of Request   * (string ->unit) * (exn->unit) * (OperationCanceledException->unit)\n    | Reply    of Guid      *  string\n    \n    type POMessage =\n    | POIdentification\n    | POEcho   of string\n    | POListeners\n    | POPendingRequests\n    | POPendingReplys\n    \n    type POResponse =\n    | POString  of string\n    | POStrings of string[]\n\nopen Messaging\n\nlet extract n (s:string) = s.Substring(0, min n s.Length)\nlet now() = System.DateTime.UtcNow.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n\ntype PostOffice() =\n    let mutable listeners = [| |]\n    let mutable requests  = [| |]\n    let mutable sent      = [| |]\n    let agent = MailboxProcessor.Start(fun mail ->\n        async {\n            while true do\n                let! mbMsg = mail.Receive()\n                match mbMsg with\n                | Listener                    (listener, lfs, lfe, lfc)  ->\n                    requests\n                    |> Array.indexed\n                    |> Array.tryPick (fun (i, (request , rfs, rfe, rfc)) -> \n                        if request.toId <> listener then None else\n                        requests <- Array.append requests .[0..i-1]  requests .[i+1..requests .Length - 1]\n                        Some(lfs, request, rfs))\n                    |> (fun v -> (if v.IsNone then \n                                    listeners <- \n                                        listeners \n                                        |> Array.filter(fun (lnr, lfs, exn, cen) -> \n                                            if lnr = listener then\n                                                //exn <| DivideByZeroException ()\n                                                //exn <| TimeoutException ()\n                                                lfs <| {\n                                                            toId      = AddressId \"\"\n                                                            fromId    = AddressId \"\"\n                                                            content   = \"{\\\"$\\\":0}\"\n                                                            messageId = None\n                                                        }\n                                                false\n                                            else true) \n                                        |> Array.append [| listener, lfs, lfe, lfc |]); v)\n                | Request                     (request , rfs, rfe, rfc)  ->\n                    listeners\n                    |> Array.indexed\n                    |> Array.tryPick (fun (i, (listener, lfs, lfe, lfc)) -> \n                        if request.toId <> listener then None else \n                        listeners <- Array.append listeners.[0..i-1] listeners.[i+1..listeners.Length - 1]\n                        Some(lfs, request, rfs))\n                    |> (fun v -> (if v.IsNone then requests  <- requests  |> Array.append [| request , rfs, rfe, rfc |]); v)\n                | Reply                       (reply   , response)  ->\n                    sent\n                    |> Array.indexed\n                    |> Array.pick (fun (i, (request , rfs)) -> \n                        if request.messageId.Value <> reply then None else\n                        sent      <- Array.append sent     .[0..i-1] sent     .[i+1..sent     .Length - 1]\n                        rfs response\n                        Some ())\n                    None\n                |> Option.iter (fun (lfs, request, rfs) -> \n                    request.messageId <- Some <| Guid.NewGuid()\n                    sent <- sent |> Array.append [| request, rfs |]\n                    lfs request\n                )\n        }\n    )\n    with\n        member this.AwaitRequest    listener  fs fe fc = agent.Post <| Listener (listener, fs, fe, fc)\n        member this.SendRequest     request   fs fe fc = \n            printfn \"%s Request: %A %A %A\" (now()) request.toId request.fromId (extract 80 request.content)\n            agent.Post <| Request  (request , fs, fe, fc)\n        member this.ReplyTo         request   response = \n            printfn \"%s Reply:   %s\"       (now()) (extract 100 response)\n            agent.Post <| Reply    (request , response  )\n        member this.Listeners       ()                 = listeners |> Array.map (function | AddressId id, _, _, _ -> id)\n        member this.Requests        ()                 = requests  |> Array.map (sprintf \"%A\")\n        member this.Sent            ()                 = sent      |> Array.map (sprintf \"%A\")\n\nlet postOffice = PostOffice()\n\n[< Rpc >]\nlet awaitRequestFor (listener:AddressId) =\n    let startAsync (fs, fe, fc) = postOffice.AwaitRequest listener fs fe fc\n    Async.FromContinuations startAsync\n\n[< Rpc >]\nlet replyTo    (reply:Guid) response =\n    async {\n        postOffice.ReplyTo reply response\n    }\n\nopen FSharp.Data\nopen FSharp.Data.JsonExtensions\n\n[< Rpc >]\nlet sendRequest  toId fromId content =\n    if toId = AddressId \"WebServer:PostOffice\" then\n        async {\n            let msg = Json.Deserialize<POMessage> content\n            return\n                match msg with\n                | POIdentification  -> POString     \"WebServer:PostOffice\"\n                | POEcho        txt -> POString     txt\n                | POListeners       -> POStrings <| postOffice.Listeners()\n                | POPendingRequests -> POStrings <| postOffice.Requests ()\n                | POPendingReplys   -> POStrings <| postOffice.Sent     ()\n                |> Json.Serialize \n        }\n    else\n    let startAsync (fs, fe, fc) = postOffice.SendRequest   \n                                    { toId      = toId   \n                                      fromId    = fromId \n                                      content   = content \n                                      messageId = None }\n                                    fs fe fc\n    Async.FromContinuations startAsync\n\nlet RpcCall (url:string) method (data:string) =\n    async {\n        //printfn \"RpcCall %s\" (extract 100 data)\n        let req = WebRequest.Create(url) :?> HttpWebRequest \n        req.Timeout         <- 300_000\n        req.ProtocolVersion <- HttpVersion.Version10\n        req.Method          <- \"POST\"\n        req.ContentType     <- \"application/json\"\n        req.Headers.Add(\"x-websharper-rpc\", method            )\n        let postBytes = Encoding.ASCII.GetBytes(data)\n        req.ContentLength <- int64 postBytes.Length\n        let reqStream = req.GetRequestStream() \n        reqStream.Write(postBytes, 0, postBytes.Length);\n        reqStream.Close()\n        \n        // Obtain response and download the resulting page \n        // (The sample contains the first & last name from POST data)\n        use resp   = req.GetResponse() \n        use stream = resp.GetResponseStream() \n        use reader = new StreamReader(stream)\n        let msg    = reader.ReadToEnd()\n        //printfn \"RpcCallResponse %s\" (extract 100 msg)\n        let json   = JsonValue.Parse msg\n        return       json.[\"$DATA\"]\n    }\n\nlet serializeAddressId aId =\n    match aId with\n    | AddressId v -> sprintf \"\"\"{\"$\":0,\"$0\":\"%s\"}\"\"\" v\n\nlet sendRequestRpc (toId: AddressId) (fromId: AddressId) (content: string): Async<string> =\n    async {\n        let! msg =\n            [| serializeAddressId toId ; serializeAddressId fromId ; Json.Serialize content |]\n            |> String.concat \", \"\n            |> sprintf \"[%s]\"\n            |> RpcCall WebSharper.Remoting.EndPoint sendRequestRpcEP\n        return msg.AsString()\n    }\n\nlet awaitRequestForRpc (listener:AddressId) =\n    async {\n        let! msg =\n            [| serializeAddressId listener |]\n            |> String.concat \", \"\n            |> sprintf \"[%s]\"\n            |> RpcCall WebSharper.Remoting.EndPoint awaitRequestForRpcEP\n        let  v = msg.[\"$V\"]\n        let req    =\n            {\n                toId      = AddressId <| v?toId  .[\"$V\"].[\"$0\"].AsString()\n                fromId    = AddressId <| v?fromId.[\"$V\"].[\"$0\"].AsString()\n                content   = v?content                          .AsString()\n                messageId = Some <| v?messageId  .[\"$V\"].[\"$0\"].AsGuid  ()\n            }\n        return req\n    }\n\nlet replyToRpc (reply:Guid) response =\n    async {\n        let! msg =\n            [| sprintf \"\\\"%s\\\"\" <| reply.ToString() ; Json.Serialize response |]\n            |> String.concat \", \"\n            |> sprintf \"[%s]\"\n            |> RpcCall WebSharper.Remoting.EndPoint replyToRpcEP\n        return ()\n    }\n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"82ab58ca-79e8-47f9-8917-f444d3320751"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FsEvaluator","content":"module FsEvaluator =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"a70b4838-75d6-40c3-9a0c-5bd03c57cce5"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"evalFsiExe","content":"open Useful\n\nmodule Evaluator =\n    open System.Diagnostics\n    open UsefulDotNet\n    \n    type FsiExe(config) =\n        let startInfo                 = ProcessStartInfo(@\"fsiAnyCPU.exe\", config |> String.concat \" \")             \n        let shell                     = new ShellEx(startInfo)  // --noninteractive\n        let endToken                  = \"xXxY\" + \"yYyhH\"\n        do  startInfo.CreateNoWindow <- false\n            shell.Start() |> ignore\n        member this.Eval txt =\n            Wrap.wrapper {\n                do! Result.tryProtection()\n                shell.Send txt \n                shell.Send \";;\"\n                let! res = shell.SendAndWait(endToken + \";;\", endToken, true)\n                return res\n            }\n        member this.IsAlive = not shell.HasExited\n        interface System.IDisposable with\n            member this.Dispose () = \n                (shell :> System.IDisposable).Dispose()\n    \n    let fsiExe = lazy new ResourceAgent<_, string> (20, (fun config -> new FsiExe([\"--nologo\" ; \"--quiet\" ; defaultArg config \"\"] )), (fun fsi -> (fsi :> System.IDisposable).Dispose()), (fun fsi -> fsi.IsAlive), \"\")\n\n    let extractConfig (code:string[]) = if code.[0].StartsWith \"////-d:\" then code.[0].[4..] else \"\"\n\n    let evalFsiExe (code:string) =\n        Wrap.wrapper {\n            let config = extractConfig (code.Split '\\n')\n            let! resR = fsiExe.Value.Process(fun fsi -> \n                Wrap.wrapper {\n                  do! Result.tryProtection()\n                  let! res = fsi.Eval code \n                  return res\n                }\n            , config)\n            let! res = resR\n            return res\n        }\n\n#define WEBSHARPER\nopen WebSharper\n\n[< Rpc >]\nlet evaluateAS source =\n    async {\n        let!    res  = Evaluator.evalFsiExe source |> Wrap.getAsyncR \n        return  res |> Result.mapMsgs (Seq.map (fun (e:ErrMsg) -> e.ErrMsg, e.IsWarning) >> Seq.toArray)\n    }\n    \n[< JavaScript >]\nlet evaluateAR source =\n    async {\n        let!   vO, msgs = evaluateAS source\n        return  Result (vO,  msgs |> Seq.map (fun (msg, wrn) -> ErrSimple(msg, wrn) :> ErrMsg) |> Seq.toList)\n    }\n    ","parent":{"$":0,"Item":"a70b4838-75d6-40c3-9a0c-5bd03c57cce5"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},{"$":0,"Item":"f930dc48-39e8-453c-8c77-18a2cd73637a"},{"$":0,"Item":"b7c2d8cd-7246-4ad1-af46-ffbb7acde6e0"},{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"}],"id":{"$":0,"Item":"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FsStationShared","content":"#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule FsStationShared =\n","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"MessagingClient","content":"#define FSS_SERVER\n\n#if FSS_SERVER\nopen FSSGlobal.UsefulDotNet\nopen FSSGlobal.UsefulDotNet.Messaging\n#r @\"Compiled\\RemotingDll\\RemotingDll.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net40\\FSharp.Data.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net40\\FSharp.Data.DesignTime.dll\"\n#else\n\n//#r \"remote.dll\"\nopen CIPHERPrototype.Messaging\n#endif\nopen WebSharper\nopen Useful\n//open UsefulFewJS\n//open UsefulFewJS.Messaging\n\n#if WEBSHARPER\n[< Inline \"true\" >]\n#endif          \nlet inJavaScript = false\n\nlet selectF fj fn =\n    match inJavaScript with\n    | true  -> fj\n    | false -> fn\n    \n#if WEBSHARPER\nlet AsyncStart asy     = Async.StartWithContinuations(asy, id, (fun e -> JS.Alert(e.ToString()) ), fun c -> JS.Alert(c.ToString()))    \n[< Inline \"\" >]\nlet awaitRequestForRpc = awaitRequestForRpc\n[< Inline \"\" >]\nlet sendRequestRpc     = sendRequestRpc\n[< Inline \"\" >]\nlet replyToRpc         = replyToRpc\n#else\nlet AsyncStart asy = Async.Start asy\n#endif          \n\nlet  AddressId = AddressId\n\nlet awaitRequestForF = selectF awaitRequestFor awaitRequestForRpc\nlet sendRequestF     = selectF sendRequest         sendRequestRpc\nlet replyToF         = selectF replyTo                 replyToRpc\nlet AsyncStartF      = selectF AsyncStart             Async.Start\n\ntype MessagingClient(clientId, ?timeout, ?endPoint:string) =\n    let wsEndPoint = endPoint    |> Option.defaultValue \"##FSHARPSTATION_ENDPOINT##\"\n    let tout       = timeout     |> Option.defaultValue 100_000\n    let fromId     = AddressId clientId\n    do WebSharper.Remoting.EndPoint <- wsEndPoint \n    let awaitMessage respond =\n        async {\n            while true do\n                printfn \"%s awaitRequest %s\" (nowStamp()) clientId\n                let! msgA  = Async.StartChild(awaitRequestForF fromId, tout)\n                try\n                    let! msg   = msgA\n                    let! resp  = respond clientId msg.content\n                    do!          replyToF msg.messageId.Value resp\n                with \n                | :? System.TimeoutException -> ()\n                | e                          -> printfn \"%A\" e\n        } \n        |> AsyncStartF\n    let sendMessage  toId msg = sendRequestF toId fromId msg\n    let poMsg checkResponse msg =\n        async {\n            let! resp = sendMessage (AddressId \"WebServer:PostOffice\") (Json.Serialize<POMessage> msg)\n            return checkResponse (Json.Deserialize<POResponse> resp)\n        }\n    let poString resp =\n                match resp with\n                | POString  v  -> v\n                | POStrings vs -> sprintf \"%A\" vs\n    let poStrings resp =\n                match resp with\n                | POString  v  -> [| sprintf \"unexpected response: %s\" v |]\n                | POStrings vs -> vs\n  with \n    member this.AwaitMessage respond  = awaitMessage (fun clientId request -> async { return respond clientId request })\n    member this.AwaitMessage respondA = awaitMessage respondA\n    member this.SendMessage toId msg  = sendMessage toId msg\n    member this.POMessage        msg  = poMsg id        msg\n    member this.POListeners      ()   = poMsg poStrings POListeners\n    member this.EndPoint              = wsEndPoint\n    member this.ClientId              = clientId\n    static member EndPoint_           = \"##FSHARPSTATION_ENDPOINT##\"\n    ","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"7a655466-e218-4121-a7b6-f9c70a922e07"}],"id":{"$":0,"Item":"eb54ba64-3d11-4347-97c8-aeae9e3e3121"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CodeSnippet","content":"open Useful\n\nlet snippetName name (content: string) =\n    if name <> \"\" then name else \n    content.Split([| '\\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n    |> Seq.map    (fun l -> l.Trim())\n    |> Seq.filter (fun l -> not (l.StartsWith(\"#\") || l.StartsWith(\"[<\") || l.StartsWith(\"//\")))\n    |> Seq.tryHead\n    |> Option.defaultValue \"<empty>\"\n\nlet sanitize n =\n    let illegal = [|'\"'   ; '<'   ; '>'   ; '|'   ; '\\000'; '\\001'; '\\002'; '\\003'; '\\004'; '\\005'; '\\006';\n                    '\\007'; '\\b'  ; '\\009'; '\\010'; '\\011'; '\\012'; '\\013'; '\\014'; '\\015';\n                    '\\016'; '\\017'; '\\018'; '\\019'; '\\020'; '\\021'; '\\022'; '\\023'; '\\024';\n                    '\\025'; '\\026'; '\\027'; '\\028'; '\\029'; '\\030'; '\\031'; ':'   ; '*'   ; '?';\n                    '\\\\'  ; '/'|] //\"\n    n |> String.filter (fun c -> not <| Array.contains c illegal)\n\ntype CodeSnippetId = CodeSnippetId of System.Guid   \nwith static member New = CodeSnippetId <| System.Guid.NewGuid()\n     member this.Text  = match this with CodeSnippetId guid -> guid.ToString()\n\ntype CodeSnippet = {\n    name         : string\n    content      : string\n    parent       : CodeSnippetId option\n    predecessors : CodeSnippetId list\n    id           : CodeSnippetId\n    expanded     : bool\n    level        : int\n    levelCode    : int\n    properties   : System.Collections.Generic.Dictionary<string, string>\n} with\n    member this.Name = snippetName this.name this.content\n    member this.NameSanitized =\n        this.Name\n        |> sanitize\n        |> (fun c -> this.id.Text + \" \" + c + \".fsx\")\n//    member this.ContentIndented addLinePrepos =\n//        let indent        = this.levelCode * 2\n//        let indentF, prfx = if indent = 0         then (id, \"\") else (Array.map    (fun (l, pr) -> String.replicate indent \" \" + l, pr), sprintf\"(%d)\" indent)\n//        let addLinePs     = if not addLinePrepos  then  id      else  Array.append [| sprintf \"# 1 @\\\"%s%s\\\"\" prfx this.NameSanitized |] \n//        this.content.Split('\\n') \n//        |> addLinePs\n//        |> separatePrepros (not addLinePrepos)\n//        |> indentF\n//      , indent\n\n// tail recursion does not optimize\nlet rec preds fetcher outs (ins : CodeSnippetId list) : CodeSnippetId list =\n    match ins with\n    | []         -> outs\n    | hd :: rest -> List.collect id [ rest ; hd |> fetcher |> Option.toList |> List.collect (fun s -> s.parent |> Option.toList |> List.append <| s.predecessors) ]\n                    |> preds fetcher (if outs |> Seq.contains hd then outs else hd::outs)\n\nlet predsL fetcher (ins : CodeSnippetId list) : CodeSnippetId list =\n    let mutable ins  = ins \n    let mutable outs = []\n    while not ins.IsEmpty do\n        match ins with\n        | []         -> ()\n        | hd :: rest -> if outs |> Seq.contains hd then\n                            ins  <- rest\n                        else\n                            ins  <- List.collect id [ rest ; hd |> fetcher |> Option.toList |> List.collect (fun s -> s.parent |> Option.toList |> List.append <| s.predecessors) ]\n                            outs <- hd::outs\n    outs\n\ntype CodeSnippet with\n    member this.UniquePredecessors (fetcher: CodeSnippetId -> CodeSnippet option) = predsL fetcher [ this.id ]        \n    static member TryFindByKey  snps key = snps |> Seq.tryFind (fun snp        -> snp.id = key)\n    member this.SeparateCode addLinePrepos =\n        let noLinePre     = not addLinePrepos || this.properties.ContainsKey \"NoLinePre\"\n        let indent        = this.levelCode * 2\n        let indentF, prfx = if indent = 0         then (id, \"\") else (Array.map    (fun (l, pr) -> String.replicate indent \" \" + l, pr), sprintf\"(%d)\" indent)\n        let addLinePs     = if noLinePre          then  id      else  Array.append [| sprintf \"# 1 @\\\"%s%s\\\"\" prfx this.NameSanitized |]\n        let code, assembs, defines, prepIs, nowarns  =\n            this.content.Split('\\n') \n            |> addLinePs\n            |> separatePrepros (not addLinePrepos)\n            |> indentF\n            |> separateDirectives\n        [| this.NameSanitized, code.Length, indent |] , code, assembs, defines, prepIs, nowarns\n    static member AddSeps (lines1:(string*int*int)[], code1:string[], assembs1:string[], defines1:string[], prepIs1:string[], nowarns1:string[])\n                          (lines2:(string*int*int)[], code2:string[], assembs2:string[], defines2:string[], prepIs2:string[], nowarns2:string[]) =\n        Array.append lines1   lines2\n      , Array.append code1    code2\n      , Seq  .append assembs1 assembs2 |> Seq.distinct |> Seq.toArray\n      , Seq  .append defines1 defines2 |> Seq.distinct |> Seq.toArray\n      , Seq  .append prepIs1  prepIs2  |> Seq.distinct |> Seq.toArray\n      , Seq  .append nowarns1 nowarns2 |> Seq.distinct |> Seq.toArray\n    static member ReducedCode  addLinePrepos (snippets: CodeSnippet seq) =\n        snippets\n        |> Seq.map(fun snp -> snp.SeparateCode addLinePrepos)\n        |> fun snps -> if snps |> Seq.isEmpty then seq [ [||],  [||],  [||],  [||],  [||],  [||] ] else snps\n        |> Seq.reduce CodeSnippet.AddSeps\n        |> fun (lines, code, assembs, defines, prepIs, nowarns) ->\n           (lines, code |> String.concat \"\\n\" |> Array.singleton, assembs, defines, prepIs, nowarns)\n    static member FinishCode addLinePrepos (lines:(string*int*int)[],code:string[], assembs:string[], defines:string[], prepIs:string[], nowarns:string[]) =\n        let config = defines |> Seq.sort |> Seq.map ((+)\"-d:\") |> String.concat \" \"\n        let part1  =\n          [ if config <> \"\" then yield \"////\" + config\n            yield! prepIs  |> Seq.map (sprintf \"#I @\\\"%s\\\"\"    )\n            yield! assembs |> Seq.map (sprintf \"#r @\\\"%s\\\"\"    )\n            if addLinePrepos && (nowarns |> Seq.isEmpty |> not) then yield \"# 1 \\\"required for nowarns to work\\\"\"\n            yield! nowarns |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\")\n          ]\n        Seq.append part1 code |> String.concat \"\\n\"\n      , lines \n        |> Seq.mapFold (fun firstLine (name, len, ind) -> (name, (ind, firstLine, firstLine + len)), firstLine + len) part1.Length\n        |> fst\n        |> Seq.toArray\n    static member CodeAndStarts   addLinePrepos (snippets:CodeSnippet seq) =\n        CodeSnippet.ReducedCode   addLinePrepos snippets\n        |> CodeSnippet.FinishCode addLinePrepos\n    static member CodeFsx         addLinePrepos snps = CodeSnippet.CodeAndStarts addLinePrepos snps |> fst\n//    static member CodeMerged  addLinePrepos (snippets: CodeSnippet seq) =\n//        let bySnippet = \n//            snippets\n//            |> Seq.map(fun snp -> \n//                let code, indent = snp.ContentIndented addLinePrepos\n//                snp, indent, code\n//            )\n//        (bySnippet, bySnippet |> Seq.collect (function _, _, code -> code))\n//    static member CodeParts addLinePrepos snippets =\n//        let bySnippet, merged                        = CodeSnippet.CodeMerged addLinePrepos snippets\n//        let code, assembs, defines, prepIs, nowarns  = separateDirectives merged\n//        let config = defines |> Seq.distinct |> Seq.sort |> Seq.map ((+)\"-d:\")             |> String.concat \" \"\n//        [   if config <> \"\" then yield \"////\" + config\n//            yield! prepIs  |> Seq.distinct             |> Seq.map (sprintf \"#I @\\\"%s\\\"\"    )\n//            yield! assembs |> Seq.distinct             |> Seq.map (sprintf \"#r @\\\"%s\\\"\"    )\n//            if addLinePrepos && (nowarns |> Seq.isEmpty |> not) then yield \"# 1 \\\"required for nowarns to work\\\"\"\n//            yield! nowarns |> Seq.distinct             |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\")\n//        ], code, bySnippet\n//    static member CodeFsx0 addLinePrepos (cur, snippets) =\n//        let part1, part2, bySnippet = CodeSnippet.CodeParts addLinePrepos (Array.append snippets [| cur |])\n//        [ yield! part1 ; yield! part2 ] |> String.concat \"\\n\"\n\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"657c8f34-c917-4659-825d-c9ead206efcf"},{"$":0,"Item":"b59aa3c7-13d9-4f78-98ea-307182bf4bd4"},{"$":0,"Item":"ace1fc12-3dfb-4db8-80c9-5bde1e7d0597"}],"id":{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FSMessage,FSResponse","content":"type FSMessage =\n    | GetIdentification\n    | GenericMessage        of string\n    | GetSnippetContentById of CodeSnippetId\n    | GetSnippetCodeById    of CodeSnippetId\n    | GetSnippetPredsById   of CodeSnippetId\n    | GetSnippetById        of CodeSnippetId\n    | GetSnippetContent     of string []\n    | GetSnippetCode        of string []\n    | GetSnippetPreds       of string []\n    | GetSnippet            of string []\n    | GetSnippetJSCode      of string []\n    | GetWholeFile\n    | RunSnippetUrlJSById   of CodeSnippetId * string\n    | RunSnippetUrlJS       of string []     * string\n\ntype FSSeverity =\n    | FSError\n    | FSWarning\n    | FSInfor\n\ntype FSResponse =\n    | IdResponse        of string\n    | StringResponse    of string option\n    | SnippetResponse   of CodeSnippet option\n    | SnippetsResponse  of CodeSnippet []\n    | StringResponseR   of string option * (string * FSSeverity)[]\n\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"}],"id":{"$":0,"Item":"f6ebdffc-049c-4493-8de8-e32072419479"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FsStationClient","content":"\ntype FsStationClientErr =\n    | FSMessage             of string * FSSeverity\n    | ``Snippet Not Found`` of string\nwith interface ErrMsg with\n        member this.ErrMsg    = \n            match this with \n            | FSMessage (msg, sev    )   -> sprintf \"%A %s\" sev msg\n            | msg                        -> sprintf \"%A\"        msg\n        member this.IsWarning =     \n            match this with \n            | FSMessage (_  , FSError)   -> true\n            | msg                        -> false\n\ntype FsStationClient(clientId, ?fsStationId:string, ?timeout, ?endPoint) =\n    let fsIds      = fsStationId |> Option.defaultValue \"##FSHARPSTATION_ID##\"\n    let msgClient  = MessagingClient(clientId, ?timeout= timeout, ?endPoint= endPoint)\n    let toId       = AddressId fsIds\n    let stringResponseR response =\n        match response with\n        | StringResponseR (Some code, msgs) -> Result.succeedWithMsgs code (msgs |> Seq.map (fun v -> FSMessage v :> ErrMsg) |> Seq.toList)\n        | _                                 -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let stringResponse  response =\n        match response with\n        | StringResponse (Some code)    -> Result.succeed code\n        | _                             -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let snippetsResponse response =\n        match response with\n        | SnippetsResponse snps         -> Result.succeed snps\n        | _                             -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let snippetResponse response =\n        match response with\n        | SnippetResponse  snp          -> Result.succeed snp\n        | _                             -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    [< Inline >]\n    let sendMsg toId (msg: FSMessage) (checkResponse: FSResponse -> Result<'a>) =\n        Wrap.wrapper {\n            let!   response = msgClient.SendMessage toId (msg |> Json.Serialize)\n            let!   resp     = checkResponse (Json.Deserialize<FSResponse> response)\n            return resp\n        } \n  with \n    member this.SendMessage     (toId2,  msg:FSMessage) = sendMsg toId2  msg    Result.succeed   \n    member this.SendMessage     (        msg:FSMessage) = sendMsg toId   msg    Result.succeed   \n    member this.RequestSnippet  (    snpPath:string   ) = sendMsg toId  (GetSnippet          (snpPath.Split '/'     ))    snippetResponse  \n    member this.RequestCode     (    snpPath:string   ) = sendMsg toId  (GetSnippetCode      (snpPath.Split '/'     ))    stringResponse   \n    member this.RequestJSCode   (    snpPath:string   ) = sendMsg toId  (GetSnippetJSCode    (snpPath.Split '/'     ))    stringResponseR  \n    member this.RequestPreds    (    snpPath:string   ) = sendMsg toId  (GetSnippetPreds     (snpPath.Split '/'     ))    snippetsResponse \n    member this.RequestPredsById(      snpId          ) = sendMsg toId  (GetSnippetPredsById  snpId                  )    snippetsResponse \n    member this.RequestWholeFile(                     ) = sendMsg toId   GetWholeFile                                     stringResponse   \n    member this.GenericMessage  (        txt:string   ) = sendMsg toId  (GenericMessage       txt                    )    stringResponse   \n    member this.RunSnippet      (url,snpPath:string   ) = sendMsg toId  (RunSnippetUrlJS     (snpPath.Split '/', url))    stringResponseR\n    member this.FSStationId                             = fsIds\n    member this.MessagingClient                         = msgClient    \n    static member FSStationId_                          = \"##FSHARPSTATION_ID##\"\n\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"eb54ba64-3d11-4347-97c8-aeae9e3e3121"},{"$":0,"Item":"f6ebdffc-049c-4493-8de8-e32072419479"}],"id":{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FsStationClient Save Extension","content":"//open CIPHERPrototype.Messaging\nopen Useful\nopen System.IO\n\nlet backupFile file = \n    try File.Delete(      file + \".bak\") ; printfn \"Deleted %s.bak\" file with _ -> ()\n    try File.Copy  (file, file + \".bak\") with _ -> ()\n\ntype FsStationClient with\n    member this.Save(contentW:Wrap<string>, msgBefore, path, file, printMsg) =\n        Wrap.wrapper {\n            printMsg <| sprintf \"%s\" msgBefore\n            let! content = contentW\n            let fullName = Path.Combine(path, file)\n            backupFile fullName\n            File.WriteAllText(fullName, content)\n            printMsg <| sprintf \"Saved %s.\" fullName\n        } |> Wrap.runSynchronouslyS false |> printMsg\n    member this.Save(contentW:Wrap<string>, msgBefore, path, file) = this.Save(contentW, msgBefore, path, file, printfn \"%s\")\n    member this.SaveSnippetJS  path snippet = this.Save(this.RequestJSCode snippet, sprintf \"Compiling %s to JavaScript\" snippet, path, (snippet.Split '/' |> Seq.last) + \".js\" )\n    member this.SaveSnippetFsx path snippet = this.Save(this.RequestCode   snippet, sprintf \"Saving %s to F#\"            snippet, path, (snippet.Split '/' |> Seq.last) + \".fsx\")\n    member this.SaveWholeFile  path name    = this.Save(this.RequestWholeFile()   , sprintf \"Saving to %s.fsjson\"        name   , path, name + \".fsjson\"                        )\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"},{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"}],"id":{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FsStationClient Compile Extension","content":"#r @\"..\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.CompOptionsModule\nopen System.IO\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n\ntype CodeSnippet with\n    static member PrepareCompileOptions (options1: CompOptions) (snps: CodeSnippet seq) =\n        let  addLinePrepos =  options1.Contains \"++removelinedirectives\" |> not\n        let  lines, code, assembs, defines, prepoIs, nowarns = CodeSnippet.ReducedCode addLinePrepos snps\n        let  options2      = prepOptions options1 (code, assembs, defines, prepoIs, nowarns)\n        options2\n\ntype FsStationClient with\n    member this.PrepareCompileOptions(options1) = \n        Wrap.wrapper {\n            let  snpPath   = options1?Snippet\n            let!   preds   = this.RequestPreds snpPath\n            let    options = CodeSnippet.PrepareCompileOptions options1 preds\n            return options\n        }\n    member this.CompileFSharpW(options:CompOptions) = \n        Wrap.wrapper {\n            let! msgs, exit = options.Get CompOptions.FSharpOptions \n                              |> Array.append [| \"IGNORED_Fsc.exe\" |] \n                              |> FSharpChecker.Create().Compile\n            let  errs       = [ yield! msgs |> Array.map fSharpError2TranspilerError\n                                if exit <> 0 && (exit <> 1 || msgs.Length = 0) then yield ErrSimple (sprintf \"ExitCode: %d\" exit, false) :> ErrMsg\n                              ]\n            let! res        = if   exit <> 0\n                              then Result.failWithMsgs                errs\n                              else Result.succeedWithMsgs \"Compiled!\" errs\n            return res\n        }\n    member this.CompileWebSharperW(options:CompOptions) =\n        Wrap.wrapper {\n            if options.Contains opWebSite then\n                let  site     = options?Website\n                if options.Contains \"++createdirectory\"     then Directory.CreateDirectory(site) |> ignore\n            let! res          = options.Get CompOptions.WSharperOptions\n                                 |> Seq.map (sprintf \"%A\")\n                                 |> String.concat \"  \"\n                                 |> fun ops -> (new ShellEx(@\"WsFsc.exe\", ops)).StartAndWaitR()\n            return if res = \"\" then \"Compiled!\" else res\n        }\n    member this.CompileSnippetW options  = \n        Wrap.wrapper {\n            let  snpPath      = options?Snippet\n            let  config       = options?Config\n            let  directory    = options?Directory\n            do   Directory.CreateDirectory(directory) |> ignore\n            let! options2     = this.PrepareCompileOptions options\n            let  compiler     = if options2.Contains \"++websharper:1\" then this.CompileWebSharperW else this.CompileFSharpW\n            let! res          = compiler options2\n            if options2.Contains \"++copyassemblies\" then copyIfMustToDir        \"FSharp.Core.dll\"          directory\n            if options2.Contains \"++copyconfig\"     then copyIfNotExistsToFile  \"FSharpStation.exe.config\" config\n            return res\n        }\n        \n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"9becc68c-9cc2-4f29-82df-e510d10226db"},{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},{"$":0,"Item":"ef053bdf-997b-49c8-a401-1611a568bd8a"},{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},{"$":0,"Item":"15cf771f-22b1-4796-8e34-6c16f35d6506"},{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"},{"$":0,"Item":"ab5ab0ca-eb45-4851-affe-4690bb75d055"}],"id":{"$":0,"Item":"56e5bc09-e528-49cc-9d42-6359b32a0cc9"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"WebSite","content":"#define WEBSHARPER\nopen WebSharper.Sitelets\nopen WebSharper.UI.Next.Server\n\ntype EndPoint = EP\n\nlet content (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n    Content.Page( Html.html [ Html.body [ Html.h1 [ Html.text \"Hello Dolly\" ] ]])\n\nlet site = Application.MultiPage content\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"47912c89-9605-41df-9425-7facea3d6b50"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"SelfHostedServer","content":"#r @\"Owin.dll\"\n#r @\"Microsoft.Owin.dll\"\n#r @\"Microsoft.Owin.Hosting.dll\"\n#r @\"Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"Microsoft.Owin.StaticFiles.dll\"\n#r @\"Microsoft.Owin.FileSystems.dll\"\n#r @\"WebSharper.Owin.dll\"\n\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://localhost\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://*\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"file://\"\nWebSharper.Web.Remoting.DisableCsrfProtection()\n\nmodule SelfHostedServer =\n\n    open global.Owin\n    open Microsoft.Owin.Hosting\n    open Microsoft.Owin.StaticFiles\n    open Microsoft.Owin.FileSystems\n    open WebSharper.Owin\n\n    [<EntryPoint>]\n    let Main args =\n        let rootDirectory, url =\n            match args with\n            | [| rootDirectory; url |] -> rootDirectory, url\n            | [| url                |] -> \"..\"         , url\n            | [|                    |] -> \"..\"         , \"http://localhost:9001/\"\n            | _ -> eprintfn \"Usage: WebServer ROOT_DIRECTORY URL\"; exit 1\n        use server = \n            WebApp.Start(url, fun appB ->\n                appB.UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(rootDirectory)))\n                    .UseWebSharper(WebSharperOptions(ServerRootDirectory = rootDirectory\n                                                   , Sitelet             = Some site\n                                                   , BinDirectory        = \".\"\n                                                   , Debug               = true))\n                |> ignore\n                let listener = appB.Properties.[\"Microsoft.Owin.Host.HttpListener.OwinHttpListener\"] |> unbox<Microsoft.Owin.Host.HttpListener.OwinHttpListener>\n                let maxA = ref 0\n                let maxB = ref 0\n                listener.SetRequestProcessingLimits(1000, 1000)\n                listener.GetRequestProcessingLimits(maxA, maxB)\n                printfn \"Accepts: %d Requests:%d\" !maxA !maxB\n                )\n        stdout.WriteLine(\"Serving {0}\", url)\n        stdin.ReadLine() |> ignore\n        0\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"47912c89-9605-41df-9425-7facea3d6b50"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"2071bfaf-8f65-47a7-98e6-7ec138e9f905"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FsTranslator","content":"module FsTranslator =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"FsTranslator","content":"#r @\"..\\packages\\Zafir.FSharp\\tools\\System.Reflection.Metadata.dll\"\n#r @\"..\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n#r @\"..\\packages\\Zafir.Compiler\\lib\\net45\\WebSharper.Compiler.dll\"\n#r @\"..\\packages\\Zafir.Compiler\\lib\\net45\\WebSharper.Compiler.FSharp.dll\"\n#r @\"..\\packages\\Mono.Cecil\\lib\\net40\\Mono.Cecil.dll\"\n#r @\"..\\packages\\Mono.Cecil\\lib\\net40\\Mono.Cecil.Pdb.dll\"\n#r @\"..\\packages\\Mono.Cecil\\lib\\net40\\Mono.Cecil.Mdb.dll\"\n//#r @\"System.Reflection.Metadata.dll\"\n\nmodule Translator =\n    open Useful\n    open UsefulDotNet\n    open System\n    open System.IO\n    open System.Reflection\n    \n    module Re = WebSharper.Core.Resources\n    module P  = WebSharper.PathConventions\n    open WebSharper.Compiler\n    open WebSharper.Compiler.FrontEnd\n    open WebSharper.Core\n    open WebSharper.Core.Resources\n    open WebSharper.Compile.CommandTools\n    open Microsoft.FSharp.Compiler.SourceCodeServices\n    open Microsoft.FSharp.Compiler\n    \n    type WebSharperError = AST.SourcePos option * CompilationError\n    type TranslatorError =\n        | MustProvideAssemblyOutputPath\n        | MustProvideProjectPath\n        | ErrWebSharper                 of string\n        | NothingToTranslateToJavaScript\n        | OutputAssemblyNotFound        of string\n    with interface ErrMsg with\n            member this.ErrMsg =\n                if this = NothingToTranslateToJavaScript then \"WebSharper found nothing that required translation to JavaScript. Possibly a [< JavaScript >] attribute is missing.\" else\n                sprintf \"%A\"this\n            member this.IsWarning = false\n    \n    let webSharperError2TranspilerError: WebSharperError -> ErrMsg =\n        fun                              (posO, error)   ->\n            posO \n            |> Option.map (fun pos -> sprintf \"%s %A - %A \" pos.FileName pos.Start pos.End )\n            |> Option.defaultValue \"\"\n            |>  sprintf \"%s%s\" <| error.ToString()\n            |> ErrWebSharper\n            :> ErrMsg\n    \n    let CompileToJsW: WsConfig -> Wrap<string> =\n        fun           config   -> Wrap.wrapper {\n            do!  config.ProjectFile  = null       |> Result.failIfTrue  MustProvideProjectPath\n            do!  config.AssemblyFile = null       |> Result.failIfTrue  MustProvideAssemblyOutputPath\n            let  fsharpChecker       = FSharpChecker.Create(keepAssemblyContents = true)\n            let! errors, exitCode    = fsharpChecker.Compile(config.CompilerArgs)\n            let  fsErrors            = errors |> Array.map fSharpError2TranspilerError |> List.ofArray\n            do!  (if exitCode = 0 then Result.succeedWithMsgs () else Result.failWithMsgs) <| fsErrors\n            do!  File.Exists config.AssemblyFile  |> Result.failIfFalse (OutputAssemblyNotFound config.AssemblyFile)\n            let  assemblyBytes       = File.ReadAllBytes config.AssemblyFile\n            do   System.IO.File.Delete config.AssemblyFile\n            let  paths               = [   for r in config.References -> \n                                               Path.GetFullPath r\n                                           yield Path.GetFullPath config.AssemblyFile\n                                       ]        \n            let  aR                  = AssemblyResolver.Create().SearchPaths(paths)\n            let  loader              = Loader.Create aR (printfn \"%s\")\n            let  refs                = [ for r in config.References -> loader.LoadFile(r, false) ]\n            let  refMeta             =\n                 System.Threading.Tasks.Task.Run(fun () ->\n                     let refErrors = ref false\n                     let metas = refs |> List.choose (fun r -> \n                         try ReadFromAssembly FullMetadata r\n                         with e ->\n                             eprintfn \"WebSharper error %s\" e.Message\n                             refErrors := true\n                             None\n                     )\n                     if !refErrors then None\n                     elif List.isEmpty metas then Some WebSharper.Core.Metadata.Info.Empty \n                     else\n                         try\n                             Some { \n                                 WebSharper.Core.Metadata.Info.UnionWithoutDependencies metas with\n                                     Dependencies = WebSharper.Core.DependencyGraph.Graph.NewWithDependencyAssemblies(metas |> Seq.map (fun m -> m.Dependencies)).GetData()\n                             }\n                         with e ->\n                             eprintfn \"WebSharper error Error merging WebSharper metadata: %s\" e.Message\n                             None\n                 )\n            let  referencedAsmNames     = paths\n                                          |> Seq.map (fun i -> \n                                              let n = Path.GetFileNameWithoutExtension(i)\n                                              n, i\n                                          ) |> Map.ofSeq\n            let  thisName               = Path.GetFileNameWithoutExtension config.AssemblyFile\n            let  assemblyResolveHandler = ResolveEventHandler(fun _ e ->\n                    //printfn \"assemblyResolveHandler %s\" e.Name\n                    let assemblyName    = AssemblyName(e.Name).Name\n                    match Map.tryFind assemblyName referencedAsmNames with\n                    | Some p when assemblyName = \"FSharp.Core\" -> typeof<option<_>>.Assembly\n                    | Some p when assemblyName = thisName      -> Assembly.Load assemblyBytes\n                    | Some p                                   -> Assembly.LoadFrom(p)\n                    | _                                        -> null\n                )\n            System.AppDomain.CurrentDomain.add_AssemblyResolve(assemblyResolveHandler)\n            let! comp        = WebSharper.Compiler.FSharp.WebSharperFSharpCompiler(printfn \"%s\", fsharpChecker)\n                                        .Compile(refMeta, config.CompilerArgs, \".\", config.ProjectFile) \n            let  wsErrors    = comp.Errors |> List.map webSharperError2TranspilerError\n            do! if wsErrors.IsEmpty then Result.succeed () else\n                Result.failWithMsgs wsErrors\n            let  assem       = loader.LoadRaw assemblyBytes None\n            let! js          = ModifyAssembly (Some comp) \n                                              (refMeta.Result |> Option.defaultValue WebSharper.Core.Metadata.Info.Empty) \n                                              (comp.ToCurrentMetadata(config.WarnOnly)) \n                                              config.SourceMap config.AnalyzeClosures assem\n                               |> Result.fromOption NothingToTranslateToJavaScript\n            let  thisProject = Path.GetFileNameWithoutExtension config.ProjectFile\n            use  stringW     = new System.IO.StringWriter()\n            use  writer      = new System.Web.UI.HtmlTextWriter(stringW)\n            let  pu          = P.PathUtility.VirtualPaths(\"/\")\n            let ctx : Resources.Context =\n                {\n                    DebuggingEnabled        = true\n                    DefaultToHttp           = false\n                    GetSetting              = fun (name: string) -> None //printfn \"GetSetting %s\" name ; None\n\n                    GetAssemblyRendering    = fun name ->\n                        //printfn \"GetAssemblyRendering %s\" name\n                        if name = thisProject || name = config.ProjectFile\n                        then WebSharper.Core.Resources.Rendering.Skip else\n                        name\n                        |> P.AssemblyId.Create\n                        |> pu.JavaScriptPath \n                        |> Re.RenderLink\n                    GetWebResourceRendering = fun ty resource ->\n                        //printfn \"GetWebResourceRendering %A\" ty\n                        let id = P.AssemblyId.Create(ty)\n                        let kind =\n                            if resource.EndsWith(\".js\") || resource.EndsWith(\".ts\")\n                                then P.ResourceKind.Script\n                                else P.ResourceKind.Content\n                        P.EmbeddedResource.Create(kind, id, resource)\n                        |> pu.EmbeddedPath\n                        |> Re.RenderLink\n                    RenderingCache          = System.Collections.Concurrent.ConcurrentDictionary()\n                    ResourceDependencyCache = System.Collections.Concurrent.ConcurrentDictionary()\n                }            \n            comp.Graph.Nodes |> comp.Graph.GetDependencies |> comp.Graph.GetResources |> Seq.iter(fun r -> r.Render ctx (fun _ -> writer) )\n            //js.RenderDependencies(ctx, writer)\n            let  includes = stringW.ToString()\n            let  incs     = includes.Split([| \"src=\"; \"href=\" ; \"<\" ; \">\" |], System.StringSplitOptions.RemoveEmptyEntries)\n                            |> Seq.choose(fun v -> if v.[0] = '\"' then v.Split([| '\"' |], System.StringSplitOptions.RemoveEmptyEntries).[0] |> sprintf \"%A\" |> Some else None)\n                            |> String.concat \", \"\n            let! f        = Result.succeedWithMsgs js.[1..js.Length - 7] (comp.Warnings |> List.map (fun v -> (sprintf \"%A\" v, true) |> ErrSimple :> ErrMsg))\n            return          sprintf \"CIPHERSpaceLoadFiles([%s], %s);\" incs f\n        }\n    \n    let compileMainW: string[] -> Wrap<string> =\n      fun             argv     ->\n        let wsArgs    = ref WsConfig.Empty\n        let refs      = ResizeArray()\n        let resources = ResizeArray()\n        let fscArgs   = ResizeArray()\n        let cArgv     =\n            [|\n                let isRNext = ref false\n                for a in argv do\n                    match a with\n                    | \"-r\" ->\n                        isRNext := true\n                    | _ ->\n                        if !isRNext then\n                            isRNext := false   \n                            yield \"-r:\" + a\n                        else\n                            yield a\n            |]\n        for a in cArgv do\n            let setProjectType t = wsArgs := { !wsArgs with ProjectType = Some t }\n            try\n                match a with\n                | \"--wig\"                          -> setProjectType WIG\n                | \"--bundle\"                       -> setProjectType Bundle\n                | \"--html\"                         -> setProjectType Html\n                | \"--site\"                         -> setProjectType Website\n                | StartsWith \"--ws:\" wsProjectType ->\n                    match wsProjectType.ToLower() with\n                    | \"site\" \n                    | \"web\" \n                    | \"website\" \n                    | \"export\"                     -> setProjectType Website\n                    | \"extension\"                  \n                    | \"interfacegenerator\"         -> setProjectType WIG\n                    | \"bundle\"                     -> setProjectType Bundle\n                    | \"html\"                       -> setProjectType Html\n                    | \"ignore\"                     -> ()\n                    | \"library\"                    -> ()\n                    | _                            -> invalidArg \"type\" (\"Invalid project type: \" + wsProjectType)\n                | StartsWith \"--project:\"        p -> wsArgs := { !wsArgs with ProjectFile   = p      } //Path.Combine(Directory.GetCurrentDirectory(), p) }\n                | StartsWith \"--wsoutput:\"       o -> wsArgs := { !wsArgs with OutputDir     = Some o }\n                | StartsWith \"--keyfile:\"        k -> wsArgs := { !wsArgs with KeyFile       = Some k }\n                | \"--jsmap\"                        -> wsArgs := { !wsArgs with SourceMap     = true   } \n                | \"--dts\"                          -> wsArgs := { !wsArgs with TypeScript    = true   } \n                | \"--wswarnonly\"                   -> wsArgs := { !wsArgs with WarnOnly      = true   } \n                | \"--printjs\"                      -> wsArgs := { !wsArgs with PrintJS       = true   }\n                | \"--debug\"                      \n                | \"--debug+\"                     \n                | \"--debug:full\"                 \n                | \"-g\"                           \n                | \"-g+\"                          \n                | \"-g:full\"                        -> wsArgs := { !wsArgs with IsDebug       = true   } ; fscArgs.Add a\n                | \"--vserrors\"                     -> wsArgs := { !wsArgs with VSStyleErrors = true   } ; fscArgs.Add a\n                | StartsWith \"-o:\"               o \n                | StartsWith \"--out:\"            o -> wsArgs := { !wsArgs with AssemblyFile = o       } ; fscArgs.Add a\n                | StartsWith \"--doc:\"            d -> wsArgs := { !wsArgs with Documentation = Some d } ; fscArgs.Add a\n                | StartsWith \"-r:\"               r             \n                | StartsWith \"--reference:\"      r -> refs.Add      r                                   ; fscArgs.Add a\n                | StartsWith \"--resource:\"       r -> resources.Add r                                   ; fscArgs.Add a\n                | _                                ->                                                     fscArgs.Add a  \n            with e ->\n                failwithf \"Parsing argument failed: '%s' - %s\" a e.Message\n        fscArgs.Add \"--define:FSHARP41\"\n        wsArgs := \n            { !wsArgs with \n                References   = refs |> Seq.map (fun s -> s.ToLower()) |> Seq.distinct |> Array.ofSeq\n                Resources    = resources.ToArray()\n                CompilerArgs = fscArgs  .ToArray() \n            }\n        CompileToJsW !wsArgs\n\n    let Process args =  \n        compileMainW args \n        |> Wrap.runSynchronouslyR\n        |> fun (Result(jsO, msgs)) -> \n               jsO |> Option.iter (printfn \"%s\")\n               if not msgs.IsEmpty then Result.getMessages msgs |> eprintfn \"%O\"\n               match jsO with\n               | Some js -> 0\n               | None    -> 1\n               \n    let endToken = sprintf \"//---------------%s-----------------\" \"EOF\"\n\n    [< EntryPoint >]\n    let Main args =\n        Console.SetIn(new StreamReader(Console.OpenStandardInput 30000))\n        let mutable cycle = true\n        if args = [| \"++loop\" |] \n        then while cycle do\n               let line = Console.ReadLine()\n               if line = null ||  line = \"++end\" then cycle <- false else\n               let argsL = match line with Regexs \"(\\\".*?\\\"|\\S+)\" ms -> ms |> Array.map (function | Regex \"(\\\"(.*)\\\")\" [_ ; m] | m -> m)\n               if Process argsL = 0 then \"success\" else \"fail\"\n               |> printfn \"//%s\"\n               eprintfn \"%s\" endToken\n             0\n        else Process args \n","parent":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"predecessors":[{"$":0,"Item":"7646acbc-2c28-4159-98b1-2365d19fc97c"},{"$":0,"Item":"9becc68c-9cc2-4f29-82df-e510d10226db"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},{"$":0,"Item":"b7c2d8cd-7246-4ad1-af46-ffbb7acde6e0"}],"id":{"$":0,"Item":"cfe0b3ef-9176-4f30-853c-27177faef6b0"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"TranslatorCaller","content":"module TranslatorCaller =\n    open Useful\n    open UsefulDotNet\n    open CompOptionsModule\n    open System\n    open System.IO\n    open System.Diagnostics\n    \n    type TranslatorExe(config) =\n        let startInfo                 = ProcessStartInfo(@\"Compiled\\FsTranslator\\FsTranslator.exe\", config |> String.concat \" \")             \n        let shell                     = new ShellEx(startInfo)  // --noninteractive\n        let endToken                  = sprintf \"//---------------%s-----------------\" \"EOF\"\n        do  startInfo.CreateNoWindow <- false\n            shell.Start() |> ignore\n        member this.Translate txt =\n            Wrap.wrapper {\n                do! Result.tryProtection()\n                let! res1 = shell.SendAndWait(txt, endToken, true)\n                let! res2 = if res1.EndsWith \"//success\" then Result.succeed res1 else Result.fail (ErrSimple (\"Translator Failed\", false))\n                return res2\n            }\n        member this.IsAlive = not shell.HasExited\n        interface System.IDisposable with\n            member this.Dispose () = \n                (shell :> System.IDisposable).Dispose()    \n\n    let translator = lazy new ResourceAgent<_, string> (20, (fun config -> new TranslatorExe([\"++loop\"; defaultArg config \"\"] )), (fun exe -> (exe :> System.IDisposable).Dispose()), (fun exe -> exe.IsAlive), \"\")\n    \n    let extractConfig (code:string[]) = if code.[0].StartsWith \"////-d:\" then code.[0].[4..] else \"\"\n\n    let getJSW (minified:bool) (options0 : (CompOption * CompOptionValue) seq) (fsCode:string) =\n        Wrap.wrapper {\n            do!  Result.tryProtection()\n            let  code           = fsCode.Split '\\n'\n            let  defines0       = (extractConfig code).Split([| \" \" ; \"-d:\" |], StringSplitOptions.RemoveEmptyEntries) \n            let  fs, assembs, defines1, prepIs, nowarns = separatePrepros false code |> separateDirectives\n            let  defines        = Array.append defines0 defines1\n            let  codeBase       = Path.GetFullPath \"bin\"\n            let  name           = \"Temp_\" + Path.GetFileNameWithoutExtension(Path.GetRandomFileName())\n            let  options1       = compileOptionsDll name\n                                  + opDirectory   /= Path.GetDirectoryName(codeBase)\n                                  + opGenWSharper /= \"project:FSharpStation\"\n                                 // + opIOption   /= @\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\bin\"\n                                  + options0\n            let  options2       = prepOptions options1 (fs, assembs, defines, prepIs, nowarns)\n            use  toErase        = new TempFileName(options2?Source)\n            let  ops            = options2.Get CompOptions.WSharperOptions\n                                  |> Seq.append [ \"IGNORED\" ]\n                                  |> Seq.map (sprintf \"%A\")\n                                  |> String.concat \" \"\n            let! jsR            = translator.Value.Process (fun tra -> tra.Translate ops)\n            let! js             = jsR\n            return js\n        }\n\n\n","parent":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"predecessors":[{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},{"$":0,"Item":"ef053bdf-997b-49c8-a401-1611a568bd8a"},{"$":0,"Item":"ace1fc12-3dfb-4db8-80c9-5bde1e7d0597"},{"$":0,"Item":"4137cad8-fd64-426e-98de-16a92a56388d"},{"$":0,"Item":"f930dc48-39e8-453c-8c77-18a2cd73637a"}],"id":{"$":0,"Item":"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Test FsTranslator.exe","content":"open Useful\nopen UsefulDotNet\nopen CompOptionsModule\n\nWrap.wrapper {\n    let    snippet = \"FSSGlobal/F# STATION TUTORIALS/1 - Hello World\" //\"FSSGlobal/WebSharper Code/WebSharper Snippets1/Test mouse\" //\"FSSGlobal/F# Code/Snippets/Failed to load argument type\"\n    //let    snippet = \"FSSGlobal/F# Code/Snippets/Failed to load argument type\"\n    let!   code    = FsStationShared.FsStationClient(\"Test FsTranslator.exe\").RequestCode snippet\n    let!   js      = TranslatorCaller.getJSW false [ (* opGenInternal /= \"showoptions\" *) ] code\n    return js\n} \n|> Wrap.runSynchronouslyS false\n|> printfn \"%A\"\n","parent":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"predecessors":[{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"},{"$":0,"Item":"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"},{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},{"$":0,"Item":"ef053bdf-997b-49c8-a401-1611a568bd8a"}],"id":{"$":0,"Item":"f587e7a5-825a-4c95-ac79-a53f43ed52c8"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"translateAR","content":"open Useful\nopen WebSharper\n\n[< Rpc >]\nlet translateAS source minified = \n    async {\n        let!    res  = TranslatorCaller.getJSW minified [] source |> Wrap.getAsyncR\n        return  res |> Result.mapMsgs (Seq.map (fun (e:ErrMsg) -> e.ErrMsg, e.IsWarning) >> Seq.toArray)\n    }\n    \n[< JavaScript >]\nlet translateAR source minified = \n    async {\n        let!   vO, msgs = translateAS source minified\n        return  Result (vO,  msgs |> Seq.map (fun (msg, wrn) -> ErrSimple(msg, wrn) :> ErrMsg) |> Seq.toList)\n    }\n    ","parent":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},{"$":0,"Item":"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"}],"id":{"$":0,"Item":"95a237c8-a9ff-40d1-bd72-bd298b20af8c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FSAutoCompleteIntermediary","content":"module FSAutoCompleteIntermediary =\n","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"b6577554-e62e-41ed-983e-d4dd12e3512f"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"FSAutocompleteCall","content":"#r @\"..\\packages\\FSharp.Data\\lib\\net40\\FSharp.Data.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net40\\FSharp.Data.DesignTime.dll\"\n#r @\"..\\packages\\NewtonSoft.JSon\\lib\\net45\\NewtonSoft.JSon.dll\"\n\nopen System.Net\nopen System.Text\nopen System.IO\nopen FSharp.Data\nopen FSharp.Data.JsonExtensions\nopen Useful\nopen Useful.Result\nopen Newtonsoft.Json\n\nopen Utils\n\n#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule CommTypes =\n    type ResponseError =\n        {\n          Code: int\n          Message: string\n          //AdditionalData: 'T\n        }\n    type Location =\n      {\n        File: string\n        Line: int\n        Column: int\n      }\n    type CompletionResponse =\n      {\n        Name: string\n        ReplacementText: string\n        Glyph: string\n        GlyphChar: string\n      }\n    //type ProjectResponse =\n    //  {\n    //    Project: ProjectFilePath\n    //    Files: List<SourceFilePath>\n    //    Output: string\n    //    References: List<ProjectFilePath>\n    //    Logs: Map<string, string>\n    //  }\n    type OverloadDescription =\n      {\n        Signature: string\n        Comment: string\n      }\n    type OverloadParameter =\n      {\n        Name : string\n        CanonicalTypeTextForSorting : string\n        Display : string\n        Description : string\n      }\n    type Overload =\n      {\n        Tip : OverloadDescription list list\n        TypeText : string\n        Parameters : OverloadParameter list\n        IsStaticArguments : bool\n      }\n    type Parameter = {\n        Name : string\n        Type : string\n      }\n    type SignatureData = {\n        OutputType : string\n        Parameters : Parameter list list\n      }\n    type MethodResponse =\n      {\n        Name : string\n        CurrentParameter : int\n        Overloads : Overload list\n      }\n    type SymbolUseRange =\n      {\n        FileName: string\n        StartLine: int\n        StartColumn: int\n        EndLine: int\n        EndColumn: int\n        IsFromDefinition: bool\n        IsFromAttribute : bool\n        IsFromComputationExpression : bool\n        IsFromDispatchSlotImplementation : bool\n        IsFromPattern : bool\n        IsFromType : bool\n      }\n    type SymbolUseResponse =\n      {\n        Name: string\n        Uses: SymbolUseRange list\n      }\n    type HelpTextResponse =\n      {\n        Name: string\n        Overloads: OverloadDescription list list\n      }\n    type CompilerLocationResponse =\n      {\n        Fsc: string\n        Fsi: string\n        MSBuild: string\n      }\n    type FSharpErrorInfo =\n      {\n        FileName: string\n        StartLine:int\n        EndLine:int\n        StartColumn:int\n        EndColumn:int\n       // Severity:FSharpErrorSeverity\n        Message:string\n        Subcategory:string\n      }\n    type ErrorResponse =\n      {\n        File: string\n        Errors: FSharpErrorInfo []\n      }\n    type Colorization =\n      {\n    //    Range: Range\n        Kind: string\n      }\n    type Declaration =\n      {\n        UniqueName: string\n        Name: string\n        Glyph: string\n        GlyphChar: string\n        IsTopLevel: bool\n    //  Range     : Utils.Range\n    //    BodyRange : Utils.Range\n        File : string\n        EnclosingEntity: string\n        IsAbstract: bool\n      }\n    type DeclarationResponse = {\n        Declaration : Declaration;\n        Nested : Declaration []\n    }\n    type OpenNamespace = {\n      Namespace : string\n      Name : string\n      Type : string\n      Line : int\n      Column : int\n      MultipleNames : bool\n    }\n    type QualifySymbol = {\n      Name : string\n      Qualifier : string\n    }\n    type ResolveNamespaceResponse = {\n      Opens : OpenNamespace []\n      Qualifies: QualifySymbol []\n      Word : string\n    }\n    type UnionCaseResponse = {\n      Text : string\n    //  Position : Pos\n    }\n    type Kind = \n    | KInfo             of string\n    | KError            of ResponseError\n    | KHelpText         of HelpTextResponse\n    | KCompletion       of CompletionResponse  []\n    | KSymbolUse        of SymbolUseResponse\n    | KHelp             of string\n    | KMethod           of MethodResponse\n    | KErrors           of ErrorResponse\n    | KColorizations    of Colorization list\n    | KFindDecl         of Location\n    | KDeclarations     of DeclarationResponse []\n    | KToolTip          of OverloadDescription [][]\n    | KTypeSig          of string\n    | KSignatureData    of SignatureData\n    | KCompilerLocation of CompilerLocationResponse\n    | KNamespaces       of ResolveNamespaceResponse\n    | KUnionCase        of UnionCaseResponse\n    | KMultiple         of Kind                []\n    \n    type ACMessage =\n    | ACMIdentification\n    | ACMEcho             of string\n    | ACMToolTip          of string * int * int\n    | ACMToolTip2         of string * int * int *  string\n    | ACMSignature        of string * int * int\n    | ACMSignature2       of string * int * int *  string\n    | ACMFindDeclaration  of string * int * int\n    | ACMFindDeclaration2 of string * int * int *  string\n    | ACMComplete         of string * int * int *  string\n    | ACMComplete2        of string * int * int *  string *  string\n    | ACMParse            of string * string    * (string * (int * int * int)) []\n    | ACMMustParse        of string * string\n\nopen CommTypes\n\ntype ParseRequest         = { FileName  : string ; IsAsync    : bool   ; Lines : string[]           ; Version : int                                            }\ntype DeclarationsRequest  = { FileName  : string ;                       Lines : string[]           ; Version : int                                            }\ntype CompletionRequest    = { FileName  : string ; SourceLine : string ; Line  : int                ; Column  : int ; Filter : string; IncludeKeywords : bool  }\ntype PositionRequest      = { FileName  : string ;                       Line  : int                ; Column  : int ; Filter : string                          }\ntype ProjectRequest       = { FileName  : string                                                                                                               }\ntype LintRequest          = { FileName  : string                                                                                                               }\ntype HelptextRequest      = { Symbol    : string                                                                                                               }\ntype WorkspacePeekRequest = { Directory : string ; Deep       : int    ; ExcludedDirs : string []                                                              }\n\ntype FARequest =\n    | FarParse         of ParseRequest         \n    | FarDeclarations  of DeclarationsRequest  \n    | FarCompletion    of CompletionRequest    \n    | FarPosition      of PositionRequest      \n    | FarProject       of ProjectRequest       \n    | FarLint          of LintRequest          \n    | FarHelptext      of HelptextRequest      \n    | FarWorkspacePeek of WorkspacePeekRequest    \nwith\n  member this.Json =\n    match this with \n    | FarParse         data -> JsonConvert.SerializeObject data \n    | FarDeclarations  data -> JsonConvert.SerializeObject data \n    | FarCompletion    data -> JsonConvert.SerializeObject data \n    | FarPosition      data -> JsonConvert.SerializeObject data \n    | FarProject       data -> JsonConvert.SerializeObject data \n    | FarLint          data -> JsonConvert.SerializeObject data \n    | FarHelptext      data -> JsonConvert.SerializeObject data \n    | FarWorkspacePeek data -> JsonConvert.SerializeObject data    \n\nlet fromJson<'a> json = JsonConvert.DeserializeObject(json, typeof<'a>) :?> 'a\nlet jsonData2Obj item = item?Data.ToString() |> fromJson\n\nlet UrlAddress = \"http://localhost:9001/\"\n\nlet HttpRequestCall (url:string) (data:string) =\n    async {\n        //printfn \"RpcCall %s\" (extract 100 data)\n        let req = WebRequest.Create(url) :?> HttpWebRequest \n        req.Timeout         <- 300_000\n        req.ProtocolVersion <- HttpVersion.Version10\n        req.Method          <- \"POST\"\n        req.ContentType     <- \"application/json\"\n        let postBytes = Encoding.ASCII.GetBytes(data)\n        //printfn \"<---\\n%s\\n\" data\n        req.ContentLength <- int64 postBytes.Length\n        let reqStream = req.GetRequestStream() \n        reqStream.Write(postBytes, 0, postBytes.Length);\n        reqStream.Close()\n        \n        // Obtain response and download the resulting page \n        // (The sample contains the first & last name from POST data)\n        use resp   = req.GetResponse() \n        use stream = resp.GetResponseStream() \n        use reader = new StreamReader(stream)\n        let msg    = reader.ReadToEnd()\n        printfn \"\\n----> \\n%s\\n\" (extract 100 msg)\n        let jsonV  = JsonValue.Parse msg\n        return       jsonV\n    }\n\nlet KindError msg = KError { Code = 0 ; Message = msg }\n\nlet json2Kind (v:JsonValue) = \n    let item =JsonValue.Parse <| v.AsString()\n    match item?Kind.AsString() with\n    | \"info\"             -> jsonData2Obj item |> KInfo\n    | \"error\"            -> jsonData2Obj item |> KError\n    | \"errors\"           -> jsonData2Obj item |> KErrors\n    | \"tooltip\"          -> jsonData2Obj item |> KToolTip\n    | \"typesig\"          -> jsonData2Obj item |> KTypeSig\n    | \"completion\"       -> jsonData2Obj item |> KCompletion\n    | \"signatureData\"    -> jsonData2Obj item |> KSignatureData\n    | \"finddecl\"         -> jsonData2Obj item |> KFindDecl\n    | \"compilerlocation\" -> jsonData2Obj item |> KCompilerLocation\n    | _                  -> KindError <| v.ToString()\n\nlet FSAutocompleteCall cmd f (req: FARequest) =\n    Wrap.wrapper {\n        let  data         = req.Json\n        let! jsonV        = HttpRequestCall (UrlAddress + cmd) data\n        let  several      = jsonV.AsArray() |> Array.map json2Kind\n        let  good, others = several |> Array.partition f\n        let  msgs         = others  |> Seq.map (fun v -> (v.ToString(), match v with | KInfo _ -> true | _ -> false) |> ErrSimple :> ErrMsg) |> Seq.toList\n        let! result       = Result (Seq.tryHead good, msgs) \n        return result\n    } \n\nlet parseCode file code =\n    Wrap.wrapper {\n        let!  result = FSAutocompleteCall \"parse\" (function | KErrors _ -> true | _ -> false) <|\n                             FarParse\n                                 { FileName   = System.IO.Path.GetFullPath file\n                                   IsAsync    = false   \n                                   Lines      = code           \n                                   Version    = 0\n                                 }\n        return result\n    } \n\nlet toolTip file lin col filter =\n    Wrap.wrapper {\n        let!  result = FSAutocompleteCall \"tooltip\" (function | KToolTip _ -> true | _ -> false) <|\n                             FarPosition\n                                 { FileName   = System.IO.Path.GetFullPath file\n                                   Line       = lin         \n                                   Column     = col\n                                   Filter     = filter\n                                 }\n        return result\n    } \n\nlet signature file lin col filter =\n    Wrap.wrapper {\n        let!  result = FSAutocompleteCall \"signatureData\" (function | KSignatureData _ -> true | _ -> false) <|\n                             FarPosition\n                                 { FileName   = System.IO.Path.GetFullPath file\n                                   Line       = lin         \n                                   Column     = col\n                                   Filter     = filter\n                                 }\n        return result\n    } \n\nlet completion file lin col lineText filter =\n    Wrap.wrapper {\n        let!  result = FSAutocompleteCall \"completion\" (function | KCompletion _ -> true | _ -> false) <|\n                             FarCompletion\n                                 { FileName        = System.IO.Path.GetFullPath file\n                                   Line            = lin         \n                                   Column          = col\n                                   Filter          = filter\n                                   SourceLine      = lineText \n                                   IncludeKeywords = false                                     \n                                 }\n        return result\n    } \n\ntype FsAutoCompleteErr =\n    | ``Code has not been parsed, use Parse F#``\n    | ``This snippet has not been previosuly parsed, use Parse F#``\n    | ``Cached typecheck results not yet available``\n    | ``Error FileCheckerOptions`` of string\nwith interface ErrMsg with\n        member this.ErrMsg    = match this with | msg -> sprintf \"%A\" msg\n        member this.IsWarning = false    \n        \n/// this converts from Result to Rop.Result\nlet fromResult' f = \n    function \n    | Failure s  -> Result.fail <| f s\n    | Success v  -> Result.succeed v\n\ntype Responder2() =\n    //let commands = Commands()\n    let starts : Map<string, Map<string, int * int * int>> ref = ref Map.empty\n    \n    let getDelta fname snpIdO =\n        Wrap.wrapper {\n            do!  Result.tryProtection()\n            let  file = System.IO.Path.GetFullPath fname\n            match snpIdO with\n            | Some snpId -> let! fileMap          = (!starts) |> Map.tryFind file         |> Result.fromOption ``Code has not been parsed, use Parse F#``\n                            let! ind, first, last = fileMap   |> Map.tryFind snpIdO.Value |> Result.fromOption ``This snippet has not been previosuly parsed, use Parse F#``\n                            return file, first, ind\n            | None       -> return file, 0    , 0 \n        }\n    let getDeltaBack fname line =\n        Wrap.wrapper {\n            do!  Result.tryProtection()\n            let  file             = System.IO.Path.GetFullPath fname\n            let! fileMap          = (!starts) |> Map.tryFind file |> Result.fromOption ``Code has not been parsed, use Parse F#``\n            let! snp, first, ind  = fileMap \n                                    |> Seq.map     (fun kv -> kv.Key, kv.Value) \n                                    |> Seq.tryPick (fun (snp, (ind, first, last)) -> if line >= first && line < last then Some (snp, first, ind) else None) \n                                    |> Result.fromOption ``This snippet has not been previosuly parsed, use Parse F#``\n            return snp, first, ind                        \n        }\n    let mustParse fname snpId =\n        getDelta fname (Some snpId)\n        |> Wrap.map              (fun _ -> false)\n        |> Wrap.RunSynchronously \n        |> Result.withError      (fun _ -> true )\n\n    let findDeclaration file lin col filter =\n        Wrap.wrapper {\n            File.WriteAllText(file, \" \")\n            let!  result = FSAutocompleteCall \"finddeclaration\" (function | KFindDecl _ -> true | _ -> false) <|\n                                 FarPosition\n                                     { FileName   = System.IO.Path.GetFullPath file\n                                       Line       = lin         \n                                       Column     = col\n                                       Filter     = filter\n                                     }\n            File.Delete file                         \n            match result with\n            | KFindDecl decl -> let! snp, dln, dcol = getDeltaBack decl.File decl.Line\n                                let resultAdj = \n                                 {  File    = snp\n                                    Line    = decl.Line   - dln\n                                    Column  = decl.Column - dcol\n                                 } |> KFindDecl\n                                return resultAdj\n            | _              -> return result\n        } \n\n    let getPosition (getKind: string -> int -> int -> string -> Wrap<Kind>) fname ln col (snpIdO:string option) =\n        Wrap.wrapper {\n            let! file, dln, dcol = getDelta fname snpIdO\n            let! res             = getKind fname (ln + dln) (col + dcol) \"\"\n            return res\n        } \n        |> Wrap.RunSynchronously\n        |> Result.withError (Result.getMessages >> KindError)\n\n    let getCompletion fname ln col lineText (snpIdO:string option) =\n        Wrap.wrapper {\n            let! file, dln, dcol = getDelta fname snpIdO\n            let! res             = completion fname (ln + dln) (col + dcol) ((String.replicate dcol \" \") + lineText) \"Contains\"\n            return res\n        } \n        |> Wrap.RunSynchronously\n        |> Result.withError (Result.getMessages >> KindError)\n        \n    member this.Respond (msg:ACMessage) =\n        match msg with\n        | ACMIdentification              -> KInfo \"FSAutoCompleteIntermedirary\"\n        | ACMEcho   txt                  -> KInfo txt \n        | ACMMustParse(fname, snpId    ) -> mustParse fname snpId |> sprintf \"%b\" |> KInfo\n        | ACMParse    (fname, code, sts) ->\n            async {\n                let  file = System.IO.Path.GetFullPath (fname)\n                do   starts := !starts |> Map.add file (Map sts)\n                //printfn \"\\n%A\\n\" sts\n                let! errors = parseCode file (code.Split '\\n') |> Wrap.getAsync\n                let  fixedErrors =\n                    match errors with\n                    | KErrors ers -> \n                          KErrors { ers with \n                                      Errors = ers.Errors \n                                        |> Array.map (fun err ->\n                                          sts \n                                          |> Array.tryFind (fun (snpNm, (ind, first, last)) -> err.StartLine >= first && err.StartLine < last)\n                                          |> Option.map    (fun (snpNm, (ind, first, last)) -> \n                                              { err with FileName    = snpNm\n                                                         StartLine   = err.StartLine   - first\n                                                         EndLine     = err.EndLine     - first\n                                                         StartColumn = err.StartColumn - ind\n                                                         EndColumn   = err.EndColumn   - ind   }) \n                                          |> Option.defaultValue err)\n                                  } \n                    | _ -> errors\n                return fixedErrors \n            }\n            |> Async.RunSynchronously\n        | ACMToolTip         (fname, ln, col)             -> getPosition   toolTip         fname ln col None\n        | ACMToolTip2        (fname, ln, col,      snpId) -> getPosition   toolTip         fname ln col (Some snpId)\n        | ACMSignature       (fname, ln, col)             -> getPosition   signature       fname ln col None\n        | ACMSignature2      (fname, ln, col,      snpId) -> getPosition   signature       fname ln col (Some snpId)\n        | ACMFindDeclaration (fname, ln, col)             -> getPosition   findDeclaration fname ln col None\n        | ACMFindDeclaration2(fname, ln, col,      snpId) -> getPosition   findDeclaration fname ln col (Some snpId)\n        | ACMComplete        (fname, ln, col, txt)        -> getCompletion                 fname ln col txt None\n        | ACMComplete2       (fname, ln, col, txt, snpId) -> getCompletion                 fname ln col txt (Some snpId)\n\n","parent":{"$":0,"Item":"b6577554-e62e-41ed-983e-d4dd12e3512f"},"predecessors":[{"$":0,"Item":"7a655466-e218-4121-a7b6-f9c70a922e07"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"319e0842-b83e-4036-9f57-602ca4a30ac5"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FSAutoCompleteIntermediaryClient","content":"open Useful\nopen FsStationShared\nopen WebSharper\nopen WebSharper.Remoting\n\n#if FSS_SERVER\n\nlet responder = Responder2()\n\n[< Rpc >]\nlet sendMessageRpc msg = async { return responder.Respond msg }\n\n[< JavaScript >]\nlet sendMessage  (msg:ACMessage) : Async<Kind> = \n    async {\n        let!   res = sendMessageRpc (msg |> box |> unbox)\n        return res                       |> box |> unbox\n    }\n#endif\n\n#if WEBSHARPER\n[< JavaScript >]\n#endif\ntype FSAutoCompleteIntermediaryClient(clientId, ?endPoint:string) =\n     #if FSS_SERVER\n     #else\n     let msgClient = MessagingClient(clientId, ?endPoint = endPoint)\n     let toId      = AddressId \"FSAutoComplete\"\n     let sendMessage (msg:ACMessage) =\n         Wrap.wrapper {\n             let! resp = msgClient.SendMessage toId (Json.Serialize msg)\n             let  acr  = resp |> Json.Deserialize<CommandResponse.Kind>\n             return acr\n         } |> Wrap.getAsyncWithDefault (Result.getMessages >> CommandResponse.KError)\n     #endif\n     let Async_map f aa = \n         async { \n             let! a = aa\n             return f a\n         }\n     let rec comp2Strings comp =\n         match comp with \n         | KCompletion cs -> cs |> Array.map (fun cs -> cs.Name, cs.ReplacementText, cs.Glyph, cs.GlyphChar)\n         | KHelpText   _  -> [||]\n         | KMultiple   ks -> ks |> Array.collect comp2Strings \n         | m              -> [| sprintf \"%A\" m, \"\", \"ErrorMsg\", \"E\" |] \n     let tip2String tip =\n         match tip with \n         | KToolTip ts -> ts |> Seq.collect id |> Seq.collect (fun t -> [ t.Signature ; t.Comment ] ) |> String.concat \"\\n\"\n         | m           -> sprintf \"%A\" m \n     let errors2String errs =\n         match errs with \n         | KErrors  es -> \n             es.Errors \n             |> Seq.map (fun er -> sprintf \"ErrFSharp \\\"F# %s.fsx (%d,%d) - (%d,%d) %s:%s\\\"\" \n                                      er.FileName er.StartLine er.StartColumn er.EndLine er.EndColumn er.Subcategory er.Message) \n             |> String.concat \"\\n\"\n         | m           -> sprintf \"%A\" m \n     let info2Bool inf =\n         match inf with\n         | KInfo \"true\" -> true\n         | _            -> false\n        \n   with\n     member this.MustParse(fname,                 sId) = sendMessage (ACMMustParse       (fname,                  sId)) |> Async_map info2Bool\n     member this.Parse    (fname, txt , sts          ) = sendMessage (ACMParse           (fname, txt , sts           )) |> Async_map errors2String\n     member this.Parse    (fname, txt                ) = sendMessage (ACMParse           (fname, txt , [||]          )) |> Async_map errors2String\n     member this.ToolTip  (fname, line, col          ) = sendMessage (ACMToolTip         (fname, line, col           )) |> Async_map tip2String\n     member this.ToolTip  (fname, line, col,      sId) = sendMessage (ACMToolTip2        (fname, line, col ,      sId)) |> Async_map tip2String\n     member this.Complete (fname, txt, line, col     ) = sendMessage (ACMComplete        (fname, line, col , txt     )) |> Async_map comp2Strings\n     member this.Complete (fname, txt, line, col, sId) = sendMessage (ACMComplete2       (fname, line, col , txt, sId)) |> Async_map comp2Strings\n     member this.FindDecl (fname, line, col          ) = sendMessage (ACMFindDeclaration (fname, line, col           )) |> Async_map id\n     member this.FindDecl (fname, line, col,      sId) = sendMessage (ACMFindDeclaration2(fname, line, col ,      sId)) |> Async_map id\n","parent":{"$":0,"Item":"b6577554-e62e-41ed-983e-d4dd12e3512f"},"predecessors":[{"$":0,"Item":"eb54ba64-3d11-4347-97c8-aeae9e3e3121"},{"$":0,"Item":"319e0842-b83e-4036-9f57-602ca4a30ac5"}],"id":{"$":0,"Item":"466e6783-0751-48d5-b79b-165aaa7d2173"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Snippets","content":"module Snippets =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"","content":"let private displayHtml html = \n  let url = Server.instance.Value.AddPage(html)\n  System.Diagnostics.Process.Start(url) |> ignore\n\nfsi.AddPrinter(fun (chart:XPlot.GoogleCharts.GoogleChart) ->\n  let ch = chart |> XPlot.GoogleCharts.Chart.WithSize (800, 600)\n  ch.GetHtml() |> displayHtml\n  \"(Google Chart)\")\n\nfsi.AddPrinter(fun (chart:XPlot.Plotly.PlotlyChart) ->\n  \"\"\"<!DOCTYPE html>\n  <html>\n  <head>\n      <title>Plotly Chart</title>\n      <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script>\n  </head>\n  <body>\"\"\" + chart.GetInlineHtml() + \"</body></html>\" |> displayHtml","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"e620b2e0-e518-4992-86f3-bc9623015345"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Free Monad","content":"(**\nFree Monad - Interpreter pattern in F#\n================================\n\nAn analysis of the Free Monad - Interpreter pattern in F# from a definition\ncreated by erdeszt and based on: http://programmers.stackexchange.com/a/242803/145941\n\nThe DSL\n-------\n\nFirst we define a DSL for our actions. Each action points to the next action using the `'next` generic type, \nevery action has a `'next` that in turn could be a DSL, thus chaining them.\n*)\ntype DSL<'next> =\n    | Set of key: string * value: string *  'next\n    | Get of key: string *       (string -> 'next)\n(** \n* `Get` returns a string which is passed to a function. `id` function can be used to finish the chain.\n* `Set` doesn't return anything, so the `'next` portion is the next DSL element in the chain, or a constant like `()` to finish.\n\nNote that used this way `'next` can be anything. It does not have to be a DSL value, so there is no real implication of a chain of DSLs.\n\nThis is what 3 actions in the DSL may look like.\n*)\nlet ex1 = Set (\"name\", \"John\"\n             , Get (\"name\"\n                  , fun name -> Set (\"greeting\", sprintf \"Hello %s\" name, () )\n                   )\n              )\n(**\n`val ex1 : DSL<DSL<DSL<unit>>> =\n  Set (\"name\",\"John\",Get (\"name\",<fun:ex1@23-4>))`\n\nNotice how the resulting type `DSL<DSL<DSL<unit>>>` is nested and not generic. \nThis means a strongly type function cannot process all posible values.\n\nThe Free Monad\n--------------\n\nHere comes the Free Monad `ChainDSL` to the rescue.\n*)\n\ntype ChainDSL<'a> =\n    | Do     of DSL<ChainDSL<'a>>\n    | Return of 'a\n\n(**\nThe `Do` option creates a chain of `ChainDSL`s that ends with the `Return` option.\nThis chain ends up having a type equal to the last `DSL` in the chain.\nThis is almost like creating a `List` of `DSL`s (`List<DSL<'a>> or DSL<'a> list`), \nexcept that each `DSL` in the chain can be of a different type.\n\nLets look at the same value above with `ChainDSL`:\n*)\n\nlet exF1 = Do (Set (\"name\", \"John\"\n                  , Do (Get (\"name\"\n                           , fun name -> Do (Set (\"greeting\", sprintf \"Hello %s\" name, Return () )) \n                            )\n                       )\n                   )\n              )\n(**\n`val exF1 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:exF1@49-3>))))`\n\nCompare the resulting type with the prior case: `ChainDSL<unit>` vs `DSL<DSL<DSL<unit>>>`.\nNo matter how deep the chain is, the value will always be of type `ChainDSL<unit>` or `ChainDSL<string>`.\n\n\nBut creating the chain is much more complex than before.\nTo solve that, lets create two helper functions: get and set.\n*)\nlet get key       = Do (Get (key, fun value -> Return value))\nlet set key value = Do (Set (key,     value,   Return ()   ))    \n(**\n`val get : key:string -> ChainDSL<string>`\n\n`val set : key:string -> value:string -> ChainDSL<unit>`\n\nNotice `get` returns a `ChainDSL<string>` and `set` returns a `ChainDSL<unit>`.\nThey both return a `ChainDSL` chain with a single `DSL` action.\n\nWith these functions we can create Get & Set operations like this:\n*)\nlet setName     name = set \"name\"     name\nlet getName          = get \"name\"\nlet setGreeting name = set \"greeting\" (sprintf \"Hello %s\" name)\n(**\nbut they are not chained together like before.\n\nBinding it together\n-------------------\n\nTo chain them we will need to define a bind function for the ChainDSL.\nWe start with a map function for DSL, thus making DSL a functor:\n*)\nlet mapDSL: ('a -> 'b) -> DSL<'a> -> DSL<'b> = \n    fun     f             action  ->\n        match action with\n        | Get (key,        fNext) -> Get (key,        fNext >> f)\n        | Set (key, value,  next) -> Set (key, value,  next |> f)\n\n(**\nAll `mapDSL` does is apply the function `f` to the `'next` part of the `DSL`.\nIn other words go to the next node in the chain.\n\nNext we define the bind function for ChainDSL, finally making it a monad:\n*)\nlet bindChain: ('a -> ChainDSL<'b>) -> ChainDSL<'a> -> ChainDSL<'b> =\n    fun        fChain                  chainTo      ->\n        let rec appendTo chain =\n            match chain with\n            | Return a   -> fChain a\n            | Do     dsl -> Do (mapDSL appendTo dsl)\n        appendTo chainTo\n(** \n`bindChain` is similar and acts like the List.append function, it concatenates two chains of `ChainDSL`s. \nThe difference is that the chain to be appended `fChain` is passed within a function.\n`bindChain` navigates recursively down `chainTo` and replaces the last element with the result of `fChain`:\n\n* On the `Do` side `bindChain` calls `mapDSL` to apply the function to the next `ChainDSL` node.\n* On the `Return` side it replaces the 'Return a' for a call to the chain to be appended `fChain`.\n\nIn a sense `ChainDSL` is actually the opposite of a `List<DSL<'a>>`. In a List new elements are\ninserted at the head, here they are attached at the tail end.\n\nNow we can bind setName, getName & setResult from above like this: *)\n\nlet exF2 = setName \"John\" \n           |> bindChain (fun _    -> getName         )\n           |> bindChain (fun name -> setGreeting name)\n\n(** \n`val exF2 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nwhich is the same as this: *)\n\nlet exF3 = set \"name\" \"John\" \n           |> bindChain (fun _ -> get \"name\"                           )\n           |> bindChain (fun v -> set \"greeting\" (sprintf \"Hello %s\" v))\n(** \n`val exF3 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nand this: *)\nlet (>>=) v f = bindChain f v\n\nlet exF4 = set \"name\" \"John\" \n           >>= fun _    -> get \"name\" \n           >>= fun name -> set \"greeting\" (sprintf \"Hello %s\" name)\n(**\n`val exF4 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nUsing Computational Expressions\n-------------------------------\n\nNow lets try it with Computational Expressions.\nFirst we define a builder class.\n*)\n\ntype ChainDSLBuilder () =\n    member this.Return      v = Return v\n    member this.ReturnFrom mv = mv\n    member this.Zero       () = Return ()\n    member this.Bind   (v, f) = v >>= f\n\nlet chainDSL = ChainDSLBuilder ()\n\n(**\nAnd now we use the computational expression like this.\n*)\n\nlet exF5 = chainDSL {\n    do!         set \"name\"     \"John\"\n    let! name = get \"name\"\n    do!         set \"greeting\" (sprintf \"Hello %s\" name)\n}\n(**\n`val exF5 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nThe Interpreter(s)\n------------------\n  \nNow we are going to create an interpreter to execute the AST created.\n\nThis first version is very simple it does not store or retrieve any values, just prints out the commands.\n*)\n(*** define-output:interpreter1 ***)    \nlet rec interpreter1: ChainDSL<'a> -> 'a =\n    fun               chain        ->\n        match chain with\n        | Return v -> printfn \"return %A\" v\n                      v\n        | Do   dsl -> \n            match dsl with\n            | Get(key,        nextF) -> printfn \"Get %s\" key\n                                        nextF (sprintf \"<get.%s>\" key) \n            | Set(key, value, next ) -> printfn \"Set %s '%s'\" key value\n                                        next                           \n            |> interpreter1\n\ninterpreter1 exF5\n(*** include-output:interpreter1 ***)\n(**\nThis next version actually stores and retrieves the values in a `Map` object, and when finished prints its content. \n*)\n(*** define-output:interpreter2 ***)    \nlet interpreter2 chain = \n    let rec interpreter2r: Map<string, string> -> ChainDSL<'a> -> 'a =\n        fun                dataStore              chain        ->\n            match chain with\n            | Return v -> printfn \"return %A\\n%A\" v dataStore\n                          v\n            | Do   dsl -> \n                match dsl with\n                | Get(key,        nextF) -> dataStore \n                                            |> Map.find key \n                                            |> (fun v -> printfn \"Get %s -> '%s'\" key v ; v )\n                                            |> nextF\n                                            |> interpreter2r dataStore\n                | Set(key, value, next ) -> printfn \"Set %s '%s'\" key value\n                                            next\n                                            |> interpreter2r (dataStore |> Map.add key value)\n\n    interpreter2r (Map.ofList []) chain\n\ninterpreter2 exF5\n(*** include-output:interpreter2 ***)\n\n(**\nA slightly longer example:\n*)\n\n(*** define-output:interpreter2b ***)    \n\nchainDSL {\n    do!           set \"first-name\" \"John\"\n    do!           set \"last-name\"  \"Smith\"\n    let! first  = get \"first-name\"\n    let! last   = get \"last-name\"\n    do!           set \"full-name\" (first + \" \"  + last)\n    let! full   = get \"full-name\"\n    return        sprintf \"Hello %s\" full\n}\n|> interpreter2\n(** Output:*)\n(*** include-output:interpreter2b ***)\n(** Return value:*)\n(*** include-it:interpreter2b ***)\n(**\nTrying to replicate this last example without the computational expression \nrequires explicitly nesting some of the calls.\n\nIt would look like this:\n\n*)\n(*** define-output:interpreter2c ***)    \n\nset \"first-name\" \"John\" \n>>= fun _     -> set \"last-name\"  \"Smith\"            \n>>= fun _     -> get \"first-name\"                    \n>>= fun first -> get \"last-name\" \n                 >>= fun last -> set \"full-name\" (first + \" \"  + last)\n>>= fun _     -> get \"full-name\"\n>>= fun full  -> Return (sprintf \"Hello %s\" full)\n|> interpreter2\n(** Output:*)\n(*** include-output:interpreter2c ***)\n(** Return value:*)\n(*** include-it:interpreter2c ***)\n\n(**\nTwo in one\n----------\n\nSo, do we really need two types, the Free Monad and the DSL?\n\nI do not think it is necessary, the free monad helps in binding the elements of the DSL. \nThe same can be achieved just by adding the `Return` option to the DSL.\n\nHere is the same implementation with just the DSL type:\n*)\n\nmodule DSL2 =\n    type DSL<'a> =\n        | Set of key: string * value: string *  DSL<'a>\n        | Get of key: string *       (string -> DSL<'a>)\n        | Return of 'a\n    \n    let set key value = Set (key, value,          Return ())\n    let get key       = Get (key,        fun v -> Return v )\n    \n    let bind: ('a -> DSL<'b>) -> DSL<'a> -> DSL<'b> =\n        fun   fChain             chainTo ->\n           let rec appendTo chain =\n               match chain with\n               | Set (k, v,  next) -> Set (k, v,  next |> appendTo)\n               | Get (k,    fNext) -> Get (k,    fNext >> appendTo)\n               | Return  v         -> fChain v\n           appendTo chainTo\n\n    let (>>=) v f = bind f v\n\n    let interpreter2 dsl =\n        let rec interpreter2r: Map<string, string> -> DSL<'a> -> 'a =\n            fun                dataStore              dslR    ->\n                match dslR with\n                | Return v               -> printfn \"return %A\\n%A\" v dataStore\n                                            v\n                | Get(key,        nextF) -> dataStore \n                                            |> Map.find key \n                                            |> (fun v -> printfn \"Get %s -> '%s'\" key v ; v )\n                                            |> nextF\n                                            |> interpreter2r dataStore\n                | Set(key, value, next ) -> printfn \"Set %s '%s'\" key value\n                                            next\n                                            |> interpreter2r (dataStore |> Map.add key value)\n        interpreter2r (Map.ofList []) dsl\n\n(**\nThere you have it the DSL definition, helper functions, the bind function and the interpreter.\nHere is the last example again.\n*)\n(*** define-output:dsl2 ***)    \n\n    set \"first-name\" \"John\" \n    >>= fun _     -> set \"last-name\"  \"Smith\"            \n    >>= fun _     -> get \"first-name\"                    \n    >>= fun first -> get \"last-name\" \n                     >>= fun last -> set \"full-name\" (first + \" \"  + last)\n    >>= fun _     -> get \"full-name\"\n    >>= fun full  -> Return (sprintf \"Hello %s\" full)\n    |> interpreter2\n(** Output:*)\n(*** include-output:dsl2 ***)\n(** Return value:*)\n(*** include-it:dsl2 ***)    \n(*** hide ***)\ninterpreter2 exF1\ninterpreter2 exF2\ninterpreter2 exF3\ninterpreter2 exF4\ninterpreter2 exF5\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"8ee6b535-3615-4066-8917-9125cf8a1f20"},"expanded":true,"level":0,"levelCode":0,"properties":{"CSS":".CodeMirror span.cm-comment {\nbackground: white;\nfont-style: normal;\nfont-weight: 600;\ncolor: black;\n}"}},{"name":"UNLOAD FSI","content":"#define UNLOAD_FSI\n\n#if WEBSHARPER\n#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Core.JavaScript.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.JavaScript.dll\"\nopen WebSharper\n[< JavaScript >]\n#endif\nlet a = 9 + 8\n\n7 * 3\n|> printfn \"%A\"\n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"1d18fdb5-2488-4ac9-813a-c96a66b9cd13"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Substring, Regex","content":"let extract n (s:string) = s.Substring(0, min n s.Length)\nlet s = \"1234567890123456789012345678901234567890\"\nprintfn \"%s\" <| extract 100 s\n\nopen System\nprintfn \"%s\" <| System.DateTime.UtcNow.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n\nopen UsefulDotNet\n//Example:\nlet phone = \"(555) 555-5555\"\nmatch phone with\n| Regex @\"\\(([0-9]{3})\\)[-. ]?([0-9]{3})[-. ]?([0-9]{4})\" [ area; prefix; suffix ] ->\n    printfn \"Area: %s, Prefix: %s, Suffix: %s\" area prefix suffix\n| _ -> printfn \"Not a phone number\"\n\nlet code = \"let a = \\\"123\\\" |> St\"\nmatch code with\n| Regex @\"([a-zA-Z_]\\w+)$\" [ txt ] -> printfn \"%s\" txt\n| _                                -> printfn \"<No match>\"\n\nlet line = \" hello how \\\"are you\\\" good \\\"and you\\\"\"\nmatch line with \n| Regexs \"(\\\".*?\\\"|\\S+)\" ms -> \n    ms \n    |> Seq.iter\n        (function | Regex \"(\\\"(.*?)\\\")\" [_ ; m] | m -> printfn \"%A\" m)\n//| Regex \"(\\\"([^\\\"]*)\\\"|\\S*)*\" r -> printfn \"%A\" r\n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"7646acbc-2c28-4159-98b1-2365d19fc97c"}],"id":{"$":0,"Item":"5df15cf1-361e-4d57-a565-683ab0b72082"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Stack Overflow","content":"let rec recursive i = 1 + recursive i\nrecursive 1","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"3d704638-8ba4-4bc8-b810-29e023a222fc"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Calculate primes","content":"open System\nopen System.ComponentModel\nopen System.Windows.Forms\n\ntype BackgroundWorker with\n        member this.AsyncRunWorker (computation, argument : 'T, progressChangedHandler) : Async<'U> =\n            let workerAsync =\n                Async.FromContinuations (fun (cont, econt, ccont) ->\n                            let handler = new RunWorkerCompletedEventHandler (fun sender args ->          \n                                if args.Cancelled then\n                                    ccont (new OperationCanceledException()) \n                                elif args.Error <> null then\n                                    econt args.Error\n                                else\n                                    cont (args.Result :?> 'U))\n                            this.WorkerSupportsCancellation <- true;\n                            this.WorkerReportsProgress <- true\n                            this.DoWork.AddHandler(new DoWorkEventHandler(fun sender args ->\n                                args.Result <- computation(argument, this, args)))\n                            this.ProgressChanged.AddHandler(progressChangedHandler)\n                            this.RunWorkerCompleted.AddHandler(handler)\n                            this.RunWorkerAsync(argument)\n                        )\n\n            async { \n                use! holder = Async.OnCancel(fun _ -> this.CancelAsync())\n                return! workerAsync\n             }\n\nlet factorial number =\n    let rec fact number =\n        match number with\n        | value when value < 0I ->\n            raise (InvalidOperationException(sprintf \"Cannot compute the factorial of a negative number: %s.\" (value.ToString())))\n        | value when value > 2000I ->\n            raise (InvalidOperationException(sprintf \"Input too large: %s\" (value.ToString())))\n        | value when value = 0I -> 1I\n        | value when value = 1I -> 1I\n        | number -> number * fact (number - 1I)\n    fact number\n\n// Recursive isprime function.\nlet isprime number =\n    let rec check count =\n        count > number/2 || (number % count <> 0 && check (count + 1))\n    check 2\n\nlet isprimeBigInt number =\n    let rec check count =\n        count > number/2I || (number % count <> 0I && check (count + 1I))\n    check 2I\n\nlet computeNthPrime (number, worker: BackgroundWorker, eventArgs: DoWorkEventArgs) =\n     if (number < 1) then\n         invalidOp <| sprintf \"Invalid input for nth prime: %s.\" (number.ToString())\n     let mutable count = 0\n     let mutable num = 1I\n     let isDone = false\n     while (count < number && not eventArgs.Cancel ) do\n         if (worker.CancellationPending) then\n             eventArgs.Cancel <- true\n         else\n             let percentComplete = int ((float count) / (float number) * 100.0)\n             worker.ReportProgress(percentComplete, num.ToString())\n         num <- num + 1I\n         if (num < bigint System.Int32.MaxValue) then\n             while (not (isprime (int num))) do\n                 num <- num + 1I\n         else\n             while (not (isprimeBigInt num)) do\n                 num <- num + 1I\n         count <- count + 1\n     num\n         \nlet async1 (progressBar:ProgressBar) (label:Label) value =\n     let worker = new BackgroundWorker()\n     label.Text <- \"Computing...\"\n     let computation value = worker.AsyncRunWorker(computeNthPrime, value,\n                                                   (fun sender (eventArgs:ProgressChangedEventArgs) ->\n                                                       label.Text <- \"Scanning ... \" + eventArgs.UserState.ToString()\n                                                       progressBar.Value <- eventArgs.ProgressPercentage ))\n     Async.StartWithContinuations(\n         computation value,\n         (fun result -> label.Text <- sprintf \"Result: %s\" (result.ToString())),\n         (fun exn -> label.Text <- \"Operation failed with error:\" + exn.Message),\n         (fun _ -> label.Text <- \"Operation canceled.\"))\n\n#if INTERACTIVE\nlet main =\n#else\n[< EntryPoint ; STAThread >]\nlet main args =\n#endif\n    Application.EnableVisualStyles()\n    let form = new Form(Text = \"Test Form\", Width = 400, Height = 400)\n    let panel1 = new Panel(Dock = DockStyle.Fill)\n    panel1.DockPadding.All <- 10\n    let spacing = 5\n    let button1 = new Button(Text = \"Start\")\n    let button2 = new Button(Text = \"Start Invalid\", Top = button1.Height + spacing)\n    let button3 = new Button(Text = \"Cancel\", Top = 2 * (button1.Height + spacing))\n    let updown1 = new System.Windows.Forms.NumericUpDown(Top = 3 * (button1.Height + spacing), \n                                                         Value = 20m,\n                                                         Minimum = 0m,\n                                                         Maximum = 1000000m)\n    let label1 = new Label (Text = \"\", Top = 4 * (button1.Height + spacing),\n                            Width = 300, Height = 2 * button1.Height)\n    let progressBar = new ProgressBar(Top = 6 * (button1.Height + spacing),\n                                      Width = 300)\n    panel1.Controls.AddRange [| button1; button2; button3; updown1; label1; progressBar; |]\n    form.Controls.Add(panel1)\n    button1.Click.Add(fun args -> async1 progressBar label1 (int updown1.Value))\n    button2.Click.Add(fun args -> async1 progressBar label1 (int (-updown1.Value)))\n    button3.Click.Add(fun args -> Async.CancelDefaultToken())\n    form.Activated.AddHandler(System.EventHandler (fun _ _ -> form.TopMost <- true(*; form.TopMost <- false*) ))\n#if INTERACTIVE\n    form.ShowDialog() |> ignore\n#else\n    form |> Application.Run\n#endif\n    0\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"bd716e89-0546-4d6b-8964-26473ddcd121"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Form test and Messaging","content":"open System\nopen System.ComponentModel\nopen System.Windows.Forms\n\nlet label1 = new Label (Text = \"\", Width = 300)\nlet newButton txt =\n    let btn = new Button(Text = txt)\n    btn.Click.Add (fun args -> label1.Text <- txt)\n    btn :> Control\n        \n\nlet spacing = 5\nlet button1 = newButton \"Start\"\nlet button2 = newButton \"Start Invalid\"\nlet button3 = newButton \"Cancel\"\n\nlet updown1 = new System.Windows.Forms.NumericUpDown(Value   = 20m     ,\n                                                     Minimum = 0m      ,\n                                                     Maximum = 1000000m)\n\nlet progressBar = new ProgressBar(Top = 6 * (button1.Height + spacing),\n                                  Width = 300)\nlet panel1 = new Panel(Dock = DockStyle.Fill)\n\n[| button1    \n   button2    \n   button3    \n   updown1     :> Control\n   label1      :> Control\n   progressBar :> Control\n|]\n|> Array.mapi (fun i cts -> cts.Top <- i * 25 ; cts)\n|> panel1.Controls.AddRange\npanel1.DockPadding.All <- 10\n//button1.Click.Add(fun args -> async1 progressBar label1 (int updown1.Value))\n//button2.Click.Add(fun args -> async1 progressBar label1 (int (-updown1.Value)))\n//button3.Click.Add(fun args -> Async.CancelDefaultToken())\nlet form = new Form(Text = \"Select Actions\", Width = 400, Height = 400)\nform.Controls.Add(panel1)\nform.Activated.AddHandler(System.EventHandler (fun _ _ -> form.TopMost <- true(*; form.TopMost <- false*) ))\nasync {\n  do Application.Run(form) \n} |> Async.Start\n\n//open CIPHERPrototype.Messaging\nopen Useful\nopen FsStationShared\n\n#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.Web.dll\"\n#nowarn \"1125\"\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Remoting\n\nlet fsClient = FsStationClient(\"ButtonTest\")\n\nbutton1.Click.Add (fun args ->                                                      \n    Wrap.wrapper {\n        let! response = fsClient.GenericMessage \"Hello\"\n        label1.Text <- response\n    } |> Wrap.Start\n)\n\n//let requestCode (snpName:string) = \n//    async {\n//        let! response = sendRequestRpc toId fromId (snpName.Split '/' |> GetSnippetCode |> Json.Serialize)\n//        let resp =\n//            match response |> Json.Deserialize<FSResponse> with\n//            | SnippetResponse(Some snp )    -> snp  |> Json.Serialize\n//            | StringResponse (Some code)    -> code\n//            | IdResponse     (AddressId id) -> id.ToString()\n//            | _                             -> sprintf \"<Incomplete response: %s>\" response\n//        return resp\n//    }    \n//\n//open Rop\n//Wrap.wrapper {\n//    let! code   = requestCode \"module FSharpStationMD   =/Evaluate F# Code/module Snippets =/Calculate primes\"\n//    let! result = processCode (compileCode \"TESTCODE\") code\n//    result |> Seq.map (sprintf \"%A\") |> String.concat \"\\n\" |> printfn \"%s\"\n//} |> Wrap.getAsyncR |> Async.Start\n\nlet respondMessage fromId (msg:string) : string =\n    label1.Text <- msg\n    match msg |> Json.Deserialize<FSMessage> with\n    | GenericMessage        txt  -> label1.Text <- txt\n                                    StringResponse <| (Some <| \"Message received: \" + txt)\n    | GetIdentification          -> IdResponse fromId \n    | _                          -> StringResponse <| (Some <| \"Message received: \" + msg)\n    |> Json.Serialize\n\nfsClient.MessagingClient.AwaitMessage respondMessage\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"}],"id":{"$":0,"Item":"dc44bbe1-876a-4910-a39a-5d74bc2304ee"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"JSON Serializer","content":"#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Core.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Collections.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Main.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.JavaScript.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Web.dll\"\n#r @\"..\\packages\\Zafir.UI.Next\\lib\\net40\\WebSharper.UI.Next.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Sitelets.dll\"\n\n//open CIPHERPrototype.Messaging\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Remoting\n\n\ntype FSMessage =\n    | GetSnippetContentById of string //CodeSnippetId\n    | GetSnippetCodeById    of string //CodeSnippetId\n    | GetSnippetById        of string //CodeSnippetId\n    | GetSnippetContent     of string []\n    | GetSnippetCode        of string []\n    | GetSnippet            of string []\n    | GenericMessage        of string\n    | GetIdentification\n\ntype FSResponse =\n    | SnippetResponse   of string //CodeSnippet option\n    | StringResponse    of string option\n    | IdResponse        of CIPHERPrototype.Messaging.AddressId\n\nGenericMessage \"Hello\" \n|> Json.ServerSideProvider.GetEncoder().Encode\n|> Json.ServerSideProvider.Pack\n|> printfn \"%A\"\n\ntype Response = {\n    ``$TYPES`` : string[]\n    ``$DATA``  : string\n}\n\n\"\"\"{\"$TYPES\":[],\"$DATA\":\"{\\\"$\\\":1,\\\"Item\\\":\\\"Message received: Hello\\\"}\"}\"\"\"\n|> Json.Deserialize<Response>\n|> (fun r -> r.``$DATA``)\n|> Json.Deserialize<FSResponse>\n|> printfn \"%A\"\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"46450fbf-b073-4a66-ab42-587be0afc45f"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"System.IO.File.Delete(@\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\EPFileX\\CodeEditor.fsx.bak\")","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"b4a9f681-f5c2-443b-8f6e-146a6d6cd093"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"let rand = System.Random()\nlet randomNumbers = seq { while true do yield rand.Next(100) }\nlet firstTenRandomNumbers =\n randomNumbers\n |> Seq.truncate 10\n |> Seq.toList\n \nprintfn \"%+A\" firstTenRandomNumbers  \n//printfn \"%t\" (fun w -> w.WriteLine 6)  \n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"210f90c1-81fc-43bd-b838-6a5dc2a8e46b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Failed to load argument type","content":"#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Collections.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.UI.Next.dll\"\n#r @\"WebSharper.JavaScript.dll\"\n#r @\"WebSharper.Web.dll\"\n#r @\"WebSharper.UI.Next.dll\"\n#r @\"WebSharper.Sitelets.dll\"\n\nopen WebSharper\n\n[< JavaScript >]\ntype AddressId = AddressId of string\n\n[< Rpc >]\nlet sendRequest  (toId:AddressId) =\n        async {\n            return \"HELLO\"\n        }\n\n[< JavaScript >]\nlet tried() =\n    let f = AddressId \"XXX\"\n    let v = sendRequest f\n    (f, v)\n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"f850ce38-14e5-47a4-81ed-df02d7979f8e"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Rules Alea","content":"let accounts =\n  [|\n    \"30\", \"Net Income After M. I. & Taxes \"\n    \"35\", \"Income (Loss) before Taxes \"\n    \"36\", \"Income (Loss) before taxes and M.I. \"\n    \"37\", \"Income from Continuing Operations \"\n    \"38\", \"Operating Income/(Loss) \"\n    \"39\", \"Actual Gross Income \"\n    \"300\", \"Total Net Revenue \"\n    \"301\", \"Orders Available to Ship \"\n    \"310\", \"Total Projected Sales Orders \"\n    \"320\", \"Plus:Orders In Backlog \"\n    \"350\", \"Less:Proj. Ending Backlog \"\n    \"360\", \"Non Interco Revenue \"\n    \"370\", \"Interco Revenue \"\n    \"400\", \"Cost of Goods Sold-Actual \"\n    \"401\", \"Memo Only:Inventory Receipts \"\n    \"402\", \"Memo Only:Interco inventory \"\n    \"410\", \"Cost of Goods Sold \"\n    \"430\", \"Standard COGS-Non Interco \"\n    \"440\", \"Standard COGS-Interco \"\n    \"500\", \"Total Mfg./Distr. Variances \"\n    \"510\", \"Purchase Price/Freight/Reclass \"\n    \"520\", \"Material Usage \"\n    \"530\", \"Inventory Adjustment \"\n    \"540\", \"Labor Performance/Rate \"\n    \"580\", \"Overhead Variance \"\n    \"5800\", \"Overhead Spending \"\n    \"5810\", \"Bonus Accrual for Overhead \"\n    \"5820\", \"Less:Overhead Absorption \"\n    \"40\", \"Actual Gross Margin %   \"\n    \"41\", \"Plan Gross Margin %  \"\n    \"60\", \"Total Expenses \"\n    \"610\", \"Engineering \"\n    \"620\", \"Sales \"\n    \"630\", \"General & Administrative \"\n    \"640\", \"ESOP/401K Contributions \"\n    \"650\", \"Bonus Accrual \"\n    \"660\", \"Warranty Expense-Total \"\n    \"700\", \"Total Non-Operating Income/(Expense) \"\n    \"710\", \"Other Income \"\n    \"720\", \"JV Profit Allocation \"\n    \"730\", \"Other (Expense) \"\n    \"740\", \"Management Fees \"\n    \"750\", \"Interest (Expense)/Income \"\n    \"810\", \"Inventory Disposal Program \"\n    \"910\", \"Minority Interest \"\n    \"920\", \"Federal State Other Income Tax \"\n    \"31\", \"P.A.T. % \"\n    \"32\", \"PLAN INCOME AFTER TAXES & M.I. \"\n    \"33\", \"$ VARIANCE TO PLAN \"\n    \"Cash Flow Statement\", \"Cash Flow Statement \"\n    \"C1\", \"Projected Ending Loan Balance \"\n    \"C10\", \"Beginning Loan Balance \"\n    \"C20\", \"NET PROJECTED CASH + (-) \"\n    \"C201\", \"Other Items- \"\n    \"C202\", \"Other Income \"\n    \"C203\", \"JV Profit Allocation \"\n    \"C204\", \"Other Expense \"\n    \"C205\", \"Management Fees \"\n    \"C206\", \"Capital Additions & Investments \"\n    \"C207\", \"Interest (Expense)/Income \"\n    \"C208\", \"Note principal payments \"\n    \"C209\", \"Other State & Fed Taxes \"\n    \"C210\", \"Tax Distributions to Holdings \"\n    \"C211\", \"Tax Dist. to Other Shareholders \"\n    \"C212\", \"Non-Tax Distributions to Holdings \"\n    \"C213\", \"Non-Tax Dist. to Other Shareholders \"\n    \"C30\", \"Net Cash Flow from Operations \"\n    \"C31\", \"= Gross Cash Inflow(Outflow) \"\n    \"C310\", \"= Net Collections \"\n    \"C311\", \"Gross Collections \"\n    \"C312\", \"Less Core Credits \"\n    \"C321\", \"Payments \"\n    \"C322\", \"Materials \"\n    \"C323\", \"Less Warranty Recovery \"\n    \"C324\", \"Freight Payments \"\n    \"C325\", \"Direct Labor \"\n    \"C326\", \"Overhead Spending \"\n    \"C33\", \"Total Expenses \"\n    \"C331\", \"Engineering \"\n    \"C332\", \"Sales \"\n    \"C333\", \"General & Administrative \"\n    \"C334\", \"ESOP/401K Contributions \"\n    \"C335\", \"Bonus Payments \"\n    \"C336\", \"Gross Warranty Payments \"\n    \"C39\", \"Add back: Depreciation \"\n    \"C2\", \"PLAN Loan Balance \"\n    \"C3\", \"$ VARIANCE TO PLAN (under) \"\n    \"Return On Assets\", \"Return On Assets \"\n    \"R10\", \"Opinion ROA (annualized) \"\n    \"R11\", \"Year End ROA Plan \"\n    \"R5\", \"Year End Net Income Plan \"\n    \"R100\", \"Net Income Calculations \"\n    \"R3\", \"YTD Comparison to Plan \"\n    \"R1\", \"Total Net Income (opinion & YTD) \"\n    \"R110\", \"Last Month Projected Net Income YTD \"\n    \"R120\", \"This Month Opinion Net Income \"\n    \"R2\", \"Net Income YTD Plan \"\n    \"R4\", \"Annualized Projected - Actual, Opinion & Plan \"\n    \"R8\", \"Assets Month to Plan (better) \"\n    \"R6\", \"Total This Month Ending Assets Opinion \"\n    \"R600\", \"Total Assets Calculation \"\n    \"R610\", \"Projected Last Month Ending Assets \"\n    \"R620\", \"Total Net Change in Assets \"\n    \"R630\", \"Total Net Change Inventory \"\n    \"R631\", \"Net Change in Inventory \"\n    \"R632\", \"Total Into Inventory \"\n    \"R633\", \"Material Receipts \"\n    \"R634\", \"Material Usage Variance \"\n    \"R635\", \"Labor \"\n    \"R636\", \"Labor Variance \"\n    \"R637\", \"Overhead Absorbed \"\n    \"R638\", \"Material Recovery from Warranty \"\n    \"R639\", \"COGS Out \"\n    \"R640\", \"Total Net Change Fixed Assets \"\n    \"R641\", \"Net Change in Fixed Assets \"\n    \"R642\", \"Capital and Investments \"\n    \"R643\", \"Depreciation \"\n    \"R650\", \"Total Net Change in A/R \"\n    \"R651\", \"Net Change in Accts Rec \"\n    \"R652\", \"Shipments \"\n    \"R653\", \"Gross Collections \"\n    \"R7\", \"Plan This Month Ending Assets \"\n    \"R9\", \"Year Ending Asset Plan \"\n    \"Earnings\", \"Earnings \"\n    \"E1\", \"EBITDA Dollar Calculations \"\n    \"E2\", \"EBITDA YTD Opinion to Plan (worse) \"\n    \"E20\", \"Annualized Projected  \"\n    \"E21\", \"Total EBITDA Dollars (opinion & YTD) \"\n    \"E22\", \"Projected Last Month EBITDA YTD \"\n    \"E23\", \"This Month Opinion EBITDA Dollars \"\n    \"E231\", \"This Month-- Profit Before Tax and M.I. \"\n    \"E232\", \"This Month-- Interest \"\n    \"E233\", \"This Month-- Depreciation/Amortization \"\n    \"E24\", \"EBITDA Plan Remaining Year \"\n    \"E25\", \"Annual EBITDA Dollars -- FROM PLAN \"\n    \"E3\", \"EBITDA Month Opinion to Plan (worse) \"\n    \"E30\", \"Plan EBITDA Dollars This Month \"\n    \"E31\", \"This Month Opinion EBITDA Dollars \"\n    \"E40\", \"Opinion EBITDA/Assets (annualized) \"\n    \"E41\", \"Annual EBITDA/Month Assets Plan \"\n    \"E42\", \"Annual EBITDA/Annual Assets Plan \"\n    \"R8\", \"Assets Month to Plan (better) \"\n    \"R6\", \"Total This Month Ending Assets Opinion \"\n    \"R600\", \"Total Assets Calculation \"\n    \"R610\", \"Projected Last Month Ending Assets \"\n    \"R620\", \"Total Net Change in Assets \"\n    \"R630\", \"Total Net Change Inventory \"\n    \"R631\", \"Net Change in Inventory \"\n    \"R632\", \"Total Into Inventory \"\n    \"R633\", \"Material Receipts \"\n    \"R634\", \"Material Usage Variance \"\n    \"R635\", \"Labor \"\n    \"R636\", \"Labor Variance \"\n    \"R637\", \"Overhead Absorbed \"\n    \"R638\", \"Material Recovery from Warranty \"\n    \"R639\", \"COGS Out \"\n    \"R640\", \"Total Net Change Fixed Assets \"\n    \"R641\", \"Net Change in Fixed Assets \"\n    \"R642\", \"Capital and Investments \"\n    \"R643\", \"Depreciation \"\n    \"R650\", \"Total Net Change in A/R \"\n    \"R651\", \"Net Change in Accts Rec \"\n    \"R652\", \"Shipments \"\n    \"R653\", \"Gross Collections \"\n    \"R7\", \"Plan This Month Ending Assets \"\n    \"R9\", \"Year Ending Asset Plan \"\n    \"Shipments\", \" \"\n    \"S1\", \"Current Shipments \"\n  |]\n  \nlet rules = \n  [| \n    \"[Version:'Projection'] =IF([Version:'Final Projection']<>0, [Version:'Final Projection'],IF([Version:'Week 5']<>0, [Version:'Week 5'],IF([Version:'Week 4']<>0, [Version:'Week 4'], IF([Version:'Week 3']<>0, [Version:'Week 3'],IF([Version:'Week 2']<>0, [Version:'Week 2'],IF([Version:'Week 1']<>0, [Version:'Week 1'],0))))));\", \"##[Projection] FROM [FP,W5,W4,W3,W2,W1] RULE: IF([Version:'Final Projection']<>0, [Version:'Final Projection'],IF([Version:'Week 5']<>0, [Version:'Week 5'],IF([Version:'Week 4']<>0, [Version:'Week 4'], IF([Version:'Week 3']<>0, [Version:'Week 3'],IF([Version:'Week 2']<>0, [Version:'Week 2'],IF([Version:'Week 1']<>0, [Version:'Week 1'],0))))))\"\n    \"[Version:'Actual\\Projection']=B:IF(NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),1,4))*100+NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),6,2))> NUMBR(!YEAR)*100+NUMBR(SUBST(!PERIOD, 2, 2)),['Actual'], ['Projection']);\", \"##[Actual\\Projection] FROM ['Actual'], ['Projection'] RULE: IF(NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),1,4))*100+NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),6,2))> NUMBR(!YEAR)*100+NUMBR(SUBST(!PERIOD, 2, 2)),['Actual'], ['Projection'])\"\n    \"[Currency:'USD'] =B:[Currency:'LC'] * DB('XRates',!YEAR, !PERIOD, !VERSION, GETATTR('ACCOUNT', !Account, 1, 'XRate'),GETATTR('UNIT', !Unit, 1, 'Currency'));\", \"##[Currency] FROM LC RULE: [Currency:'LC'] * DB('XRates',!YEAR, !PERIOD, !VERSION, GETATTR('ACCOUNT', !Account, 1, 'XRate'),GETATTR('UNIT', !Unit, 1, 'Currency'))\"\n    \"[Period:'YTD']=[Period:'YTD_12'];\", \"##[YTD] FROM [YTD_12] RULE: [Period:'YTD_12']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'310'] =B:-1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370'];\", \"##ELIM [Total Projected Sales Orders] FROM [Interco Revenue] RULE: -1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'370']=-1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370'];\", \"##ELIM [Interco Revenue]                     FROM [Interco Revenue]  RULE: -1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'401']=[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'370']\", \"##ELIM Memo [Only:Inventory Receipts] FROM [Interco Revenue] RULE: [Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'370']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'440'] =B:-1*[Level:'Net Reported', Unit:'Consolidated wo Elims', Account:'440'];\", \"##ELIM [Standard COGS-Interco] FROM [Standard COGS-Interco] RULE: -1*[Level:'Net Reported', Unit:'Consolidated wo Elims', Account:'440']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'430'] =B:-1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']+[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'440'];\", \"##ELIM [Standard COGS-Non Interco] FROM [Interco Revenue] AND [Standard COGS-Interco] RULE: -1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']+[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'440']\"\n    \"[Account:'910', Version:'Plan']=#NA;\", \"##[Minority Interest] RULE: #NA\"\n    \"[Level:'Adjustments', Account:'910']=B:-1*([Account:'36',Level:'Net Reported'])*DB('UNITSET',!YEAR, !PERIOD, !UNIT, 'Minority %');\", \"##[Minority Interest] FROM [Income (Loss) before taxes and M.I.] RULE: -1*([Account:'36',Level:'Net Reported'])*DB('UNITSET',!YEAR, !PERIOD, !UNIT, 'Minority %')\"\n    \"[Account:'40'] =[Account:'39']/[Account:'300'];\", \"##[Actual Gross Margin %] FROM [Actual Gross Income] / [Total Net Revenue] RULE: [Account:'39']/[Account:'300']\"\n    \"[Account:'41'] =[Account:'39',Version:'Plan']/[Account:'300',Version:'Plan'];\", \"##[Plan Gross Margin %] FROM [Actual Gross Income] / [Total Net Revenue] RULE: [Account:'39',Version:'Plan']/[Account:'300',Version:'Plan']\"\n    \"[Account:'31'] =[Account:'30']/[Account:'360'];\", \"##[P.A.T. %] FROM [Net Income After M. I. & Taxes] / [Income (Loss) before taxes and M.I.] RULE: [Account:'30']/[Account:'360']\"\n    \"[Account:'32'] =[Account:'30',Version:'Plan'];\", \"##[PLAN INCOME AFTER TAXES & M.I.] FROM [Net Income After M. I. & Taxes] RULE: [Account:'30',Version:'Plan']\"\n    \"[Account:'33'] =B:[Account:'30']-[Account:'32'];\", \"##[$ VARIANCE TO PLAN] FROM [Net Income After M. I. & Taxes] - [PLAN INCOME AFTER TAXES & M.I.] RULE: [Account:'30']-[Account:'32']\"\n    \"###[Account:'C326']=B:-1*([Account:'5800']-[Account:'5810'])\", \"##[Overhead Spending] FROM [Overhead Spending] - [Bonus Accrual for Overhead] RULE: -1*([Account:'5800']-[Account:'5810'])\"\n    \"[Account:'C331']=-1*([Account:'610']);\", \"##[Engineering] FROM [Engineering] RULE: -1*([Account:'610'])\"\n    \"[Account:'C332']=-1*([Account:'620']);\", \"##[Sales] FROM [Sales] RULE: -1*([Account:'620'])\"\n    \"[Account:'C333']=-1*([Account:'630']);\", \"##[General & Administrative] FROM [General & Administrative] RULE: -1*([Account:'630'])\"\n    \"[Account:'C334']=-1*[Account:'640'];\", \"##[ESOP/401K Contributions] FROM [ESOP/401K Contributions] RULE: -1*([Account:'640'])\"\n    \"[Account:'C205']=B:[Account:'740'];\", \"##[Management Fees] FROM [Management Fees] RULE: [Account:'740']\"\n    \"[Account:'C207']=[Account:'750'];\", \"##[Interest (Expense)/Income] FROM [Interest (Expense)/Income] RULE: [Account:'750']\"\n    \"[Account:'C3'] =[Account:'C1']-[Account:'C2'];\", \"##[$ VARIANCE TO PLAN (under)] FROM [Projected Ending Loan Balance] - [PLAN Loan Balance] RULE: [Account:'C1']-[Account:'C2']\"\n    \"[Account:'C2']=B:IF(!VERSION@='Plan',STET,[Version:'Plan', Account:'C2']);\", \"##[PLAN Loan Balance] FROM [PLAN Loan Balance] RULE: IF(!VERSION@='Plan',STET,[Version:'Plan', Account:'C2'])\"\n    \"[Account:'R110']=B:IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), !VERSION, !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE));\", \"##BC [Last Month Projected Net Income YTD] FROM [Income (Loss) before taxes and M.I.] RULE: IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), !VERSION, !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE))\"\n    \"[Account:'R110']=C:IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Account:'36'], STET);\", \"##CC [Last Month Projected Net Income YTD] FROM [Income (Loss) before taxes and M.I.] RULE: IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Account:'36'], STET)\"\n    \"[Account:'R120'] =[Account:'30'];\", \"##[This Month Opinion Net Income] FROM [Net Income After M. I. & Taxes] RULE: [Account:'30']\"\n    \"[Account:'R2']=B:DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##BC [Net Income YTD Plan] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'R2']=C:IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Version:'Plan', Account:'36'], STET);\", \"##CC [Net Income YTD Plan] FROM [Income (Loss) before taxes and M.I.] RULE: IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Version:'Plan', Account:'36'], STET)\"\n    \"[Account:'R610']=B:IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.SIBLING('Period',!PERIOD,-1), 'Projection', !CURRENCY, !LEVEL, !UNIT, 'R6', !MEASURE));\", \"##[Projected Last Month Ending Assets] FROM [Total This Month Ending Assets Opinion] RULE: IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.SIBLING('Period',!PERIOD,-1), 'Projection', !CURRENCY, !LEVEL, !UNIT, 'R6', !MEASURE))\"\n    \"[Account:'R7']=[Version:'Plan',Account:'R6'];\", \"##[Plan This Month Ending Assets] FROM [Total This Month Ending Assets Opinion] RULE: [Version:'Plan',Account:'R6']\"\n    \"[Account:'R9']=[Period:'Year', Version:'Plan', Account:'R6'];\", \"##[Year Ending Asset Plan] FROM [Total This Month Ending Assets Opinion] RULE: [Period:'Year', Version:'Plan', Account:'R6']\"\n    \"###[Account:'R3'] =[Account:'R1']-[Account:'R2']\", \"##[YTD Comparison to Plan] FROM [Total Net Income (opinion & YTD)] - [Net Income YTD Plan] RULE: [Account:'R1']-[Account:'R2']\"\n    \"[Account:R633] =[Account:401];\", \"##[Material Receipts] FROM [Memo Only:Inventory Receipts] RULE: [Account:401]\"\n    \"[Account:R634] =-1*[Account:520];\", \"##[Material Usage Variance] FROM [Material Usage] RULE: -1*[Account:520]\"\n    \"[Account:R635] =-1*[Account:C325];\", \"##[Labor] FROM [Direct Labor] RULE: -1*[Account:C325]\"\n    \"[Account:R637] =-1*[Account:5820];\", \"##[Overhead Absorbed] FROM [Less:Overhead Absorption] RULE: -1*[Account:5820]\"\n    \"[Account:R636] =-1*[Account:540];\", \"##[Labor Variance] FROM [Labor Performance/Rate] RULE: -1*[Account:540]\"\n    \"[Account:R638] =[Account:C323];\", \"##[Material Recovery from Warranty] FROM [Less Warranty Recovery] RULE: [Account:C323]\"\n    \"[Account:R639] =-1*[Account:'410'];\", \"##[COGS Out] FROM [Cost of Goods Sold] RULE: -1*[Account:'410']\"\n    \"[Account:R642] =-1*[Account:C206];\", \"##[Capital and Investments] FROM [Capital Additions & Investments] RULE: -1*[Account:C206]\"\n    \"[Account:R643] =-1*[Account:C39];\", \"##[Depreciation] FROM [Add back: Depreciation] RULE: -1*[Account:C39]\"\n    \"[Account:R652] =[Account:300];\", \"##[Shipments] FROM [Total Net Revenue] RULE: [Account:300]\"\n    \"[Account:R653] =[Account:C311];\", \"##[Gross Collections] FROM [Gross Collections] RULE: [Account:C311]\"\n    \"[Account:'R10']=[Account:'R4']/[Account:'R6'];\", \"##[Opinion ROA (annualized)] FROM [Annualized Projected - Actual, Opinion & Plan] / [Total This Month Ending Assets Opinion] RULE: [Account:'R4']/[Account:'R6']\"\n    \"[Account:'R11']=[Account:'R5']/[Account:'R9'];\", \"##[Year End ROA Plan] FROM [Year End Net Income Plan] / [Year Ending Asset Plan] RULE: [Account:'R5']/[Account:'R9']\"\n    \"[Account:'E22']=DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), 'Projection', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##[Projected Last Month EBITDA YTD] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), 'Projection', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'E24']=DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)-DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##[EBITDA Plan Remaining Year] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)-DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'E25']=DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##[Annual EBITDA Dollars -- FROM PLAN] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'E30']=[Version:'Plan',Account:'36'];\", \"##[Plan EBITDA Dollars This Month] FROM [Income (Loss) before taxes and M.I.] RULE: [Version:'Plan',Account:'36']\"\n    \"[Account:'E31']=[Account:'E23'];\", \"##[This Month Opinion EBITDA Dollars] FROM [This Month Opinion EBITDA Dollars] RULE: [Account:'E23']\"\n    \"[Account:'E231']=[Account:'36'];\", \"##[This Month-- Profit Before Tax and M.I.] FROM [Income (Loss) before taxes and M.I.] RULE: [Account:'36']\"\n    \"[Account:'E233']=[Account:'C39'];\", \"##[This Month-- Depreciation/Amortization] FROM [Add back: Depreciation] RULE: [Account:'C39']\"\n    \"[Account:'E232']=-1*[Account:'750'];\", \"##[This Month-- Interest] FROM [Interest (Expense)/Income] RULE: -1*[Account:'750']\"\n    \"[Account:'E40']=[Account:'E20']/[Account:'R6'];\", \"##[Opinion EBITDA/Assets (annualized)] FROM [Annualized Projected ] / [Total This Month Ending Assets Opinion] RULE: [Account:'E20']/[Account:'R6']\"\n    \"[Account:'E41']=[Account:'E25']/[Account:'R7'];\", \"##[Annual EBITDA/Month Assets Plan] FROM [Annual EBITDA Dollars -- FROM PLAN] / [Plan This Month Ending Assets] RULE: [Account:'E25']/[Account:'R7']\"\n    \"[Account:'E42']=[Account:'E25']/[Account:'R9'];\", \"##[Annual EBITDA/Annual Assets Plan] FROM [Annual EBITDA Dollars -- FROM PLAN] / [Year Ending Asset Plan] RULE: [Account:'E25']/[Account:'R9']\"\n  |]  \n  \n#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\nopen System.Text.RegularExpressions\n\nlet AccountP = @\"(\\[((.+?),)*\\s*Account\\s*:\\s*'?(.+?)'?(,(.+?))*\\])\"\nlet input    = @\"[Level:'Adjustments', Account:'910']=B:-1*([Account:'36',Level:'Net Reported'])*DB('UNITSET',!YEAR, !PERIOD, !UNIT, 'Minority %');\"\n\nlet splitRule r =\n    Regex.Match(r, @\"(.+?)=(.+)\")\n    |> (fun m -> m.Groups.[1].Value, m.Groups.[2].Value)\n\nlet replace input =\n    Regex.Matches(input, AccountP)\n    |> Seq.cast<Match>\n    |> Seq.map (fun m -> \n        let whole = m.Groups.[0]\n        let acct  = m.Groups.[4]\n        let pres  = m.Groups.[3].Captures |> Seq.cast<Capture>\n        let sufs  = m.Groups.[6].Captures |> Seq.cast<Capture>\n        accounts \n        |> Seq.tryFind (fst >> ((=) acct.Value)) \n        |> Option.map snd \n        |> Option.defaultValue (\"Not Found: \" + acct.Value) \n        |> (fun s -> \n            let txt  = \n                [ yield s.Trim()\n                  for pre in pres do yield pre.Value\n                  for suf in sufs do yield suf.Value \n                ] \n                |> String.concat \"~\" \n                |> sprintf \"{%s}\" \n            txt, whole.Index, whole.Length)\n       )\n    |> Seq.fold (fun (txt:string, i, out) (v, s, l) -> (txt.[s + l - i ..], s + l, out + txt.[0 .. s - i - 1] + v) ) (input, 0, \"\")\n    |> fun (res, _, out) -> out + res\n    \nrules\n|> Seq.iter (\n    fun (r, c) ->\n        let a, b = splitRule r\n        printfn \"%s\\t%s\\t%s\" (replace a) (replace b) c\n \n)","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"dfc80990-ada5-4f24-8192-85bfe3b115a5"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FSharpPlus","content":"#r \"..\\packages\\FSharpPlus\\lib\\net40\\FSharpPlus.dll\"\n\nopen FSharpPlus\n\nmap string [|2;3;4;5|]\n// val it : string [] = [|\"2\"; \"3\"; \"4\"; \"5\"|]\n|> printfn \"%A\"\n\nmap ((+) 9) (Some 3)\n// val it : int option = Some 12\n|> printfn \"%A\"\n\nmap string (NonEmptyList.create 2 [3;4;5])\n// val it : NonEmptyList<string> = {Head = \"2\"; Tail = [\"3\"; \"4\"; \"5\"];}\n|> printfn \"%A\"\n\n[\"hello\";\" \";\"world\"] >>= (fun x -> Seq.toList x)\n// val x : char list = ['h'; 'e'; 'l'; 'l'; 'o'; ' '; 'w'; 'o'; 'r'; 'l'; 'd']\n|> printfn \"%A\"\n\n\nlet tryParseInt : string -> int option = tryParse\nlet tryDivide x n = if n = 0 then None else Some (x / n)\n\nSome \"20\" >>= tryParseInt >>= tryDivide 100\n// val y : int option = Some 5\n|> printfn \"%A\"\n\nlet parseAndDivide100By = tryParseInt >=> tryDivide 100\n\nparseAndDivide100By \"20\"   // Some 5\n|> printfn \"%A\"\nparseAndDivide100By \"zero\" // None\n|> printfn \"%A\"\nparseAndDivide100By \"0\"    // None\n|> printfn \"%A\"\n\nlet parseElement n = List.tryItem n >=> tryParseInt\nparseElement 2 [\"0\"; \"1\";\"2\"]\n|> printfn \"%A\"\n\nlet tryParseInt' x : Choice<int, string> = \n    match tryParse x with \n    | Some x -> Choice1Of2 x\n    | None   -> Choice2Of2 (\"Failed to parse \" + x)\n        \n\nlet tryDivide' x n = \n    if n = 0 then Choice2Of2 \"Can't divide by zero\"\n    else Choice1Of2 (x / n)\n    \nlet parseAndDivide100By' = tryParseInt' >=> tryDivide' 100\n\nparseAndDivide100By' \"20\"   // Some 5\n|> printfn \"%A\"\nparseAndDivide100By' \"zero\" // None\n|> printfn \"%A\"\nparseAndDivide100By' \"0\"    // None\n|> printfn \"%A\"\n\nSome (+) <*> Some 2 <*> Some 10     // val sumAllOptions : int option = Some 12\n|> printfn \"%A\"\n\n[(+)] <*> [10; 100] <*> [1; 2; 3]   // int list = [11; 12; 13; 101; 102; 103]\n|> printfn \"%A\"\n\nopen FSharpPlus.Lens\n\n\n(\"hello\",\"world\")^. FSharpPlus.Lens._2\n// val it : string = \"world\"\n|> printfn \"%A\"\n\nset _2 42 (\"hello\",\"world\", 8)\n// val it : string * int = (\"hello\", 42)\n|> printfn \"%A\"\n\n(\"hello\",(\"world\",\"!!!\"))^.(_2 << _1)\n// val it : string = \"world\"\n|> printfn \"%A\"\n\nset (_2 << _1) 42 (\"hello\",(\"world\",\"!!!\"))             \n// val it : string * (int * string) = (\"hello\", (42, \"!!!\"))\n|> printfn \"%A\"\n\n\"hello\"^.to' length\n// val it : int = 5\n|> printfn \"%A\"\n\n(\"hello\",(\"world\",\"!!!\"))^. (_2 << _2 << to' length)\n// val it : int = 3\n|> printfn \"%A\"\n\n_1 .-> \"hello\" <| ((),\"world\")\n// val it : string * string = (\"hello\", \"world\")\n|> printfn \"%A\"\n\n((), \"world\") |> _1 .-> \"hello\"\n// val it : string * string = (\"hello\", \"world\")\n|> printfn \"%A\"\n\nview _2 (10,20)\n// val it : int = 20\n|> printfn \"%A\"\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"3def8b16-6c90-40f4-a78e-b2b293df699a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"System.IO.Path.GetRandomFileName()\n|> printfn \"%s\"","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"c8d8aeb9-a872-45dc-b240-b7846e076d1a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Check All F# Code 1","content":"#define JUSTCHECKING","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"c8d8aeb9-a872-45dc-b240-b7846e076d1a"},{"$":0,"Item":"dfc80990-ada5-4f24-8192-85bfe3b115a5"},{"$":0,"Item":"f850ce38-14e5-47a4-81ed-df02d7979f8e"},{"$":0,"Item":"210f90c1-81fc-43bd-b838-6a5dc2a8e46b"},{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},{"$":0,"Item":"b4a9f681-f5c2-443b-8f6e-146a6d6cd093"},{"$":0,"Item":"08e9600a-804b-4aba-a262-85f22e0cc8de"},{"$":0,"Item":"8efdcd5a-95c4-4212-9c75-1ebedce83dd8"},{"$":0,"Item":"c7e56d1e-aea8-483a-a99a-23b7e056de0d"},{"$":0,"Item":"16f618b6-0483-44dc-9c54-550f4f5b725d"},{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},{"$":0,"Item":"56e5bc09-e528-49cc-9d42-6359b32a0cc9"},{"$":0,"Item":"8ee6b535-3615-4066-8917-9125cf8a1f20"},{"$":0,"Item":"1d18fdb5-2488-4ac9-813a-c96a66b9cd13"},{"$":0,"Item":"5df15cf1-361e-4d57-a565-683ab0b72082"},{"$":0,"Item":"3d704638-8ba4-4bc8-b810-29e023a222fc"},{"$":0,"Item":"bd716e89-0546-4d6b-8964-26473ddcd121"},{"$":0,"Item":"dc44bbe1-876a-4910-a39a-5d74bc2304ee"},{"$":0,"Item":"46450fbf-b073-4a66-ab42-587be0afc45f"}],"id":{"$":0,"Item":"caa2898b-b46a-4e93-99ba-63cc8e5726d0"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Test FSharp.Compiler.Service","content":"let input = \"\"\"\n(**)#r @\"D:\\Abe\\CIPHERWorkspace\\Repos\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\nopen System\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n\n// Create an interactive checker instance \n#if HELLO\nlet checker = FSharpChecker.Create()\n#endif\n// Sample input as a multi-line string\nlet input = \"\"\n// Split the input & define file name\nlet inputLines = input.Split('\\n')\nlet file = \"/home/user/Test.fsx\"\n\nasync {\n    let! projOptions                   = checker.GetProjectOptionsFromScript(file, input)\n    let! parseResults, checkFileAnswer = checker.ParseAndCheckFileInProject(file, 0, input, projOptions) \n    let! tip                           =\n        match checkFileAnswer with\n        | FSharpCheckFileAnswer.Succeeded res -> async { let! tip = res.GetToolTipTextAlternate(4, 13, inputLines.[1], [\"foo\"], FSharpTokenTag.Identifier) \n                                                         return sprintf \"%A\" tip                              }\n        | res                                 -> async { return sprintf \"Parsing did not finish... (%A)\" res }      \n    printfn \"%s\" tip\n} |> Async.RunSynchronously\n\"\"\"              \n\n#define FSHARP40\n#r @\"D:\\Abe\\CIPHERWorkspace\\Repos\\packages\\ServiceStack.Text\\lib\\net45\\ServiceStack.Text.dll\"\n#if FHSARP40\n#r @\"D:\\Abe\\CIPHERWorkspace\\Repos\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n#else\n#r @\"FSharp.Compiler.Service.dll\"\n#endif\n\nopen System\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\nopen ServiceStack.Text\n\nlet checker = FSharpChecker.Create()\n\nlet file       = @\"Compiled\\Test.fsx\"\nlet inputLines = input.Split('\\n')\nlet line       = 2\nlet lineStr    = inputLines.[line - 1]\nasync {\n    #if FSHARP40 \n    let! projOptions0    = checker.GetProjectOptionsFromScript(file, input)\n    #else\n    let! projOptions02, errors           = checker.GetProjectOptionsFromScript(file, input)\n    printfn \"ERRORS: %A\" errors\n    #endif\n    let  projOptions     = { projOptions0 with OtherOptions = Array.append projOptions0.OtherOptions [| \"-d:HELLO\" |]}\n    let! parseResults, checkFileAnswer = checker.ParseAndCheckFileInProject(file, 0, \"////-d:HELLO\\nlet a = 1\", projOptions)\n    let! tip                           =\n        match checkFileAnswer with\n        | FSharpCheckFileAnswer.Succeeded res -> \n//                 sprintfn \"answer:%A\" res.GetAllUsesOfAllSymbolsInFile\n                 async { let! tip = res.GetToolTipTextAlternate(2, 5, \"let a = 1\", [\"a\"], FSharpTokenTag.IDENT) \n//                 async { //let tip = res.//GetAllUsesOfAllSymbolsInFile() \n                         //.Replace(\" \", \"_\")\n                               //|> Seq.map (fun u -> u.DisplayContext, u.FileName, u.RangeAlternate, u.Symbol)\n                               // |> Seq.map (sprintf \"%A\")\n                               // |> String.concat \"\\n\"\n                         return sprintf \"%A\" tip }\n        | res -> async { return sprintf \"Parsing did not finish... (%A)\" res }      \n    printfn \"%s\" tip\n    printfn \":%s\" lineStr\n    printfn \"PROJECT: %A\" projOptions\n    //parseResults.PrintDump()\n    let res = checker.TryGetRecentCheckResultsForFile(file, projOptions)\n    printfn \"RES: %A\" res\n    match res with\n    | None  -> ()\n    | Some  (_, res,_) ->\n        let! tip2 = res.GetToolTipTextAlternate(2, 5, \"let a = 1\", [\"a\"], FSharpTokenTag.IDENT) \n        printfn \"TIP2: %A\" tip2\n} |> Async.RunSynchronously","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"d54a55c5-1462-4983-a966-4feb4cfccb2a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Check All F# Code 2","content":"// separate check for FSAutoComplete because it uses a different version of Compiler.Services.dll than Compile\n#define JUSTCHECKING","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"d54a55c5-1462-4983-a966-4feb4cfccb2a"},{"$":0,"Item":"971e9b81-6e5d-4f11-a604-f87504d7c950"}],"id":{"$":0,"Item":"11e21cf6-f497-4f73-a287-a2d5ff5b0445"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"WebSharper Code","content":"#define WEBSHARPER\n(*\n Code to be Compiled to Javascript and run in the browser\n using `Compile WebSharper` or `Run WebSharper`\n*)\n","parent":{"$":0,"Item":"bf864f3c-1370-42f2-ac8a-565a604892e8"},"predecessors":[{"$":0,"Item":"66ab3e22-f5ed-4e75-966d-28394d24f3d7"}],"id":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"expanded":false,"level":0,"levelCode":0,"properties":{"Theme":"twilight","DisableFSI":"1","NoIndent":"1"}},{"name":"HtmlNode","content":"\n[<JavaScript>]\nmodule HtmlNode      =\n","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"Val","content":"[<NoComparison>]\ntype Val<'a> =\n    | Constant  of 'a\n    | DynamicV  of IRef<'a>\n    | Dynamic   of View<'a>\n  with member this.FooBar = 0\n\nmodule Val =\n    \n    let mapV : ('a -> 'b) -> Val<'a> -> Val<'b> =\n        fun    f             va      ->\n            match va with\n            | Constant  a -> f a                   |> Constant\n            | Dynamic  wa -> wa      |> View.Map f |> Dynamic \n            | DynamicV va -> va.View |> View.Map f |> Dynamic \n\n    let iterV : ('a -> unit) -> Val<'a> -> unit = //f v = toView v |> View.Get f\n        fun     f               va      ->\n            match va with\n            | Constant  a ->          f  a                  \n            | Dynamic  wa -> View.Get f wa \n            | DynamicV va ->          f va.Value \n\n    let toView v =\n        match v with\n        | Constant  a -> View.Const a\n        | Dynamic  wa -> wa\n        | DynamicV va -> va.View\n\n    let bindV : ('a -> Val<'b>) -> Val<'a> -> Val<'b> =\n        fun     f                  v       -> \n            match v with\n            | Constant  a -> f a\n            | Dynamic  wa -> wa      |> View.Bind (f >> toView) |> Dynamic \n            | DynamicV va -> va.View |> View.Bind (f >> toView) |> Dynamic \n\n    let inline map2V f = // : ('a -> 'b -> 'c) -> Val<'a> -> Val<'b> -> Val<'c> =\n        //fun     f                ->\n        let inline swap f a b = f b a\n        let inline fv vb = bindV (swap (f >> mapV) vb)\n        swap fv\n\n    let inline map3V f3 v1 v2 v3    = map2V f3 v1 v2    |> map2V (|>) v3\n    let inline map4V f3 v1 v2 v3 v4 = map3V f3 v1 v2 v3 |> map2V (|>) v4\n    \n    let tagDoc: ('a -> Doc) -> Val<'a> -> Doc =\n        fun     tag            va      ->\n            match va with\n            | Constant  a -> tag   a\n            | Dynamic  wa -> wa      |> View.Map tag |> Doc.EmbedView\n            | DynamicV va -> va.View |> View.Map tag |> Doc.EmbedView\n\n    let tagElt: ('a -> Elt) -> Val<'a> -> Doc =\n        fun     tag            va     ->\n            match va with\n            | Constant  a -> tag   a :> Doc\n            | Dynamic  wa -> wa     |> View.Map tag |> Doc.EmbedView\n            | DynamicV va -> va.View |> View.Map tag |> Doc.EmbedView\n\n    let attrVO att       vao     =\n            match vao with\n            | Constant (Some a)-> Attr.Create      att   a\n            | Constant  None   -> Attr.DynamicPred att  (View.Const false              ) (View.Const                      \"\"         )\n            | Dynamic       wa -> Attr.DynamicPred att  (View.Map Option.isSome wa     ) (View.Map   (Option.defaultValue \"\") wa     )\n            | DynamicV      va -> Attr.DynamicPred att  (View.Map Option.isSome va.View) (View.Map   (Option.defaultValue \"\") va.View)\n\n    let attrV att       va      =\n            match va with\n            | Constant  a -> Attr.Create  att   a\n            | Dynamic  wa -> Attr.Dynamic att  wa\n            | DynamicV va -> Attr.Dynamic att  va.View\n\n\n    type HelperType = HelperType with\n        static member (&>) (HelperType, a :     string option   ) = Constant  a\n        static member (&>) (HelperType, a :     string          ) = Constant  a\n        static member (&>) (HelperType, a :     bool            ) = Constant  a\n        static member (&>) (HelperType, a :     int             ) = Constant  a\n        static member (&>) (HelperType, a :     float           ) = Constant  a\n        static member (&>) (HelperType, a :     Doc             ) = Constant  a\n        static member (&>) (HelperType, va: Val<string option>  ) =          va\n        static member (&>) (HelperType, va: Val<string       >  ) =          va\n        static member (&>) (HelperType, va: Val<bool         >  ) =          va\n        static member (&>) (HelperType, va: Val<int          >  ) =          va\n        static member (&>) (HelperType, va: Val<float        >  ) =          va\n        static member (&>) (HelperType, va: Val<Doc          >  ) =          va\n        static member (&>) (HelperType, va: Val<_            >  ) =          va\n        static member (&>) (HelperType, vr: IRef<_           >  ) = DynamicV vr\n        static member (&>) (HelperType, vw: View<_           >  ) = Dynamic  vw\n\n(*    [< Inline @\"(\n            typeof($v) == 'function' ? {$:2, $0:$v} // View\n            :   typeof($v) == 'object'\n                      ? typeof($v.$) != 'undefined' // Val\n                            ? $v \n                            : typeof($v.Id) == 'number' || typeof($v.i) == 'number' || typeof($v.RView == 'function')// Var\n                                 ? {$:1, $0:$v}\n                                 : typeof($v.docNode) != 'undefined'\n                                     ? {$:0, $0:$v} // Doc\n                                     : {$:2, $0:$v} // View?\n                      : {$:0, $0:$v}) // other\n                                     \" >]\n    let fixit0 v = Constant v\n    let fixit2 v = let result = fixit0 v\n                   result\n                   \n    [< Direct \"FSSGlobal.HtmlNode.Val.fixit2($v)\" >]\n    //[< Inline >]\n    let inline fixit v = HelperType &> v\n*)\n    let toVal (o: obj) =\n        match o with\n        | :?      string   as t   -> Val.Constant t \n        | :?      int      as t   -> Val.Constant t |> As<Val<string>> \n        | :?      bool     as t   -> Val.Constant t |> As<Val<string>>  \n        | :?      Doc      as t   -> Val.Constant t |> As<Val<string>>  \n        | :? Val< string>  as v   ->              v        \n        | :? Var< string>  as v   -> Val.DynamicV v        \n        | v when JS.In \"RSet\" v   -> Val.DynamicV (As<IRef<string>> v)\n        | :? Function      as vw  -> Val.Dynamic  (As<View<string>> vw)        \n        | _                       -> failwith <| sprintf \"Could not convert %A\" o\n\n    [< Direct \"$f($v)\" >]\n    let inline fixitF f v = HelperType &> v\n    let inline fixit    v = fixitF toVal v\n\n    let [<Inline>] inline bindIRef0 (f: 'a->IRef<'b>) (view: View<'a>) = \n        let contentVar = Var.Create Unchecked.defaultof<'b>\n        let changingIRefO : IRef<'b> option ref = ref None\n        let contentVarChanged = ref 0L\n        let refVarChanged     = ref 0L\n    \n        contentVar.View \n        |> View.Sink (fun _ -> \n            !changingIRefO \n            |> Option.iter (fun r -> \n                if  !contentVarChanged  > !refVarChanged   then refVarChanged := !contentVarChanged\n                elif r.Value           <> contentVar.Value then refVarChanged := !refVarChanged       + 1L ; r.Value         <-  contentVar.Value\n               )\n           )\n    \n        view |> View.Bind (fun cur ->\n            let r = f cur\n            changingIRefO    := Some r\n            refVarChanged    := !contentVarChanged + 100L\n            contentVar.Value <- r.Value\n            r.View\n        ) |> View.Sink (fun _ -> \n            !changingIRefO \n            |> Option.iter (fun r -> \n                if  !refVarChanged  > !contentVarChanged then contentVarChanged := !refVarChanged\n                elif r.Value       <> contentVar.Value   then contentVarChanged := !contentVarChanged + 10L; contentVar.Value  <-  r.Value\n               )\n            )\n        contentVar\n    \n    let inline toDoc       v           = toView      (fixit v ) |> Doc.EmbedView\n    let [<Inline>] inline bindIRef f  v           = bindIRef0 f (fixit v   |> toView)\n    let inline iter     f  v           = iterV     f (fixit v )\n    let inline bind     f  v           = bindV     f (fixit v )\n    let inline map      f  v           = mapV      f (fixit v )\n    let inline map2     f  v1 v2       = map2V     f (fixit v1) (fixit v2)\n    let inline map3     f  v1 v2 v3    = map3V     f (fixit v1) (fixit v2) (fixit v3)\n    let inline map4     f  v1 v2 v3 v4 = map4V     f (fixit v1) (fixit v2) (fixit v3) (fixit v4)\n    let inline sink     f  v           = fixit v |> toView |> View.Sink f\n\n    let inline iter2    f  v1 v2       = map2      f v1 v2       |> iterV id\n    let inline iter3    f  v1 v2 v3    = map3      f v1 v2 v3    |> iterV id\n    let inline iter4    f  v1 v2 v3 v4 = map4      f v1 v2 v3 v4 |> iterV id\n\n    let inline mapAsync f  v           = View.MapAsync f (fixit v |> toView) \n\n","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"0f5719f0-e95e-498d-ab88-f89ff1440e32"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"HtmlNode","content":"[<NoComparison ; NoEquality>]\ntype HtmlNode =\n    | HtmlElement    of name: string * children: HtmlNode seq\n    | HtmlAttribute  of name: string * value:    Val<string>\n    | HtmlAttributeO of name: string * value:    Val<string option>\n    | HtmlText       of Val<string>\n    | HtmlEmpty\n    | HtmlElementV   of Val<HtmlNode>\n    | SomeDoc        of Doc\n    | SomeAttr       of Attr\n    \nlet addClassX    (classes:string) (add:string) = classes.Split ' ' |> Set.ofSeq |> Set.union  (Set.ofSeq <| add.Split ' ') |> String.concat \" \"\n//let removeClass (classes:string) (rem:string) = classes.Split ' ' |> Set.ofSeq |> Set.remove               rem            |> String.concat \" \"\n\n//let callAddClassX = addClassX \"a\" \"b\" // so that WebSharper.Collections.js is included\n\nlet inline chooseAttr node = \n    match node with\n    | HtmlAttribute (name, value   ) when name <> \"class\" && name <> \"style\" \n                                     -> Some <| Val.attrV    name value\n    | HtmlAttributeO(name, valueO  ) when name <> \"class\" && name <> \"style\" \n                                     -> Some <| Val.attrVO   name valueO\n    | SomeAttr             attr      -> Some <| attr\n    | _                              -> None\n\nlet chooseThisAttr this node =\n    match node with\n    | HtmlAttribute (att, value) when att = this -> Some value\n    | _                                          -> None\n\nlet concat s a b = a + s + b\nlet groupAttr name sep children = \n    children \n    |> Seq.choose (chooseThisAttr name)\n    |> (fun ss -> if ss |> Seq.isEmpty \n                  then None \n                  else ss |> Seq.reduce (Val.map2 <| concat sep ) |> Val.attrV name |> Some)\n\nlet inline getAttrsFromSeq children =\n    children \n    |> Seq.choose chooseAttr\n    |> Seq.append (List.choose id [ children |> groupAttr \"class\" \" \" ; children |> groupAttr \"style\" \"; \" ])\n\nlet rec chooseNode node =\n    match node with\n    | HtmlElement (name, children) -> Some <| (Doc.Element name (getAttrsFromSeq children) (children |> Seq.choose chooseNode) :> Doc)\n    | HtmlText     vtext           -> Some <| Val.tagDoc WebSharper.UI.Next.Html.text vtext\n    | SomeDoc      doc             -> Some <| doc\n    | HtmlElementV vnode           -> Some <| (vnode |> Val.toView |> Doc.BindView (chooseNode >> Option.defaultValue Doc.Empty))\n    | _                            -> None\n\nlet getAttrChildren attr =\n    Seq.tryPick (function \n                | HtmlAttribute(a, v) when a = attr -> Some v \n                | _                                 -> None)\n    >> Option.defaultValue (Constant \"\")\n\nlet rec mapHtmlElement (f:string -> seq<HtmlNode> -> string * HtmlNode seq) (element:HtmlNode) :HtmlNode =\n    match element with\n    | HtmlElement (name, children) -> f name  children                    |> HtmlElement\n    | HtmlElementV vnode           -> vnode |> Val.map (mapHtmlElement f) |> HtmlElementV\n    | _                            -> element\n\n//let getAttr attr element =\n//    match element with\n//    | HtmlElement(_, children) -> children\n//    | _                        -> seq []\n//    |> getAttrChildren attr\n//\n//let getClass = getAttr \"class\"\n//let getStyle = getAttr \"style\"\n\n//let replaceAttribute att (children: HtmlNode seq) newVal =\n//    HtmlAttribute(att, newVal)\n//    :: (children\n//        |> Seq.filter (function HtmlAttribute(old, _) when old = att -> false | _ -> true)\n//        |> Seq.toList\n//       )\n//\n//let replaceAtt att node newVal = mapHtmlElement (fun n ch -> n, replaceAttribute att ch newVal |> Seq.ofList) node\n\nlet inline htmlElement    name ch = HtmlElement   (name, ch           )\nlet inline htmlAttribute  name v  = HtmlAttribute (name, Val.fixit v  )\nlet inline htmlAttributeO name v  = HtmlAttributeO(name, Val.fixit v  )\nlet inline htmlText       txt     = HtmlText      (      Val.fixit txt)\nlet inline someElt        elt     = SomeDoc       (elt :> Doc         )    \n  \nlet inline addChildren    add (h:HtmlNode) = h |> mapHtmlElement (fun n ch -> n, Seq.append ch   add)\nlet inline insertChildren add (h:HtmlNode) = h |> mapHtmlElement (fun n ch -> n, Seq.append add  ch )\nlet inline addClass       c    h           = h |> addChildren [ htmlAttribute  \"class\" c ] \nlet inline addClassIf     c v              = addClass <| Val.map (fun b -> if b then c else \"\") (Val.fixit v)\n\ntype HtmlNode with\n    member inline this.toDoc = \n        match this with\n        | HtmlAttribute _\n        | HtmlEmpty       -> Doc.Empty\n        | _               -> chooseNode this |> Option.defaultValue Doc.Empty\n    // member inline   this.Class          clas = Val.fixit clas |> replaceAtt \"class\" this\n    member          this.AddChildren    add  = this |> addChildren    add\n    member          this.InsertChildren add  = this |> insertChildren add\n    member inline   this.AddClass       c    = this |> addClass       c\n\nlet renderDoc = chooseNode >> Option.defaultValue Doc.Empty\n    ","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"0f5719f0-e95e-498d-ab88-f89ff1440e32"}],"id":{"$":0,"Item":"d9124644-0af6-4a7f-a711-ef76ca77f0de"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"HTML Elements & Attributes","content":"let inline atr att v = Val.attrV  att (Val.fixit v)\nlet inline tag tag v = Val.tagDoc tag (Val.fixit v)\n\nlet inline _class       v = atr \"class\"       v\nlet inline _type        v = atr \"type\"        v\nlet inline _style       v = atr \"style\"       v\nlet inline _placeholder v = atr \"placeholder\" v\nlet inline textV        v = tag  Html.text    v\n\nlet inline a           ch = htmlElement   \"a\"           ch\nlet inline ul          ch = htmlElement   \"ul\"          ch\nlet inline li          ch = htmlElement   \"li\"          ch\nlet inline br          ch = htmlElement   \"br\"          ch\nlet inline hr          ch = htmlElement   \"hr\"          ch\nlet inline h1          ch = htmlElement   \"h1\"          ch\nlet inline h2          ch = htmlElement   \"h2\"          ch\nlet inline h3          ch = htmlElement   \"h3\"          ch\nlet inline h4          ch = htmlElement   \"h4\"          ch\nlet inline h5          ch = htmlElement   \"h5\"          ch\nlet inline h6          ch = htmlElement   \"h6\"          ch\nlet inline div         ch = htmlElement   \"div\"         ch\nlet inline img         ch = htmlElement   \"img\"         ch\nlet inline span        ch = htmlElement   \"span\"        ch\nlet inline form        ch = htmlElement   \"form\"        ch\nlet inline table       ch = htmlElement   \"table\"       ch\nlet inline thead       ch = htmlElement   \"thead\"       ch\nlet inline th          ch = htmlElement   \"th\"          ch\nlet inline tr          ch = htmlElement   \"tr\"          ch\nlet inline td          ch = htmlElement   \"td\"          ch\nlet inline tbody       ch = htmlElement   \"tbody\"       ch\nlet inline label       ch = htmlElement   \"label\"       ch\nlet inline button      ch = htmlElement   \"button\"      ch\nlet inline script      sc = htmlElement   \"script\"      sc\nlet inline styleH      st = htmlElement   \"style\"       st\nlet inline fieldset    ch = htmlElement   \"fieldset\"    ch\nlet inline link        sc = htmlElement   \"link\"        sc\nlet inline iframe      at = htmlElement   \"iframe\"      at\nlet inline body        ch = htmlElement   \"body\"        ch\n\n\nlet inline target      v  = htmlAttribute  \"target\"      v\nlet inline href        v  = htmlAttribute  \"href\"        v\nlet inline hrefO       vO = htmlAttributeO \"href\"        vO\nlet inline rel         v  = htmlAttribute  \"rel\"         v\nlet inline charset     v  = htmlAttribute  \"charset\"     v\nlet inline src         v  = htmlAttribute  \"src\"         v\nlet inline ``class``   v  = htmlAttribute  \"class\"       v\nlet inline ``type``    v  = htmlAttribute  \"type\"        v\nlet inline width       v  = htmlAttribute  \"width\"       v\nlet inline title       v  = htmlAttribute  \"title\"       v\nlet inline Id          v  = htmlAttribute  \"id\"          v\nlet inline frameborder v  = htmlAttribute  \"frameborder\" v\nlet inline spellcheck  v  = htmlAttribute  \"spellcheck\"  v\nlet inline draggable   v  = htmlAttribute  \"draggable\"   v\nlet inline style       v  = htmlAttribute  \"style\"       v\n\nlet inline style1    n v  = style <| Val.map ((+) (n + \":\")) v\n\ntype HtmlNode with\n    member inline   this.Style          sty  = this.AddChildren([ style sty ])\n\nlet inline css         v  = styleH [ htmlText v ] \n\nlet inline classIf cls v = ``class`` <| Val.map (fun b -> if b then cls else \"\") (Val.fixit v)\n\nlet inline ``xclass`` v  = \n    match Val.fixit v with\n    | Constant c  -> Attr.Class        c       \n    | Dynamic  cw -> Attr.DynamicClass \"class_for_view_not_implemented\" cw      ((<>)\"\")\n    | DynamicV cv -> Attr.DynamicClass cv.Value                         cv.View ((<>)\"\")\n    |> SomeAttr\n\nlet style2pairs (ss:string) : (string * string) [] =\n    ss.Split(';') \n    |> Array.map   (fun s -> s.Split(':') ) \n    |> Array.filter(fun d -> d.Length = 2 )\n    |> Array.map   (fun d -> d.[0].Trim(), d.[1].Trim() )\n\nlet string2Styles = style2pairs >> Array.map (fun (n, v) -> Attr.Style n v |> SomeAttr)\n\n//let composeDoc elt dtl dtlVal = dtlVal |> Val.toView |> Doc.BindView (Seq.append dtl >> elt >> renderDoc) |> SomeDoc\n\nlet inline bindHElem hElemF v  = Val.map hElemF  (Val.fixit v) |> HtmlElementV\n\nlet createIFrame f =\n    let cover = Var.Create true\n    div [ style           \"position: relative; overflow: hidden; height: 100%; width: 100%;\" \n          iframe \n            [ style       \"position: absolute; width:100%; height:100%;\"\n              frameborder \"0\"\n              SomeAttr <| on.afterRender f\n              SomeAttr <| on.mouseLeave (fun _ _ -> cover.Value <- true)\n            ]\n          div \n            [ style       \"position: absolute;\"\n              classIf     \"iframe-cover\" (Val.map id cover)               \n              SomeAttr <| on.mouseEnter (fun _ _ -> Input.Mouse.MousePressed \n                                                    |> View.Get (fun pressed -> if not pressed then cover.Value <- false))\n            ]          \n          styleH [ htmlText \".iframe-cover { top:0; left:0; right:0; bottom:0; background: blue; opacity: 0.04; z-index: 2; }\" ]\n        ]\n\n[< Inline \"\"\"(!$v)\"\"\">]\nlet isUndefined v = true\n\nlet  findRootElement (e:Dom.Element) =\n    let root = e.GetRootNode()\n    if isUndefined root?body \n    then root.FirstChild :?> Dom.Element\n    else root?body  |> unbox<Dom.Element>\n","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"d9124644-0af6-4a7f-a711-ef76ca77f0de"}],"id":{"$":0,"Item":"c3755c07-1385-495d-bad7-a5b0fa54ac9b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"storeVar","content":"[< Inline >]\nlet inline storeVar<'T> storeName (var:IRef<_>) =\n    JS.Window.LocalStorage.GetItem storeName |> fun v -> if v <> null then           var.Value <- Json.Deserialize<'T> v\n    Val.sink (fun v -> JS.Window.LocalStorage.SetItem (storeName, Json.Serialize v)) var\n\n","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"0f5719f0-e95e-498d-ab88-f89ff1440e32"}],"id":{"$":0,"Item":"336d6f19-0c57-4af9-8716-1b3fbf6b112c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"LoadFiles","content":"[< Inline \"CIPHERSpaceLoadFiles($files, $cb)\" >]\nlet LoadFiles (files: string []) (cb: unit -> unit) : unit = X<_>","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"02d3bc50-4aa0-41ce-a37e-5b90a943481f"}],"id":{"$":0,"Item":"1f1aa135-fd74-42cc-b9a5-87f380c113a9"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"open HtmlNode","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"c3755c07-1385-495d-bad7-a5b0fa54ac9b"}],"id":{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Template","content":"[<JavaScript>]\nmodule Template      =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"11ecbe45-3d0c-4121-a8fd-7c126b96f4a3"}],"id":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"","content":"let container content = div <| [ ``class`` \"container\" ] @ content","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"8fb54777-3046-4aae-9282-33401a45c280"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Bootstrap","content":"type Bootstrap() =\n    member this.Render =\n        div [\n          script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js' type='text/javascript\"    ; ``type`` \"text/javascript\" ; charset \"UTF-8\"      ]\n          script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"   ; ``type`` \"text/javascript\" ; charset \"UTF-8\"      ]\n          link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" ; ``type`` \"text/css\"        ; rel     \"stylesheet\" ]\n          link   [ href \"/EPFileX/css/main.css\"                                                ; ``type`` \"text/css\"        ; rel     \"stylesheet\" ]\n         ]\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"40614ad6-3f81-468b-a4ff-034124b82ae1"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Button","content":"[<NoComparison ; NoEquality>]\ntype Button = {\n    _class  : Val<string>\n    _type   : Val<string>\n    style   : Val<string>\n    text    : Val<string>\n    onClick : Dom.Element -> Dom.MouseEvent -> unit\n    disabled: Val<bool>\n    id      : string\n} with\n  static member inline New txt = \n      { _class   = Val.fixit \"btn\" \n        _type    = Val.fixit \"button\" \n        style    = Val.fixit \"\"\n        text     = Val.fixit txt\n        onClick  = fun _ _ -> ()\n        disabled = Val.fixit false\n        id       = \"\"\n      }\n  member        this.Render     =         \n    button [ ``type``  <| this._type\n             ``class`` <| this._class\n             Id        <| this.id  \n             style     <| this.style\n             SomeAttr  <| attr.disabledDynPred (View.Const \"\") (this.disabled |> Val.toView)\n             SomeAttr  <| on.click <@ this.onClick @>\n             HtmlText  <| this.text \n           ]\n  member inline this.Id          id   = { this with id       = id             }\n  member inline this.Class       clas = { this with _class   = Val.fixit clas }\n  member inline this.Type        typ  = { this with _type    = Val.fixit typ  }\n  member inline this.Style       sty  = { this with style    = Val.fixit sty  }\n  member inline this.Text        txt  = { this with text     = Val.fixit txt  }\n  member inline this.Disabled    dis  = { this with disabled = Val.fixit dis  }\n  member inline this.OnClick     f    = { this with onClick  = f              }","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Input","content":"[<NoComparison ; NoEquality>]\ntype Input = {\n    _type       : Val<string>\n    _class      : Val<string>\n    style       : Val<string>\n    placeholder : Val<string>\n    id          : string\n    var         : IRef<string>\n    prefix      : HtmlNode\n    suffix      : HtmlNode\n    content     : Attr seq\n    prefixAdded : bool\n    suffixAdded : bool\n} with\n  static member  New(var) = { _class      = Val.fixit \"form-control\" \n                              _type       = Val.fixit \"text\" \n                              style       = Val.fixit \"\" \n                              placeholder = Val.fixit \"Enter text:\"\n                              id          = \"\"\n                              content     = []\n                              prefix      = HtmlEmpty\n                              prefixAdded = false\n                              suffix      = HtmlEmpty\n                              suffixAdded = false\n                              var         = var   \n                            }\n  static member  New(v)   = Input.New(Var.Create v)\n  member        this.Render    =         \n    let groupClass det = match det with HtmlText _  -> \"input-group-addon\" | _ -> \"input-group-btn\"\n    div [\n        if this.prefixAdded || this.suffixAdded then\n            yield ``class`` \"input-group\"\n        if this.prefixAdded then\n            yield  span     [ ``class`` <| groupClass this.prefix \n                              this.prefix       ]\n        yield Doc.Input ([_type            this._type\n                          _class           this._class\n                          _style           this.style\n                          attr.id          this.id  \n                          _placeholder     this.placeholder ] |> Seq.append this.content)\n                          this.var\n              :> Doc |> SomeDoc\n        if this.suffixAdded then\n            yield  span     [ ``class`` <| groupClass this.suffix \n                              this.suffix       ]\n      ]\n  member inline this.Class       clas = { this with _class      = Val.fixit clas                  }\n  member inline this.Type        typ  = { this with _type       = Val.fixit typ                   }\n  member inline this.Style       sty  = { this with style       = Val.fixit sty                   }\n  member inline this.Placeholder plc  = { this with placeholder = Val.fixit plc                   }\n  member inline this.Id          id   = { this with id          =       id                        }\n  member inline this.Content     c    = { this with content     =       c                         }\n  member inline this.Prefix      p    = { this with prefix      =       p    ; prefixAdded = true }\n  member inline this.Prefix      p    = this.Prefix(htmlText p)\n  member inline this.Suffix      s    = { this with suffix      =       s    ; suffixAdded = true }\n  member inline this.SetVar      v    = { this with var         = v                               }\n  member inline this.Var              = this.var","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Hoverable","content":"[<NoComparison ; NoEquality>]\ntype Hoverable = {\n    hover      : IRef<bool>\n} with\n  static member  New   = \n    let hover      = Var.Create false\n    { \n        hover      = hover     \n    }\n  member inline this.Content    (c: HtmlNode seq) = \n    [ classIf \"hovering\" this.hover\n      SomeAttr <| on.mouseEnter (fun _ _ -> this.hover.Value <- true )\n      SomeAttr <| on.mouseLeave (fun _ _ -> this.hover.Value <- false)\n    ] \n    |> Seq.append  c\n    |> div\n  member inline this.Content    (c:HtmlNode) = \n      c.AddChildren \n          [ classIf \"hovering\" this.hover\n            SomeAttr <| on.mouseEnter (fun _ _ -> this.hover.Value <- true )\n            SomeAttr <| on.mouseLeave (fun _ _ -> this.hover.Value <- false)\n          ] \n  static member  Demo  = Hoverable.New.Content(div [ style \"flex-flow: column;\" ])\n  \nlet hoverable (c:HtmlNode) = Hoverable.New.Content c\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Panel","content":"[<NoComparison ; NoEquality>]\ntype Panel = {\n    _class   : Val<string>\n    _style   : Val<string>\n    title    : Val<string>\n    header   : HtmlNode seq\n    content  : HtmlNode seq\n    disabled : Val<bool>\n} with\n  static member  New   = { _class   = Val.fixit <| \"panel panel-default shadow\"\n                           _style   = Val.fixit <| \"text-align:center\" \n                           title    = Val.fixit <| \"Panel\"        \n                           header   =          [ htmlText \"Some text\"    ] \n                           content  =          [ htmlText \"Some Content\" ] \n                           disabled = Val.fixit <| Var.Create false\n                         }\n  member        this.Render          =  \n    fieldset [ SomeAttr <| attr.disabledDynPred (View.Const \"\")  (this.disabled |> Val.toView)\n               div [ ``class`` this._class\n                     div (Seq.append\n                              [ ``class`` \"panel-heading\"\n                                label [ ``class``  \"panel-title text-center\" ; htmlText this.title ]\n                              ]\n                              this.header)\n\n                     div (Seq.append\n                              [ ``class`` \"panel-body\"\n                                style     this._style \n                              ]\n                              this.content)\n                   ] \n             ]\n  member inline this.Class       clas = { this with _class   = Val.fixit clas                                        }\n  member inline this.Style       sty  = { this with _style   = Val.fixit sty                                         }\n  member inline this.Title       txt  = { this with title    = Val.fixit txt                                         }\n  member inline this.Header      h    = { this with header   =       h                                           }\n  member inline this.Content     c    = { this with content  =       c                                           }\n  member inline this.Disabled    dis  = { this with disabled =       dis                                         }\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"}],"id":{"$":0,"Item":"0a11766b-f227-4b38-88a3-919d964387bf"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"TextArea","content":"[<NoComparison ; NoEquality>]\ntype TextArea = {\n    _class      : Val<string>\n    placeholder : Val<string>\n    title       : Val<string>\n    spellcheck  : Val<bool>\n    id          : string\n    var         : IRef<string>\n} with\n  static member  New(var) = { _class      = Val.fixit \"form-control\"\n                              placeholder = Val.fixit \"Enter text:\"\n                              title       = Val.fixit \"\"\n                              spellcheck  = Val.fixit false\n                              id          = \"\"\n                              var         = var \n                            }\n  static member  New(v)   = TextArea.New(Var.Create v)\n  member        this.RenderWith  more  =    \n    Doc.InputArea\n        ([ \n          _class              this._class\n          attr.id             this.id  \n          atr \"spellcheck\" <| Val.map (fun spl -> if spl then \"true\" else \"false\") this.spellcheck\n          atr \"title\"         this.title\n          atr \"style\"        \"height: 100%;  width: 100%; box-sizing: border-box; \"\n          _placeholder        this.placeholder \n        ] @ more)\n        this.var\n    |> someElt \n    |> Seq.singleton \n    //|> Seq.append [ style \"height: 100%;  width: 100%; box-sizing: border-box; \" ] \n    |> div\n  member        this.Render           = this.RenderWith []    \n  member inline this.Class       clas = { this with _class      = Val.fixit clas }\n  member inline this.Placeholder plc  = { this with placeholder = Val.fixit plc  }\n  member inline this.Title       ttl  = { this with title       = Val.fixit ttl  }\n  member inline this.Spellcheck  spl  = { this with spellcheck  = spl            }\n  member inline this.Id          id   = { this with id          = id             }\n  member inline this.SetVar      v    = { this with var         = v              }\n  member inline this.Var              = this.var\n  ","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"codeMirrorIncludes","content":"let codeMirrorIncludes =\n   [| \"/EPFileX/codemirror/scripts/codemirror/codemirror.js\"             \n      \"/EPFileX/codemirror/scripts/intellisense.js\"                      \n      \"/EPFileX/codemirror/scripts/codemirror/codemirror-intellisense.js\"\n      \"/EPFileX/codemirror/scripts/codemirror/codemirror-compiler.js\"    \n      \"/EPFileX/codemirror/scripts/codemirror/mode/none.js\"            \n      \"/EPFileX/codemirror/scripts/codemirror/mode/fsharp.js\"            \n      \"/EPFileX/codemirror/scripts/codemirror/mode/css.js\"            \n      \"/EPFileX/codemirror/scripts/codemirror/mode/javascript.js\"            \n      \"/EPFileX/codemirror/scripts/codemirror/mode/markdown.js\"            \n      \"/EPFileX/codemirror/scripts/addon/search/searchcursor.js\"          \n      \"/EPFileX/codemirror/scripts/addon/search/search.js\"          \n      \"/EPFileX/codemirror/scripts/addon/search/jump-to-line.js\"          \n      \"/EPFileX/codemirror/scripts/addon/dialog/dialog.js\"          \n      \"/EPFileX/codemirror/scripts/addon/edit/matchbrackets.js\"          \n      \"/EPFileX/codemirror/scripts/addon/selection/active-line.js\"       \n      \"/EPFileX/codemirror/scripts/addon/display/fullscreen.js\"          \n      \"/EPFileX/codemirror/scripts/addon/hint/show-hint.js\"          \n      \"/EPFileX/codemirror/scripts/addon/lint/lint.js\"          \n//      \"/EPFileX/codemirror/scripts/codemirror/mode/markdown.js\"                 \n   |]","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"4180353c-9dc5-438d-862d-851539b02075"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CodeMirror","content":"type CodeMirrorPos = { line: int ; ch  : int }\nlet inline cmPos(l, c) = { line = l ; ch  = c }\n\ntype CodeMirrorEditor() =\n    let a = 1\n  with\n    [< Inline \"CodeMirror($elt, {\n\t    theme        : 'rubyblue'\n\t  , lineNumbers  : true\n\t  , matchBrackets: true\n      , gutters      : ['CodeMirror-lint-markers']\n      , extraKeys    : {\n\t\t    Tab  : function (cm) { cm.replaceSelection('    ', 'end'); }\n\t\t  , 'F11': function (cm) { cm.setOption('fullScreen', !cm.getOption('fullScreen')); }\n        }\n})\"    >]\n//    [< Inline \"setupEditor($elt)\" >]\n    static member SetupEditor elt                                     : CodeMirrorEditor = X<_>\n    [< Inline \"$this.getValue()\"              >]      \n    member this.GetValue()                                            : string           = X<_>\n    [< Inline \"$this.setValue($v)\"            >]      \n    member this.SetValue(v:string)                                    : unit             = X<_>\n    [< Inline \"$this.refresh()\"               >]      \n    member this.Refresh()                                             : unit             = X<_>\n    [< Inline \"$this.setOption($o, $v)\"       >]      \n    member this.SetOption(o:string, v:obj)                            : unit             = X<_>\n    [< Inline \"$this.getCursor()\"             >]      \n    member this.GetCursor()                                           : CodeMirrorPos    = X<_>\n    [< Inline \"$this.setCursor($line, $col)\"  >]      \n    member this.SetCursor(line:int, col:int)                          : unit             = X<_>\n    [< Inline \"$this.focus()\"                 >]      \n    member this.Focus()                                               : unit             = X<_>\n    [< Inline \"$this.getLine($l)\"             >]      \n    member this.GetLine(l:int)                                        : string           = X<_>\n    [< Inline \"$this.getDoc().markText({line:$fl, ch:$fc}, {line:$tl, ch:$tc}, {className: $className, title: $title})\" >]\n    member this.MarkText (fl:int, fc:int) (tl:int, tc:int) (className: string) (title: string): unit       = X<_>\n    [< Inline \"while($this.getAllMarks().length > 0) { $this.getAllMarks()[0].clear() }\" >]\n    member this.RemoveMarks() : unit       = X<_>\n    [< Inline \"$this.getDoc().clearHistory()\" >]\n    member this.ClearHistory()                                        : unit             = X<_>\n    [< Inline \"$this.on($event, $f)\"          >]\n    member this.On(event: string, f:(CodeMirrorEditor * obj) -> unit) : unit             = X<_>\n    [< Inline \"$this.addKeyMap($keyMap)\"      >]\n    member this.AddKeyMap(keyMap: obj)                                : unit              = X<_>\n    [< Inline \"$this.getWrapperElement()\"     >]\n    member this.GetWrapperElement()                                   : Dom.Element       = X<_>\n\n[<NoComparison ; NoEquality>]\ntype CodeMirror = {\n    _class          : Val<string>\n    style           : Val<string>\n    id              : string\n    var             : IRef<string>\n    onChange        : (unit             -> unit)\n    onRender        : (CodeMirrorEditor -> unit) option\n    mutable editorO : CodeMirrorEditor option\n} with\n\n  static member  New(var) = \n      { _class   = Val.fixit \"\" \n        style    = Val.fixit \"\" \n        id       = \"\"\n        var      = var \n        onChange = ignore\n        onRender = None\n        editorO  = None\n      }\n  static member  New(v)   = CodeMirror.New(Var.Create v)\n  member        this.Render    =\n    div [ \n          ``class``            this._class\n          SomeAttr <| attr.id  this.id \n          style \"position: relative; height: 300px\"\n          style                this.style\n          div [\n                style \"height: 100%; width: 100%; position: absolute;\"\n                SomeAttr <| on.afterRender (fun el ->\n                  LoadFiles codeMirrorIncludes\n                    (fun () ->                       \n                       let editor = CodeMirrorEditor.SetupEditor el\n                       this.editorO <- Some editor\n                       this.onRender |> Option.iter (fun onrender -> onrender editor)\n                       let editorChanged = ref 0L\n                       let varChanged    = ref 0L\n                       editor.On(\"changes\", fun (cm, change) ->\n                           let v = editor.GetValue() \n                           if this.var.Value <> v then editorChanged := !editorChanged + 1L; this.var.Value <- v; this.onChange() \n                       )\n                       this.var.View |> View.Sink (fun _ ->\n                           if  !editorChanged      > !varChanged    then varChanged := !editorChanged\n                           elif editor.GetValue() <> this.var.Value then editor.SetValue this.var.Value ; editor.ClearHistory()\n                       )\n                    )\n                )    \n              ]\n          link [ href \"/EPFileX/codemirror/content/editor.css\"                   ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/content/codemirror.css\"               ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/display/fullscreen.css\" ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/dialog/dialog.css\"      ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/hint/show-hint.css\"     ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/lint/lint.css\"          ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          css  \".CodeMirror { height: 100% }\"\n     ]\n  member inline this.Class    clas = { this with _class    = Val.fixit clas }\n  member inline this.Id       id   = { this with id        =       id       }\n  member inline this.SetVar   v    = { this with var       = v              }\n  member inline this.Style    sty  = { this with style     = Val.fixit sty  }\n  member inline this.OnChange f    = { this with onChange  = f              }\n  member inline this.OnRender f    = { this with onRender  = Some f         }\n  member inline this.Var           = this.var\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"1f1aa135-fd74-42cc-b9a5-87f380c113a9"},{"$":0,"Item":"4180353c-9dc5-438d-862d-851539b02075"}],"id":{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CodeMirror Hints","content":"\ntype Hint = {\n    text        : string\n    displayText : string\n    className   : string\n}\n\ntype HintResponse  = {\n    list           : Hint []\n    from           : CodeMirrorPos   \n    ``to``         : CodeMirrorPos   \n}\n\ntype HintFunc      = FuncWithArgs<CodeMirrorEditor * (HintResponse -> unit) * obj,  unit>\n\ntype HintOptions   = {\n    hint           : HintFunc\n    completeSingle : bool   \n    container      : Dom.Element\n}\n\n[< Inline \"($v.hint.async = 1, $ed.showHint($v))\"          >]\nlet showHint_ (ed:CodeMirrorEditor) v   : unit       = X<_>\nlet showHints (ed:CodeMirrorEditor) getHints completeSingle _ =\n    showHint_ ed\n        {  completeSingle = completeSingle\n           hint           = HintFunc getHints\n           container      = ed.GetWrapperElement() |> findRootElement\n        }\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"id":{"$":0,"Item":"a05dd36e-a15e-4394-8013-128e21e69574"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CodeMirror Lint","content":"type LintResponse  = {\n    message        : string\n    severity       : string\n    from           : CodeMirrorPos   \n    ``to``         : CodeMirrorPos   \n}\n\ntype LintFunc      = FuncWithArgs<string * (LintResponse[] -> unit) * obj * CodeMirrorEditor,  unit>\n\n[< Inline \"($ed.setOption('lint', { async: 1, getAnnotations: $f, container: $elm }))\"          >]\nlet setLint_(ed:CodeMirrorEditor) (f:LintFunc) (elm:Dom.Element)  : unit = X<_>\nlet setLint (ed:CodeMirrorEditor) getAnnotations       = \n    setLint_ ed (LintFunc getAnnotations) (ed.GetWrapperElement() |> findRootElement)\n\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"id":{"$":0,"Item":"18d8153d-422c-42f6-8266-9a9d854bd6a1"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"SplitterBar","content":"[<NoComparison ; NoEquality>]\ntype HtmlMeasure =\n| Percentage of Val<float>\n| Pixel      of Val<float>\n\n[<NoComparison ; NoEquality>]\ntype SplitterBar = {\n    value            : IRef<float>\n    min              : Val<float>\n    max              : Val<float>\n    vertical         : Val<bool>\n    node             : HtmlNode\n    children         : HtmlNode seq\n    after            : bool\n    mutable dragging : bool\n    mutable startVer : bool \n    mutable startP   : float \n    mutable start    : float \n    mutable size     : float \n    mutable domElem  : Dom.Element option\n}\nwith\n    static member New(var) = \n        {\n            value    = var\n            min      = Val.fixit   5.0\n            max      = Val.fixit  95.0\n            vertical = Val.fixit  true  \n            node     = div [ ``class`` \"Splitter\" ]\n            children = []\n            after    = true\n            dragging = false\n            startVer = true\n            startP   = 0.0\n            start    = 0.0\n            size     = 0.0\n            domElem  = None\n        }\n    static member New(value)    = SplitterBar.New(Var.Create value)\n    member        this.Var      = this.value\n    member        this.GetValue = this.value |> Val.map2 max this.min |> Val.map2 min this.max\n    member        this.Render   =\n        let mouseCoord (ev: Dom.MouseEvent) = if this.startVer then float ev.ClientX else float ev.ClientY\n        let size () : float =\n            match this.domElem with\n            | None    -> 100.0\n            | Some el -> \n             el.ParentElement.GetBoundingClientRect() \n             |> fun r -> \n                 match this.startVer, this.after with\n                 | true , true  ->  r.Width  \n                 | true , false -> -r.Width \n                 | false, true  ->  r.Height\n                 | false, false -> -r.Height\n        let drag (ev: Dom.Event) =\n            ev :?> Dom.MouseEvent\n            |> mouseCoord\n            |> fun m   -> (m - this.start) * 100.0 / this.size + this.startP\n            |> fun v   -> this.value.Value <- v // ; JS.Inline(\"console.log($0)\", this)\n           \n        let rec finishDragging (_: Dom.Event) =\n            if this.dragging then\n                this.dragging <- false\n                JS.Window.RemoveEventListener(\"mousemove\", drag          , false) \n                JS.Window.RemoveEventListener(\"mouseup\"  , finishDragging, false) \n                //printfn \"mouseup\"\n        let startDragging _ (ev: Dom.MouseEvent) =\n            if not this.dragging then\n                Val.map2 (fun startP dirV ->\n                    this.dragging <- true\n                    this.startVer <- dirV\n                    this.startP   <- startP\n                    this.start    <- mouseCoord ev\n                    this.size     <- size()\n                    JS.Window.AddEventListener(\"mousemove\", drag          , false) \n                    JS.Window.AddEventListener(\"mouseup\"  , finishDragging, false) \n                    ev.PreventDefault()\n                ) this.GetValue this.vertical\n                |> Val.iter id\n        this.node\n          .AddChildren(\n          [\n            ``class`` <| Val.map (fun ver -> if ver then \"Vertical\" else \"Horizontal\") this.vertical \n            SomeAttr  <| on.mouseDown startDragging\n            SomeAttr  <| on.afterRender (fun el -> this.domElem <- Some el)\n            css \"\n                .Splitter.Vertical   { cursor: col-resize; background-color: #eef ; width : 5px ; margin-left:-7px; }\n                .Splitter.Horizontal { cursor: row-resize; background-color: #eef ; height: 5px ; margin-top :-7px; }\n            \"\n          ])\n          .AddChildren this.children\n    member inline this.Value       v =   this.value.Value <- v  ; this\n    member inline this.Node     node = { this with node         = node                        }\n    member inline this.Min         v = { this with min          = Val.fixit v                 }\n    member inline this.Max         v = { this with max          = Val.fixit v                 }\n    member inline this.Vertical    v = { this with vertical     = Val.fixit v                 }\n    member inline this.Horizontal  v = { this with vertical     = Val.fixit v |> Val.map not  }\n    member inline this.Vertical   () = { this with vertical     = Val.fixit true              }\n    member inline this.Horizontal () = { this with vertical     = Val.fixit false             }\n    member inline this.Before        = { this with after        =           false             }\n    member inline this.After         = { this with after        =           true              }\n    member inline this.Children   ch = { this with children     = ch                          }\n    ","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"ResizeObserver","content":"[< Inline \"!!(ResizeObserver)\" >]\nlet implementedResizeObserver() = false\n\n[< Inline \"new ResizeObserver($f)\" >]\nlet newResizeObserver (f: unit->unit) = X<_> \n\n[< Inline \"$ro.observe($el)\" >]\nlet RObserve ro (el:Dom.Element) = X<_> \n\nlet mutable observers : obj list = []\n\nlet addResizeObserver f el =\n    if implementedResizeObserver() then\n        let ro =  newResizeObserver f\n        observers <- ro::observers\n        RObserve ro el\n    else \n        JS.SetInterval f 110 |> ignore","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"5878287a-a18f-4c71-b086-bd6e146270a1"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Grid","content":"[<NoComparison ; NoEquality>]\ntype Area =\n| Auto     of SplitterBar\n| Fixed    of HtmlMeasure\n| Splitter of SplitterBar\n\ntype SectionType =\n| StVariable\n| StFixedPx\n| StFixedPerc\n\n[<NoComparison ; NoEquality>]\ntype Grid = {\n    padding       : float\n    gap           : float\n    content       : (string option * HtmlNode) []\n    cols          : Area []\n    rows          : Area []\n    width         : IRef<float>\n    height        : IRef<float>\n    lastSplitter  : (int * bool) option\n}\nwith\n    static member New = {\n       padding       = 9.0\n       gap           = 9.0\n       cols          = [| |]\n       rows          = [| |]\n       content       = [| |]\n       width         = Var.Create 1000.0\n       height        = Var.Create  100.0\n       lastSplitter  = None\n    }\n    member this.NewSplitter  (f: float)  col =\n        let spl = SplitterBar.New(f)\n        if col then\n            { this with lastSplitter = Some (this.cols.Length, col) ; cols = Array.append this.cols  [| spl              |> Splitter |] }\n        else \n            { this with lastSplitter = Some (this.rows.Length, col) ; rows = Array.append this.rows  [| spl.Horizontal() |> Splitter |] }\n    member inline this.ColFixedPx   f              = { this with cols    = Array.append this.cols    [| Pixel     (Val.fixit f)              |> Fixed    |] }\n    member inline this.ColFixed     f              = { this with cols    = Array.append this.cols    [| Percentage(Val.fixit f)              |> Fixed    |] }\n    member inline this.ColVariable (s:SplitterBar) = { this with cols    = Array.append this.cols    [| s                                    |> Splitter |] }\n    member inline this.ColVariable (f:float)       = this.NewSplitter f true\n    member inline this.ColAuto     (f:float)       = { this with cols    = Array.append this.cols    [| SplitterBar.New(     f)              |> Auto     |] }\n    member inline this.RowFixedPx   f              = { this with rows    = Array.append this.rows    [| Pixel     (Val.fixit f)              |> Fixed    |] }\n    member inline this.RowFixed     f              = { this with rows    = Array.append this.rows    [| Percentage(Val.fixit f)              |> Fixed    |] }\n    member inline this.RowVariable (s:SplitterBar) = { this with rows    = Array.append this.rows    [| s                                    |> Splitter |] }\n    member inline this.RowVariable (f:float)       = this.NewSplitter f false\n    member inline this.RowAuto     (f:float)       = { this with rows    = Array.append this.rows    [| SplitterBar.New(     f).Horizontal() |> Auto     |] }\n    member        this.Content (area, html)        = { this with content = Array.append this.content [| Some area, html                                  |] }\n    member        this.Content        html         = { this with content = Array.append this.content [| None     , html                                  |] }\n    member inline this.Padding      f              = { this with padding = f                                                                                }\n    member inline this.Gap          f              = { this with gap     = f                                                                                }\n    member this.changeSplitter f =\n        this.lastSplitter\n        |> Option.iter (fun (pos, col) ->\n            if col then\n                match this.cols.[pos] with\n                | Splitter spl -> this.cols.[pos] <- Splitter <| f spl \n                | _            -> ()\n            else \n                match this.rows.[pos] with\n                | Splitter spl -> this.rows.[pos] <- Splitter <| f spl \n                | _            -> ()\n        )\n        this\n    member        this.Before                = this.changeSplitter (fun spl -> spl.Before     )\n    member inline this.Max                 v = this.changeSplitter (fun spl -> spl.Max       v)\n    member inline this.Min                 v = this.changeSplitter (fun spl -> spl.Min       v)\n    member inline this.Children           ch = this.changeSplitter (fun spl -> spl.Children ch)\n    member this.style    (areas:Area[]) size =\n        if areas.Length = 0 then Val.Constant \"100%\" else\n        let pcs, pxs = \n            areas \n            |> Seq.fold (fun (pcs, pxs) a ->\n                match a with\n                | Auto              spl -> (                          pcs,                pxs)          \n                | Splitter          spl -> (Val.map2 (+) spl.GetValue pcs,                pxs) \n                | Fixed (Percentage v)  -> (Val.map2 (+) v            pcs,                pxs)\n                | Fixed (Pixel      v)  -> (                          pcs, Val.map2 (+) v pxs)\n            ) (Val.Constant 0.0, Val.Constant 0.0)\n        let finalPerc = Val.map2 (fun v size -> (size - this.padding * 2. - this.gap * ((float areas.Length) - 1.) - v) / (size - this.padding * 2.)) pxs size\n        let autoPct   = Val.map  ((-) 100.0)  pcs \n        let perc   pc = Val.map2 (fun finalPerc pc -> finalPerc * pc |> max 0.0 |> sprintf \"%f%%\") finalPerc pc\n        let pixel  px = Val.map  (fun           px ->             px |> max 0.0 |> sprintf \"%fpx\")           px\n        areas\n        |> Seq.foldBack (fun a state ->\n            match a with\n            |  Auto              spl -> perc  autoPct          \n            |  Splitter          spl -> perc  spl.GetValue\n            |  Fixed (Percentage v)  -> perc  v\n            |  Fixed (Pixel      v)  -> pixel v\n            |> Val.map2(fun state v -> v::state) state\n           )  <| (Val.Constant [])\n        |> Val.map (String.concat \" \")\n    member this.styles() =\n        [ style1 \"grid-template-columns\" <| this.style this.cols this.width\n          style1 \"grid-template-rows\"    <| this.style this.rows this.height\n        ]\n    member this.GridTemplate() =\n        [ \n            yield!\n                this.content\n                |> Seq.map (fun (area, html) ->\n                    match area with\n                    | None   -> html\n                    | Some a -> html.AddChildren([ style <| sprintf \"grid-area: %s\" a ])\n                   )\n            yield!\n                this.cols\n                |> Seq.indexed\n                |> Seq.choose (function\n                    | i, Auto     spl -> None           \n                    | i, Splitter spl -> Some <| spl.Render.InsertChildren( \n                                            [ style1 \"grid-column\" (string (i + if spl.after then 2 else 1))\n                                              style1 \"grid-row\"    (sprintf \"1 / %d\" (this.rows.Length + 1)) ] ) \n                    | i, Fixed    _   -> None\n               )\n            yield!\n                this.rows\n                |> Seq.indexed\n                |> Seq.choose (function\n                    | i, Auto     spl -> None           \n                    | i, Splitter spl -> Some <| spl.Render.InsertChildren( \n                                            [ style1 \"grid-row\"    (string (i + if spl.after then 2 else 1))\n                                              style1 \"grid-column\" (sprintf \"1 / %d\" (this.cols.Length + 1)) ] ) \n                    | i, Fixed    _   -> None\n               )\n            yield! this.styles() \n            yield style    <| sprintf \"display: grid; grid-gap: %fpx; padding: %fpx; box-sizing: border-box\" this.gap this.padding \n            yield SomeAttr <| on.afterRender(fun el   -> \n                let setVar (vr:IRef<_>) vl = if vr.Value <> vl then vr.Value <- vl \n                let setDimensions () =\n                    el.GetBoundingClientRect()\n                    |> fun r ->  \n                        setVar this.width  r.Width\n                        setVar this.height r.Height\n                async {\n                    do! Async.Sleep 60\n                    do  setDimensions()\n                } |> Async.Start\n                addResizeObserver setDimensions el\n              ) \n        ]\n    member this.Render =\n        div <| this.GridTemplate()\n    static member inline NewBisect(first, secT, ver, per:float, ch1, ch2) =\n        let sect, auto, areas = \n            if ver then match secT with\n                        | StVariable  -> fun (g:Grid) -> g.ColVariable per\n                        | StFixedPx   -> fun (g:Grid) -> g.ColFixedPx  per\n                        | StFixedPerc -> fun (g:Grid) -> g.ColFixed    per\n                       ,                (fun (g:Grid) -> g.ColAuto 50.0)\n                       ,                 fun (g:Grid) -> g.Content( style \"grid-template-areas: 'one   two' \" )\n                   else match secT with\n                        | StVariable  -> fun (g:Grid) -> g.RowVariable per\n                        | StFixedPx   -> fun (g:Grid) -> g.RowFixedPx  per\n                        | StFixedPerc -> fun (g:Grid) -> g.RowFixed    per\n                       ,                (fun (g:Grid) -> g.RowAuto 50.0)\n                       ,                 fun (g:Grid) -> g.Content( style \"grid-template-areas: 'one' 'two' \" )\n        Grid.New.Content(\"one\", ch1)\n                .Content(\"two\", ch2).Padding(0.0)\n        |> areas\n        |> (if first then sect >> auto\n                     else auto >> sect)\n        ","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"5878287a-a18f-4c71-b086-bd6e146270a1"},{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"id":{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"TabStrip","content":"let reorderList (ts:'a list) drag drop =\n    if drop < drag then\n       ts.[0       ..drop - 1     ]\n     @    [      ts.[drag]        ]\n     @ ts.[drop    ..drag - 1     ]\n     @ ts.[drag + 1..ts.Length - 1]\n    else\n       ts.[0..drag - 1            ]\n     @ ts.[drag + 1..drop         ]\n     @    [      ts.[drag]        ]\n     @ ts.[drop + 1..ts.Length - 1]\n\nlet reorderArray (ts:'a []) drag drop =\n   (if drop < drag then\n      [|\n       ts.[0       ..drop - 1     ]\n       [|        ts.[drag]       |]\n       ts.[drop    ..drag - 1     ]\n       ts.[drag + 1..ts.Length - 1]\n      |]\n    else\n      [|\n       ts.[0..drag - 1            ]\n       ts.[drag + 1..drop         ]\n       [|        ts.[drag]       |]\n       ts.[drop + 1..ts.Length - 1]\n      |]\n   )|> Array.collect id \n\n\n[< NoComparison >]\ntype TabStrip =\n    { selected  : IRef<int>\n      tabs      : IRef<(System.Guid * (string * HtmlNode)) []>\n      top       : bool\n      horizontal: bool\n      id        : System.Guid\n    } \n\nlet draggedTab: (TabStrip * int) option ref = ref None\n\nlet uid2s (uid: System.Guid) = \"X\" + uid.ToString().Replace(\"-\", \"\")\n\nlet selectedPanels: Var<Map<System.Guid, System.Guid>> = Var.Create Map.empty \n\nlet setSelectedPanel group panelO = \n    selectedPanels.Value <- \n        match panelO with\n        | Some panel -> selectedPanels.Value.Add    (group, panel)\n        | None       -> selectedPanels.Value.Remove  group\n\nlet mutable TabMoved : ((TabStrip * TabStrip) -> unit) option = None\nlet RaiseTabMoved fromS toS = TabMoved |> Option.iter (fun f -> f (fromS, toS))\n\ntype TabStrip with\n    member this.moveTab from drag drop =\n        let ts = this.tabs.Value\n        let ft = from.tabs.Value\n        let newTabsT =\n            [|\n             ts.[0       ..drop - 1     ]\n             [|        ft.[drag]       |]\n             ts.[drop    ..ts.Length - 1]\n            |]\n            |> Array.collect id\n        let newTabsF =\n            [|\n             ft.[0       ..drag - 1     ]\n             ft.[drag + 1..ft.Length - 1]\n            |]\n            |> Array.collect id\n        from.tabs.Value     <- newTabsF\n        this.tabs.Value     <- newTabsT\n        this.selected.Value <- drop\n        if from.selected.Value >= newTabsF.Length then from.selected.Value <- 0\n        RaiseTabMoved from this\n\n    member this.reorder drop =\n        match !draggedTab with\n        | None                                     -> ()\n        | Some(from, drag) when from.id <> this.id -> this.moveTab from drag drop\n        | Some(from, drag)                         ->\n        this.tabs.Value     <- reorderArray this.tabs.Value drag drop\n        let sel = this.selected.Value\n        this.selected.Value <- if    sel = drag                then drop\n                               elif (sel < drag && sel < drop)\n                                 || (sel > drag && sel > drop) then sel \n                               elif  sel < drag                then sel + 1\n                               else                                 sel - 1\n                               \n    static member New(tabs)    =\n        { selected   = Var.Create 0\n          tabs       = tabs \n          top        = false \n          horizontal = true\n          id         = System.Guid.NewGuid() \n        } \n    static member New(tabs) = TabStrip.New(tabs |> Seq.map (fun def -> System.Guid.NewGuid(), def) |> Seq.toArray |> Var.Create)\n    member this.Top         = { this with top        = true  }\n    member this.Bottom      = { this with top        = false }\n    member this.Horizontal  = { this with horizontal = true  }\n    member this.Vertical    = { this with horizontal = false }\n    member this.Selected    = Val.map2 (fun tabs sel -> tabs |> Seq.tryItem sel |> Option.map fst) this.tabs this.selected\n    member this.Select    n = this.selected.Value <- n\n    member this.Select   nm = this.tabs.Value |> Seq.indexed |> Seq.tryPick (fun (i, (_ , (tn, _))) -> if tn = nm then this.selected.Value <- i ; Some true else None) |> Option.defaultValue false\n    member this.Select   gi = this.tabs.Value |> Seq.indexed |> Seq.tryPick (fun (i, (ti, (_ , _))) -> if ti = gi then this.selected.Value <- i ; Some true else None) |> Option.defaultValue false\n    member this.Render      =\n        let strip =\n            this.tabs\n            |> bindHElem (\n                fun tabs ->\n                    div [ yield ``class`` <| sprintf \"tab-strip %s %s\"\n                                                (if this.top        then \"top\"        else \"bottom\"  ) \n                                                (if this.horizontal then \"horizontal\" else \"vertical\")\n                          \n                          for i, (uid, (txt, _)) in  tabs |> Seq.indexed  do\n                              yield Hoverable.New.Content(\n                                    div [ htmlText txt\n                                          ``class`` <| Val.map (fun sel -> \"tab\" + (if sel = i then \" selected\" else \"\")) this.selected\n                                          draggable \"true\"\n                                          SomeAttr <| on.dragOver(fun _ ev -> ev.PreventDefault()                            )\n                                          SomeAttr <| on.drag    (fun _ _  ->                     draggedTab := Some(this, i))\n                                          SomeAttr <| on.drop    (fun e ev -> ev.PreventDefault(); ev.StopPropagation() ; this.reorder i )\n                                          SomeAttr <| on.click   (fun _ _  ->                       this.selected.Value <- i ) \n                                        ])\n                        ]\n            )\n        Val.sink (setSelectedPanel this.id) this.Selected  \n        let content = \n            this.tabs\n            |> bindHElem (fun tabs ->\n                div [\n                  yield  ``class`` \"tab-children\"\n                  yield  Id <| uid2s this.id\n                  yield!\n                      tabs\n                      |> Seq.map (fun (uid, (txt, sub)) -> \n                          sub.AddChildren(\n                            [ style <| Val.map (fun sels -> if sels |> Map.toSeq |> Seq.map snd |> Seq.contains uid then \"\" else \"display : none\") selectedPanels\n                              Id    <| uid2s uid\n                            ]))\n                ] \n             )\n        div [ ``class`` \"tab-panel\"\n              (if     this.top then strip else HtmlEmpty)\n              div [ content ; ``class`` \"tab-content\" ]\n              (if not this.top then strip else HtmlEmpty)\n              SomeAttr <| on.dragOver(fun _ ev -> ev.PreventDefault()                                      )\n              SomeAttr <| on.drop    (fun e ev -> ev.PreventDefault() ; this.reorder this.tabs.Value.Length)\n              css @\"\n\n.tab-panel {\n overflow  : hidden   ;\n display   : flex     ;\n flex-flow : column   ;\n background: lightgray;\n}\n.tab-content {\n flex      : 1 1     ;\n overflow  : auto    ;\n position  : relative;\n}\n.tab-children {\n height    : 100%    ;\n width     : 100%    ;\n position  : absolute;\n display   : grid    ;\n}\n.tab-strip {\n padding   : 0pt     ;\n flex      : 0 0     ;\n}\n.tab {\n border     : 0.2pt solid transparent;\n padding    : 0pt 4pt;\n display    : inline-block;\n font-family: sans-serif;\n font-weight: 200;\n font-size  : small;\n color      : #666;\n cursor     : pointer;\n}\n.top>.tab {\n border-radius: 2pt 2pt 0pt 0pt;\n border-bottom-width: 0pt;\n vertical-align: bottom;\n}\n.bottom>.tab {\n border-top-width: 0pt;\n border-radius: 0pt 0pt 2pt 2pt;\n vertical-align: top;\n}\n.horizontal>.tab:not(:first-child) {\n border-left-width: 0pt;\n}\n.tab.hovering {\n background: red;\n}\n.tab.selected {\n background: white;\n border-left-width: 0.2pt;\n color: black;\n font-weight: 500;\n border-color: black;\n}\n.horizontal>.tab.selected {\n border-left-width: 0.2pt;\n}\n\"]","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"}],"id":{"$":0,"Item":"cddabd38-7ecb-4692-99bd-13ca70e4232f"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"SplitterNode","content":"#nowarn \"1178\"\ntype SplitterNode = | SplitterNode of Var<SplitterStructure>\nand  SplitterStructure =\n    | SHtmlNode of HtmlNode\n    | STabStrip of TabStrip\n    | Split     of SplitterNode * SplitterNode * (SplitterNode -> SplitterNode -> HtmlNode)\n\nlet rec renderSplitterNode      sn = match sn with SplitterNode chV -> bindHElem (fun ch -> renderSplitterStructure ch) chV \nand     renderSplitterStructure ss =\n        match ss with\n        | SHtmlNode node        -> node\n        | STabStrip strip       -> strip.Render  \n        | Split   (ch1, ch2, f) -> f ch1 ch2\n\nlet renderSplitter (per:float) ver ch1 ch2 = Grid.NewBisect(true, StVariable, ver, per, renderSplitterNode ch1, renderSplitterNode ch2).Render\n\ntype SplitterStructure with    \n    static member New(vertical : bool, child1, child2, per) = Split(SplitterNode (Var.Create              child1), SplitterNode (Var.Create              child2), renderSplitter per  vertical)\n    static member New(vertical : bool, child1, child2     ) = Split(SplitterNode (Var.Create              child1), SplitterNode (Var.Create              child2), renderSplitter 50.0 vertical)\n    static member New(vertical : bool, child1, child2, per) = Split(SplitterNode (Var.Create <| SHtmlNode child1), SplitterNode (Var.Create <| SHtmlNode child2), renderSplitter per  vertical)\n    static member New(vertical : bool, child1, child2, per) = Split(SplitterNode (Var.Create <| STabStrip child1), SplitterNode (Var.Create <| STabStrip child2), renderSplitter per  vertical)\n    static member New(ss1, ss2, f                    ) = Split(SplitterNode (Var.Create ss1                ), SplitterNode (Var.Create ss2                ), f                      )\n    static member New(strip                          ) = STabStrip strip\n    static member New(node                           ) = SHtmlNode node\n\ntype SplitterNode with\n    static member New        ss           = SplitterNode <| Var.Create ss\n    static member New       (ss:HtmlNode) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    static member New       (ss:TabStrip) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    member this.Render                    = renderSplitterNode this\n    member this.Var                       = match this with SplitterNode chV -> chV\n    member this.Value                     = this.Var.Value\n    member this.SplitMe(first, ver, node) =\n        this.Var.Value <- if first then SplitterStructure.New(ver, node      , this.Value) \n                                   else SplitterStructure.New(ver, this.Value, node      )\n    member this.SplitMe(first, ver, node:TabStrip) = this.SplitMe(first, ver, STabStrip node      )\n    member this.SplitMe(first, ver, node:HtmlNode) = this.SplitMe(first, ver, SHtmlNode node      )\n    member this.SplitMe(first, ver               ) = this.SplitMe(first, ver, TabStrip.New([||])  )\n    member this.Navigate recFun                    =\n        match this.Value with\n        | SHtmlNode _           \n        | STabStrip _           -> recFun this.Value\n        | Split   (ch1, ch2, f) -> ch1.Navigate recFun || ch2.Navigate recFun\n    member this.SelectTab  (nm: string)            = this.Navigate (function | STabStrip strip -> strip.Select nm | _ -> false) \n    member this.IsEmpty                            =\n        match this.Value with\n        | SHtmlNode HtmlEmpty   -> true\n        | SHtmlNode _           -> false\n        | STabStrip strip       -> strip.tabs.Value.Length = 0\n        | Split   (ch1, ch2, f) -> ch1.IsEmpty && ch2.IsEmpty\n    member this.UnSplitEmpties()                   =\n        if                                    this.IsEmpty then this.Var.Value <- SplitterStructure.New(TabStrip.New([||])) else\n        match this.Value with\n        | Split   (ch1, ch2, f) -> if   ch1.IsEmpty then ch2.UnSplitEmpties() ; this.Var.Value <- ch2.Value \n                                   elif ch2.IsEmpty then ch1.UnSplitEmpties() ; this.Var.Value <- ch1.Value \n                                                    else ch1.UnSplitEmpties()\n                                                         ch2.UnSplitEmpties()\n        | _                     -> ()  \n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"cddabd38-7ecb-4692-99bd-13ca70e4232f"}],"id":{"$":0,"Item":"a48d72fc-5220-4dac-b3b3-98bad48b0561"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"MenuBar","content":"let inline menuEntry content   = li [ content ]\nlet inline refA      cont  t r = a  [ cont ; hrefO r ; target t ] \nlet inline refText   txt   t r = bindHElem (fun t -> if t = \"\" then HtmlEmpty else refA(htmlText t) t r) txt\nlet inline entryTxt  txt   t r = menuEntry (refText  txt t  r)\n  \nlet inline entries    ch cl    =  ul ch |> addClass cl\nlet inline nav        ch       =  entries ch \"nav navbar-nav\"\nlet inline dropdown   ch       =  entries ch \"dropdown-menu\"\nlet navbar brand center right  =\n    div [ ``class``                     \"navbar navbar-default\"\n          div [ ``class``               \"container-fluid\"\n                div [ ``class``         \"navbar-header\"\n                      div [ ``class``   \"navbar-brand\"\n                            brand\n                          ]\n                    ]\n                div [ ``class``         \"navbar-collapse collapse\"\n                      center\n                      right |> addClass \"navbar-right\"\n                    ]\n              ]\n    ]\n    \n#nowarn \"1178\"    \n\ntype MenuEntry = {\n    text       : Val<string>\n    ref        : Val<string option>\n    active     : Val<bool>\n    disabled   : Val<bool>\n    subMenu    : Menu option\n    toolTip    : string option\n    target     : string option\n    divider    : bool\n    onClick    : (Dom.Element -> Dom.MouseEvent -> unit) option\n} with\n    static member inline New txt = { \n        text      = Val.fixit  txt\n        active    = Val.fixit  false \n        ref       = Val.Constant None\n        toolTip   = None\n        subMenu   = None\n        onClick   = None\n        target    = None\n        divider   = false\n        disabled  = Val.fixit false\n    } \n    static member inline New(txt, ref) = { MenuEntry.New(txt) with ref      = Val.map Some ref }\n    member this.Render           = \n        entryTxt this.text (this.target |> Option.defaultValue \"\") this.ref \n        |> addClassIf \"active\" this.active |> addClassIf \"disabled\" this.disabled\n        |> match this.subMenu with | None  -> id | Some m -> addChildren [ ``class`` \"dropdown\" ; m.Render ]\n        |> match this.onClick with | None  -> id | Some f -> addChildren [ SomeAttr  <| on.click <@ f @>   ; style \"cursor : pointer\" ]\n        |> match this.divider with | false -> id | true   -> addClass    \"divider\"\n    member inline this.Target   t   = { this with target   = Some t                         }\n    member inline this.Divider      = { this with divider  = true                           }\n    member inline this.OnClick  f   = { this with onClick  = Some f                         }\n    member inline this.Disabled dis = { this with disabled = Val.fixit dis                  }\n    member inline this.SubMenu  es  = { this with subMenu  = Some <| Menu.New( es).DropDown } \n    member inline this.SubMenu  es  = { this with subMenu  = Some <| Menu.New2(es).DropDown } \n    member        this.MenuNode     = MenuEntry this\nand MenuNode =\n    | MenuHtml  of HtmlNode\n    | MenuEntry of MenuEntry \n  with\n    member this.Render = match this with | MenuHtml h -> h | MenuEntry e -> e.Render\nand Menu = {\n    entries  : MenuNode seq\n    dropdown : bool\n} with\n    static member New es : Menu = { \n        entries = es\n        dropdown = false\n    }    \n    static member New2 es : Menu = Menu.New(es |> Seq.map MenuEntry) \n    member this.DropDown        = { this      with dropdown = true  }\n    member this.Render          =\n        (if this.dropdown then dropdown else nav) <|\n            seq [\n                for entry in this.entries -> \n                    entry.Render\n            ]","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"f3c86328-e5b6-4ef1-a3d9-d82098f4ffe2"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Action","content":"type Action = {\n    text       : Val<string>\n    highlight  : Val<bool>\n    disabled   : Val<bool>\n    toolTip    : string option\n    onClick    : (Dom.Element -> Dom.MouseEvent -> unit) option\n} with\n    static member inline New txt = { \n        text      = Val.fixit  txt\n        highlight = Val.fixit  false \n        disabled  = Val.fixit  false\n        toolTip   = None\n        onClick   = None\n    } \n    member inline this.OnClick   f   = { this with onClick   = Some f        }\n    member inline this.OnClick2  f   = { this with onClick   = Some (f this) }\n    member inline this.Disabled  dis = { this with disabled  = Val.fixit dis }\n    member inline this.Highlight h   = { this with highlight = Val.fixit h   }\n    member        this.MenuEntry     = {\n        MenuEntry.text      = this.text\n        MenuEntry.active    = this.highlight \n        MenuEntry.disabled  = this.disabled\n        MenuEntry.toolTip   = this.toolTip\n        MenuEntry.onClick   = this.onClick\n        MenuEntry.ref       = Val.Constant None\n        MenuEntry.divider   = false\n        MenuEntry.subMenu   = None\n        MenuEntry.target    = None\n    }\n    member        this.Button       = {\n        Button.text      = this.text\n        Button.disabled  = this.disabled\n        Button.onClick   = this.onClick |> Option.defaultValue (fun _ _ -> ())\n//        Button.toolTip   = this.toolTip\n        Button._class    = Val.map (fun h -> if h then \"btn btn-primary\" else \"btn\") this.highlight \n        Button._type     = Val.fixit \"button\" \n        Button.style     = Val.fixit \"\"\n        Button.id        = \"\"\n      }\n\nlet Do  f p = (fun     _ _ -> f     p)\nlet Do2 f p = (fun act _ _ -> f act p)","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"f3c86328-e5b6-4ef1-a3d9-d82098f4ffe2"}],"id":{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"RunCode","content":"[<JavaScript>]\nmodule RunCode       =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"1095ae38-19fc-4195-840c-c368a3a486c4"}],"id":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"completeJS","content":"let completeJS js = \n  \"\"\"","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[],"id":{"$":0,"Item":"36fc221f-7e61-4a04-abf3-317f901e5211"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"1"}},{"name":"CIPHERSpaceLoadFiles","content":"    CIPHERSpaceLoadFileGlobalFileRef = null;\n    CIPHERSpaceLoadFile = function (filename, callback) {\n        if (filename.slice(-3) == \".js\" || filename.slice(-4) == \".fsx\" || filename.slice(-3) == \".fs\") { //if filename is a external JavaScript file\n            var fileRef = null;\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement('script')\n                fileRef.setAttribute(\"type\", \"text/javascript\")\n                fileRef.setAttribute(\"src\", filename)\n            }\n            else callback();\n        }\n        else if (filename.slice(-4) == \".css\") { //if filename is an external CSS file\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement(\"link\")\n                fileRef.setAttribute(\"rel\", \"stylesheet\")\n                fileRef.setAttribute(\"type\", \"text/css\")\n                fileRef.setAttribute(\"href\", filename)\n            }\n            else callback();\n        }\n        else if (filename.slice(-5) == \".html\") { //if filename is an external HTML file\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement(\"link\")\n                fileRef.setAttribute(\"rel\", \"import\")\n                fileRef.setAttribute(\"type\", \"text/html\")\n                fileRef.setAttribute(\"href\", filename)\n            }\n            else callback();\n        }\n        if (!!fileRef) {\n            CIPHERSpaceLoadFileGlobalFileRef = fileRef;\n\t\t\tfileRef.onload = function () { fileRef.onload = null;  callback(); }\n            document.getElementsByTagName(\"head\")[0].appendChild(fileRef);\n        }\n    }\n    CIPHERSpaceLoadFiles = function (files, callback) {\n        var newCallback = callback\n        if (!!CIPHERSpaceLoadFileGlobalFileRef && !!(CIPHERSpaceLoadFileGlobalFileRef.onload)) {\n            var oldCallback = CIPHERSpaceLoadFileGlobalFileRef.onload;\n            CIPHERSpaceLoadFileGlobalFileRef.onload = null;\n            newCallback = function () {\n                callback();\n                oldCallback();\n            }\n        }\n        var i = 0;\n        loadNext = function () {\n            if (i < files.length) {\n                var file = files[i];\n                i++;\n                CIPHERSpaceLoadFile(file, loadNext);\n            }\n            else newCallback();\n        };\n        loadNext();\n\t}\n    CIPHERSpaceLoadFiles(['https://code.jquery.com/jquery-3.1.1.min.js'], function() {}); \n\tCIPHERSpaceLoadFilesDoAfter = function (callback) {\n\t\tvar newCallback = callback\n\t\tif (!!CIPHERSpaceLoadFileGlobalFileRef) {\n\t\t\tif (!!(CIPHERSpaceLoadFileGlobalFileRef.onload)) {\n\t\t\t\tvar oldCallback = CIPHERSpaceLoadFileGlobalFileRef.onload;\n\t\t\t\tCIPHERSpaceLoadFileGlobalFileRef.onload = null;\n\t\t\t\tnewCallback = function () {\n\t\t\t\t\toldCallback();\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse CIPHERSpaceLoadFileGlobalFileRef = {};\n\t\tCIPHERSpaceLoadFileGlobalFileRef.onload = newCallback;\n\t}\n\nCIPHERSpaceLoadFilesDoAfter(function() { \n  if (typeof IntelliFactory !=='undefined')\n    IntelliFactory.Runtime.Start();\n  for (key in window) { \n    if (key.startsWith(\"StartupCode$\")) \n      try { window[key].$cctor(); } catch (e) {} \n  } \n})\n","parent":{"$":0,"Item":"36fc221f-7e61-4a04-abf3-317f901e5211"},"predecessors":[],"id":{"$":0,"Item":"a3676bbd-c1ea-4fc0-b599-6fde2c8d0816"},"expanded":true,"level":0,"levelCode":0,"properties":{"Theme":"colorforth","Mode":"javascript","NoLinePre":"1"}},{"name":"\"\"\" + js","content":"                 \"\"\" + js","parent":{"$":0,"Item":"36fc221f-7e61-4a04-abf3-317f901e5211"},"predecessors":[{"$":0,"Item":"a3676bbd-c1ea-4fc0-b599-6fde2c8d0816"}],"id":{"$":0,"Item":"afaac2af-143d-4745-9447-7e8d3044950f"},"expanded":true,"level":0,"levelCode":0,"properties":{"NoLinePre":"1"}},{"name":"","content":"type RunNode(nodeName, ?clearNode: bool) =\n  let bClearNode    = defaultArg clearNode true\n  let createNode() =\n      let e = JS.Document.CreateElement \"div\"\n      e?style <- \"height: 100%; width: 100%;\"\n      e\n  let createBaseNode () =\n      let el = JS.Document.CreateElement \"div\"\n      el.SetAttribute(\"id\", nodeName)\n      JS.Document.Body.AppendChild el |> ignore\n      el\n  let baseNode = \n      match JS.Document.GetElementById nodeName with\n      | null -> createBaseNode()\n      | node -> node\n  let runNode =\n      match baseNode.ShadowRoot with\n      | null -> let p = createNode()\n                baseNode.AttachShadow(Dom.ShadowRootInit(Dom.ShadowRootMode.Open)).AppendChild p |> ignore\n                let e = createNode()\n                p.AppendChild e |> ignore\n                e\n      | root -> root.FirstChild :?> Dom.Element\n  do if bClearNode then runNode.InnerHTML <- \"\"\nwith\n  new(?clearNode: bool) = RunNode(\"TestNode\", ?clearNode = clearNode)\n  member this.RunNode   = runNode","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[],"id":{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"AddBootstrap","content":"  member this.AddBootstrap =\n    JS.Document.CreateElement \"div\"\n    |> fun el -> \n        el.InnerHTML <- \n          @\"<script src='http://code.jquery.com/jquery-3.1.1.min.js' type='text/javascript' charset='UTF-8'></script>\n            <script src='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js' type='text/javascript' charset='UTF-8'></script>\n            <link type='text/css' rel='stylesheet' href='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css'>\n            <link type='text/css' rel='stylesheet' href='/EPFileX/css/main.css'>\n           \"\n        runNode.ParentElement.AppendChild el |> ignore\n    this","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"}],"id":{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"RunDoc","content":"  member inline this.RunDoc doc = doc :> Doc |> Doc.Run this.RunNode","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"},{"$":0,"Item":"aba6c516-0ac9-4abe-95a2-7257d077e338"}],"id":{"$":0,"Item":"c110a9c9-bc3b-4be7-8e5d-f43cc75f93ed"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"RunHtml","content":"  member inline this.RunHtml node = node |> renderDoc |> this.RunDoc\n  ","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"c110a9c9-bc3b-4be7-8e5d-f43cc75f93ed"}],"id":{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"RunHtmlPlusFree","content":"  member        this.RunHtmlPlusFree node =\n    let freeHtml    = Var.Create \"\"\n    let freeCSS     = Var.Create \"\"\n    let freeFS      = Var.Create \"\"\n    let freeJS      = Var.Create \"\"\n    let freeMsgs    = Var.Create \"\"\n    let sendMsg msg = \n        freeMsgs.Value  <- \n            match freeMsgs.Value, msg with\n            | null, m \n            | \"\"  , m\n            | m   , null\n            | m   , \"\"   -> m\n            | m1  , m2   -> m1 + \"\\n\" + m2\n    let runJS () =\n        sendMsg \"Running JavaScript...\"\n        try JS.Eval(freeJS.Value) |> (fun v -> sendMsg \"Done!\"; v.ToString())\n        with e -> sendMsg \"Failed!\"; e.ToString()\n        |> sendMsg\n    let runFS () =\n        Useful.Wrap.wrapper {\n            freeMsgs.Value <- \"Compiling to JavaScript...\"\n            freeJS.Value   <- \"\"\n            let    code      = freeFS.Value\n            let!   jsR       = FsTranslator.translateAR code false\n            let!   js        = jsR\n            let    jsc       = completeJS js\n            freeJS.Value    <- jsc\n            sendMsg            \"Compiled!\"\n            runJS()\n        } |> Useful.Wrap.start sendMsg\n    div [ style \"height: 100%\"\n          node\n          Template.Button.New(\"Eval F#\").Style(\"vertical-align:top\").OnClick(fun _ _ -> runFS()                        ).Render  \n          someElt <| Doc.InputArea [ attr.placeholder \"F#:\"         ; attr.title \"Add F# code and invoke with Eval F#\" ] freeFS\n          someElt <| Doc.InputArea [ attr.placeholder \"HTML:\"       ; attr.title \"Enter HTML tags and text\"            ] freeHtml \n          someElt <| Doc.InputArea [ attr.placeholder \"CSS:\"        ; attr.title \"Test your CSS styles dynamically\"    ] freeCSS \n          someElt <| Doc.InputArea [ attr.placeholder \"JavaScript:\" ; attr.title \"Add JS code and invoke with Eval JS\" ] freeJS\n          Template.Button.New(\"Eval JS\").Style(\"vertical-align:top\").OnClick(fun _ _ -> freeMsgs.Value <- \"\" ; runJS() ).Render  \n          someElt <| Doc.InputArea [ attr.placeholder \"Output:\"     ; attr.title \"Messages\"                            ] freeMsgs\n          SomeDoc <| tag Doc.Verbatim (Val.map2 (sprintf \"%s<style>%s</style>\") freeHtml freeCSS)\n    ]\n    |> this.RunHtml","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"afaac2af-143d-4745-9447-7e8d3044950f"},{"$":0,"Item":"95a237c8-a9ff-40d1-bd72-bd298b20af8c"},{"$":0,"Item":"79f8f6c6-d1f5-4593-9775-60ba2863e94d"},{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"}],"id":{"$":0,"Item":"456562f7-0757-4431-9aeb-d58b050cecf7"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"ShowHtmlResult","content":"  member inline this.ShowHtmlResult res =\n    this.AddBootstrap |> ignore\n    div [ ``class`` \"container\"\n          Template.Panel.New\n            .Title(\"Result:\")\n            .Header([])\n            .Content([ h3 res ; style \"font-family:monospace;\" ])\n            .Render\n     ] |> this.RunHtml\n  member inline this.ShowHtmlResult res = this.ShowHtmlResult [res]\n","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"0a11766b-f227-4b38-88a3-919d964387bf"},{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"}],"id":{"$":0,"Item":"bf400a85-8264-4540-9381-f3be0c968c94"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"ShowResult","content":"  member inline this.ShowResult res = htmlText (sprintf \"%A\" res) |> this.ShowHtmlResult\n","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"bf400a85-8264-4540-9381-f3be0c968c94"}],"id":{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FSharpStation Code","content":"module FSharpStation =\n","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[],"id":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0","DisableWebSharper":"1"}},{"name":"CodeSnippet Extensions, Position","content":"open Template\nopen FsStationShared\nopen System.Collections.Generic\nopen Useful\n\n#if FSS_SERVER\nopen FsTranslator\nopen FsEvaluator\n#endif\n\n[< JavaScript >]\nmodule FsGlobal =\n    [< Inline >]\n    let inline storeVarCodeEditor name = storeVar <| \"CodeEditor.\" + name\n    \n    //let codeSnippetsStorage = WebSharper.UI.Next.Storage.LocalStorage \"CodeSnippets\" Serializer.Typed<CodeSnippet>\n    //let codeSnippets        = ListModel.CreateWithStorage<CodeSnippetId, CodeSnippet> (fun s -> s.id) codeSnippetsStorage\n    let codeSnippets        = ListModel.Create<CodeSnippetId, CodeSnippet> (fun s -> s.id) []\n\n    [< Inline \"(Date.now())\" >]\n    let now() = 0\n    let fsIds  = \"FSharpStation\" + (now() |> string)\n    \n    let tryPickI f s = s |> Seq.indexed |> Seq.filter f |> Seq.tryHead\n    \n    type CodeSnippet \n        with\n        static member PickIO       id   = codeSnippets.Value    |> tryPickI (fun (_, snp) -> snp.id = id)\n        static member FetchO       id   = codeSnippets.TryFindByKey id\n        static member FetchL       id   = CodeSnippet.FetchO id |> Option.toList\n        static member New(            pred    , cnt) = CodeSnippet.New(\"\", None   , pred, [], cnt)\n        static member New(        pa, pred    , cnt) = CodeSnippet.New(\"\", Some pa, pred, [], cnt)\n        static member New(        pa,           cnt) = CodeSnippet.New(\"\", Some pa, []  , [], cnt)\n        static member New(                      cnt) = CodeSnippet.New(\"\", None   , []  , [], cnt)\n        static member New(    nm, pa, pred, co, cnt) = CodeSnippet.New(codeSnippets.Length, nm, pa, pred, co, cnt)\n        static member New(od, nm, pa, pred, co, cnt) =\n            let newS =\n                {\n                    name         = nm\n                    content      = cnt\n                    parent       = pa\n                    predecessors = pred\n                    id           = CodeSnippetId.New\n                    expanded     = true\n                    level        = 0\n                    levelCode    = 0\n                    properties   = System.Collections.Generic.Dictionary<string, string>()\n                }\n            match od, codeSnippets.Length with\n            | _, 0            -> codeSnippets.Append newS\n            | 0, _            -> codeSnippets.Set <| Seq.append [| newS |] codeSnippets.Value\n            | i, n when i < n -> codeSnippets.Value \n                                    |> Seq.toArray\n                                    |> Array.splitAt od\n                                    |> fun (fst, snd) -> Array.append fst <| Array.append [| newS |] snd\n                                    |> codeSnippets.Set \n            | _, _            -> codeSnippets.Append newS\n            newS\n        member this.Levels =\n            let rec levels (out, out2) snp = \n                snp.parent\n                |> Option.bind CodeSnippet.FetchO\n                |> Option.map (levels <| (out + 1, out2 + if snp.properties.ContainsKey \"NoIndent\" then 0 else 1)) \n                |> Option.defaultValue (out, out2)\n            levels (0, 0) this\n        member this.PrepareSnippet   =\n            let lvl, lvlCode = this.Levels\n            { this with level     = lvl\n                        levelCode = lvlCode\n                        content   = this.content\n                                        .Replace(\"##\" + \"FSHARPSTATION_ID\" + \"##\"      , fsIds                  )\n                                        .Replace(\"##\" + \"FSHARPSTATION_ENDPOINT\" + \"##\", JS.Window.Location.Href) }\n        member this.Predecessors     () =\n            let preds = this.UniquePredecessors CodeSnippet.FetchO |> Seq.toArray\n            codeSnippets.Value\n            |> Seq.filter (fun snp -> preds |> Array.contains snp.id)\n            |> Seq.map    (fun snp -> snp.PrepareSnippet)\n            |> Seq.toArray\n        member this.GetCodeAndStarts addLinePrepos = this.Predecessors() |> CodeSnippet.CodeAndStarts addLinePrepos\n        member this.GetCodeFsx       addLinePrepos = this.GetCodeAndStarts addLinePrepos |> fst\n        member this.IsDescendantOf antId =\n            let rec isDescendantOf snp =\n                match snp.parent with\n                | None       -> false\n                | Some parId ->\n                if parId = antId then true else\n                CodeSnippet.FetchO parId\n                |> Option.map isDescendantOf\n                |> Option.defaultValue false\n            isDescendantOf this\n        static member FetchByPathO names      = \n            let tryFindByName      snps name  = snps |> Seq.filter (fun (snp:CodeSnippet) -> snp.Name = name) |> Seq.tryHead\n            let rec tryFindByPath  snps names = \n                let first = names |> Seq.tryHead |> Option.bind (tryFindByName snps)\n                if names |> Seq.length <= 1 then first else\n                first\n                |> Option.bind (fun f ->\n                    names \n                    |> Seq.tail\n                    |> tryFindByPath  (codeSnippets.Value |> Seq.filter (fun snp -> snp.parent = Some f.id))\n                )\n            names \n            |> tryFindByPath (codeSnippets.Value |> Seq.filter (fun snp -> snp.parent.IsNone))\n        member this.propValue p =\n            if this.properties.ContainsKey p \n            then Some this.properties.[p]\n            else this.parent |> Option.bind CodeSnippet.FetchO |> Option.bind (fun par -> par.propValue p)\n    \n    type Position =\n        | Below\n        | Right\n        | Tab\n        | NewBrowser\n        \n    \n    type ErrCompiler =\n        | JsCompilerMsg  of string * bool\n        | ``Snippet Missing``\n        | ``Could not open new browser, Popup blocker may be active``\n        interface ErrMsg with\n            member this.ErrMsg   : string = \n                match this with \n                | JsCompilerMsg(msg, err) -> sprintf \"%s\" msg\n                | _                       -> sprintf \"%A\" this\n            member this.IsWarning: bool   = \n                match this with \n                | JsCompilerMsg(msg, err) -> not err\n                | _                       -> false\n                \n    [< Inline \"saveAs(new Blob([$txt], {type: 'text/plain;charset=utf-8'}), $name)\" >]\n    let saveAs (txt:string) (name:string) = ()\n    \n    type KeyMapAutoComplete = { \n        F2              : Template.CodeMirrorEditor -> unit \n        LeftDoubleClick : Template.CodeMirrorEditor -> unit\n        ``Ctrl-Space``  : Template.CodeMirrorEditor -> unit\n    }\n    \n    type Property(setDirty: unit->unit, props: Dictionary<string, string>, keyP: string) =\n        let mutable key = keyP\n        let getK () = key\n        let setK k  = props.Add(k, props.[key]) ; props.Remove key |> ignore ; key <- k ; setDirty()\n        let getV () = props.[key]\n        let setV v  = props.[key] <- v ; setDirty()\n        interface IRef<string> with\n           member this.Id  = \"?\"\n           member this.Set                                   v = setK v\n           member this.Value                        with set v = setK v\n           member this.Get ()                                  = getK()\n           member this.Value                                   = getK()\n           member this.Update      (f:string -> string       ) = getK() |> f |>             setK\n           member this.UpdateMaybe (f:string -> string option) = getK() |> f |> Option.iter setK\n           member this.View                     : View<string> = getK() |> View.Const\n        member this.KeyVar   = this :> IRef<string>  \n        member this.ValueVar =  PropValue this\n        member this.GetK     = getK\n        member this.SetK     = setK\n        member this.GetV     = getV\n        member this.SetV     = setV\n        member this.Remove() = props.Remove key |> ignore ; setDirty()\n\n    and PropValue(prop: Property) =\n        let get  = prop.GetV\n        let set  = prop.SetV\n        interface IRef<string> with\n           member this.Id  = \"?\"\n           member this.Set                                   v = set v\n           member this.Value                        with set v = set v\n           member this.Get ()                                  = get()\n           member this.Value                                   = get()\n           member this.Update      (f:string -> string       ) = get() |> f |>             set\n           member this.UpdateMaybe (f:string -> string option) = get() |> f |> Option.iter set\n           member this.View                     : View<string> = get() |> View.Const\n\nopen FsGlobal                \n\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"},{"$":0,"Item":"95a237c8-a9ff-40d1-bd72-bd298b20af8c"},{"$":0,"Item":"336d6f19-0c57-4af9-8716-1b3fbf6b112c"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"}],"id":{"$":0,"Item":"1787d1fe-db11-4716-b3f6-164048e8991b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CIPHERPrototype Module","content":"#r @\"ZafirTranspiler.dll\"\n    \n[< JavaScript >]\ntype CIPHERPrototypeMsg(msg: string, warning: bool) =\n    interface ErrMsg with\n        member this.ErrMsg    = msg\n        member this.IsWarning = warning\n\n[< JavaScript >]\nlet translateAR fsCode minified = \n    Wrap.wrapper {\n        let! vO, msgs = CIPHERPrototype.Editor.translate fsCode minified\n        let!   js     = Result (vO, [ CIPHERPrototypeMsg(msgs, vO.IsNone) :> ErrMsg ])\n        return js\n    } |> Wrap.getAsyncR\n\n[< JavaScript >]\nlet evaluateAR  fsCode = \n    Wrap.wrapper {\n        let! vO, msgs = CIPHERPrototype.Editor.evaluate fsCode\n        let!   txt    = Result (vO, [ CIPHERPrototypeMsg(msgs, vO.IsNone) :> ErrMsg ])\n        return txt\n    } |> Wrap.getAsyncR\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"8fbd59ac-9417-4309-8d01-3ccd5d62452c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FSharpStationClient","content":"[< JavaScript >]\nlet FSharpStationClient (loadFromUri: string) =\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"336d6f19-0c57-4af9-8716-1b3fbf6b112c"},{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"currentCodeSnippetId","content":"\nlet missingVar  = Var.Create \"\"\nlet missing def find lens k =\n    match find k with\n    | Some _ -> lens k\n    | None   -> missingVar.Lens (fun _ -> def) (fun _ _ -> \"\")\n    \nlet currentCodeSnippetId  = Var.Create <| CodeSnippetId.New\n\nstoreVarCodeEditor \"currentCodeSnippetId\" currentCodeSnippetId\n\nlet refresh       = Var.Create()\nlet refreshView b = refresh.Value <- b\n\nlet currentCodeSnippetO = Val.map2 (fun k () -> codeSnippets.TryFindByKey k) currentCodeSnippetId refresh\n\nlet curSnippetNameOf k = missing \"\"        codeSnippets.TryFindByKey <| codeSnippets.LensInto (fun s -> s.Name      ) (fun s n -> { s with name       = n }) <| k\nlet curSnippetCodeOf k = missing \"\"        codeSnippets.TryFindByKey <| codeSnippets.LensInto (fun s -> s.content   ) (fun s n -> { s with content    = n }) <| k\nlet curSnippetPrpsOf k = missing (System.Collections.Generic.Dictionary<string, string>()) codeSnippets.TryFindByKey <| codeSnippets.LensInto (fun s -> s.properties) (fun s p -> { s with properties = p }) <| k\n    \nlet positionTxt v =\n    match v with\n    | Below      -> \"Below\"\n    | Right      -> \"Right\"\n    | Tab        -> \"In Tab\"\n    | NewBrowser -> \"New Browser\"\n    \nlet position = Var.Create Below\nstoreVarCodeEditor \"position\" position\n\nlet directionVertical    = \n    Val.map (fun pos -> \n        match pos with\n        | Right -> true\n        | _     -> false\n    ) position\n    \n()    ","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"1787d1fe-db11-4716-b3f6-164048e8991b"},{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"}],"id":{"$":0,"Item":"987560b0-1fe6-4835-ad99-aed93db7da1a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CodeEditorMain","content":"\n\nlet noSelection cur = CodeSnippet.FetchO cur = None\nlet noSelectionVal  = Val.map noSelection currentCodeSnippetId\n\nlet genericPropertyVal p def f =\n    currentCodeSnippetId\n    |> Val.map \n        (CodeSnippet.FetchO\n         >> Option.bind (fun snp -> snp.propValue p |> Option.map f)\n         >> Option.defaultValue def\n        )\n\nlet propertyCssVal       = genericPropertyVal \"CSS\"      \"\"         id\nlet propertyCssLinkVal   = genericPropertyVal \"CSSLink\"  \"\"         id   \nlet propertyModeVal      = genericPropertyVal \"Mode\"     \"fsharp\"   id   \nlet propertyThemeVal0    = genericPropertyVal \"Theme\"    \"\"         id   \nlet disablePropertyVal p = genericPropertyVal p          false      ((<>) \"0\")\n\n\nlet propertyThemeVar     = Var.Create                    \"\"\nVal.sink (fun v -> if v <> propertyThemeVar.Value then propertyThemeVar.Value <- v) propertyThemeVal0\nlet propertyThemeVal     = Val.DynamicV propertyThemeVar   \n\nlet propertyThemeLinkVal = Val.map (sprintf \"/EPFileX/codemirror/content/theme/%s.css\") propertyThemeVal   \n\nlet disableParseVal      = disablePropertyVal \"DisableParse\" \nlet disableFSIVal        = disablePropertyVal \"DisableFSI\"        |> Val.map2 (||) disableParseVal  \nlet disableWebSharperVal = disablePropertyVal \"DisableWebSharper\" |> Val.map2 (||) disableParseVal \n\nlet mutable lastCodeAndStarts : (CodeSnippetId * bool * ((string * int * int) [] * string [] * string [] * string [] * string [] * string [])) option = None\n\nlet getPredecessors curO =\n    curO\n    |> Option.map (fun (snp:CodeSnippet) -> snp.UniquePredecessors CodeSnippet.FetchO |> HashSet)\n    |> Option.defaultValue (System.Collections.Generic.HashSet())\n\nlet getPredecessorsM = Useful.ResetableMemoize(getPredecessors)\n\nlet codeFS         = Var.Create \"\"\nlet codeJS         = Var.Create \"\"\nlet parserMsgs     = Var.Create \"\"\nlet outputMsgs     = Var.Create \"\"\nlet mutable parsed = false\nlet dirty          = Var.Create false \nlet setDirtyPart() = parsed            <- false\n                     dirty.Value       <- true       \nlet setDirty()     = lastCodeAndStarts <- None\n                     setDirtyPart               ()\nlet setDirtyPred() = setDirty                   ()\n                     getPredecessorsM.ClearCache()\n                     refreshView                ()\nlet setClean()     = getPredecessorsM.ClearCache()\n                     dirty.Value       <- false\n                     lastCodeAndStarts <- None\n                     \n\n//storeVarCodeEditor \"dirty\" dirty\nlet appendMsg (var:IRef<string>) msg =\n    if isUndefined msg then () else\n    let newM =\n        match var.Value, msg.ToString() with\n        | null, m \n        | \"\"  , m\n        | m   , null\n        | m   , \"\"   -> m\n        | m1  , m2   -> m1 + \"\\n\" + m2\n    if newM <> var.Value then\n        var.Value  <- newM\n\nlet addOutMsg msg = appendMsg outputMsgs msg\nlet addPrsMsg msg = appendMsg parserMsgs msg\n\nlet getFSCode () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value \n    |> Option.iter (fun snp -> codeFS.Value <- snp.GetCodeFsx true )\n\ndo Val.sink (fun m -> \n    JS.Window.Onbeforeunload <- \n        if m then System.Action<Dom.Event>(fun (e:Dom.Event) -> e?returnValue  <- \"Changes you made may not be saved.\")\n        else null\n    ) dirty \n\n//let evalIFrameJS success failure js =\n//    createIFrame (fun frame ->\n//        try\n//             let window   = frame?contentWindow\n//             let eval   s = JS.Apply window \"eval\" [| s |]\n//             eval js           |> success\n//        with e -> e.ToString() |> failure\n//    )\n//    |> RunCode.RunNode().RunHtml\n//\n//let evalWindowUrlJS (url:string) success failure js =\n//    let window       = JS.Apply JS.Window \"open\" [| url |]\n//    match window with\n//    | null -> failure \"could not open new browser. Popup blocker may be active.\"\n//    | _    ->\n//    800 \n//    |> JS.SetTimeout (fun () -> \n//        try\n//             let eval   s = JS.Apply window   \"eval\" [| s |]\n//             //printfn \"Evaluating...\"\n//             JS.Apply window   \"focus\" [|  |]\n//             eval js           |> success\n//        with e -> e.ToString() |> failure)\n//    |> ignore\n//\n//let runUrlJS url pos msgs js =\n//    sendMsg \"Running JavaScript...\"\n//    match pos with\n//    | NewBrowser -> evalWindowUrlJS url\n//    | _          -> evalIFrameJS\n//    <| (fun res  -> sendMsg \"Done!\"   ; sendMsg res ; sendMsg msgs) \n//    <| (fun res  -> sendMsg \"Failed!\" ; sendMsg res ; sendMsg msgs)\n//    <| js\n//\n//let processSnippet getCode msg processCode =\n//    CodeSnippet.FetchO currentCodeSnippetId.Value \n//    |> Option.iter (fun snp -> \n//        codeMsgs.Value <- msg\n//        codeJS.Value   <- \"\"\n//        let code = getCode snp\n//        codeFS.Value   <- code\n//        processCode       code\n//    )\n//\n//let compileSnippet fThen fFail = \n//    processSnippet (fun snp -> snp.GetCodeFsx true) \"Compiling to JavaScript...\" (RunCode.compile (fun msgs js -> codeJS.Value <- js ; fThen msgs js) fFail)\n//\n//let compileRunP pos = compileSnippet (runJS pos)                                         sendMsg\n//let compileRun  ()  = compileRunP           position.Value\n//let justCompile ()  = compileSnippet (fun msgs _ -> sendMsg \"Compiled!\" ; sendMsg msgs)  sendMsg\n\nlet reorderSnippet toId fromId =\n    let trySnippet id = tryPickI (fun (_, snp) -> snp.id = id) \n    let moving, others = codeSnippets.Value |> Seq.toArray |> Array.partition (fun snp -> snp.id = fromId || snp.IsDescendantOf fromId)\n    match trySnippet fromId moving, trySnippet toId others with\n    | Some(_, snp), Some(ti, tsn) ->\n        [| others.[0..ti - 1] ; moving ; others.[ti..] |]\n        |> Array.collect id\n        |> codeSnippets.Set\n        codeSnippets.UpdateBy (fun c -> Some { c with parent = tsn.parent }) snp.id\n    | _ -> ()\n    setDirtyPred()\n\nlet indentCodeIn () =\n    CodeSnippet.PickIO currentCodeSnippetId.Value\n    |> Option.iter (fun (j, snp) ->\n        let rec doPriorUntil f i =\n            if i < 0 then () else\n            if codeSnippets.Value |> Seq.item i |> f then () else\n            doPriorUntil f (i - 1)\n        j - 1 |> doPriorUntil (fun pri ->\n            if pri.parent = snp.parent \n            then codeSnippets.UpdateBy (fun c -> Some { c with parent = Some pri.id }) snp.id\n                 true\n            else false\n        )\n        setDirtyPred()\n    )\n\nlet indentCodeOut () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value\n    |> Option.iter (fun snp ->\n        let newP = snp.parent\n                   |> Option.bind CodeSnippet.FetchO\n                   |> Option.bind (fun p -> p.parent)\n        codeSnippets.UpdateBy (fun c -> Some { c with parent = newP }) snp.id\n        setDirtyPred()\n    )\n\nlet mutable draggedId   = CodeSnippetId.New\n\n()","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"8efdcd5a-95c4-4212-9c75-1ebedce83dd8"},{"$":0,"Item":"a28fe808-236e-4b7e-9509-51ebe21e35fc"},{"$":0,"Item":"987560b0-1fe6-4835-ad99-aed93db7da1a"}],"id":{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Compile","content":"let compileSnippetW (snpO: CodeSnippet option) =\n    Wrap.wrapper {\n        let!   snp         = snpO |> Result.fromOption ``Snippet Missing``\n        outputMsgs.Value  <- \"Compiling to JavaScript...\"\n        codeJS.Value      <- \"\"\n        let    code        = snp.GetCodeFsx true\n        codeFS.Value      <- code\n        let!   jsR         = translateAR code false\n        let!   js          = jsR\n        let    jsc         = RunCode.completeJS js\n        codeJS.Value      <- jsc\n        addOutMsg            \"Compiled!\"\n        return jsc\n    }\n    \nlet newWindow url = \n    JS.Apply JS.Window \"open\"  [| url |]\n    |> function\n       | null   -> Result.fail    ``Could not open new browser, Popup blocker may be active``\n       | window -> Result.succeed window\n    \nlet eval  window js = JS.Apply window \"eval\"  [| js  |]\nlet focus window    = JS.Apply window \"focus\" [|     |] |> ignore\n\nlet evalWindowUrlJSW (url:string) js =\n    Wrap.wrapper {\n        do!    Result.tryProtection()\n        let!   window       = newWindow url\n        do     focus window\n        do!    Async.Sleep 800 \n        let    res : string = eval window js\n        return res\n    }\n\nlet createIFrameA () =\n    Async.FromContinuations\n        (fun (cb, errF: exn -> unit, canF: System.OperationCanceledException -> unit) ->\n            try\n                createIFrame cb |> RunCode.RunNode().RunHtml     \n            with e -> errF e\n        )\n\nlet evalIFrameJSW js =\n    Wrap.wrapper {\n        do!    Result.tryProtection()\n        let!   frame        = createIFrameA () \n        let    window       = frame?contentWindow\n        window?document?body?style?margin <- \"0px\"\n        let    res : string = eval window js\n        return res\n    }\n\nlet compileRunUrlW url pos snpO =\n    Wrap.wrapper {\n        let! js  = compileSnippetW snpO\n        outputMsgs.Value <-  \"Running JavaScript...\"\n        let! res = match pos with\n                   | NewBrowser -> evalWindowUrlJSW url js\n                   | _          -> evalIFrameJSW        js\n        addOutMsg res\n        addOutMsg \"Done!\"\n        return  pos, res\n    }\n\nlet getSnpO () = CodeSnippet.FetchO currentCodeSnippetId.Value\n\nlet evaluateSnippetW (snpO: CodeSnippet option) =\n    Wrap.wrapper {\n        let!   snp        = snpO |> Result.fromOption ``Snippet Missing``\n        outputMsgs.Value <- \"Evaluating F# code...\"\n        let    code       = snp.GetCodeFsx true\n        codeFS.Value     <- code\n        let! resR         = evaluateAR code\n        let! res          = resR\n        addOutMsg res\n        addOutMsg \"Done!\"\n        return  res\n    }\n\nlet compileRunW = compileRunUrlW (JS.Window.Location.Origin + \"/Main.html\") \n\nlet compileRunP pos = getSnpO() |> compileRunW pos  //|> Wrap.map ignore |> Wrap.start addOutMsg\nlet justCompile     = getSnpO   >> compileSnippetW  //>> Wrap.map ignore >> Wrap.start addOutMsg\nlet evaluateFS      = getSnpO   >> evaluateSnippetW //>> Wrap.map ignore >> Wrap.start addOutMsg\nlet compileRun  ()  = compileRunP position.Value\n\n()","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"},{"$":0,"Item":"afaac2af-143d-4745-9447-7e8d3044950f"},{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"3f2ec5e2-8ab6-4e5b-bb89-1943ed3a4964"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Messaging","content":"#if NOMESSAGING\n#else\n\nlet fsStationClient = FsStationClient(fsIds, fsIds, endPoint = JS.Window.Location.Href)\n\nlet transMsgs (msgs: ErrMsg list)  =  msgs |> Seq.map (fun e -> e.ErrMsg, if e.IsWarning then FSWarning else FSError) |> Seq.toArray\n\nlet result2response res = \n    match res with \n    | Result (a, b) -> StringResponseR (a |> Option.map snd, b |> Seq.map (fun err -> err.ErrMsg, if err.IsWarning then FSWarning else FSError) |> Seq.toArray ) \n\nlet respond fromId (msg:FSMessage) : Async<FSResponse> =\n    async {\n        match msg with\n        | GetWholeFile                     -> return  codeSnippets.Value            |> Seq.toArray |> Json.Serialize |> Some                                   |> StringResponse       \n        | GetSnippetContentById sId        -> return  CodeSnippet.FetchO       sId  |> Option.map (fun snp -> snp.content        )                             |> StringResponse       \n        | GetSnippetCodeById    sId        -> return  CodeSnippet.FetchO       sId  |> Option.map (fun snp -> snp.GetCodeFsx true)                             |> StringResponse \n        | GetSnippetPredsById   sId        -> return  CodeSnippet.FetchO       sId  |> Option.map (fun snp -> snp.Predecessors ()) |> Option.defaultValue [||] |> SnippetsResponse\n        | GetSnippetById        sId        -> return  CodeSnippet.FetchO       sId                                                                             |> SnippetResponse \n        | GetSnippetContent     path       -> return  CodeSnippet.FetchByPathO path |> Option.map (fun snp -> snp.content        )                             |> StringResponse\n        | GetSnippetCode        path       -> return  CodeSnippet.FetchByPathO path |> Option.map (fun snp -> snp.GetCodeFsx true)                             |> StringResponse\n        | GetSnippetJSCode      path       -> match   CodeSnippet.FetchByPathO path with\n                                              | Some snp -> let!    jsR = translateAR (snp.GetCodeFsx true) false\n                                                            return (jsR |> Result.map RunCode.completeJS |> Result.getOption, jsR |> Result.getMsgs |> transMsgs)      |> StringResponseR\n                                              | None     -> return (None, [| \"Snippet not found\" , FSError |] )                                                |> StringResponseR\n        | GetSnippetPreds       path       -> return  CodeSnippet.FetchByPathO path |> Option.map (fun snp -> snp.Predecessors ()) |> Option.defaultValue [||] |> SnippetsResponse\n        | GetSnippet            path       -> return  CodeSnippet.FetchByPathO path                                                                            |> SnippetResponse \n        | GenericMessage        txt        -> return  (Some <| \"Message received: \" + txt)                                                                     |> StringResponse\n        | GetIdentification                -> return  fromId                                                                                                   |> IdResponse  \n        | RunSnippetUrlJSById  (sId , url) -> return! CodeSnippet.FetchO       sId  |> compileRunUrlW url NewBrowser |> Wrap.getAsyncR |> Async.map result2response\n        | RunSnippetUrlJS      (path, url) -> return! CodeSnippet.FetchByPathO path |> compileRunUrlW url NewBrowser |> Wrap.getAsyncR |> Async.map result2response\n    }     \n     \nlet respondMessage fromId txt =\n    async {\n        let  msg = Json.Deserialize txt \n        let! res = respond fromId msg\n        return Json.Serialize res\n    }\n\nasync {\n    do! Async.Sleep 1000\n    do fsStationClient.MessagingClient.AwaitMessage respondMessage\n} |> Async.Start\n\n#endif","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"3f2ec5e2-8ab6-4e5b-bb89-1943ed3a4964"},{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"}],"id":{"$":0,"Item":"95ca1e9f-4029-4fc1-8b1c-ab12db71c90b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"List Code","content":"let isDirectPredecessor pre curO =\n    curO\n    |> Option.map (fun snp -> snp.predecessors |> List.contains pre)\n    |> Option.defaultValue false\n\n\nlet curPredecessors = Val.map getPredecessorsM.Call currentCodeSnippetO\n\nlet isIndirectPredecessor pre (predecessors: HashSet<CodeSnippetId>) = predecessors.Contains pre //predecessors |> Set.contains pre\n\n//let isIndirectPredecessorT (preId, curId) = getPredecessors curId |> Set.contains preId            // horrible performance\n//let isIndirectPredecessorM  preId  curId  = (Useful.memoize isIndirectPredecessorT) (preId, curId) // horrible performance\n\nlet togglePredecessorForCur (pre:CodeSnippet) curO =\n    curO |> Option.iter (fun cur ->\n        if cur = pre || isIndirectPredecessor cur.id (pre.UniquePredecessors CodeSnippet.FetchO |> HashSet) then () else\n        let preds = \n            if cur.predecessors |> List.contains pre.id\n            then List.filter ((<>) pre.id)\n            else fun l -> pre.id :: l\n            <| cur.predecessors\n        codeSnippets.UpdateBy  (fun c -> Some { c with predecessors = preds }) cur.id\n        setDirtyPred()\n    )\n\nlet toggleExpanded snp =\n    codeSnippets.UpdateBy  (fun c -> Some { c with expanded = not c.expanded }) snp.id\n    refreshView()\n\nlet listEntry isParent isExpanded code =\n    Template.Hoverable.New\n        .Content( [ ``class`` \"code-editor-list-tile\"\n                    classIf   \"selected\"              <| Val.map ((=)                    code.id) currentCodeSnippetId\n                    classIf   \"direct-predecessor\"    <| Val.map (isDirectPredecessor    code.id) currentCodeSnippetO\n                    classIf   \"indirect-predecessor\"  <| Val.map (isIndirectPredecessor  code.id) curPredecessors\n                    draggable \"true\"\n                    SomeAttr <| on.dragOver(fun _ ev -> ev.PreventDefault()                                              )\n                    SomeAttr <| on.drag    (fun _ _  ->                                              draggedId <- code.id)\n                    SomeAttr <| on.drop    (fun _ ev -> ev.PreventDefault() ; reorderSnippet code.id draggedId           )\n                    span    [ ``class`` \"node\"\n                              classIf   \"parent\"   isParent\n                              classIf   \"expanded\" isExpanded\n                              SomeAttr <| on.click(fun _ _ -> if isParent then toggleExpanded code)\n                              title    <| if isParent then (if isExpanded then \"collapse\" else \"expand\") else \"\"\n                              htmlText <| if isParent then (if isExpanded then \"-\"        else \"+\"     ) else \"\"\n                            ]\n                    div     [ ``class`` \"code-editor-list-text\"\n                              style1 \"text-indent\" (code.Levels |> fst |> sprintf \"%dem\")\n                              style  \"white-space: pre\"\n                              htmlText <| Val.map2 snippetName (curSnippetNameOf code.id) (curSnippetCodeOf code.id)\n                              SomeAttr <| on.click (fun _ _ -> currentCodeSnippetId.Value <- code.id)\n                            ]\n                    span    [ ``class``   \"predecessor\"\n                              title       \"toggle predecessor\"\n                              SomeAttr <| on.click(fun _ _ -> Val.iter (togglePredecessorForCur code) currentCodeSnippetO)\n                              htmlText    \"X\"\n                            ]\n                    ])\n\nlet mutable topScrollList = 0.0\n\nlet listEntries snps =\n    let list =\n      div [ \n        yield style \"overflow: auto\"\n        yield! \n            snps\n            |> Seq.indexed\n            |> Seq.mapFold (fun expanded (i, snp) ->\n                if snp.parent |> Option.map (fun p -> Set.contains p expanded) |> Option.defaultValue true then \n                    let isParent    = codeSnippets |> Seq.tryItem (i + 1) |> Option.map (fun nxt -> nxt.parent = Some snp.id) |> Option.defaultValue false\n                    let isExpanded  = isParent && snp.expanded\n                    (listEntry isParent isExpanded snp |> Some, if isExpanded then Set.add snp.id expanded else expanded)\n                else  (None, expanded)\n            )  (Set [])\n            |> fst\n            |> Seq.choose id\n        yield SomeAttr <| on.scroll      (fun e _ -> topScrollList <- e.ScrollTop   )\n        yield SomeAttr <| on.afterRender (fun e   -> e.ScrollTop   <- topScrollList )\n      ]\n    list\n\n()    ","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"},{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}],"id":{"$":0,"Item":"93f32df7-da8b-472f-8bad-e82cc58ec52b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Deserialize","content":"let inline ifUndef def v = if isUndefined v then def else v\nlet obj2CodeSnippetId o = \n    if isUndefined o then\n        System.Guid(\"00000000-0000-0000-0000-000000000000\")\n    else\n        o?Item\n    |> CodeSnippetId \n\nlet obj2CodeSnippetIdO o = // the json representation of an option is different from the internal representation\n    if isUndefined o then\n        None\n    else\n        Some <| obj2CodeSnippetId o\n\nlet obj2Map o =\n    let dict = System.Collections.Generic.Dictionary<string, string>()\n    if isUndefined o then\n        dict\n    else\n        JS.GetFields o |> Array.map (fun (f, v) -> f, v :?> string ) |> Seq.iter dict.Add\n        dict\n\nlet deserializeCodeSnipets v = \n    try\n        let objs= WebSharper.Json.Parse v |> unbox<obj[]>\n        printfn \"%A\" <| Array.length objs\n        let snps =\n            objs\n            |> Array.choose (fun o ->\n                 if isUndefined o then None else\n                 {\n                    name         = o?name         |> ifUndef \"\"\n                    content      = o?content      |> ifUndef \"\"\n                    parent       = o?parent       |> obj2CodeSnippetIdO\n                    predecessors = o?predecessors |> ifUndef [||] |> Array.map  obj2CodeSnippetId |> Seq.toList\n                    id           = o?id           |> obj2CodeSnippetId\n                    expanded     = o?expanded     |> ifUndef false\n                    level        = o?level        |> ifUndef 0\n                    levelCode    = o?levelCode    |> ifUndef 0\n                    properties   = o?properties   |> obj2Map\n                  } |> Some)\n        snps\n    with _ -> [||]\n    \n()    ","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}],"id":{"$":0,"Item":"54304360-819a-498c-a091-e6ece880a35a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Add,Delete,Load,Save","content":"let addCode   ()   =\n    CodeSnippet.PickIO currentCodeSnippetId.Value\n    |> Option.map (fun (i, snp) -> CodeSnippet.New(i + 1, \"\", snp.parent, [], [], \"\"))\n    |> Option.defaultWith (fun _ -> CodeSnippet.New \"\")\n    |> fun n -> currentCodeSnippetId.Value <- n.id\n    setDirty()\n    refreshView()\n\n\nlet deleteCode () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value\n    |> Option.iter (fun snp -> \n        if JS.Confirm (sprintf \"Do you want to delete %s?\" snp.Name) then\n            currentCodeSnippetId.Value <- CodeSnippetId.New\n            codeSnippets.Remove snp\n            setDirty()\n            refreshView()\n    )\n    \nlet justFileName (f:string) = f.Split [| '/' ; '\\\\' |] |> Seq.last\n\nlet fileName  = Var.Create \"\"\nlet emptyFile = Val.map (fun v -> v = \"\") fileName\n\nlet loadTextFile element (f: string -> unit) =\n    let files = element |> FileList.OfElement \n    if files.Length > 0 then\n        let  reader  = TextFileReader()\n        reader.Onload <- (fun e -> f e.Target?result)\n        reader.ReadAsText files.[0] \n\nlet parseText txt =\n    try\n        txt\n        |> deserializeCodeSnipets\n        |> codeSnippets.Set\n        setClean()\n        refreshView()\n    with e -> JS.Alert <| e.ToString()\n\nlet fileInputElementId = \"CodeEditorFileSel\"\nlet loadFile (e: Dom.Element) =\n    if (not dirty.Value) || JS.Confirm \"Changes have not been saved, do you really want to load?\" then\n      let root = findRootElement e\n      loadTextFile \n          <| root.QuerySelector(\"#\" + fileInputElementId)\n          <| parseText\n\nlet downloadFile() = // Save as...\n    codeSnippets.Value\n        |> Seq.toArray\n        |> Json.Serialize\n        |> saveAs <| match justFileName fileName.Value with | \"\" -> \"snippets.fsjson\" | fname -> fname\n    setClean()\n\nlet loadFileElement =\n    Template.Input.New(fileName.Lens justFileName (fun prev n -> prev) )\n        .Prefix( label [ ``class`` \"btn btn-primary\" ; htmlText \"Load File...\" \n                         Template.Input.New(fileName)\n                                 .Type(\"file\")\n                                 .Style(\"display: none\")\n                                 .Content([ on.change (fun el _ -> loadFile el   )\n                                            on.click  (fun el _ -> el?value <- \"\")\n                                          ])\n                                 .Id(fileInputElementId)\n                                 .Render \n                        ]\n                )\n                \nlet do_LoadFile (e:Dom.Element) _ =          \n    let root = findRootElement e\n    (root.QuerySelector(\"#\" + fileInputElementId))?click()\n\nif loadFromUri <> \"\" then\n    async {\n        do! Async.Sleep 3000\n        printfn \"loading %s...\" loadFromUri\n        let  r = JQuery.JQuery.GetJSON(loadFromUri)\n        r.Done (fun () -> parseText r.ResponseText) |> ignore\n    } |> Async.Start\n    \n    ","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"54304360-819a-498c-a091-e6ece880a35a"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}],"id":{"$":0,"Item":"60191ea0-da20-4fbf-96b8-3871338a66d8"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"codeMirror","content":"let autoCompleteClient = FSAutoCompleteIntermediary.FSAutoCompleteIntermediaryClient(\"FSharpStation\", endPoint = JS.Window.Location.Href)\n\n#if FSS_SERVER\nlet parseFile = fsIds + \".fsx\"\n#else\nlet parseFile = \"..\\\\\" + fsIds + \".fsx\"\n#endif\n\nlet setDirtyCond() =\n    match lastCodeAndStarts with\n    | Some (pId, _, red) when pId = currentCodeSnippetId.Value -> setDirtyPart()\n    | _                                                        -> setDirty    ()\n\nlet isParseDisabled = disableParseVal |> Val.toView |> View.GetAsync \n\nlet getCodeAndStartsFast msgF (snp:CodeSnippet) addLinePrepos =\n    let red0, cur = \n        match lastCodeAndStarts with\n        | Some (pId, alp, red) when pId = snp.id && alp = addLinePrepos -> msgF \"Reparsing...\"; red, snp.PrepareSnippet\n        | _ -> \n        msgF \"Parsing...\"\n        let preds = snp.Predecessors()\n        let red = CodeSnippet.ReducedCode addLinePrepos preds.[0..preds.Length - 2]\n        let cur = preds.[preds.Length - 1]\n        lastCodeAndStarts <- Some(cur.id, addLinePrepos, red)\n        red, cur\n    let red1 = CodeSnippet.ReducedCode addLinePrepos [| cur |]\n    CodeSnippet.AddSeps red0 red1\n    |> CodeSnippet.FinishCode addLinePrepos\n\nlet mutable parseRun = 1\n\nlet parseFSA silent =\n    async {\n        let msgF = if silent then ignore else fun txt -> parserMsgs.Value <- txt\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        let runN           = parseRun + 1\n        parseRun          <- runN\n        let  code, starts  = getCodeAndStartsFast msgF cur false\n        parsed            <- true\n        let! res           = autoCompleteClient.Parse(parseFile, code, starts)\n        if not silent && runN = parseRun && parsed then\n            addPrsMsg res\n            addPrsMsg \"Parsed!\"\n    }\n\nlet parseFS() = \n    Wrap.wrapper {\n        lastCodeAndStarts <- None\n        do! parseFSA false\n    }\n\n\nlet mustParse (cur:CodeSnippet) =\n    async {\n        if not parsed then return true \n        else\n            let! must = autoCompleteClient.MustParse(parseFile, cur.NameSanitized)\n            return must\n    }\n\nlet parseIfMustThen silent =\n    async {\n        let! disabled = isParseDisabled \n        if disabled then () else\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        let! must = mustParse cur\n        if must then \n            do! parseFSA silent\n    }\n\nlet getStartWord (line:string) ch =\n    match line.Substring(0, ch) with\n    | REGEX @\"([a-zA-Z_]\\w*)$\" \"g\" [| txt |] -> txt\n    | _                                      -> \"\"          \n\nlet getEndWord (line:string) ch =\n    match line.Substring(ch) with\n    | REGEX @\"^([a-zA-Z_]\\w*)\" \"g\" [| txt |] -> txt\n    | _                                      -> \"\"          \n\nlet showToolTip (ed:Template.CodeMirrorEditor) =\n    async {\n        let! disabled = isParseDisabled \n        if disabled then () else\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        do!  parseIfMustThen false\n        let  pos   = ed.GetCursor()\n        let  l     = ed.GetLine pos.line\n        let  sub   = (getStartWord l pos.ch |> String.length)   \n        let  add0  = (getEndWord   l pos.ch |> String.length)    \n        let  add   = if sub = 0 && add0 = 0 then 2 else add0 \n        let! tip   = autoCompleteClient.ToolTip  (parseFile, pos.line + 1, pos.ch + 1, cur.NameSanitized)\n        addPrsMsg <| sprintf \"InfoFSharp \\\"%s %A - %A %s \\\"\" cur.NameSanitized (pos.line + 1, pos.ch - sub + 1) (pos.line + 1, pos.ch + add + 1) (tip.Replace(\"\\\"\",\"''\"))\n    } |> Async.Start\n\nlet getHints (ed:Template.CodeMirrorEditor, cb, _) =\n    async {\n        let! disabled = isParseDisabled \n        if disabled then () else\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        do!  parseIfMustThen true\n        let  pos    = ed.GetCursor()\n        let  l      = ed.GetLine pos.line\n        let  word   = getStartWord l pos.ch     \n        let! com    = autoCompleteClient.Complete(parseFile, l, pos.line + 1, pos.ch + 1, cur.NameSanitized)\n        cb { Template.list   = com \n                               |> Array.map (fun (dis, rep, cls, chr) -> \n                                    { text        = rep\n                                      displayText = chr + \"| \" + dis\n                                      className   = cls                              \n                                    })\n             Template.from   = { pos with ch = pos.ch - word.Length }\n             Template.``to`` = pos \n           }\n    } |> Async.Start\n    \nlet rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\"\"\"\nlet rex2 = \"\"\"(Err|Warning|Info)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) ?)?F?#? ?(.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\nlet rex = rex1 + \"|\" + rex2\n\nlet getAnnotations (txt, cb, _, ed:Template.CodeMirrorEditor) =\n    async {\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        do!  parseIfMustThen false\n        match parserMsgs.Value with\n        | REGEX rex \"g\" m -> m\n        | _               -> [||]\n        |> Array.choose (fun v ->\n            match v with\n            | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, indent, int fl, int fc    , int tl, int tc, sev, from , msg)\n            | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, indent, int fl, int fc - 1, int fl, int fc, sev, \"fsi\", msg)\n            | _ -> None\n        )\n        |> Array.choose (fun (file, indent, fl, fc, tl, tc, sev, from, msg) ->\n            if file.StartsWith cur.id.Text || file = sanitize cur.name then\n                let ind = if int indent > 0 then int indent else 0\n                { Template.LintResponse.message  = msg\n                  Template.LintResponse.severity = (if sev.ToUpper().StartsWith(\"ERR\") then \"error\" elif sev.ToUpper().StartsWith(\"INFO\") then \"info\" else \"warning\")\n                  Template.LintResponse.from     = Template.cmPos(fl - 1, fc - 1 - ind) \n                  Template.LintResponse.``to``   = Template.cmPos(tl - 1, tc - 1 - ind)\n                } |> Some\n            else     None\n          )\n        |> cb\n    } |> Async.Start\n\nlet codeMirror = \n    Template.CodeMirror.New(Val.bindIRef curSnippetCodeOf currentCodeSnippetId)\n        .OnChange(setDirtyCond)\n        .OnRender(fun ed ->\n          ed.AddKeyMap({  F2              = showToolTip            \n                          LeftDoubleClick = showToolTip\n                          ``Ctrl-Space``  = Template.showHints ed getHints false\n                       })\n          Template.setLint ed getAnnotations \n          Val.sink (fun v ->\n              async {\n                  ed.SetOption(\"theme\", v)\n                  do! Async.Sleep(50)\n                  ed.Refresh()\n              } |> Async.Start\n              ) propertyThemeVal \n          Val.sink (fun v -> ed.SetOption(\"mode\" , v)) propertyModeVal \n        )\n        .Style(\"height: 100%\")\n\nlet rec expandParents snp = \n    snp.parent\n    |> Option.bind CodeSnippet.FetchO\n    |> Option.iter (fun me -> \n        expandParents me\n        if not me.expanded then toggleExpanded me)\n\nlet goto codeId line col =\n    async {\n        currentCodeSnippetId.Value <- codeId\n        CodeSnippet.FetchO codeId |> Option.iter expandParents\n        do! Async.Sleep 200\n        codeMirror.editorO \n        |> Option.iter (fun ed -> \n            ed.SetCursor(line - 1, col - 1) \n            ed.Focus()\n        )\n    } |> Async.Start\n\nlet rexGuid = \"\"\"([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}).+?\\((\\d+)\\,\\s*(\\d+)\\)\"\"\"\n\nlet jumpToLine (line:string) = \n    match line with\n    | REGEX rexGuid \"\" [| _ ; guid ; line ; col |] -> goto <| CodeSnippetId (System.Guid guid) <| int line <| int col\n    | _                                            -> ()\n\nlet gotoDefinition () =\n    async {\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        match codeMirror.editorO  with\n        | None     -> () \n        | Some ed  ->\n        let  pos   = ed.GetCursor()\n        let  l     = ed.GetLine pos.line\n        let! kind  = autoCompleteClient.FindDecl(parseFile, pos.line + 1, pos.ch + 1, cur.NameSanitized)\n        match kind with\n        | FSAutoCompleteIntermediary.CommTypes.KFindDecl decl -> jumpToLine <| sprintf \"%s (%d, %d) - (%d, %d)\" decl.File decl.Line decl.Column decl.Line decl.Column\n        | FSAutoCompleteIntermediary.CommTypes.KError    err  -> JS.Alert   <| sprintf \"%A\" err\n        | _                                                   -> JS.Alert   <| sprintf \"%A\" kind\n    } |> Async.Start\n\nlet codeMirrorRender = \n    codeMirror.Render.AddChildren [ \n        SomeAttr <| on.dblClick (fun _ _ -> showToolTip codeMirror.editorO.Value)  \n        htmlElement \"menu\" [  // does not work anymore. support for this was dropped by Chrome\n            ``type`` \"context\"\n            Id       \"right-menu\"\n            htmlElement \"menuitem\" [ \n                htmlAttribute \"label\" \"Goto Definition\"\n                SomeAttr <| on.click (fun _ _ -> gotoDefinition() )  \n            ] \n        ]\n        htmlAttribute \"contextmenu\" \"right-menu\"\n    ]\n\nparserMsgs\n|> Val.sink (fun msgs ->\n    async {\n        if not parsed then () else\n        match codeMirror.editorO  with\n        | None    -> () \n        | Some ed ->\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        let! must = autoCompleteClient.MustParse(parseFile, cur.NameSanitized)\n        if must       then () else\n        ed?performLint() |> ignore\n    } |> Async.Start      \n)\n//let mutable prior = \"\", \"\"\n//Val.map2 (fun msgs curO -> msgs, curO) codeMsgs currentCodeSnippetO\n//|> Val.sink (fun (msgs, curO) ->\n//    async {\n//        match codeMirror.editorO  with\n//        | None        -> () \n//        | Some editor ->\n//            match curO with \n//            | None -> () \n//            | Some cur ->\n//            curSnippetNameOf cur.id\n//            |> Val.iter (fun name ->\n//                printfn \"RemoveMarks: %s\" name\n//                if prior = (msgs, name) then () else\n//                prior   <- (msgs, name)\n//                editor.RemoveMarks()\n//                match msgs with\n//                | REGEX rex \"g\" m -> m\n//                | _               -> [||]\n//                |> Array.choose (fun v ->\n//                    match v with\n//                    | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, int fl, int fc - int indent    , int tl, int tc - int indent, sev, from , msg)\n//                    | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, int fl, int fc - int indent - 1, int fl, int fc - int indent, sev, \"fsi\", msg)\n//                    | _ -> None\n//                )\n//                |> Array.iter (fun (file, fl, fc, tl, tc, sev, from, msg) ->\n//                    printfn \"inside -%s-%s-\" file (sanitize name)\n//                    if file.StartsWith cur.id.Text || file = sanitize name then\n//                        100\n//                        |> JS.SetTimeout (fun () ->\n//                            editor.MarkText (fl - 1, fc - 1) (tl - 1, tc - 1) (if sev.ToUpper().StartsWith(\"ERR\") then \"Error\" else \"Warning\")  msg)\n//                        |> ignore\n//    \n//                )\n//            )\n//    } |> Async.Start\n//)\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"93f32df7-da8b-472f-8bad-e82cc58ec52b"},{"$":0,"Item":"466e6783-0751-48d5-b79b-165aaa7d2173"},{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"},{"$":0,"Item":"18d8153d-422c-42f6-8266-9a9d854bd6a1"},{"$":0,"Item":"a05dd36e-a15e-4394-8013-128e21e69574"},{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"id":{"$":0,"Item":"47f7c0ba-35b0-466e-a759-4e4d9963e524"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"styleEditor","content":"let styleEditor    =\n     \"\"\"\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"id":{"$":0,"Item":"fa5b4506-b26d-4387-8e04-ac7a5a90861a"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"1"}},{"name":"CSS","content":"body { margin: 0px }     \n     \ndiv textarea {\n    font-family     : monospace;\n}\n.code-editor-list-tile {\n    white-space     : nowrap; \n    border-style    : solid none none;\n    border-color    : white;\n    border-width    : 1px;\n    background-color: #D8D8D8;\n    display         : flex;\n}\n.code-editor-list-text{\n    padding         : 1px 10px 1px 5px;\n    overflow        : hidden;\n    text-overflow   : ellipsis;\n    white-space     : nowrap;\n    flex            : 1;\n}\n\n.code-editor-list-tile.direct-predecessor {\n    font-weight     : bold;\n}\n.code-editor-list-tile.indirect-predecessor {\n    color           : blue;\n}\n.code-editor-list-tile.selected {\n    background-color: #77F;\n    color           : white;\n}\n.code-editor-list-tile.hovering {\n    background      : lightgray;\n}\n.code-editor-list-tile.hovering.selected {\n    background      : blue;\n}\n.code-editor-list-tile>.predecessor {\n    font-weight     : bold;\n    border-style    : inset;\n    border-width    : 1px;\n    text-align      : center;\n    color           : transparent;\n}\n.code-editor-list-tile.direct-predecessor>.predecessor {\n    color           : blue;\n}\n\n.CodeMirror { height: 100%; }\n\n.node {\n    background-color: white; \n    width           : 2ch; \n    color           : #A03; \n    font-weight     : bold; \n    text-align      : center;\n    font-family     : arial;\n}\n.Warning { text-decoration: underline lightblue } \n.Error   { text-decoration: underline red       } \n.body    { margin         : 0px                 }","parent":{"$":0,"Item":"fa5b4506-b26d-4387-8e04-ac7a5a90861a"},"predecessors":[],"id":{"$":0,"Item":"78648685-ff9c-4dc6-800a-3285f135dec4"},"expanded":true,"level":0,"levelCode":0,"properties":{"Theme":"bespin","Mode":"css","NoLinePre":"1"}},{"name":"","content":"\"\"\"","parent":{"$":0,"Item":"fa5b4506-b26d-4387-8e04-ac7a5a90861a"},"predecessors":[{"$":0,"Item":"78648685-ff9c-4dc6-800a-3285f135dec4"}],"id":{"$":0,"Item":"aeb92943-97ea-4297-9097-926410e9d10f"},"expanded":true,"level":0,"levelCode":0,"properties":{"NoLinePre":"1"}},{"name":"Actions","content":"let triggerWSResult = Var.Create ()\n\nlet DoW f p _ _ = f p |> Wrap.map ignore |> Wrap.start addOutMsg\nlet DoP f p _ _ = f p |> Wrap.startV (function\n                                      | Some (Below, _), msgs -> msgs |> addOutMsg ;  triggerWSResult.Value <- ()\n                                      | Some _         , msgs -> msgs |> addOutMsg \n                                      | None           , msgs -> \"Failed!\\n\" + msgs |> addOutMsg)\n\nlet actLoadFile       = Template.Action.New(\"Load...\"                    ).OnClick(do_LoadFile                  )  \nlet actSaveFile       = Template.Action.New(\"Save as...\"                 ).OnClick(Do  downloadFile   ()        ).Highlight(dirty)\nlet actAddSnippet     = Template.Action.New(\"Add Snippet\"                ).OnClick(Do  addCode        ()        )\nlet actDeleteSnippet  = Template.Action.New(\"Delete Snippet\"             ).OnClick(Do  deleteCode     ()        ).Disabled(noSelectionVal      )\nlet actIndentSnippet  = Template.Action.New(\"Indent In  >>\"              ).OnClick(Do  indentCodeIn   ()        ).Disabled(noSelectionVal      )\nlet actOutdentSnippet = Template.Action.New(\"Indent Out <<\"              ).OnClick(Do  indentCodeOut  ()        ).Disabled(noSelectionVal      )\nlet actGetFsCode      = Template.Action.New(\"Get F# Code\"                ).OnClick(Do  getFSCode      ()        ).Disabled(disableParseVal     )\nlet actEvalCode       = Template.Action.New(\"Evaluate F#\"                ).OnClick(DoW evaluateFS     ()        ).Disabled(disableFSIVal       )\nlet actRunWSNewTab    = Template.Action.New(\"Run WebSharper in new tab\"  ).OnClick(DoW compileRunP    NewBrowser).Disabled(disableWebSharperVal)\nlet actRunWSHere      = Template.Action.New(\"Run WebSharper in WS Result\").OnClick(DoP compileRunP    Below     ).Disabled(disableWebSharperVal)\nlet actRunWSIn        = Template.Action.New(\"Run WebSharper in ...\"      ).OnClick(DoP compileRun     ()        ).Disabled(disableWebSharperVal)\nlet actParseCode      = Template.Action.New(\"Parse F#\"                   ).OnClick(DoW parseFS        ()        ).Disabled(disableParseVal     )\nlet actCompileWS      = Template.Action.New(\"Compile WebSharper\"         ).OnClick(DoW justCompile    ()        ).Disabled(disableWebSharperVal)\nlet actFindDefinition = Template.Action.New(\"Find Definition\"            ).OnClick(Do  gotoDefinition ()        ).Disabled(disableParseVal     )\n     \nlet buttonsH =\n    div [ \n          actAddSnippet    .Button.Render\n          actOutdentSnippet.Button.Render\n          actIndentSnippet .Button.Render\n          loadFileElement.Render.AddChildren([ style \"grid-column: 4/6\" ])\n          actParseCode     .Button.Render\n          actEvalCode      .Button.Render\n          actGetFsCode     .Button.Render\n       \n          actDeleteSnippet .Button.Render\n          actFindDefinition.Button.Render\n          span []       \n          actSaveFile      .Button.Render\n          span []\n          actCompileWS     .Button.Render\n          actRunWSIn       .Button.Render\n          Doc.Select [ attr.id \"Position\" ] positionTxt [ NewBrowser ; Below ] position |> someElt\n          style \"\"\"\n              overflow: hidden;\n              display: grid;\n              grid-template-columns: repeat(8, 12.1%);\n              bxackground-color: #eee;\n              padding : 5px;\n              grid-gap: 5px;\n          \"\"\"\n        ]\n\nlet menuLeft =\n    Menu.New2\n      [\n        MenuEntry.New(\"File\")\n            .SubMenu(\n                    [\n                        actLoadFile.MenuEntry\n                        actSaveFile.MenuEntry\n                    ]           \n            )            \n        MenuEntry.New(\"Code\")           \n            .SubMenu(           \n                    [           \n                        actAddSnippet    .MenuEntry\n                        actDeleteSnippet .MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actIndentSnippet .MenuEntry\n                        actOutdentSnippet.MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actFindDefinition.MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actGetFsCode     .MenuEntry\n                    ]     \n            )      \n        MenuEntry.New(\"Run\")     \n            .SubMenu(     \n                    [     \n                        actEvalCode      .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actRunWSNewTab   .MenuEntry\n                        actRunWSHere     .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actParseCode     .MenuEntry\n                        actCompileWS     .MenuEntry\n                    ]\n            ) \n      ]\n\nlet menuRight =\n    Menu.New2\n      [\n        MenuEntry.New(\"About\")\n            .SubMenu [\n                MenuEntry.New(\"Source @ GitHub\", \"https://github.com/amieres/FSharpStation\").Target \"_blank\"\n            ]\n      ]      \n\nlet menuBar =\n    navbar <| h1 [ htmlText \"F# Station\" ; style \"font-size: 48px; margin-top: -17px\" ]\n           <| menuLeft .Render \n           <| menuRight.Render\n           \n()           ","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"3f2ec5e2-8ab6-4e5b-bb89-1943ed3a4964"},{"$":0,"Item":"60191ea0-da20-4fbf-96b8-3871338a66d8"},{"$":0,"Item":"47f7c0ba-35b0-466e-a759-4e4d9963e524"},{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"}],"id":{"$":0,"Item":"70bc3916-4714-4ee1-a2d0-d3917eeadf9d"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Properties","content":"//let setProp k v = props.[k] <- v\n\nlet redraw = Var.Create ()\nlet setDirtyP () = dirty.Value <- true\n\nlet tableProps =\n  currentCodeSnippetId\n  |> Val.bind (curSnippetPrpsOf >> DynamicV)\n  |> Val.map2 (fun () (props: Dictionary<string,string>) ->\n      table [\n        yield thead [\n            th [ htmlText \"Property\" ; style \"padding-right:10px\" ] \n            th [ htmlText \"Value\"                                 ] \n        ] \n        yield! \n            props.Keys\n            |> Seq.map (fun kvp ->\n                let prop = Property(setDirtyP, props, kvp)\n                tr [\n                    td [ Doc.Input     [                             ] prop.KeyVar   |> someElt ] \n                    td [ Doc.InputArea [ atr \"style\" \"height: 1.5em\" ] prop.ValueVar |> someElt ] \n                    td [ title \"remove\" ; style \" cursor: pointer \"\n                         htmlText \"x\" ; SomeAttr <| on.click (fun _ _ ->  prop.Remove()                    ; redraw.Value <- () ) ] |> hoverable\n                ])\n        yield tr [\n            td [ htmlText \"Add...\"    ; SomeAttr <| on.click (fun _ _ ->  props.Add(\"\", \"1\") ; setDirtyP() ; redraw.Value <- () ) ] |> hoverable\n            td [ htmlText \"\"    ] \n        ]\n      ]\n  ) redraw\n\nlet properties =\n    div [\n      HtmlElementV tableProps\n      css \"\"\" td.hovering { background: gray; } \"\"\"\n    ]\n\n()","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"70bc3916-4714-4ee1-a2d0-d3917eeadf9d"}],"id":{"$":0,"Item":"7cdba50e-5de9-4377-a7fc-705df0d909fa"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CodeEditorGrid","content":"let spl1         = Template.SplitterBar.New(20.0).Children([ style \"grid-row: 2 / 4\" ])\nstoreVarCodeEditor \"splitterV1\" spl1.Var\n//storeVarCodeEditor \"splitterV2\" splitterV2.Var\n//storeVarCodeEditor \"splitterH3\" splitterH3.Var\n\nlet jumpToRef (e:obj) _ = \n    let v : string = e?value |> unbox\n    let s : int    = e?selectionStart |> unbox\n    let lines = v.Split '\\n'\n    lines \n    |> Seq.mapFold (fun total line -> (line, total, total + line.Length + 1), total + line.Length + 1) 0 \n    |> fst\n    |> Seq.pick (fun (line, from, to_) -> if s >= from && s < to_ then Some line else None)\n    |> jumpToLine\n\nlet Messages =\n    [\n     \"Output\"    , Template.TextArea.New(outputMsgs).Placeholder(\"Output:\"         ).Title(\"Output\"                   ).RenderWith [ on.dblClick jumpToRef ]\n     \"Parser\"    , Template.TextArea.New(parserMsgs).Placeholder(\"Parser messages:\").Title(\"Parser\"                   ).RenderWith [ on.dblClick jumpToRef ]\n     \"JavaScript\", Template.TextArea.New(codeJS    ).Placeholder(\"Javascript:\"     ).Title(\"JavaScript code generated\").Render\n     \"F# code\"   , Template.TextArea.New(codeFS    ).Placeholder(\"F# code:\"        ).Title(\"F# code assembled\"        ).Render\n     \"WS Result\" , div [ div [ Id \"TestNode\" ; style \"background: white; height: 100%; width: 100%; \"] ]\n    ]\n    \n(*\nlet CodeEditor() =\n  Template.Grid.New\n     .ColVariable(spl1)\n     .ColAuto(     0.0)\n     .ColVariable( 0.0).Min(0.0).Max(Val.map ((-) 92.0) spl1.GetValue).Before.Children([ style \"grid-row   : 1 / 5\" ])\n     .RowFixedPx( 34.0) \n     .RowAuto(     0.0)\n     .RowVariable(17.0)                                               .Before.Children([ style \"grid-column: 2 / 3\" ])\n     .RowFixedPx( 80.0)\n     .Padding(1.0)\n     .Content(\"sidebar\", \n         codeSnippets.View\n         |> View.SnapshotOn codeSnippets.Value refresh.View\n         |> bindHElem listEntries\n      )\n     .Content(\"header\"  , Template.Input     .New(Val.bindIRef curSnippetNameOf currentCodeSnippetId).Prefix(htmlText \"name:\")         .Render)\n     .Content(\"content1\", codeMirror                                                                                                   .Render)\n     .Content(\"content2\", Template.TabStrip  .New(Messages).Top                                                                        .Render)\n     .Content(\"footer\"  ,       \n        div [ \n              actAddSnippet    .Button.Render\n              actOutdentSnippet.Button.Render\n              actIndentSnippet .Button.Render\n              loadFileElement.Render.AddChildren([ style \"grid-column: 4/6\" ])\n              actParseCode     .Button.Render\n              actEvalCode      .Button.Render\n              actGetFsCode     .Button.Render\n       \n              actDeleteSnippet .Button.Render\n              span []       \n              span []       \n              actSaveFile      .Button.Render\n              span []\n              actCompileWS     .Button.Render\n              actRunWSIn       .Button.Render\n              Doc.Select [ attr.id \"Position\" ] positionTxt [ Below ; Right ; NewBrowser ] position |> someElt\n              style \"\"\"\n                  overflow: hidden;\n                  display: grid;\n                  grid-template-columns: repeat(8, 12.1%);\n                  bxackground-color: #eee;\n                  padding : 5px;\n                  grid-gap: 5px;\n              \"\"\"\n            ]\n        )\n     .Content( script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                                     ; ``type`` \"text/javascript\"             ] )\n     .Content( script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ] )\n     .Content( script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ] )\n     .Content( link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ] )\n     .Content( link   [ href \"/EPFileX/css/main.css\"                                               ; ``type`` \"text/css\" ; rel \"stylesheet\" ] )\n     .Content( css styleEditor                                                                                                                )\n     .Render\n     .Style(\"\"\" \n            grid-template-areas:\n                'header0 header   sidebar2'\n                'sidebar content1 sidebar2'\n                'sidebar content2 sidebar2'\n                'footer  footer   sidebar2';\n            color      : #333;\n            height     : 100%;\n            font-size  : small;\n            font-family: monospace;\n            line-height: 1.2;\n                \"\"\")\n\n*)\n()","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"aeb92943-97ea-4297-9097-926410e9d10f"},{"$":0,"Item":"e702bf50-ad01-45eb-8b7b-813cc9046bef"},{"$":0,"Item":"70bc3916-4714-4ee1-a2d0-d3917eeadf9d"},{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"},{"$":0,"Item":"cddabd38-7ecb-4692-99bd-13ca70e4232f"},{"$":0,"Item":"47f7c0ba-35b0-466e-a759-4e4d9963e524"},{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"93f32df7-da8b-472f-8bad-e82cc58ec52b"},{"$":0,"Item":"60191ea0-da20-4fbf-96b8-3871338a66d8"},{"$":0,"Item":"b417f7b1-5e53-4c51-a23f-6f2c8c5a77b7"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"id":{"$":0,"Item":"75c3d033-99b5-409f-8ecb-cd9bd8b101ab"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"MainForm","content":"let snippetList = \n    codeSnippets.View\n       |> View.SnapshotOn codeSnippets.Value refresh.View\n       |> bindHElem listEntries\n       \nlet inline fixedHorSplitter1 px ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", renderSplitterNode ch1)\n                       .Content(\"two\", renderSplitterNode ch2).Padding(0.0)\n    grid.RowFixedPx(px).RowAuto(50.0).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\nlet inline fixedHorSplitter2 px ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", renderSplitterNode ch1)\n                       .Content(\"two\", renderSplitterNode ch2).Padding(0.0)\n    grid.RowAuto(50.0).RowFixedPx(px).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\nlet title          = SHtmlNode <| Template.Input.New(Val.bindIRef curSnippetNameOf currentCodeSnippetId).Prefix(htmlText \"name:\").Render\nlet messagesT      = STabStrip <| TabStrip.New([]      ).Bottom\nlet messagesB      = STabStrip <| TabStrip.New(Messages).Top\nlet messagesL      = STabStrip <| TabStrip.New([]      ).Top   .Vertical\nlet messagesR      = STabStrip <| TabStrip.New([ \"Properties\", properties ]).Top   .Vertical\nlet code           = SHtmlNode <| codeMirrorRender\nlet snippets       = SHtmlNode <| snippetList\nlet buttons        = SHtmlNode <| buttonsH\nlet menu           = SHtmlNode <| menuBar\n\nlet inline fixedHorSplitter first            px  ch1 ch2 = Grid.NewBisect(first, StFixedPx , false, px , renderSplitterNode ch1, renderSplitterNode ch2)                  .Render\nlet inline split (min:float) (max:float) ver per ch1 ch2 = Grid.NewBisect(true , StVariable, ver  , per, renderSplitterNode ch1, renderSplitterNode ch2).Min(min).Max(max).Render\n\nlet title_code     = SplitterStructure.New(       title         , code          , fixedHorSplitter true  34.0)\nlet code_buttons   = SplitterStructure.New(       title_code    , buttons       , fixedHorSplitter false 80.0)\nlet snippets_code  = SplitterStructure.New(true , snippets      , code_buttons  ,                        15.0)\nlet main_messagesB = SplitterStructure.New(       snippets_code , messagesB     , split 30. 100. false   82.0)\nlet main_messagesT = SplitterStructure.New(       messagesT     , main_messagesB, split  0.  75. false    0.0)\nlet main_messagesR = SplitterStructure.New(       main_messagesT, messagesR     , split 25. 100. true    92.0)\nlet main_messagesL = SplitterStructure.New(       messagesL     , main_messagesR, split  0.  75. true     0.0)\nlet main_window    = SplitterStructure.New(       menu          , main_messagesL, fixedHorSplitter true  50.0)\n\n//let code_messages = SplitterStructure.New(false, title_Code           , STabStrip messages,                   75.0)\n//let main_Buttons  = SplitterStructure.New(       snippets_code        , SHtmlNode buttons                 , fixedHorSplitter2 80.0)\n\nlet rootSplitter = SplitterNode.New(main_window)\n\nVal.sink (fun _ -> rootSplitter.SelectTab \"Output\"    |> ignore ) outputMsgs \nVal.sink (fun _ -> rootSplitter.SelectTab \"Parser\"    |> ignore ) parserMsgs \nVal.sink (fun _ -> rootSplitter.SelectTab \"WS Result\" |> ignore ) triggerWSResult \n\ndiv [\n    style \"height: 100vh; width: 100% \"\n    rootSplitter.Render.Style(\"height: 100%; width: 100% \")\n    script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                                     ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ]\n    link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    link   [ href \"/EPFileX/css/main.css\"                                               ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    css styleEditor                                                                                                               \n    style  \"\"\" \n          color      : #333;\n          font-size  : small;\n          font-family: monospace;\n          line-height: 1.2;\n              \"\"\"\n    link   [ href propertyThemeLinkVal                                                  ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    link   [ href propertyCssLinkVal                                                    ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    css propertyCssVal\n] |> renderDoc \n\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"7cdba50e-5de9-4377-a7fc-705df0d909fa"},{"$":0,"Item":"75c3d033-99b5-409f-8ecb-cd9bd8b101ab"},{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},{"$":0,"Item":"95ca1e9f-4029-4fc1-8b1c-ab12db71c90b"},{"$":0,"Item":"a48d72fc-5220-4dac-b3b3-98bad48b0561"}],"id":{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"CodeEditor (old not used)","content":"let splitterMain1 =\n    Template.SplitterBar.New( 0.0).Vertical(directionVertical).Min( 0.0).Max(35.0)\n\nlet splitterMain2 =\n    Template.SplitterBar.New(24.0).Vertical(directionVertical).Min( 0.5).Max(Val.map (fun pos -> if pos = NewBrowser then 0.1 else 50.0) position).Before\n\nstoreVarCodeEditor \"splitterMain1\" splitterMain1.Var\nstoreVarCodeEditor \"splitterMain2\" splitterMain2.Var\n\n//RunCode.RunNode(\"CodeEditor\").AddBootstrap.RunHtml <| CodeEditor()\n//addNodeById \"pageStyle\"                            <| styleH [ htmlText pageStyle ]\n//addNodeById \"splitterMain1\"                        <| splitterMain1.Render\n//addNodeById \"splitterMain2\"                        <| splitterMain2.Render\n\nlet grid = \n    Template.Grid.New\n       .Padding(0.0)\n       .Content(\"editor\", CodeEditor())\n       .Content(style    \"height: 100vh; margin: 0px; \")\n       .Content(css \"\"\"\n           #CodeEditor              { grid-area: editor  ; overflow: hidden; }\n           #TestNode                { grid-area: testNode; overflow: auto  ; }\n           body > div:first-of-type { grid-area: header  ; overflow: hidden; }\n       \"\"\")\n\ndirectionVertical\n|> Val.map (fun dir ->\n    (if dir\n     then grid.ColVariable(splitterMain1).ColAuto(16.0).ColVariable(splitterMain2).Content(style \"\"\" grid-template-areas: 'header   editor   testNode'; \"\"\")\n     else grid.RowVariable(splitterMain1).RowAuto(16.0).RowVariable(splitterMain2).Content(style \"\"\" grid-template-areas: 'header' 'editor' 'testNode'; \"\"\")\n    ).GridTemplate())\n|> bindHElem body\n|> renderDoc\n|> Doc.RunReplace JS.Document.Body\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"75c3d033-99b5-409f-8ecb-cd9bd8b101ab"},{"$":0,"Item":"95ca1e9f-4029-4fc1-8b1c-ab12db71c90b"},{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},{"$":0,"Item":"456562f7-0757-4431-9aeb-d58b050cecf7"}],"id":{"$":0,"Item":"07f11803-2084-4a0a-9066-a43fd11be1c7"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Editor2","content":"// Version using ZafirTranspiler.dll & Remote.dll\n[< JavaScript >]\nlet Main = FSharpStationClient() |> Doc.Run JS.Document.Body\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"8fbd59ac-9417-4309-8d01-3ccd5d62452c"},{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"}],"id":{"$":0,"Item":"8d84a97a-8fbf-4ee6-81c3-cf70db4adfa4"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Site","content":"// Version using internal Rpc's\n#define FSS_SERVER\n//#define NOMESSAGING\n\nopen WebSharper.Sitelets\nopen WebSharper.UI.Next.Server\nopen WebSharper.UI.Next\n\ntype EndPoint = \n    | [< EndPoint \"/\" >] EPStart\n    | EPLoad of string\n    | FSharpStation\n\nlet FSharpStationPage uri =\n    Content.Page(\n        Title = \"F# Station\"\n      , Head  = [ Html.scriptAttr [ attr.``type`` \"text/javascript\"; attr.src \"https://code.jquery.com/jquery-3.1.1.min.js\"] [] \n                  Html.scriptAttr [ attr.``type`` \"text/javascript\"; attr.src \"/EPFileX/CIPHERSpaceLoadFiles.js\"           ] [] \n                ]\n      , Body  = [ Html.client <@  FSharpStationClient uri @> ])\n\nlet content (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n    printfn \"%A\" endpoint\n    match endpoint with\n    | FSharpStation -> FSharpStationPage \"\"\n    | EPStart       -> FSharpStationPage \"https://raw.githubusercontent.com/amieres/FSharpStation/master/Start.fsjson\"\n    | EPLoad    uri -> uri |> System.Web.HttpUtility.UrlDecode |> System.Web.HttpUtility.UrlDecode |> FSharpStationPage\n\nlet site = Application.MultiPage content\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"},{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"}],"id":{"$":0,"Item":"b9ca9697-6cb4-4085-b509-9f702a62086f"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"FSharpStation","content":"#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net45\\Microsoft.Owin.Hosting.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net45\\Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net45\\Microsoft.Owin.StaticFiles.dll\"\n#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net45\\Microsoft.Owin.FileSystems.dll\"\n#r @\"..\\packages\\Zafir.Owin\\lib\\net45\\WebSharper.Owin.dll\"\n#r @\"..\\packages\\Zafir.Owin\\lib\\net45\\HttpMultipartParser.dll\"\n//#r @\"WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n\nopen global.Owin\nopen Microsoft.Owin.Hosting\nopen Microsoft.Owin.StaticFiles\nopen Microsoft.Owin.StaticFiles.ContentTypes\nopen Microsoft.Owin.FileSystems\nopen WebSharper.Owin\n\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://localhost\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://*\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"file://\"\nWebSharper.Web.Remoting.DisableCsrfProtection()\n\n[< EntryPoint >]\nlet Main args =\n    let rootDirectory, url =\n        match args with\n        | [| rootDirectory; url |] -> rootDirectory, url\n        | [| url                |] -> \"website\"    , url\n        | [|                    |] -> \"website\"    , \"http://localhost:9010/\"\n        | _ -> eprintfn \"Usage: WebServer3 ROOT_DIRECTORY URL\"; exit 1\n    let provider = FileExtensionContentTypeProvider()\n    provider.Mappings.[\".fsjson\"] <- \"application/x-fsjson\"\n    use server = \n        WebApp.Start(url, fun appB ->\n            appB.UseWebSharper( WebSharperOptions(ServerRootDirectory  = rootDirectory\n                                                , Sitelet              = Some site\n                                                , BinDirectory         = \".\"\n                                                , Debug                = true))\n                .UseStaticFiles(StaticFileOptions(FileSystem           = PhysicalFileSystem(rootDirectory)\n                                                , ContentTypeProvider  = provider ))\n                            |> ignore\n            let listener = appB.Properties.[\"Microsoft.Owin.Host.HttpListener.OwinHttpListener\"] |> unbox<Microsoft.Owin.Host.HttpListener.OwinHttpListener>\n            listener.SetRequestProcessingLimits(1000, 1000)\n            let maxA : int ref = ref 0\n            let maxB : int ref = ref 0\n            listener.GetRequestProcessingLimits(maxA, maxB)\n            printfn \"Accepts: %d Requests:%d\" !maxA !maxB\n        )\n    stdout.WriteLine(\"Serving {0}\", url)\n    stdin.ReadLine() |> ignore\n    0\n    ","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"95a237c8-a9ff-40d1-bd72-bd298b20af8c"},{"$":0,"Item":"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"},{"$":0,"Item":"b9ca9697-6cb4-4085-b509-9f702a62086f"},{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"}],"id":{"$":0,"Item":"0dbfcc9d-8ea2-42a3-8f81-ce2bf7d0fad4"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Invoke FSharpStation","content":"\n[< JavaScript >]\nlet fss =\n    FSharpStationClient \"Start.fsjson\"\n    |> RunCode.RunNode().AddBootstrap.RunDoc\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"}],"id":{"$":0,"Item":"c165e3de-7838-42a4-a7ec-2b2f8e5b69c6"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableWebSharper":"0"}},{"name":"compile & run FSharpStation","content":"#define FSS_SERVER\n\nopen System.IO\nopen FsStationShared\nopen Useful\nopen UsefulDotNet\nopen CompOptionsModule\n\nWrap.wrapper {\n    let  options   = compileOptionsExeDebug \"FSSGlobal/WebSharper Code/FSharpStation Code/FSharpStation\"\n                     + opDirectory    /= @\"Compiled\\FSharpStation2\"\n                     + siteOptions\n                     + (opGenInternal /= \"showoptions\")\n    let  exeFile   = options?Output\n    let  site      = Path.GetFullPath(options?Website)\n    let! res       = FsStationClient(\"Compile WebSharper\").CompileSnippetW options\n    do   printfn     \"%s\"              res\n    do   printfn     \"Starting %s\"     exeFile\n    let  url       = @\"http://localhost:9020\"\n    let  parms     = sprintf \"%A %A\" site url \n    do   runProcess  exeFile parms |> ignore\n    do   runProcess  url     \"\"    |> ignore\n} |> Wrap.runSynchronouslyS true |> printfn \"%s\"\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"56e5bc09-e528-49cc-9d42-6359b32a0cc9"}],"id":{"$":0,"Item":"5e8209e0-9203-4fe0-8289-fb4579b24038"},"expanded":true,"level":0,"levelCode":0,"properties":{"Theme":"rubyblue","DisableFSI":"0"}},{"name":"WebSharper Snippets1","content":"[< JavaScript >]\nmodule Snippets =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"456562f7-0757-4431-9aeb-d58b050cecf7"},{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"}],"id":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"Demo Button","content":"\nTemplate.Button\n   .New(    \"Press me!\"                         )\n   .OnClick(fun _ _ -> JS.Alert \"Button pressed\")\n   .Style(  \"font-size: 48px\"                   )\n   .Render\n|> RunCode.RunNode(\"HEllo\").RunHtml//PlusFree\n   \n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}],"id":{"$":0,"Item":"0a1fa320-b731-473a-93e2-dae49cc296f7"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Demo Input","content":"let inp = Template.Input.New(\"Type something...\")\n\nlet inline show3Sizes txt styleP =\n    div [\n      style styleP\n      htmlText txt\n      h2 [ htmlText txt ]\n      h1 [ htmlText <| Val.map (fun (s: string) -> s.ToUpper()) txt ]\n    ]\n    \ndiv [\n  inp.Render\n  show3Sizes inp.Var \"\"\n]    \n|> RunCode.RunNode().RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"f3a7ead2-49e1-4ff4-b96e-6fe699a1c8a9"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Demo TextArea","content":"let inp = Template.TextArea.New(\"Type Something...\").Placeholder(\"Output:\"    ).Title(\"Output\"                   )\n\nlet inline h1 ch = htmlElement \"h1\" ch\n\nlet text = htmlText inp.Var\n\nh3 [\n  inp.RenderWith [ on.dblClick (fun e m -> \n      let v : string = e?value |> unbox\n      let s : int    = e?selectionStart |> unbox\n      let lines = v.Split '\\n'\n      lines \n      |> Seq.mapFold (fun total line -> (line, total, total + line.Length + 1), total + line.Length + 1) 0 \n      |> fst\n      |> Seq.pick (fun (line, from, to_) -> if s >= from && s < to_ then Some line else None)\n      |> JS.Alert\n      ) ]\n  text\n  htmlElement \"h2\" [ text ]\n  h1 [ text ]\n  htmlElement \"menu\" // does not work anymore. support for this was dropped by Chrome\n      [ ``type`` \"context\"\n        Id       \"right-menu\"\n        htmlElement \"menuitem\" [ htmlAttribute \"label\" \"Goto Definition\" ; SomeAttr <| on.click (fun _ _ -> JS.Alert \"Goto Definition\")  ] \n      ]\n  htmlAttribute \"contextmenu\" \"right-menu\"\n]\n|> RunCode.RunNode().RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}],"id":{"$":0,"Item":"87770aad-e1d9-4fcb-be12-ff3c4ce58b7b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Demo CodeMirror","content":"open FSAutoComplete\nopen Template\nopen Useful\n\nlet  file               = @\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\bin\\Test.fsx\"\nlet  autoCompleteClient = FSAutoCompleteClient(\"Demo Code\")\n\ntype KeyMapAutoComplete = { \n    F2             : CodeMirrorEditor -> unit \n    ``Ctrl-Space`` : CodeMirrorEditor -> unit\n}\n\n[< Inline \"$editor.setOption('extraKeys', { 'F2': function(cm) { var pos = cm.getCursor(); $f(pos) } })\" >]\nlet addMiddleClick (f: CodeMirrorPos -> unit) (editor:CodeMirrorEditor) = ()\n\nlet showToolTip (ed:CodeMirrorEditor) =\n    printfn \"showToolTip\"\n    async {\n        let  pos = ed.GetCursor()\n        let! tip = autoCompleteClient.ToolTip(file, pos.line + 1, pos.ch + 1)\n        do   JS.Alert tip\n    } |> Async.Start\n\nlet getHints (ed:Template.CodeMirrorEditor, cb, _) =\n    async {\n        let  pos    = ed.GetCursor()\n        let  l      = ed.GetLine pos.line\n        let  word   = match l.Substring(0, pos.ch) with\n                      | REGEX @\"([a-zA-Z_]\\w*)$\" \"g\" [| txt |] -> txt\n                      | _                                      -> \"\"          \n        let! res    = autoCompleteClient.Parse   (file, ed.GetValue()           )\n        let! com    = autoCompleteClient.Complete(file, pos.line + 1, pos.ch + 1)\n        cb { list   = com |> Array.map (fun (dis, rep, cls, chr) -> \n                            { text        = rep\n                              displayText = chr + \"| \" + dis\n                              className   = cls                              \n                            })\n             from   = { pos with ch = pos.ch - word.Length }\n             ``to`` = pos \n           }\n    } |> Async.Start\n\nlet rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\"\"\"\nlet rex2 = \"\"\"(Err|Warning)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) ?)?F?#? ?(.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\nlet rex = rex1 + \"|\" + rex2\n\nlet getAnnotations (txt, cb, _, ed:Template.CodeMirrorEditor) =\n    async {\n        let! res    = autoCompleteClient.Parse   (file, ed.GetValue()           )\n        match res with\n        | REGEX rex \"g\" m -> m\n        | _               -> [||]\n        |> Array.choose (fun v ->\n            match v with\n            | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, int fl, int fc - int indent    , int tl, int tc - int indent, sev, from , msg)\n            | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, int fl, int fc - int indent - 1, int fl, int fc - int indent, sev, \"fsi\", msg)\n            | _ -> None\n        )\n        |> Array.map (fun (file, fl, fc, tl, tc, sev, from, msg) ->\n            { message  = msg\n              severity = (if sev.ToUpper().StartsWith(\"ERR\") then \"error\" else \"warning\")\n              from     = cmPos(fl - 1, fc - 1) \n              ``to``   = cmPos(tl - 1, tc - 1)\n            }\n          )\n        |> cb\n    } |> Async.Start\n\nlet code = \n    Template.CodeMirror.New(\"let a = \\\"123\\\" |> Str\")\n       .OnRender(fun ed -> \n          ed.SetOption(\"gutter\", [| \"CodeMirror-lint-markers\" |])\n          ed.AddKeyMap({ F2             = showToolTip \n                         ``Ctrl-Space`` = showHints   ed getHints false\n                       })\n          setLint ed getAnnotations\n       )\n\ndiv [ \n      code.Render.AddChildren [ SomeAttr <| on.dblClick (fun _ _ -> JS.Alert \"HIHI\")  ]\n      Template.Button.New(\"Mark\").OnClick(fun _ _ -> \n          printfn \"Mark\"\n          code.editorO \n          |> Option.iter (fun ed -> \n              printfn \"inside\"\n              ed.MarkText (0,5) (0,12) \"Error\"   \"this is wrong!\"\n              ed.MarkText (0,0) (0, 3) \"Warning\" \"this is not so bad.Fix it now.\"\n            )\n      ).Render\n      Template.Button.New(\"Unmark\").OnClick(fun _ _ -> \n          printfn \"Unmark\"\n          code.editorO \n          |> Option.iter (fun ed -> \n              printfn \"inside\"\n              ed.RemoveMarks()\n            )\n      ).Render\n      Template.Button.New(\"Parse\").OnClick(fun _ _ -> \n          code.editorO \n          |> Option.iter (fun ed -> autoCompleteClient.Parse(file, ed.GetValue()) |> Async.map ignore |> Async.Start)\n      ).Render\n      css  \".Error   { text-decoration: underline; text-decoration-color: orange; text-decoration-style: wavy } \n            .Warning { text-decoration: underline; text-decoration-color: yellow                              } \"\n      h1 [ htmlText code.Var ]      \n      htmlElement \"menu\" \n          [ ``type`` \"context\"\n            Id       \"right-menu\"\n            htmlElement \"menuitem\" [ htmlAttribute \"label\" \"Goto Definition\" ; SomeAttr <| on.click (fun _ _ -> JS.Alert \"Goto Definition\")  ] \n          ]\n      htmlAttribute \"contextmenu\" \"right-menu\"\n]\n|> RunCode.RunNode().RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"08e9600a-804b-4aba-a262-85f22e0cc8de"},{"$":0,"Item":"18d8153d-422c-42f6-8266-9a9d854bd6a1"},{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},{"$":0,"Item":"a05dd36e-a15e-4394-8013-128e21e69574"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"id":{"$":0,"Item":"f2cc3e92-5e61-47b2-982b-40f5c5784e6a"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Demo SplitterBar","content":"let styleT   p =\n  sprintf \"\"\"\n.SplitterArea {\n    display: grid;\n    grid-template-columns: %f%% %f%%;\n    grid-template-areas:   \"left right\";\n    background-color: #41414d;\n    color: #444;\n    height: 50px;\n    width: 1000px;\n    grid-gap: 9px;\n    padding : 9px;\n}\n\n.SplitterArea > :nth-child(1){  grid-area: left  ; overflow: hidden; background-color: lightgreen; }\n.SplitterArea > :nth-child(2){  grid-area: right ; overflow: hidden; background-color: lightblue ; }\n\n.Splitter { \n    grid-column     :    2      ;\n    grid-row        :  1/2      ;\n    width           :    5px    ; \n    margin-left     :   -7px    ; \n    border          :    0px    ; \n    padding         :    0px    ;\n    cursor          : col-resize;\n  \tbackground-color: #eef      ; \n}   \"\"\"  (p * 0.99) (0.99 * (100.0 - p))\n\nlet min        = Template.Input.New(\"25.0\").Prefix(htmlText \"Min:  \")\nlet max        = Template.Input.New(\"75.0\").Prefix(htmlText \"Max:  \")\nlet value      = Template.Input.New(\"40.0\").Prefix(htmlText \"Value:\")\nlet splitter   = Template.SplitterBar.New(value.Var.Lens (fun s -> float s) (fun prev f -> sprintf \"%f\" <| (f * 10. |> Math.Round |> float ) / 10. ) )\n                     .Min(Val.map float min.Var)\n                     .Max(Val.map float max.Var)\n                     \n\nlet bar =\n    div [\n      ``class`` \"SplitterArea\"\n      div    [ htmlText <| Val.map (             sprintf \"LEFT  %f\")  splitter.GetValue ]\n      div    [ htmlText <| Val.map (((-)100.) >>(sprintf \"RIGHT %f\")) splitter.GetValue ]\n      styleH [ htmlText <| Val.map styleT                             splitter.GetValue ]\n      splitter.Render\n    ]\n    \ndiv [\n  bar\n  min  .Render\n  max  .Render\n  value.Render\n]\n|> RunCode.RunNode().AddBootstrap.RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"id":{"$":0,"Item":"0aa90429-4e7c-42eb-b108-3dd70e710bf1"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Demo Grid","content":"open Template\n        \nlet sc1 = SplitterBar.New(30.0)\nlet sr1 = SplitterBar.New(30.0).Horizontal()\n\nlet inline content1 v     (g: Grid) = g.Content(v   )\nlet inline content2 (a,b) (g: Grid) = g.Content(a, b)\nlet inline render         (g: Grid)         = g.Render\n\nlet inline fixedHorSplitter1 px ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", ch1)\n                       .Content(\"two\", ch2).Padding(0.0)\n    grid.RowFixedPx(px).RowAuto(50.0).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\nlet inline fixedHorSplitter2 px ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", ch1)\n                       .Content(\"two\", ch2).Padding(0.0)\n    grid.RowAuto(50.0).RowFixedPx(px).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\nlet div22 =\n        fixedHorSplitter2 80.0    \n            <| (fixedHorSplitter1 34.0 \n                <| div [ htmlText \"Fixed34px\" ; style \"background-color: lightblue\"  ]\n                <| div [ htmlText \"Variable \" ; style \"background-color: lightgreen\" ])\n            <| div [ htmlText \"Fixed80px\" ; style \"background-color: magenta\"    ]\n\nlet grid =\n  Grid.New\n    .ColFixed(8.0).ColVariable(sc1).ColAuto(16.0).ColVariable(50.0).Before.Max(Val.map ((-) 84.0) sc1.GetValue)\n    .RowFixed(8.0).RowVariable(sr1).RowAuto(16.0).RowVariable(50.0).Before.Max(Val.map ((-) 84.0) sr1.GetValue)\n    .Content(         div [ htmlText \"Div11\" ; style \"background-color: lightblue\"  ])\n    .Content(\"1 / 2\", div [ htmlText \"Div12\" ; style \"background-color: lightgreen\" ])\n    .Content(\"1 / 3\", div [ htmlText \"Div13\" ; style \"background-color: pink\"       ])\n    .Content(\"1 / 4\", div [ htmlText \"Div14\" ; style \"background-color: magenta\"    ])\n    .Content(\"2 / 1\", div [ htmlText \"Div21\" ; style \"background-color: lightblue\"  ])\n    .Content(\"2 / 2\", div22                                                          )\n    .Content(\"3 / 3\", div [ htmlText \"Div33\" ; style \"background-color: pink\"       ])\n    .Content(\"4 / 4\", div [ htmlText \"Div44\" ; style \"background-color: magenta\"    ])\n\ngrid.Render\n|> fun el -> el.AddChildren [ style \"height: 600px\" ]\n|> RunCode.RunNode().ShowHtmlResult\n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"},{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"id":{"$":0,"Item":"9682eb8f-e1de-4d7c-adca-a5e2322558c2"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"F# Station Layout1","content":"printfn \"F# Station Layout\"\nopen Template\n        \nlet output = Var.Create \"HEre\"        \n\nlet mutable x: obj =  0 :> obj\n\nlet codeMirror = \n    Template.CodeMirror.New(\"let a = \\\"123\\\" |> Str\").Style(\"height: 100%\").Render\n        .AddChildren [\n            SomeAttr <| on.afterRender(fun el   -> \n                JS.SetTimeout\n                    (fun () ->\n                        addResizeObserver(fun () ->\n                            let r = el.GetBoundingClientRect()\n                            output.Value <- sprintf \"%A\" (r.Width, r.Height) ) el\n                        printfn \"F# Station Layout\"\n                    )\n                    2000 |> ignore\n            )\n        ]\n\n\nlet Messages =\n    [\n     \"Output\"    , Template.TextArea.New( output     ).Placeholder(\"Output:\"    ).Title(\"Output\"                   ).RenderWith [ on.dblClick (fun _ _ -> JS.Alert \"DblClick\") ]\n     \"Errors\"    , Template.TextArea.New(\"parserMsgs\").Placeholder(\"Errors:\"    ).Title(\"Messages\"                 ).RenderWith [ on.dblClick (fun _ _ -> JS.Alert \"DblClick\") ]\n     \"JavaScript\", Template.TextArea.New(\"codeJS    \").Placeholder(\"Javascript:\").Title(\"JavaScript code generated\").Render\n     \"F# code\"   , Template.TextArea.New(\"codeFS    \").Placeholder(\"F# code:\"   ).Title(\"F# code assembled\"        ).Render\n     \"WS Result\" , div [ div [ Id \"TestNode\" ; style \"background: white; height: 100%; width: 100%; \"] ]\n    ]\n\nlet inline fixedHorSplitter first px ch1 ch2 = Grid.NewBisect(first, StFixedPx, false, px, renderSplitterNode ch1, renderSplitterNode ch2).Render\nlet inline split (min:float) (max:float) ver (per:float) ch1 ch2 = Grid.NewBisect(true, StVariable, ver, per, renderSplitterNode ch1, renderSplitterNode ch2).Min(min).Max(max).Render\n\nlet title          = SHtmlNode <| div [ htmlText \"Title\"    ; style \"background-color: lightblue\"  ]\nlet snippets       = SHtmlNode <| div [ htmlText \"Snippets\" ; style \"background-color: lightgreen\" ]\nlet buttons        = SHtmlNode <| div [ htmlText \"Buttons\"  ; style \"background-color: magenta\"    ]\nlet menu           = SHtmlNode <| div [ htmlText \"Menu\"     ; style \"background-color: lightgray\"  ]\nlet code           = SHtmlNode <| codeMirror\nlet messagesT      = STabStrip <| TabStrip.New([]      ).Bottom\nlet messagesB      = STabStrip <| TabStrip.New(Messages).Top\nlet messagesL      = STabStrip <| TabStrip.New([]      ).Top   .Vertical\nlet messagesR      = STabStrip <| TabStrip.New([]      ).Top   .Vertical\n\nlet title_code     = SplitterStructure.New(       title         , code          , fixedHorSplitter true  34.0)\nlet code_buttons   = SplitterStructure.New(       title_code    , buttons       , fixedHorSplitter false 80.0)\nlet snippets_code  = SplitterStructure.New(true , snippets      , code_buttons  ,                        15.0)\nlet main_messagesB = SplitterStructure.New(       snippets_code , messagesB     , split 30. 100. false   82.0)\nlet main_messagesT = SplitterStructure.New(       messagesT     , main_messagesB, split  0.  75. false    0.0)\nlet main_messagesR = SplitterStructure.New(       main_messagesT, messagesR     , split 25. 100. true    99.5)\nlet main_messagesL = SplitterStructure.New(       messagesL     , main_messagesR, split  0.  75. true     0.0)\nlet main_window    = SplitterStructure.New(       menu          , main_messagesL, fixedHorSplitter true  50.0)\n\n//let code_messages = SplitterStructure.New(false, title_Code           , STabStrip messages,                   75.0)\n//let main_Buttons  = SplitterStructure.New(       snippets_code        , SHtmlNode buttons                 , fixedHorSplitter2 80.0)\n\nlet rootSplitter = SplitterNode.New(main_window)\n\nlet styleEditor    =\n     \"\"\"\nbody { margin: 0px }     \n     \ndiv textarea {\nfont-family: monospace;\n}\n.code-editor-list-tile {\nwhite-space: nowrap; \nborder-style: solid none none;\nborder-color: white;\nborder-width: 1px;\nbackground-color: #D8D8D8;\ndisplay: flex;\n}\n.code-editor-list-text{\npadding: 1px 10px 1px 5px;\noverflow:hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;\nflex: 1;\n}\n\n.code-editor-list-tile.direct-predecessor {\nfont-weight: bold;\n}\n.code-editor-list-tile.indirect-predecessor {\ncolor: blue;\n}\n.code-editor-list-tile.selected {\nbackground-color: #77F;\ncolor: white;\n}\n.code-editor-list-tile.hovering {\nbackground: lightgray;\n}\n.code-editor-list-tile.hovering.selected {\nbackground:  blue;\n}\n.code-editor-list-tile>.predecessor {\nfont-weight: bold;\nborder-style: inset;\nborder-width: 1px;\ntext-align: center;\ncolor: transparent;\n}\n.code-editor-list-tile.direct-predecessor>.predecessor {\ncolor: blue;\n}\n\n.CodeMirror { height: 100%; }\n\n.node {\n    background-color:white; \n    width: 2ch; \n    color: #A03; \n    font-weight:bold; \n    text-align: center;\n    font-family: arial;\n}\n.Warning { text-decoration: underline lightblue } \n.Error   { text-decoration: underline red       } \n.body    { margin         : 0px                 }\n    \"\"\"\n\ndiv [\n    style \"height: 100vh; width: 100% \"\n    rootSplitter.Render.Style(\"height: 100%; width: 100% \")\n    script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                                     ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ]\n    link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    link   [ href \"/EPFileX/css/main.css\"                                               ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    css styleEditor                                                                                                               \n    style  \"\"\" \n          color      : #333;\n          font-size  : small;\n          font-family: monospace;\n          line-height: 1.2;\n              \"\"\"\n] \n|> renderDoc\n|> RunCode.RunNode().RunDoc\n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},{"$":0,"Item":"a48d72fc-5220-4dac-b3b3-98bad48b0561"}],"id":{"$":0,"Item":"a6148457-ad15-4de6-a038-af77ff4af675"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"F# Station Layout2","content":"printfn \"F# Station Layout\"\nopen Template\n\nlet actLoadFile       = Template.Action.New(\"Load...\"                    ).OnClick(Do id ()        )  \nlet actSaveFile       = Template.Action.New(\"Save as...\"                 ).OnClick(Do id ()        )//.Highlight(dirty)\nlet actAddSnippet     = Template.Action.New(\"Add Snippet\"                ).OnClick(Do id ()        )\nlet actDeleteSnippet  = Template.Action.New(\"Delete Snippet\"             ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actIndentSnippet  = Template.Action.New(\"Indent In  >>\"              ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actOutdentSnippet = Template.Action.New(\"Indent Out <<\"              ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actGetFsCode      = Template.Action.New(\"Get F# Code\"                ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actEvalCode       = Template.Action.New(\"Evaluate F#\"                ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actRunWSNewTab    = Template.Action.New(\"Run WebSharper in new tab\"  ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actRunWSHere      = Template.Action.New(\"Run WebSharper in WS Result\").OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actRunWSIn        = Template.Action.New(\"Run WebSharper in ...\"      ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actParseCode      = Template.Action.New(\"Parse F#\"                   ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actCompileWS      = Template.Action.New(\"Compile WebSharper\"         ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actFindDefinition = Template.Action.New(\"Find Definition\"            ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\n\nlet buttonsH =\n    div [ \n          actAddSnippet    .Button.Render\n          actOutdentSnippet.Button.Render\n          actIndentSnippet .Button.Render\n          span []       \n          span []       \n          actParseCode     .Button.Render\n          actEvalCode      .Button.Render\n          actGetFsCode     .Button.Render\n       \n          actDeleteSnippet .Button.Render\n          actFindDefinition.Button.Render\n          span []       \n          actSaveFile      .Button.Render\n          span []\n          actCompileWS     .Button.Render\n          actRunWSIn       .Button.Render\n          span []       \n          style \"\"\"\n              overflow: hidden;\n              display: grid;\n              grid-template-columns: repeat(8, 12.1%);\n              bxackground-color: #eee;\n              padding : 5px;\n              grid-gap: 5px;\n          \"\"\"\n        ]\n\nlet menuLeft =\n    Menu.New2\n      [\n        MenuEntry.New(\"File\")\n            .SubMenu(\n                    [\n                        actLoadFile.MenuEntry\n                        actSaveFile.MenuEntry\n                    ]           \n            )            \n        MenuEntry.New(\"Code\")           \n            .SubMenu(           \n                    [           \n                        actAddSnippet    .MenuEntry\n                        actDeleteSnippet .MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actIndentSnippet .MenuEntry\n                        actOutdentSnippet.MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actFindDefinition.MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actGetFsCode     .MenuEntry\n                    ]     \n            )      \n        MenuEntry.New(\"Run\")     \n            .SubMenu(     \n                    [     \n                        actEvalCode      .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actRunWSNewTab   .MenuEntry\n                        actRunWSHere     .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actParseCode     .MenuEntry\n                        actCompileWS     .MenuEntry\n                    ]\n            ) \n      ]\n\nlet menuRight =\n    Menu.New2\n      [\n        MenuEntry.New(\"About\")\n      ]      \n\nlet menuBar =\n    navbar <| h1 [ htmlText \"F# Station\" ; style \"font-size: 48px; margin-top: -17px\" ]\n           <| menuLeft .Render \n           <| menuRight.Render\n\nlet output = Var.Create \"HEre\"        \n\nlet mutable x: obj =  0 :> obj\n\nlet codeMirror = \n    Template.CodeMirror.New(\"let a = \\\"123\\\" |> Str\").Style(\"height: 100%\").Render\n        .AddChildren [\n            SomeAttr <| on.afterRender(fun el   -> \n                JS.SetTimeout\n                    (fun () ->\n                        addResizeObserver(fun () ->\n                            let r = el.GetBoundingClientRect()\n                            output.Value <- sprintf \"%A\" (r.Width, r.Height) ) el\n                        printfn \"F# Station Layout\"\n                    )\n                    2000 |> ignore\n            )\n        ]\n\n\nlet Messages =\n    [\n     \"Output\"    , Template.TextArea.New( output     ).Placeholder(\"Output:\"         ).Title(\"Output\"                   ).RenderWith [ on.dblClick (fun _ _ -> JS.Alert \"DblClick\") ]\n     \"Parser\"    , Template.TextArea.New(\"parserMsgs\").Placeholder(\"Parser Messages:\").Title(\"Parser Messages\"          ).RenderWith [ on.dblClick (fun _ _ -> JS.Alert \"DblClick\") ]\n     \"JavaScript\", Template.TextArea.New(\"codeJS    \").Placeholder(\"Javascript:\"     ).Title(\"JavaScript code generated\").Render\n     \"F# code\"   , Template.TextArea.New(\"codeFS    \").Placeholder(\"F# code:\"        ).Title(\"F# code assembled\"        ).Render\n     \"WS Result\" , div [ div [ Id \"TestNode\" ; style \"background: white; height: 100%; width: 100%; \"] ]\n    ]\n\nlet inline fixedHorSplitter first px ch1 ch2 = Grid.NewBisect(first, StFixedPx , false, px, ch1, ch2).Render\nlet inline varSplitter        ver pc ch1 ch2 = Grid.NewBisect(true , StVariable, ver  , pc, ch1, ch2).Render\n\nlet title         = div [ htmlText \"Title\"    ; style \"background-color: lightblue\"  ]\nlet snippets      = div [ htmlText \"Snippets\" ; style \"background-color: lightgreen\" ]\nlet buttons       = buttonsH\nlet menu          = menuBar\nlet code          = codeMirror\nlet messages      = TabStrip.New(Messages).Top.Render\n\nlet title_code    = fixedHorSplitter true  34.0 title         code\nlet code_buttons  = fixedHorSplitter false 80.0 title_code    buttons\nlet snippets_code = varSplitter      true  15.0 snippets      code_buttons                        \nlet main_messages = varSplitter      false 82.0 snippets_code messages                            \nlet main_window   = fixedHorSplitter true  50.0 menu          main_messages\n\n//let code_messages = SplitterStructure.New(false, title_Code           , STabStrip messages,                   75.0)\n//let main_Buttons  = SplitterStructure.New(       snippets_code        , SHtmlNode buttons                 , fixedHorSplitter2 80.0)\n\nlet rootSplitter = main_window\n\nlet styleEditor    =\n     \"\"\"\nbody { margin: 0px }     \n     \ndiv textarea {\nfont-family: monospace;\n}\n.code-editor-list-tile {\nwhite-space: nowrap; \nborder-style: solid none none;\nborder-color: white;\nborder-width: 1px;\nbackground-color: #D8D8D8;\ndisplay: flex;\n}\n.code-editor-list-text{\npadding: 1px 10px 1px 5px;\noverflow:hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;\nflex: 1;\n}\n\n.code-editor-list-tile.direct-predecessor {\nfont-weight: bold;\n}\n.code-editor-list-tile.indirect-predecessor {\ncolor: blue;\n}\n.code-editor-list-tile.selected {\nbackground-color: #77F;\ncolor: white;\n}\n.code-editor-list-tile.hovering {\nbackground: lightgray;\n}\n.code-editor-list-tile.hovering.selected {\nbackground:  blue;\n}\n.code-editor-list-tile>.predecessor {\nfont-weight: bold;\nborder-style: inset;\nborder-width: 1px;\ntext-align: center;\ncolor: transparent;\n}\n.code-editor-list-tile.direct-predecessor>.predecessor {\ncolor: blue;\n}\n\n.CodeMirror { height: 100%; }\n\n.node {\n    background-color:white; \n    width: 2ch; \n    color: #A03; \n    font-weight:bold; \n    text-align: center;\n    font-family: arial;\n}\n.Warning { text-decoration: underline lightblue } \n.Error   { text-decoration: underline red       } \n.body    { margin         : 0px                 }\n    \"\"\"\n\ndiv [\n    style \"height: 100vh; width: 100% \"\n    rootSplitter.Style(\"height: 100%; width: 100% \")\n    script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                                     ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ]\n    link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    link   [ href \"/EPFileX/css/main.css\"                                               ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    css styleEditor                                                                                                               \n    style  \"\"\" \n          color      : #333;\n          font-size  : small;\n          font-family: monospace;\n          line-height: 1.2;\n              \"\"\"\n] \n|> renderDoc\n|> RunCode.RunNode().RunDoc\n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"cddabd38-7ecb-4692-99bd-13ca70e4232f"},{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"}],"id":{"$":0,"Item":"a657ae67-b4ba-4249-a2f1-a4063843c9c6"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"let snippetName0 (content: string) =\n    content.Split([| '\\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n    |> Seq.map    (fun l -> l.Trim())\n    |> Seq.filter (fun l -> not (l.StartsWith(\"#\") || l.StartsWith(\"[<\")))\n    |> Seq.tryHead\n    |> Option.defaultValue \"<empty>\"\n\n[\n  \"\"\"#if INTERACTIVE\n  #I @\"../WebServer/bin\"\n  #else\n  namespace TestFS\n  #endif\n  #nowarn \"1182\"\n  \"\"\"    \n  |> snippetName0    \n  \"[< hjhj >]\n    let name = \n  \" \n  |> snippetName0\n]\n|> Seq.map (htmlText >> List.singleton >> li)\n|> ul\n|> RunCode.RunNode().ShowHtmlResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[],"id":{"$":0,"Item":"a54701f2-1d68-4997-a1ea-62deaeb73e1b"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Test mouse","content":"//Template.Button.New(\"Run JS\").Style(\"vertical-align:top\").OnClick(fun _ _ -> JS.Eval(\"alert('hello')\") |> ignore).Render\n//|> getStyle\n//|> sprintf \"%A\"\n//|> RunCode.RunNode().ShowResult\nlet panel1 res =\n    Template.Panel.New\n      .Title(Val.map (fun pressed -> if pressed then \"PRESSED\" else \"---\") Input.Mouse.MousePressed)\n      .Header([])\n      .Content([ h3 [ htmlText <| sprintf \"%A\" res ; style \"font-family:monospace;\"] ])\n      .Render\n\n\ndiv [ ``class`` \"container\"\n      panel1 <| 7 * 7\n      div [ ``class`` \"container\"\n            div [ ``class`` \"container\"\n                  panel1 <| 7 * 8\n\n                ]\n          ]\n    ]\n|> RunCode.RunNode().AddBootstrap.RunHtml\n     ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}],"id":{"$":0,"Item":"4dc58ba1-75d1-4c96-9641-235ee7d8c2c2"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"[1..10] |> Seq.take 5 |> Seq.toArray\n|> RunCode.RunNode().ShowResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[],"id":{"$":0,"Item":"74b8570e-dcd4-4dff-87a5-cd7ec96b8527"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"InputSelect","content":"module InputSelect = \n    type Position =\n        | Below\n        | Right\n        | Tab\n        | NewBrowser\n        \n    let positionTxt v =\n        match v with\n        | Below      -> \"Below\"\n        | Right      -> \"Right\"\n        | Tab        -> \"In Tab\"\n        | NewBrowser -> \"New Browser\" \n    \n    let position = Var.Create Below \n    \n    let inp = Template.Input.New(position.Lens positionTxt (fun prev s -> \n        match s with\n        | \"Below\"        -> Below     \n        | \"Right\"        -> Right     \n        | \"In Tab\"       -> Tab       \n        | \"New Browser\"  -> NewBrowser\n        | _              -> prev\n        ) )\n    \n    div [\n      inp.Render\n      Doc.Select [] positionTxt [ Below ; Right ; Tab ; NewBrowser ] position |> someElt\n    ]\n    |> RunCode.RunNode().RunHtml\n        ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"38b21610-7350-4676-993b-88fea844314f"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Regex Pattern matching","content":"module regex1 =\n    // from: https://github.com/intellifactory/websharper/blob/master/docs/ECMA-262.md\n    let str    = new String(\"Bob likes pineapples.\")\n    let regex  = new RegExp(@\"^\\w+\") // matches the first word\n    let newstr = str.Replace(regex,\"Alice\")\n    \n    let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n        if value = null then None else\n        try \n            match String(value).Match(RegExp(expr, opt)) with\n            | null         -> None\n            | [| |]        -> None\n            | m            -> Some m\n        with e -> None\n        \n    let duple a b = a, b\n    4 * 8\n    let txt = \"\"\"Compiling to JavaScript...\n    2 errors, 0 warnings\n    ErrFSharp\n      \"F# Regex Pattern matching (47,39) - (47,40) parse 10: Unexpected symbol '<' in expression\"\n    ErrFSharp\n      \"F# Regex Pattern matching (47,49) - (47,50) parse 514: End of file in string begun at or before here\" \n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"  \n    Evaluating F# code...\n    (6) F# 7k.fsx(1,7): error FS1156: This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).  \n    Compiling to JavaScript...\n    6 errors, 1 warnings\n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (120, 19) - (120, 46) Type not found in JavaScript compilation: System.Text.RegularExpressions.Regex\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 14) - (121, 23) Type not found in JavaScript compilation: System.Text.RegularExpressions.Group\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 67) - (121, 74) Type not found in JavaScript compilation: System.Text.RegularExpressions.Capture\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.Match\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Method name not found in JavaScript compilation: (EnumerateFromFunctions<_,_> : (unit -> 'T0) * ('T0 -> System.Boolean) * ('T0 -> 'T1) -> System.Collections.Generic.IEnumerable`1<'T1>), Members: safeDispose, EnumerateThenFinally, EnumerateUsing, EnumerateWhile, CreateEvent\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.GroupCollection\"\n    \"\"\"\n    let rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\\.\"\"\"\n    let rex2 = \"\"\"(Err|Warning|Info)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) ?)?F?#? ?(.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\n    //\"\n    let rex = rex1 + \"|\" + rex2\n    \n    //[ \"JavaScript RegExp:\"\n    //  sprintf \"String(%A).Match  %A: %A\" txt rex <| String(txt).Match rex\n    //  sprintf \"Active pattern: %A\" <|\n    //      match txt with\n    //      | REGEX rex m -> m\n    //      | _           -> \"<no match>\"\n    //]\n    //|> List.map  (fun t -> div [ htmlText t ] )\n    //|> fun lst -> List.Cons (style \"text-align: left\", lst)  // two different styles\n    //|> List.map  (htmlText >> List.singleton >> div )\n    //|> (duple (style \"text-align: left\") >> List.Cons) \n    //|> RunCode.RunNode().ShowHtmlResult\n    \n    let inp = Template.TextArea.New(txt)                            .Placeholder(\"Text\")\n    let rx  = Template.Input   .New(rex).Prefix(htmlText \"RegEx  :\").Placeholder(\"Regex: . \\d \\w \\s \\n \\r \\t \\f (|)[a-z]+*?{3,5}\")  \n    let opt = Template.Input   .New(\"g\").Prefix(htmlText \"Options:\").Placeholder(\"Options: g i m u y\") \n    \n    h5 [\n      inp.Render\n      rx .Render\n      opt.Render\n      Val.map3 (fun inp rx opt ->\n              ul [\n                  match inp with\n                  | REGEX rx opt m -> yield! m |> Array.map (htmlText >> List.singleton >> li)\n                  | _              -> yield  htmlText \"<no match>\" \n              ]\n          ) inp.Var rx.Var opt.Var\n          |> bindHElem id\n    ]\n    |> RunCode.RunNode().ShowHtmlResult\n    \n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n    //open System.Text.RegularExpressions\n    //\n    //let (|Regex|_|) pattern input =\n    //    let m = Regex.Match(input, pattern)\n    //    if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])\n    //    else None\n    //\n    ////Example:\n    //let phone = \"(555) 555-5555\"\n    //match phone with\n    //| Regex @\"\\(([0-9]{3})\\)[-. ]?([0-9]{3})[-. ]?([0-9]{4})\" [ area; prefix; suffix ] ->\n    //    printfn \"Area: %s, Prefix: %s, Suffix: %s\" area prefix suffix\n    //| _ -> printfn \"Not a phone number\"","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"7754c074-862e-4550-9d61-ea837adf6d85"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Regex Pattern matching2","content":"module regex2 =\n    let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n        if value = null then None else\n        try \n            match String(value).Match(RegExp(expr, opt)) with\n            | null         -> None\n            | [| |]        -> None\n            | m            -> Some m\n        with e -> None \n       \n    let txt = \"\"\"Compiling to JavaScript...\n    Compiling to JavaScript...\n    Compiled!\n    0 errors, 1 warnings\n    WarningFSharp\n      \"(6)47f7c0ba-35b0-466e-a759-4e4d9963e524 codeMirror (1,11) - (1,19) typecheck 1178: The struct, record or union type 'KeyMapF2' is not structurally comparable because the type 'obj' does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type 'KeyMapF2' to clarify that the type is not comparable\"\n      2 errors, 0 warnings\n    ErrFSharp\n      \"F# Regex Pattern matching (47,39) - (47,40) parse 10: Unexpected symbol '<' in expression\"\n    ErrFSharp\n      \"F# Regex Pattern matching (47,49) - (47,50) parse 514: End of file in string begun at or before here\" \n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"  \n    Evaluating F# code...\n    (6) F# 7k.fsx(1,7): error FS1156: This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).  \n    Compiling to JavaScript...\n    6 errors, 1 warnings\n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (120, 19) - (120, 46) Type not found in JavaScript compilation: System.Text.RegularExpressions.Regex\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 14) - (121, 23) Type not found in JavaScript compilation: System.Text.RegularExpressions.Group\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 67) - (121, 74) Type not found in JavaScript compilation: System.Text.RegularExpressions.Capture\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.Match\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Method name not found in JavaScript compilation: (EnumerateFromFunctions<_,_> : (unit -> 'T0) * ('T0 -> System.Boolean) * ('T0 -> 'T1) -> System.Collections.Generic.IEnumerable`1<'T1>), Members: safeDispose, EnumerateThenFinally, EnumerateUsing, EnumerateWhile, CreateEvent\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.GroupCollection\"\n    \"\"\"\n    let rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\\.\"\"\"\n    let rex2 = \"\"\"(Err|Warning)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) )?F# (.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\n    let rex = rex1 + \"|\" + rex2\n    \n    match txt with\n    | REGEX rex \"g\" m -> m\n    | _               -> [||]\n    |> Array.choose (fun v ->\n        match v with\n        | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, int fl, int fc - int indent, int tl, int tc - int indent, sev, from , msg)\n        | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, int fl, int fc - int indent, int fl, int fc - int indent, sev, \"fsi\", msg)\n        | _ -> None\n    )\n    |> Array.map (fun (file, fl, fc, tl, tc, sev, from, msg) -> sprintf \"%s (%d,%d)-(%d,%d) %s %s : %s\" file fl fc tl tc sev from msg)\n    |> Array.map (htmlText >> List.singleton >> List.append [ style \"text-align: left\" ] >> li)\n    |> h5\n    |> RunCode.RunNode().ShowHtmlResult\n    ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"ff6bfed0-83ae-4497-b197-fea6432aa958"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Load File","content":"let fileName = Var.Create \"\"\nlet justFileName (f:string) = f.Split [| '/' ; '\\\\' |] |> Seq.last\n\nTemplate.Input \n    .New(fileName.Lens justFileName (fun prev n -> prev) )\n    .Prefix(\n        label [ \n            ``class`` \"btn btn-primary\" \n            htmlText \"Browse...\" \n            Template.Input.New(fileName).Type(\"file\").Style(\"display: none\")\n              .Content([ on.change (fun el _ -> JS.Alert \"loading \" ) ]) \n              .Render \n        ])\n    .Render\n|> RunCode.RunNode().ShowHtmlResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"ee8fe0d0-14ad-4ae8-bd77-e0918817d67e"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Storage","content":"module Storage =\n    let min        = Template.Input.New(\"25.0\").Prefix(htmlText \"Min:  \")\n    let max        = Template.Input.New(\"75.0\").Prefix(htmlText \"Max:  \")\n    let value      = Template.Input.New(\"40.0\").Prefix(htmlText \"Value:\")\n    \n    let settingsStorage = JS.Window.LocalStorage\n    \n    settingsStorage.GetItem \"CodeEditor.min\"   |> fun v -> if v <> null then min  .Var.Value <- v\n    settingsStorage.GetItem \"CodeEditor.max\"   |> fun v -> if v <> null then max  .Var.Value <- v\n    settingsStorage.GetItem \"CodeEditor.value\" |> fun v -> if v <> null then value.Var.Value <- v\n    \n    Val.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.min\"  , v)) min  .Var\n    Val.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.max\"  , v)) max  .Var\n    Val.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.value\", v)) value.Var\n    \n    let styleT   p =\n      p |> sprintf \"\"\"\n    .SplitterArea {\n        display: grid;\n        grid-template-columns: %f%% auto;\n        grid-template-areas:   \"left right\";\n        background-color: #41414d;\n        color: #444;\n        height: 50px;\n        grid-gap: 9px;\n        padding : 9px;\n    }\n    \n    .SplitterArea > :nth-child(1){  grid-area: left  ; overflow: hidden; background-color: lightgreen; }\n    .SplitterArea > :nth-child(2){  grid-area: right ; overflow: hidden; background-color: lightblue ; }\n    \n    .Splitter { \n        grid-column     :    2      ;\n        grid-row        :  1/2      ;\n        width           :    5px    ; \n        margin-left     : -7.5px    ; \n        border          :    0px    ; \n        padding         :    0px    ;\n        cursor          : col-resize;\n      \tbackground-color: #eef      ; \n    }   \"\"\"\n    \n    let splitter   = Template.SplitterBar\n                         .New(value.Var.Lens (fun s -> float s) (fun prev f -> sprintf \"%f\" <| (f * 10. |> Math.Round |> float ) / 10. ) )\n                         .Min(Val.map float min.Var)\n                         .Max(Val.map float max.Var)\n                         \n    \n    let bar =\n        div [\n          ``class`` \"SplitterArea\"\n          div    [ htmlText <| Val.map (             sprintf \"LEFT  %f\")  splitter.GetValue ]\n          div    [ htmlText <| Val.map (((-)100.) >>(sprintf \"RIGHT %f\")) splitter.GetValue ]\n          styleH [ htmlText <| Val.map styleT                             splitter.GetValue ]\n          splitter.Render\n        ]\n        \n    div [\n      bar\n      min  .Render\n      max  .Render\n      value.Render\n    ]\n    |> RunCode.RunNode().AddBootstrap.RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"3d8bf6d2-a66b-4f18-aa83-8e74836e38e4"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Messaging Test","content":"//#r @\"remote.dll\"\n\n//open CIPHERPrototype.Messaging\nopen FsStationShared\nopen System\nopen Useful\n\nlet messageTypes = \n    [\n        GetSnippetContentById CodeSnippetId.New\n        GetSnippetCodeById    CodeSnippetId.New\n        GetSnippetPredsById   CodeSnippetId.New\n        GetSnippetById        CodeSnippetId.New\n        GetSnippetContent     [||]\n        GetSnippetPreds       [||]\n        GetSnippetCode        [||]\n        GetSnippetJSCode      [||]\n        GetSnippet            [||]\n        GenericMessage        \"\"\n        GetIdentification     \n        GetWholeFile\n    ]\n    \nlet messageTxt v =\n    match v with\n    | GetSnippetContentById _ -> \"GetSnippetContentById\"\n    | GetSnippetCodeById    _ -> \"GetSnippetCodeById   \"\n    | GetSnippetPredsById   _ -> \"GetSnippetCodeById   \"\n    | GetSnippetById        _ -> \"GetSnippetById       \"\n    | GetSnippetContent     _ -> \"GetSnippetContent    \"\n    | GetSnippetPreds       _ -> \"GetSnippetPreds      \"\n    | GetSnippetCode        _ -> \"GetSnippetCode       \"\n    | GetSnippetJSCode      _ -> \"GetSnippetJSCode     \" \n    | GetSnippet            _ -> \"GetSnippet           \"\n    | GenericMessage        _ -> \"GenericMessage       \"\n    | RunSnippetUrlJS       _ -> \"RunSnippetUrlJS      \"\n    | RunSnippetUrlJSById   _ -> \"RunSnippetUrlJSById  \"\n    | GetIdentification       -> \"GetIdentification    \"\n    | GetWholeFile            -> \"GetWholeFile         \"\n\nlet fsClient = FsStationClient(\"MessagingTest\")\n\nlet snpId       = Var.Create \"\" \nlet message     = Var.Create \"\"\nlet messageType = Var.Create GetIdentification\n\nlet listener  : Var<string option> = Var.Create None\nlet listeners : Var<string[]     > = Var.Create [||]\n\nlet getListeners _ _ =\n    async {\n        let! ls          = fsClient.MessagingClient.POListeners()\n        do   if listeners.Value <> ls then listeners.Value <- ls\n    } |> Async.Start\n\nlet requestMessage msgT (content:string) : Async<string> =\n    let msg =\n        match msgT with\n        | GetSnippetContentById _ -> GetSnippetContentById  <| CodeSnippetId (Guid content)\n        | GetSnippetCodeById    _ -> GetSnippetCodeById     <| CodeSnippetId (Guid content)\n        | GetSnippetPredsById   _ -> GetSnippetPredsById    <| CodeSnippetId (Guid content)\n        | GetSnippetById        _ -> GetSnippetById         <| CodeSnippetId (Guid content)\n        | RunSnippetUrlJSById   _ -> RunSnippetUrlJSById    <|(CodeSnippetId (Guid content), \"http://localhost:9000\")\n        | RunSnippetUrlJS       _ -> RunSnippetUrlJS        <|(content.Split '/'           , \"http://localhost:9000\")\n        | GetSnippetContent     _ -> GetSnippetContent      <| content.Split '/'\n        | GetSnippetPreds       _ -> GetSnippetPreds        <| content.Split '/'\n        | GetSnippetCode        _ -> GetSnippetCode         <| content.Split '/'\n        | GetSnippetJSCode      _ -> GetSnippetJSCode       <| content.Split '/'\n        | GetSnippet            _ -> GetSnippet             <| content.Split '/'\n        | GenericMessage        _ -> GenericMessage         <| content\n        | GetIdentification       -> GetIdentification    \n        | GetWholeFile            -> GetWholeFile         \n    async {\n        let! response = fsClient.SendMessage(AddressId(listener.Value |> Option.defaultValue \"WebServer:PostOffice\"), msg) |> Wrap.getAsync\n        let resp =\n            match response with\n            | SnippetResponse(Some snp )    -> snp  |> Json.Serialize\n            | SnippetsResponse     snps     -> snps |> Json.Serialize\n            | StringResponse (Some code)    -> code\n            | IdResponse      id            -> id\n            | _                             -> sprintf \"<Incomplete response: %A>\" response\n        return resp\n    }\n\ndiv [\n    Doc.SelectDynOptional [ on.click getListeners ] \"--\" id    (View.Map Seq.toList listeners.View) listener    |> someElt\n    Doc.Select            [ ] messageTxt messageTypes                         messageType |> someElt\n    Template.Input   .New(snpId  ).Render\n    Template.TextArea.New(message).Render\n    Template.Button.New(\"Send Message to Server\").OnClick(fun _ _ ->\n        async {\n          message.Value <- \"Sending request...\"\n          let! code = requestMessage messageType.Value snpId.Value\n          message.Value <- code\n          return ()\n        }  |> Async.Start\n      ).Render\n]    \n|> RunCode.RunNode().ShowHtmlResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}],"id":{"$":0,"Item":"e9c3ceaf-8fe5-4752-aa4c-2db6e1ac4577"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Json.Parse","content":"module JsonParse =\n    open Useful\n    open FsStationShared\n    //let provider = WebSharper.Json.Provider\n    let inp = Template.TextArea.New(\"[ { \\\"name\\\": \\\"Hello\\\" }, { \\\"name\\\": \\\"How are you?\\\" } ]\").Placeholder(\"Text\")\n    \n    let inline ifUndef def v = if isUndefined v then def else v\n    let obj2CodeSnippetId o = \n        if isUndefined o then\n            System.Guid(\"00000000-0000-0000-0000-000000000000\")\n        else\n            o?Item\n        |> CodeSnippetId \n    \n    let obj2CodeSnippetIdO o = // the json representation of an option is different from the internal representation\n        if isUndefined o then\n            None\n        else\n            Some <| obj2CodeSnippetId o\n    \n    let obj2Map o =\n        if isUndefined o then\n            Map.empty\n        else\n            JS.GetFields o |> Array.map (fun (f, v) -> f, v :?> string ) |> Map.ofSeq\n    \n    let deserializeCodeSnipets v = \n        try\n            let objs= WebSharper.Json.Parse v |> unbox<obj[]>\n            printfn \"%A\" <| Array.length objs\n            let snps =\n                objs\n                |> Array.choose (fun o ->\n                     if isUndefined o then None else\n                     {\n                        name         = o?name         |> ifUndef \"\"\n                        content      = o?content      |> ifUndef \"\"\n                        parent       = o?parent       |> obj2CodeSnippetIdO\n                        predecessors = o?predecessors |> ifUndef [||] |> Array.map  obj2CodeSnippetId |> Seq.toList\n                        id           = o?id           |> obj2CodeSnippetId\n                        expanded     = o?expanded     |> ifUndef false\n                        level        = o?level        |> ifUndef 0\n                        properties   = o?properties   |> obj2Map\n                      } |> Some)\n            snps\n        with _ -> [||]\n    \n    \n    \n    h5 [\n      inp.Render\n      bindHElem (deserializeCodeSnipets >> Array.map (sprintf \"%A\" >> htmlText >> Seq.singleton >> li) >> ul) inp.Var\n    ]\n    |> RunCode.RunNode().ShowHtmlResult\n    ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}],"id":{"$":0,"Item":"b47dbe9c-8623-4b35-98ee-5073edfc21b3"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Grid Bisect","content":"open Template\n\nGrid.NewBisect(true, StVariable, false, 38.1953\n      , Grid.NewBisect(true, StVariable, true , 38.1953, div[ htmlText \"One\"   ], div[ htmlText \"Two\"  ]).Render\n      , Grid.NewBisect(true, StVariable, true , 38.1953, div[ htmlText \"Three\" ], div[ htmlText \"Four\" ]).Render\n    ).Content(style \"height: 100vh\").Render\n|> RunCode.RunNode().RunHtml\n\n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"}],"id":{"$":0,"Item":"054a5cfc-2353-41a2-ab17-251c87cd4f38"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"WebSharper Snippets2","content":"[< JavaScript >]\nmodule Snippets2 = ","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"},{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"}],"id":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"Tab Panel","content":"printfn \"strip\"\nopen Template\n#nowarn \"1178\"\n\ntype SplitterNode = | SplitterNode of Var<SplitterStructure>\nand  SplitterStructure =\n    | HtmlNode of HtmlNode\n    | TabStrip of TabStrip\n    | Split    of bool * Var<float> * SplitterNode * SplitterNode\nwith    \n    static member New(vertical : bool, child1, child2) = Split(vertical, Var.Create 50.0, SplitterNode (Var.Create             child1), SplitterNode (Var.Create             child2))\n    static member New(vertical : bool, child1, child2) = Split(vertical, Var.Create 50.0, SplitterNode (Var.Create <| HtmlNode child1), SplitterNode (Var.Create <| HtmlNode child2))\n    static member New(vertical : bool, child1, child2) = Split(vertical, Var.Create 50.0, SplitterNode (Var.Create <| TabStrip child1), SplitterNode (Var.Create <| TabStrip child2))\n    static member New(strip                          ) = TabStrip strip\n    static member New(node                           ) = HtmlNode node\n\nlet rec renderSplitterNode      sn = match sn with SplitterNode chV -> bindHElem (fun ch -> renderSplitterStructure ch) chV \nand     renderSplitterStructure ss =\n        match ss with\n        | HtmlNode node                -> node\n        | TabStrip strip               -> strip.Render  \n        | Split   (ver, var, ch1, ch2) ->\n        let grid = Grid.New.Content(\"one\", renderSplitterNode ch1)\n                           .Content(\"two\", renderSplitterNode ch2).Padding(0.0)\n        if ver then grid.ColVariable(50.0).ColAuto(50.0).Content( style \"grid-template-areas: 'one   two' \" ).Render\n               else grid.RowVariable(50.0).RowAuto(50.0).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\ntype SplitterNode with\n    static member New        ss           = SplitterNode <| Var.Create ss\n    static member New       (ss:HtmlNode) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    static member New       (ss:TabStrip) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    member this.Render                    = renderSplitterNode this\n    member this.Var                       = match this with SplitterNode chV -> chV\n    member this.Value                     = this.Var.Value\n    member this.SplitMe(first, ver, node) =\n        this.Var.Value <- if first then SplitterStructure.New(ver, node      , this.Value) \n                                   else SplitterStructure.New(ver, this.Value, node      )\n    member this.SplitMe(first, ver, node:TabStrip) = this.SplitMe(first, ver, TabStrip  node      )\n    member this.SplitMe(first, ver, node:HtmlNode) = this.SplitMe(first, ver, HtmlNode  node      )\n    member this.SplitMe(first, ver               ) = this.SplitMe(first, ver, TabStrip.New([||])  )\n    member this.IsEmpty                            =\n        match this.Value with\n        | HtmlNode HtmlEmpty           -> true\n        | HtmlNode _                   -> false\n        | TabStrip strip               -> strip.tabs.Value.Length = 0\n        | Split   (ver, var, ch1, ch2) -> ch1.IsEmpty && ch2.IsEmpty\n    member this.UnSplitEmpties()                   =\n        if                                    this.IsEmpty then this.Var.Value <- SplitterStructure.New(TabStrip.New([||])) else\n        match this.Value with\n        | Split   (ver, var, ch1, ch2) -> if   ch1.IsEmpty then ch2.UnSplitEmpties() ; this.Var.Value <- ch2.Value \n                                          elif ch2.IsEmpty then ch1.UnSplitEmpties() ; this.Var.Value <- ch1.Value \n                                                           else ch1.UnSplitEmpties()\n                                                                ch2.UnSplitEmpties()\n        | _                            -> ()  \n\nlet tabs1 = \n      [|\n        \"Hello\"   \n        \"How\"   \n        \"Are\"   \n        \"You\"   \n        \"Today?\"\n      |]\n\nlet tabs2 = \n      [|\n        \"Very\"   \n        \"Well\"  \n        \"Thank\" \n        \"You\"   \n      |]\n\nlet direction    = Var.Create true\nlet createdNodes = System.Collections.Generic.Dictionary<System.Guid, Dom.Element>()\n\nlet getU tabs =\n    [| for tab in tabs do \n           yield tab\n               , Template.TextArea.New(tab:string).Render\n    |]\n    \nlet getU2 tabs = tabs |> getU |> Array.map (fun def -> System.Guid.NewGuid(), def)    \n\nlet tabs1V = TabStrip.New(getU tabs1).Top   \nlet tabs2V = TabStrip.New(getU tabs2).Bottom\n\nlet rootSplitter = SplitterNode.New(SplitterStructure.New(true, tabs1V, tabs2V))\n\ndo  TabMoved <- Some (fun _ -> rootSplitter.UnSplitEmpties())\n\ndiv [ style \"height: 500px\"\n      rootSplitter.Render.Style(\"height: 100%; width: 100% \")\n      //direction\n      //|> Val.map3 (fun t1 t2 dir-> t1,t2,dir) tabs1V.tabs tabs2V.tabs\n      //|> bindHElem (fun (t1,t2,dir) ->\n      //    match t1.Length, t2.Length with\n      //    | _, 0 -> tabs1V.Render\n      //    | 0, _ -> tabs2V.Render\n      //    | _, _ -> Grid.New\n      //                   .Content(\"one\", tabs1V.Render.Style(\"height: 100%; width: 100% \")\n      //                   .Content(\"two\", tabs2V.Render.Style(\"height: 100%; width: 100% \") )\n      //              |> (fun grid -> if dir then grid.ColVariable(50.0).ColAuto(50.0).Content( style \"grid-template-areas: 'one   two' \" ).Render\n      //                                     else grid.RowVariable(50.0).RowAuto(50.0).Content( style \"grid-template-areas: 'one' 'two' \" ).Render)\n      //    |> (fun html -> html.Style(\"height: 100%; width: 100% \")\n      //)\n      Button.New(\"print\"  ).OnClick(fun _ _ -> printfn \"strip\"                                                                ).Render\n      Button.New(\"Split\"  ).OnClick(fun _ _ -> direction.Value <- not direction.Value\n                                               rootSplitter.SplitMe(false, direction.Value)                                   ).Render\n      Button.New(\"New\"    ).OnClick(fun _ _ -> tabs1V.tabs.Value <- Array.append tabs1V.tabs.Value <| getU2 [| \"New1\" |] \n                                               tabs2V.tabs.Value <- Array.append tabs2V.tabs.Value <| getU2 [| \"New2\" |]      ).Render\n      //Button.New(\"UnSplit\").OnClick(fun _ _ -> rootSplitter.UnSplitEmpties()                                                  ).Render\n]\n|> RunCode.RunNode().AddBootstrap.RunHtml\n\n//    css \"\n//:host {\n//  all: initial;\n//  display: block;\n//  contain: content; /* Boom. CSS containment FTW. */\n//}\"\n","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"cddabd38-7ecb-4692-99bd-13ca70e4232f"},{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"}],"id":{"$":0,"Item":"58e71035-74ac-4b97-8798-3a15d4944467"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Grid Bug","content":"\ntype Grid = {  before : bool }\nwith\n    static member New  = {           before = false }\n    member this.Before = { this with before = true  }\n\n\nGrid.New\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n|> printfn \"%A\"    ","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[],"id":{"$":0,"Item":"b3d2418a-1cb8-48bd-9f12-e90b61dcc572"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Demo Action","content":"printfn \"Menu00\"\nopen Template\n\nlet actionClick act () = Val.iter (fun txt -> JS.Alert <| txt + \" Clicked!\") act.text\n\nlet actLoadFile       = Action.New(\"Load...\"                    ).OnClick2(Do2 actionClick () ) \nlet actSaveFile       = Action.New(\"Save as...\"                 ).OnClick2(Do2 actionClick () ).Highlight(true)\nlet actAddSnippet     = Action.New(\"Add Snippet\"                ).OnClick2(Do2 actionClick () )\nlet actDeleteSnippet  = Action.New(\"Delete Snippet\"             ).OnClick2(Do2 actionClick () )\nlet actIndentSnippet  = Action.New(\"Indent Snippet\"             ).OnClick2(Do2 actionClick () )\nlet actOutdentSnippet = Action.New(\"Outdent Snippet\"            ).OnClick2(Do2 actionClick () )\nlet actGetFsCode      = Action.New(\"Get F# Code\"                ).OnClick2(Do2 actionClick () )\nlet actEvalCode       = Action.New(\"Evaluate F#\"                ).OnClick2(Do2 actionClick () )\nlet actRunWSNewTab    = Action.New(\"Run WebSharper in new tab\"  ).OnClick2(Do2 actionClick () )\nlet actRunWSHere      = Action.New(\"Run WebSharper in WS Result\").OnClick2(Do2 actionClick () )\nlet actParseCode      = Action.New(\"Parse F#\"                   ).OnClick2(Do2 actionClick () )\nlet actCompileWS      = Action.New(\"Compile WebSharper\"         ).OnClick2(Do2 actionClick () )\n\nlet menu1 =\n    Menu.New2\n      [\n        MenuEntry.New(\"File\")\n            .SubMenu(\n                    [\n                        actLoadFile      .MenuEntry\n                        actSaveFile      .MenuEntry\n                    ]\n            ) \n        MenuEntry.New(\"Code\")\n            .SubMenu(\n                    [\n                        actAddSnippet    .MenuEntry.MenuNode\n                        actDeleteSnippet .MenuEntry.MenuNode\n                        MenuHtml <| li [ ``class`` \"divider\" ] \n                        actIndentSnippet .MenuEntry.MenuNode\n                        actOutdentSnippet.MenuEntry.MenuNode\n                        MenuHtml <| li [ ``class`` \"divider\" ] \n                        actGetFsCode     .MenuEntry.MenuNode \n                    ]\n            ) \n        MenuEntry.New(\"Run\")\n            .SubMenu(\n                    [\n                        actEvalCode      .MenuEntry\n                        MenuEntry.New(\"\").Divider\n                        actRunWSNewTab   .MenuEntry\n                        actRunWSHere     .MenuEntry\n                        MenuEntry.New(\"\").Divider\n                        actParseCode     .MenuEntry\n                        actCompileWS     .MenuEntry\n                    ]\n            ) \n      ]\n\nlet buttons =\n        div [ \n              actAddSnippet    .Button.Render\n              actOutdentSnippet.Button.Render\n              actIndentSnippet .Button.Render\n              actLoadFile      .Button.Render\n              actParseCode     .Button.Render\n              actEvalCode      .Button.Render\n              actGetFsCode     .Button.Render\n       \n              actDeleteSnippet .Button.Render\n              span []       \n              span []       \n              actSaveFile      .Button.Render\n              span []\n              actRunWSNewTab   .Button.Render\n              actCompileWS     .Button.Render\n//              Doc.Select [ attr.id \"Position\" ] positionTxt [ Below ; Right ; NewBrowser ] position |> someElt\n              style \"\"\"\n                  overflow: hidden;\n                  display: grid;\n                  grid-template-columns: repeat(8, 12.1%);\n                  bxackground-color: #eee;\n                  padding : 5px;\n                  grid-gap: 5px;\n              \"\"\"\n            ]\n\n\nprintfn \"Menu1\"\n\ndiv [\n    navbar <| h1 [ htmlText \"F# Station\" ; style \"font-size: 48px; margin-top: -19px\" ]\n           <| menu1.Render \n           <| menu1.Render\n    buttons\n]       \n|> RunCode.RunNode().AddBootstrap.RunHtml","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"}],"id":{"$":0,"Item":"332b130a-111b-48ca-bd75-26f96dcbb779"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Properties Table","content":"\nopen Template\n\nlet props = System.Collections.Generic.Dictionary<string, string>()\n\ndo [ for i in 1..300 do yield i ]\n   |> Seq.iter (fun i -> props.Add(string i, string i) )  \n\nlet setProp k v = props.[k] <- v\n\ntype TVar(key: string) =\n    let get () = props.[key]\n    let set v  = setProp key v\n    interface IRef<string> with\n       member this.Id  = \"?\"\n       member this.Set                                   v = set v\n       member this.Value                        with set v = set v\n       member this.Get ()                                  = get()\n       member this.Value                                   = get()\n       member this.Update      (f:string -> string       ) = get() |> f |>             set\n       member this.UpdateMaybe (f:string -> string option) = get() |> f |> Option.iter set\n       member this.View                     : View<string> = get() |> View.Const\n\nlet redraw = Var.Create ()\n\nlet tableProps =\n  redraw\n  |> Val.map (fun () ->\n      table [\n        yield thead [\n            th [ htmlText \"Property\" ; style \"padding-right:10px\" ] \n            th [ htmlText \"Value\"                                 ] \n        ] \n        yield! \n            props.Keys\n            |> Seq.map (fun kvp ->\n                tr [\n                    td [ htmlText kvp ] |> hoverable\n                    td [ Doc.Input [] <| (TVar kvp :> IRef<string>) |> someElt ] |> hoverable\n                ])\n        yield tr [\n            td [ htmlText \"Add...\" ; SomeAttr <| on.click (fun _ _ ->  props.Add(\"New\", \"Prop\") ; redraw.Value <- () )]\n            td [ htmlText \"\"    ] \n        ]\n      ]\n  )\n\n\ndiv [\n  HtmlElementV tableProps\n  css \"\"\"\n    td.hovering { background: lightgray; }\n     \"\"\"\n]\n\n|> RunCode.RunNode().AddBootstrap.RunHtml","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"}],"id":{"$":0,"Item":"57b45464-1dcd-4ea0-b4a8-279d5cc5621e"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"kimsereyblog single-page-app-with-websharper-uinext","content":"// https://kimsereyblog.blogspot.com/2015/08/single-page-app-with-websharper-uinext.html\n\n#r \"WebSharper.JQuery.dll\"\n\nopen System\nopen WebSharper\n\n[<JavaScript>]\nmodule Domain =\n    type Claim = {\n        id: string\n        name: string\n    }\n\n    type Claims = Claim list\n\n    type User = {\n        id: string\n        fullName: string\n        emailAddress: Option<string>\n        phoneNumber: Option<string>\n        enabled: bool\n        claims: Claims\n    }\n\n[<JavaScript>]\nmodule Async =\n    let map f xAsync = async { let! x = xAsync\n                               return f x      }\n    let retn x       = async { return   x      }\n\n[<JavaScript>]\nmodule AsyncApi =\n    type ApiResult<'a> =\n        | Success of 'a\n        | Failure of ApiResponseException list\n\n    and ApiResponseException =\n        | Unauthorized of string\n        | NotFound of string\n        | UnsupportedMediaType of string\n        | BadRequest of string\n        | JsonDeserializeError of string\n        override this.ToString() =\n            match this with\n            | ApiResponseException.Unauthorized         err -> err\n            | ApiResponseException.NotFound             err -> err\n            | ApiResponseException.UnsupportedMediaType err -> err\n            | ApiResponseException.BadRequest           err -> err\n            | ApiResponseException.JsonDeserializeError err -> err\n\n    let map f xAsyncApiResult =\n        async {\n            let! xApiResult = xAsyncApiResult\n            match xApiResult with\n            | Success x   -> return Success(f x)\n            | Failure err -> return Failure err\n        }\n\n    let retn x = async { return ApiResult.Success x }\n\n    let apply fAsyncApiResult xAsyncApiResult =\n        async {\n            let! fApiResult = fAsyncApiResult\n            let! xApiResult = xAsyncApiResult\n            match fApiResult, xApiResult with\n            | Success f   , Success x    -> return Success(f x)\n            | Success f   , Failure err  -> return Failure err\n            | Failure err , Success f    -> return Failure err\n            | Failure err1, Failure err2 -> return Failure(List.concat [ err1; err2 ])\n        }\n\n    let bind f xAsyncApiResult =\n        async {\n            let! xApiResult = xAsyncApiResult\n            match xApiResult with\n            | Success x -> return! f x\n            | Failure err -> return (Failure err)\n        }\n\n    let start xAsyncApiRes =\n        xAsyncApiRes\n        |> Async.map (fun x -> ())\n        |> Async.Start\n\n    type ApiCallBuilder() =\n\n        member this.Bind(x, f) =\n            async {\n                let! xApiResult = x\n                match xApiResult with\n                | Success x -> return! f x\n                | Failure err -> return (Failure err)\n            }\n        member this.Return x = async { return ApiResult.Success x }\n        member this.ReturnFrom x = x\n\n    let apiCall = new ApiCallBuilder()\n\n[<JavaScript>]\nmodule ApiClient =\n    open WebSharper.JavaScript\n    open WebSharper.JQuery\n    open AsyncApi\n    open Domain\n    open WebSharper.UI.Next\n\n    type AuthToken =\n        { Token : string\n          Expiry : DateTime }\n        member this.IsExpired() = DateTime.UtcNow - this.Expiry < TimeSpan.FromMinutes(10.0)\n\n        static member Make token =\n            { Token = token\n              Expiry = DateTime.UtcNow }\n\n        static member Default =\n            { Token = \"\"\n              Expiry = DateTime.UtcNow }\n\n    type ValidToken =\n        | ValidToken of string\n\n    type Credentials =\n        { Username : string\n          Password : string }\n        static member Default =\n            { Username = \"admin\"\n              Password = \"admin\" }\n\n    type RequestSettings =\n        { RequestType :  JQuery.RequestType\n          Url         :  string\n          ContentType :  string option\n          Headers     : (string * string) list option\n          Data        :  string option }\n        member this.toAjaxSettings ok ko =\n            let success  (result:obj)  (_ : string) (_ : JqXHR ) : unit = ok (result :?> string)\n            let errorf   (jqXHR:JqXHR) (_ : string) (_ : string) : unit = ko (System.Exception(string jqXHR.Status))\n            let settings =\n                JQuery.AjaxSettings\n                    (Url      = \"http://localhost/api/\" + this.Url\n                   , Type     = this.RequestType\n                   , DataType = JQuery.DataType.Text\n                   , Success  = Action<obj,string,JqXHR> success\n                   , Error    = Action<JqXHR,string,string> errorf)\n\n            this.Headers     |> Option.iter (fun h -> settings.Headers     <- Object<string>(h |> Array.ofList))\n            this.ContentType |> Option.iter (fun c -> settings.ContentType <- Union2Of2 c                      )\n            this.Data        |> Option.iter (fun d -> settings.Data        <- d                                )\n            settings\n\n    type Api =\n        { Login     : Credentials -> Async<ApiResult<unit>>\n          Logout    : unit        -> unit\n          GetUsers  : unit        -> Async<ApiResult<User list>>\n          GetClaims : unit        -> Async<ApiResult<Claims>> }\n\n    [<Literal>]\n    let tokenStorageKey = \"authtoken\"\n\n    let private ajaxCall (requestSettings : RequestSettings) =\n        Async.FromContinuations <| fun (ok, ko, _) ->\n            requestSettings.toAjaxSettings ok ko\n            |> JQuery.Ajax\n            |> ignore\n\n    let private matchErrorStatusCode url code =\n        match code with\n        | \"401\" ->\n            Failure\n                [ ApiResponseException.Unauthorized\n                  <| sprintf \"\"\"\"%s\" - 401 The Authorization header did not pass security\"\"\" url ]\n        | \"404\" -> Failure [ ApiResponseException.NotFound <| sprintf \"\"\"\"%s\" - 404 Endpoint not found\"\"\" url ]\n        | \"415\" ->\n            Failure\n                [ ApiResponseException.UnsupportedMediaType\n                  <| sprintf \"\"\"\"%s\" - 415 The request Content-Type is not supported/invalid\"\"\" url ]\n        | code -> Failure [ ApiResponseException.BadRequest <| sprintf \"\"\"\"%s\" - %s Bad request\"\"\" url code ]\n\n    let private tryDeserialize deserialization input =\n        try\n            deserialization input |> ApiResult.Success\n        with _ ->\n            Failure [ ApiResponseException.JsonDeserializeError <| sprintf \"\"\"\"{%s}\" cannot be deserialized\"\"\" input ]\n        |> Async.retn\n\n    let private getToken() =\n        try\n            JS.Window.LocalStorage.GetItem tokenStorageKey\n            |> Json.Deserialize<AuthToken>\n            |> ApiResult.Success\n        with ex -> ApiResult.Failure [ Unauthorized \"Unauthorized\" ]\n        |> Async.retn\n\n    let private refreshToken (authToken : AuthToken) =\n        async {\n            let url = \"auth/login/token/renew\"\n            if not (authToken.IsExpired()) then return ApiResult.Success authToken.Token\n            else\n                try\n                    let! token = ajaxCall {\n                                    RequestType = JQuery.RequestType.POST\n                                    Url = url\n                                    ContentType = None\n                                    Headers = Some [ \"Authorization\", \"Bearer \" + authToken.Token ]\n                                    Data = None }\n                    return ApiResult.Success token\n                with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (tryDeserialize Json.Deserialize<string>)\n        |> AsyncApi.map (ValidToken)\n\n    let private login credentials =\n        async {\n            let url = \"auth/login/token\"\n            try\n                let! token = ajaxCall {\n                                RequestType = JQuery.RequestType.POST\n                                Url = url\n                                ContentType = Some \"application/json\"\n                                Headers = None\n                                Data = Some(Json.Serialize<Credentials>(credentials)) }\n                return ApiResult.Success token\n            with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (Json.Deserialize<string>\n                          >> AuthToken.Make\n                          |> tryDeserialize)\n        |> AsyncApi.map (fun token -> JS.Window.LocalStorage.SetItem(tokenStorageKey, Json.Serialize<AuthToken>(token)))\n\n    let private logout() = JS.Window.LocalStorage.RemoveItem(tokenStorageKey)\n\n    let private getClaims (ValidToken token) =\n        async {\n            let url = \"auth/claims\"\n            try\n                let! claims = ajaxCall {\n                                RequestType = JQuery.RequestType.GET\n                                Url = url\n                                ContentType = None\n                                Headers = Some [ \"Authorization\", \"Bearer \" + token ]\n                                Data = None\n                            }\n                return ApiResult.Success(claims)\n            with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (tryDeserialize Json.Deserialize<Claims>)\n\n    let private getUsers (ValidToken token) =\n        async {\n            let url = \"users\"\n            try\n                let! users = ajaxCall {\n                                RequestType = JQuery.RequestType.GET\n                                Url = url\n                                ContentType = None\n                                Headers = Some [ \"Authorization\", \"Bearer \" + token ]\n                                Data = None\n                            }\n                return ApiResult.Success users\n            with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (tryDeserialize Json.Deserialize<User list>)\n\n    let api =\n        { Login    = login\n          Logout   = logout\n          GetUsers = fun () -> apiCall {\n                                    let! token      = getToken()\n                                    let! validToken = refreshToken token\n                                    return! getUsers  validToken\n                                }\n          GetClaims = fun () -> apiCall {\n                                    let! token      = getToken()\n                                    let! validToken = refreshToken token\n                                    return! getClaims validToken\n                                } }\n\n[<JavaScript>]\nmodule BootstrapUI =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n\n    module Button =\n        type private ButtonColor =\n            | Default\n            | Primary\n\n        type private ButtonStyle =\n            | FullWidth\n            | Inline\n\n        let private makeButton txt btnColor btnStyle action =\n            let classes =\n                [ yield \"btn\"\n                  yield match btnColor with\n                        | Default -> \"btn-default\"\n                        | Primary -> \"btn-primary\"\n                  yield match btnStyle with\n                        | FullWidth -> \"full\"\n                        | Inline -> \"inline\" ]\n                |> String.concat (\" \")\n            Doc.Button <| txt <| [ attr.``class`` classes\n                                   attr.``type`` \"submit\" ]\n            <| action\n\n        let bsBtnDefaultInline txt action =\n            makeButton txt ButtonColor.Default ButtonStyle.Inline action\n\n        let bsBtnDefaultFull txt action =\n            makeButton txt ButtonColor.Default ButtonStyle.FullWidth action\n\n        let bsBtnPrimaryInline txt action =\n            makeButton txt ButtonColor.Primary ButtonStyle.Inline action\n\n        let bsBtnPrimaryFull txt action =\n            makeButton txt ButtonColor.Primary ButtonStyle.FullWidth action\n\n    let bsNav brand leftLinks rightLinks =\n        let navHeader =\n            divAttr [ attr.``class`` \"navbar-header\" ]\n                    [ buttonAttr [ attr.``class`` \"navbar-toggle collapsed\"\n                                   Attr.Create \"data-toggle\" \"collapse\"\n                                   Attr.Create \"data-target\" \"#menu\"\n                                   Attr.Create \"aria-expanded\" \"false\" ]\n                                 [ spanAttr [ attr.``class`` \"sr-only\" ] []\n                                   spanAttr [ attr.``class`` \"icon-bar\" ] []\n                                   spanAttr [ attr.``class`` \"icon-bar\" ] []\n                                   spanAttr [ attr.``class`` \"icon-bar\" ] [] ]\n                      aAttr [ attr.``class`` \"navbar-brand title\"\n                              attr.href \"#\" ] [ text brand ] ]\n\n        let navMenu =\n            divAttr [ attr.``class`` \"collapse navbar-collapse\"\n                      attr.id \"menu\" ]\n                    [ ulAttr [ attr.``class`` \"nav navbar-nav\" ] [ leftLinks ]\n                      ulAttr [ attr.``class`` \"nav navbar-nav navbar-right\" ]\n                             [ rightLinks ] ]\n\n        navAttr [ attr.``class`` \"navbar navbar-default\" ]\n            [ divAttr [ attr.``class`` \"container-fluid\" ]\n                      [ navHeader; navMenu ] ] :> Doc\n\n    let bsInput placeHolder rvTxt =\n        Doc.Input [ attr.``class`` \"form-control\"\n                    attr.placeholder placeHolder ] rvTxt\n\n    let bsPasswordInput placeHolder rvPwd =\n        Doc.PasswordBox [ attr.``class`` \"form-control\"\n                          attr.placeholder placeHolder ] rvPwd\n\n    let bsPanelDefault body =\n        divAttr [ attr.``class`` \"panel panel-default\" ] [ divAttr [ attr.``class`` \"panel-body\" ] body ]\n\n    let bsPanelDefaultWithTitle title body =\n        divAttr [ attr.``class`` \"panel panel-default\" ]\n                [ divAttr [ attr.``class`` \"panel-heading\" ]\n                          [ h3Attr  [ attr.``class`` \"panel-title\" ]\n                                    [ text title ] ]\n                  divAttr [ attr.``class`` \"panel-body\" ] body ]\n\n    let bsAlertDanger message =\n        divAttr [ attr.``class`` \"alert alert-danger\"\n                  Attr.Create \"role\" \"alert\" ] [ text message ] :> Doc\n\n    let bsRow bsCol = divAttr [ attr.``class`` \"row\" ] bsCol\n\n    let bsCol3 body = divAttr [ attr.``class`` \"col-md-3\" ] body\n\n    let bsCol4 body = divAttr [ attr.``class`` \"col-md-4\" ] body\n\n    let bsContainer body = divAttr [ attr.``class`` \"container\" ] body\n\n    let bsJumbotron title body =\n        divAttr [ attr.``class`` \"jumbotron\" ]\n                [ divAttr [ attr.``class`` \"container\" ]\n                          [ h1 [ text title ] \n                            body ] ]\n\n[<JavaScript>]\nmodule ClientRoutes =\n    open WebSharper.UI.Next\n\n    type Page =\n        | Home\n        | Claims\n        | Users\n        | Login\n        override this.ToString() =\n            match this with\n            | Home -> \"Home\"\n            | Claims -> \"Claims\"\n            | Users -> \"Users\"\n            | Login -> \"Login\"\n\n    let private map =\n        function\n        | Home -> []\n        | Claims -> [ \"claims\" ]\n        | Users -> [ \"users\" ]\n        | Login -> [ \"login\" ]\n\n    let private reverMap =\n        function\n        | [] -> Home\n        | [ \"home\" ] -> Home\n        | [ \"claims\" ] -> Claims\n        | [ \"users\" ] -> Users\n        | [ \"login\" ] -> Login\n        | _ -> failwith \"404\"\n\n    let install () =\n        RouteMap.Create map reverMap\n        |> RouteMap.Install\n\n[<JavaScript>]\nmodule NavBarPage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n    open ApiClient\n\n    let private makeNavlinks routerView go =\n        routerView\n        |> View.Map(fun currentPage ->\n               [ ClientRoutes.Home; ClientRoutes.Claims; ClientRoutes.Users ]\n               |> List.map\n                      (fun page ->\n                      liAttr [ if page = currentPage then yield attr.``class`` \"active\" ]\n                             [ Doc.Link (string page) [] (fun _ -> go page) ] :> Doc)\n               |> Doc.Concat)\n        |> Doc.EmbedView\n\n    let private logout go =\n        li [ Doc.Link \"Log out\" [] (fun () ->\n                                     api.Logout()\n                                     go ClientRoutes.Login) ] :> Doc\n\n    let doc routerView go = bsNav \"admin portal\" (makeNavlinks routerView go) (logout go)\n\n\n[<JavaScript>]\nmodule LoginPage =\n    open BootstrapUI\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open ApiClient\n\n    let private login rvUsername rvPassword rvLoginError go () =\n        async {\n            let! login = api.Login { Username = Var.Get rvUsername\n                                     Password = Var.Get rvPassword }\n            match login with\n            | AsyncApi.Failure err ->\n                Var.Set rvLoginError\n                        \"You may have keyed in an invalid Username or Password. Please try again.\"\n                api.Logout()\n            | _ -> ()\n            return login\n        }\n        |> AsyncApi.map (fun _ -> go ClientRoutes.Home)\n        |> AsyncApi.start\n\n    let doc go =\n        let rvUsername = Var.Create \"\"\n        let rvPassword = Var.Create \"\"\n        let rvErr = Var.Create \"\"\n\n        let nameInput = bsInput \"Username\" rvUsername\n        let pwdInput = bsPasswordInput \"Password\" rvPassword\n        let errDiv = rvErr.View\n                     |> View.Map(fun err ->     if err = \"\" then Doc.Empty\n                                                else bsAlertDanger err)\n                     |> Doc.EmbedView\n\n        let buttons =\n            bsPanelDefault\n                [ form [ errDiv\n                         nameInput\n                         pwdInput\n                         Button.bsBtnDefaultFull \"Log in\"\n                                                 (login rvUsername rvPassword rvErr go) ] ]\n        bsRow [ bsCol4 [ Doc.Empty ]\n                bsCol4 [ h1Attr [attr.``class`` \"title\"]\n                                [text \"admin portal\"]\n                         buttons ]\n                bsCol4 [ Doc.Empty ] ]\n\n\n[<JavaScript>]\nmodule HomePage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let doc go =\n        bsJumbotron \"Hello,\"\n                    ([p [text \"Welcome to the admin portal v1.0.\"] :> Doc\n                      Button.bsBtnPrimaryInline \"View claims\"\n                                                (fun () -> go ClientRoutes.Claims) :> Doc\n                      Button.bsBtnPrimaryInline \"View users\"\n                                                (fun () -> go ClientRoutes.Users) :> Doc]\n                     |> Doc.Concat)\n\n[<JavaScript>]\nmodule ClaimsPage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let doc go =\n        bsJumbotron \"Claims\" Doc.Empty\n\n[<JavaScript>]\nmodule UsersPage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let doc go =\n        bsJumbotron \"Users\" Doc.Empty\n\n[<JavaScript>]\nmodule Client =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let Main =\n        let router = ClientRoutes.install()\n\n        let doc =\n            router.View\n            |> View.Map(fun page ->\n                   let go = Var.Set router\n\n                   let addNavBar body =\n                       [ NavBarPage.doc router.View go\n                         body ]\n                       |> Doc.Concat\n\n                   let embedInContainer body = bsContainer [ body ]\n\n                   match page with\n                   | ClientRoutes.Login ->\n                       LoginPage.doc go\n                       |> embedInContainer :> Doc\n                   | ClientRoutes.Home ->\n                       HomePage.doc go\n                       |> embedInContainer\n                       |> addNavBar\n                   | ClientRoutes.Claims ->\n                       ClaimsPage.doc go\n                       |> embedInContainer\n                       |> addNavBar\n                   | ClientRoutes.Users ->\n                       UsersPage.doc go\n                       |> embedInContainer\n                       |> addNavBar)\n            |> Doc.EmbedView\n\n        RunCode.RunNode().AddBootstrap.RunDoc doc","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[],"id":{"$":0,"Item":"9ff8bc4a-76c7-4db5-b59a-9252f82fa61d"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Check All WebSharper Code","content":"// add everyone as a predecessor to check if they parse/compile","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"},{"$":0,"Item":"b9ca9697-6cb4-4085-b509-9f702a62086f"},{"$":0,"Item":"9ff8bc4a-76c7-4db5-b59a-9252f82fa61d"},{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"},{"$":0,"Item":"332b130a-111b-48ca-bd75-26f96dcbb779"},{"$":0,"Item":"58e71035-74ac-4b97-8798-3a15d4944467"},{"$":0,"Item":"0a1fa320-b731-473a-93e2-dae49cc296f7"},{"$":0,"Item":"f3a7ead2-49e1-4ff4-b96e-6fe699a1c8a9"},{"$":0,"Item":"f2cc3e92-5e61-47b2-982b-40f5c5784e6a"},{"$":0,"Item":"0aa90429-4e7c-42eb-b108-3dd70e710bf1"},{"$":0,"Item":"9682eb8f-e1de-4d7c-adca-a5e2322558c2"},{"$":0,"Item":"a54701f2-1d68-4997-a1ea-62deaeb73e1b"},{"$":0,"Item":"4dc58ba1-75d1-4c96-9641-235ee7d8c2c2"},{"$":0,"Item":"74b8570e-dcd4-4dff-87a5-cd7ec96b8527"},{"$":0,"Item":"38b21610-7350-4676-993b-88fea844314f"},{"$":0,"Item":"7754c074-862e-4550-9d61-ea837adf6d85"},{"$":0,"Item":"ff6bfed0-83ae-4497-b197-fea6432aa958"},{"$":0,"Item":"ee8fe0d0-14ad-4ae8-bd77-e0918817d67e"},{"$":0,"Item":"3d8bf6d2-a66b-4f18-aa83-8e74836e38e4"},{"$":0,"Item":"e9c3ceaf-8fe5-4752-aa4c-2db6e1ac4577"},{"$":0,"Item":"b47dbe9c-8623-4b35-98ee-5073edfc21b3"},{"$":0,"Item":"b3d2418a-1cb8-48bd-9f12-e90b61dcc572"}],"id":{"$":0,"Item":"a3bec308-c3bd-4fad-b400-b9a33d1b15c8"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Client-Server Demo","content":"module WSServer = ","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[],"id":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"expanded":false,"level":0,"levelCode":0,"properties":{"DisableParse":"0","DisableWebSharper":"1"}},{"name":"Client (and Rpc)","content":"\nlet invert (txt: string) : string = txt |> Seq.rev |> Seq.map string |> String.concat \"\"\n\n[< Rpc >]\nlet invertA txt = async { return invert txt }\n\n[< JavaScript >]\nlet ClientForm () =\n    let inp = Template.Input.New(\"Type something...\")\n    div [ \n      ``class`` \"container\"    \n      Template.Bootstrap().Render\n      Template.Panel.New\n        .Title(\"Client Server Demo\")\n        .Header([])\n        .Content(\n          [ h3 [\n              inp.Render\n              htmlText inp.Var\n              htmlElement \"h2\" [ htmlText inp.Var ]\n              h1 [ htmlText <| Val.mapAsync invertA inp.Var ]\n            ]\n          ]).Render\n    ] |> renderDoc\n","parent":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"predecessors":[{"$":0,"Item":"0a11766b-f227-4b38-88a3-919d964387bf"},{"$":0,"Item":"40614ad6-3f81-468b-a4ff-034124b82ae1"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"0dabc34f-673d-4f79-ae00-3960ca196392"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"Site","content":"open WebSharper.Sitelets\nopen WebSharper.UI.Next.Server\nopen WebSharper.UI.Next\n\ntype EndPoint = | [< EndPoint \"/\" >] EP\n\nlet content (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n    Content.Page(\n        Title = \"Main Page\"\n      , Head  = [ Html.scriptAttr [ attr.``type`` \"text/javascript\"; attr.src \"https://code.jquery.com/jquery-3.1.1.min.js\"] [] ]\n      , Body  = [ Html.client <@  ClientForm () @> ])\n\nlet site = Application.MultiPage content\n","parent":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"predecessors":[{"$":0,"Item":"0dabc34f-673d-4f79-ae00-3960ca196392"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"92837099-e4e4-4c7f-ac52-6c922824304f"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"ClientServerDemo","content":"#r @\"Owin.dll\"\n#r @\"Microsoft.Owin.dll\"\n#r @\"Microsoft.Owin.Hosting.dll\"\n#r @\"Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"Microsoft.Owin.StaticFiles.dll\"\n#r @\"Microsoft.Owin.FileSystems.dll\"\n#r @\"WebSharper.Owin.dll\"\n#r @\"HttpMultipartParser.dll\"\n#r @\"WebSharper.Core.JavaScript.dll\"\n\nopen global.Owin\nopen Microsoft.Owin.Hosting\nopen Microsoft.Owin.StaticFiles\nopen Microsoft.Owin.FileSystems\nopen WebSharper.Owin\n\n[< EntryPoint >]\nlet Main args =\n    let rootDirectory, url =\n        match args with\n        | [| rootDirectory; url |] -> rootDirectory, url\n        | [| url                |] -> \"website\"    , url\n        | [|                    |] -> \"website\"    , \"http://localhost:9000/\"\n        | _ -> eprintfn \"Usage: WebServer3 ROOT_DIRECTORY URL\"; exit 1\n    use server = \n        WebApp.Start(url, fun appB ->\n            appB.UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(rootDirectory)))\n                .UseWebSharper(WebSharperOptions(ServerRootDirectory = rootDirectory\n                                               , Sitelet             = Some site\n                                               , BinDirectory        = \".\"\n                                               , Debug               = true))\n            |> ignore\n            let listener = appB.Properties.[\"Microsoft.Owin.Host.HttpListener.OwinHttpListener\"] |> unbox<Microsoft.Owin.Host.HttpListener.OwinHttpListener>\n            listener.SetRequestProcessingLimits(1000, 1000)\n            let maxA = ref 0\n            let maxB = ref 0\n            listener.GetRequestProcessingLimits(maxA, maxB)\n            printfn \"Accepts: %d Requests:%d\" !maxA !maxB\n        )\n    stdout.WriteLine(\"Serving {0}\", url)\n    stdin.ReadLine() |> ignore\n    0\n    ","parent":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"predecessors":[{"$":0,"Item":"92837099-e4e4-4c7f-ac52-6c922824304f"}],"id":{"$":0,"Item":"7e36bd56-d4fa-4509-bece-b4444df38c5c"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"compile & run ClientServerDemo","content":"open System.IO\nopen FsStationShared\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.CompOptionsModule\n\nWrap.wrapper {\n    let  options   = compileOptionsExeDebug \"FSSGlobal/WebSharper Code/Client-Server Demo/ClientServerDemo\"\n                     + siteOptions\n    let  exeFile   = options?Output\n    let  site      = Path.GetFullPath(options?Website)\n    let! res       = FsStationClient(\"Compile WebSharper\").CompileSnippetW options\n    do   printfn     \"Starting %s\"     exeFile\n    let  url       = @\"http://localhost:9001/\"\n    let  parms     = sprintf \"%A %A\" site url \n    do   runProcess  exeFile parms |> ignore\n    do   runProcess  url     \"\"    |> ignore\n    return res\n} |> Wrap.runSynchronouslyS true |> printfn \"%s\"\n","parent":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"predecessors":[{"$":0,"Item":"56e5bc09-e528-49cc-9d42-6359b32a0cc9"}],"id":{"$":0,"Item":"c8c93861-321c-4d73-beb0-2fef0052bc7b"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableFSI":"0"}},{"name":"F# STATION TUTORIALS","content":"// go to 1. Hello World\n#nowarn \"20\"\n#nowarn \"52\"\n#nowarn \"1178\"\n#nowarn \"3180\"\n[<JavaScript>]\nmodule Tutorials =\n","parent":{"$":0,"Item":"bf864f3c-1370-42f2-ac8a-565a604892e8"},"predecessors":[{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"}],"id":{"$":0,"Item":"3e6eb5de-d69e-4fcd-a472-d326d673ae52"},"expanded":true,"level":0,"levelCode":0,"properties":{"CSS":".CodeMirror span.cm-comment {\nbackground : white;\nfont-style : normal;\nfont-weight: 600;\ncolor      : black;\nfont-size  : 20px;  \n}","Theme":"neat","DisableFSI":"1"}},{"name":"1. Hello World","content":"\"Hello World!\"                                // Mandatory Hello World example\n|> RunCode.RunNode().AddBootstrap.ShowResult  // <=== ShowResult shows any value as a text in an html pane  \n\n\n\n// Click on \"Run WebSharper\" button below to run example\n// Simple, right?\n\n\n// Intellisense:\n// Double click once on ShowResult to see a tooltip\n\n\n\"\"\"\n\nRun WebSharper can show the result in a new browser tab or in the \"WS Result\" tab below\nDisable pop up blocker for this page\n\n\"\"\"","parent":{"$":0,"Item":"3e6eb5de-d69e-4fcd-a472-d326d673ae52"},"predecessors":[],"id":{"$":0,"Item":"fde83d46-bd7c-48e4-80f4-647639de87b9"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"2. Working with Predecessors","content":"// Expand me and go to: \"2.3 Many Hellos\"","parent":{"$":0,"Item":"3e6eb5de-d69e-4fcd-a472-d326d673ae52"},"predecessors":[{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"}],"id":{"$":0,"Item":"7df1af66-2085-4125-aa78-ce48ecbe8838"},"expanded":true,"level":0,"levelCode":0,"properties":{"NoIndent":"1","DisableParse":"1"}},{"name":"2.1 countTo","content":"let countTo n = [| 1..n |]\n\n\n\"\"\"\n\nParent snippets are automatically predecessors too\n\n\n\"\"\"","parent":{"$":0,"Item":"7df1af66-2085-4125-aa78-ce48ecbe8838"},"predecessors":[],"id":{"$":0,"Item":"a9437ce3-e291-46e8-ab1b-6879efee4b53"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"2.2 sayItManyTimes","content":"let sayItManyTimes s n = \n    countTo n                            // <=== countTo is defined above\n    |> Array.map (sprintf \"%s %A\" s)\n\n\n\"\"\"\n\nThis snippet has a direct predecessor: \"2.1 countTo\"\n\n\n\"\"\"","parent":{"$":0,"Item":"7df1af66-2085-4125-aa78-ce48ecbe8838"},"predecessors":[{"$":0,"Item":"a9437ce3-e291-46e8-ab1b-6879efee4b53"}],"id":{"$":0,"Item":"6ec1d5bf-6a84-471a-89aa-d9e9f8ffd141"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"2.3 Many Hellos","content":"// Working with predecessors\n\nsayItManyTimes \"Hello\" 10                     // \"sayItManyTimes\" is defined in the prior snippet\n|> RunCode.RunNode().AddBootstrap.ShowResult \n\n\n\"\"\" \nClick on \"Run WebSharper\" button below to run example\n\n\nBy using the predecessor mechanism a bunch of code is added with this snippet.\nAll predecessors direct and indirect are highlighted in blue on the left.\nDirect predecessors are marked with an X on the right side of the snippet list.\nTry toggling the direct predecessor 2.2\n\nThe parent of a snippet is automatically a predecessor.\nBy default children snippets code is indented, except when NoIndent property is used.\n\nONLY the highlighted snippets are included in the final code.\n\nTo see the F# code generated, select the \"F# code\" tab below.\n(click on \"Get F# Code\" if it is empty)\n\nThe F# code is translated into JavaScript by WebSharper\nSelect the \"JavaScript\" tab to see the translated JS Code\n(click on \"Run WebSharper\" or \"Compile WebSharper\" if it is empty)\n\n\"\"\"\n// Intellisense:\n// ShowResult is defined somewhere else, to find it\n// click on it and then use <Find Definition> button\n\n","parent":{"$":0,"Item":"7df1af66-2085-4125-aa78-ce48ecbe8838"},"predecessors":[{"$":0,"Item":"6ec1d5bf-6a84-471a-89aa-d9e9f8ffd141"}],"id":{"$":0,"Item":"c93f1a5c-0145-4456-b71b-78923fc8a4f7"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"3. Using Html","content":"div [                                              // an Html tag:  <div>\n    htmlText \"Many Hellos!\"                        // some text\n    ul [                                           // more tags:    <ul> <li>\n        for hello in sayItManyTimes \"Hello\" 10 do\n            yield \n                li [ htmlText hello ]\n    ]\n]\n|> RunCode.RunNode().AddBootstrap.ShowHtmlResult   // \"ShowHtmlResult\" displays Html instead of plain text\n\n\n\"\"\"\n\nThis is a simplified version of the WebSharper syntax.\nSubtags and attributes are combined in the same sequence.\n\n\n\"\"\"","parent":{"$":0,"Item":"3e6eb5de-d69e-4fcd-a472-d326d673ae52"},"predecessors":[{"$":0,"Item":"6ec1d5bf-6a84-471a-89aa-d9e9f8ffd141"}],"id":{"$":0,"Item":"9c57f2d5-6e05-410c-8262-1f0573cf7c8e"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"4. Html Attributes","content":"div [                                              \n    style \"background: beige; color: red\"          // an attribute: \"style\"\n    h1 [ htmlText \"Many Hellos!\" ]\n    style \"font-style: italic; font-family: Times\" // and another one!\n    ul [\n        for hello in sayItManyTimes \"Hello\" 10 do\n            yield \n                li [\n                    style    \"color: blue\"\n                    htmlText hello \n                ]\n        yield style \"font-style: normal\"\n    ]\n    style \"text-align: center\"                    // attributes can be in any order\n]\n|> RunCode.RunNode().AddBootstrap.RunHtml         // \"RunHtml\" also displays Html but not in a pane\n\n\"\"\"\n\nMultiple \"style\" and \"class\" attributes are combined automatically.\n\n\n\"\"\"\n\n// Intellisense: Ctrl-Space for autocomplete\n// try it: place cursor right after \"AddBootstrap.\" and press ctrl-space\n\n","parent":{"$":0,"Item":"3e6eb5de-d69e-4fcd-a472-d326d673ae52"},"predecessors":[{"$":0,"Item":"6ec1d5bf-6a84-471a-89aa-d9e9f8ffd141"}],"id":{"$":0,"Item":"4d7c9a6a-9610-49df-9e97-1292a0608074"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"5. Calculated Attributes","content":"let fontSize i = sprintf \"font-size: %dpx\" ((i + 1) * 3) // <== a nice formula to calculate font size\n\ndiv [                                              \n    style \"background: beige; color: red\"         \n    h1 [ htmlText \"Many Hellos!\" ]\n    style \"font-style: italic; font-family: Times\"\n    ul [\n        for i, hello in sayItManyTimes \"Hello\" 10 |> Seq.indexed do\n            yield \n                li [\n                    style    \"color: blue\"\n                    style <| fontSize i                    // <=== applied here, as a static style\n                    htmlText hello \n                ]\n        yield style \"font-style: normal\"\n    ]\n    style \"text-align: center\"   \n]\n|> RunCode.RunNode().AddBootstrap.RunHtml   ","parent":{"$":0,"Item":"3e6eb5de-d69e-4fcd-a472-d326d673ae52"},"predecessors":[{"$":0,"Item":"6ec1d5bf-6a84-471a-89aa-d9e9f8ffd141"}],"id":{"$":0,"Item":"f5d15bec-c4fa-4a62-998d-24a91c4981a2"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"6. Using Templates and Variables","content":"let multiplier = Template.Input.New(\"3\")                                          // a Template for text input\n                         .Placeholder(\"Enter multiplier:\")                        // with some nice predefined features\n                         .Prefix(\"Multiplier:\")\n\nlet fontSizeVal i = \n    multiplier.Var                                                                // Use UI.Next Var from the template object\n    |> Val.map (fun m -> sprintf \"font-size: %dpx\" ((i + 1) * int m))             // <=== not static anymore, this one is dynamic!\n\ndiv [\n    multiplier.Render                                                             // Render text input into HtmlNode type\n    div [                                              \n        style \"background: beige; color: red\"         \n        h1 [ htmlText <| Val.map (sprintf \"Many Hellos! x %spx\") multiplier.Var ] // <=== a dynamic text\n        style \"font-style: italic; font-family: Times\"\n        ul [\n            for i, hello in sayItManyTimes \"Hello\" 10 |> Seq.indexed do\n                yield \n                    li [\n                        style    \"color: blue\"\n                        style <| fontSizeVal i                                     // <=== apply dynamic style\n                        htmlText hello \n                    ]\n            yield style \"font-style: normal\"\n        ]\n        style \"text-align: center\"   \n    ]\n]\n|> RunCode.RunNode().AddBootstrap.RunHtml   \n\n\"\"\"\n\n\nThe Val type is a wrapper class that unifies WebSharper's UI.Next Var, View and constant values for a simpler syntax.\n\n\n\"\"\"","parent":{"$":0,"Item":"3e6eb5de-d69e-4fcd-a472-d326d673ae52"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"6ec1d5bf-6a84-471a-89aa-d9e9f8ffd141"}],"id":{"$":0,"Item":"cdb3cc85-46be-44a5-9a92-599f080e01e2"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"7. Work in progress","content":"FSharpStation.FSharpStationClient \"\"\n|> RunCode.RunNode().AddBootstrap.RunDoc    // Run WebSharper (preferrably in New Browser)\n\n\n\"\"\"\n\nYes, the tutorial is too short. This is a work in progress.\n\nPeople usually complain that examples in tutorials are only Mickey Mouse versions \nbut \"F# Station\" is fully coded in F# Station. \nI mean the code is all here including client and server sides, \nfeel free to explore and discover.\n\nEven though it is client-server it isn't intended to be used over the Web,\n\"Evaluate F#\" uses FSI which gives full access to the server computer which is dangerous.\nThat is why \"Evaluate F#\" is disabled over the web.\n\nTo get the full power of F# Station install locally in your computer.\n\n\"\"\"\n\n// To install locally goto: https://github.com/amieres/FSharpStation \n","parent":{"$":0,"Item":"3e6eb5de-d69e-4fcd-a472-d326d673ae52"},"predecessors":[{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"}],"id":{"$":0,"Item":"b3f2df8c-b6d9-46e2-b09a-a6550b02d5a6"},"expanded":true,"level":0,"levelCode":0,"properties":{}},{"name":"ACTIONS","content":"module Actions =","predecessors":[],"id":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"expanded":false,"level":0,"levelCode":0,"properties":{"Theme":"rubyblue","DisableParse":"1","DisableWebSharper":"1"}},{"name":"SAVE FSharpStation.js","content":"FSSGlobal.FsStationShared.FsStationClient(\"SAVE CodeEditor\")\n    .SaveSnippetJS @\"website\\EPFileX\" \"FSSGlobal/WebSharper Code/FSharpStation Code/FSharpStation\"\n","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"}],"id":{"$":0,"Item":"07a3e5d2-a793-49cf-bb87-88a98c5d9c7d"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"SAVE FSharpStation.fsx","content":"FSSGlobal.FsStationShared.FsStationClient(\"SAVE CodeEditor\")\n    .SaveSnippetFsx @\"..\\bin\\website\\EPFileX\" \"FSSGlobal/WebSharper Code/FSharpStation Code/FSharpStation\"","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"}],"id":{"$":0,"Item":"56b4fb1e-909e-4b83-b312-8993751d0685"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"SAVE FsJson File","content":"FSSGlobal.FsStationShared.FsStationClient(\"SAVE CodeEditor\")\n    .SaveWholeFile @\"..\\..\" \"CodeEditor\"","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"}],"id":{"$":0,"Item":"df25d045-936b-4f0e-9a22-429cd4f8848a"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"DO Saves","content":"// Click Evaluate F#","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"07a3e5d2-a793-49cf-bb87-88a98c5d9c7d"},{"$":0,"Item":"56b4fb1e-909e-4b83-b312-8993751d0685"},{"$":0,"Item":"df25d045-936b-4f0e-9a22-429cd4f8848a"}],"id":{"$":0,"Item":"e307def4-b29d-4abf-9ec6-8744c0b8d75a"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"Compile Modules","content":"#define FSS_SERVER\n#define COMPILING\nopen FSSGlobal.FsStationShared // open's need to be here\nopen FSSGlobal.Useful\nopen FSSGlobal.UsefulDotNet.CompOptionsModule\n\nlet fsStation = FsStationClient(\"Compile Modules\")\n[\n\n","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"56e5bc09-e528-49cc-9d42-6359b32a0cc9"}],"id":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"expanded":false,"level":0,"levelCode":0,"properties":{}},{"name":"","content":"\"FSSGlobal/F# Code/FsTranslator/FsTranslator\"        |> compileOptionsExeDebug\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"b89801cc-5412-4025-bd88-c6ec0624a970"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"Prop"}},{"name":"","content":"\"FSSGlobal/F# Code/FsStationShared/SelfHostedServer\" |> compileOptionsExeDebug\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"2db6dbb4-6c03-4c3d-990f-abfb997e9855"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"1"}},{"name":"","content":"(\"FSSGlobal/F# Code/UsefulDotNet/RemotingDll\"        |> compileOptionsDllDebug)\n  + opGenWSharper /= \"ws:library\" \n  + opDirectory   /= \"Compiled/RemotingDll2\"\n  + wsProjectOptions\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"8deb7606-0602-4a16-83b4-4528985f267e"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"1"}},{"name":"","content":"\"FSSGlobal/F# Code/FSAutoComplete/FSAutoCompleteDll\" |> compileOptionsDllDebug\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"53c32bfe-219e-4ff1-8913-adbc067b40d4"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"1"}},{"name":"","content":"\"FSSGlobal/F# Code/Snippets/Calculate primes\"        |> compileOptionsWinExeDebug","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"7196e914-b38c-489b-a119-c980432ac41b"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"1"}},{"name":"Compile selected modules","content":"// select the module(s) to compile\n\n] |> Seq.iter (id \n        >> swap (+) [ opGenInternal /= \"showoptions\" ] \n        //>> swap (+) [ opGenFSharp2  /= \"standalone\"  ] \n        >> fsStation.CompileSnippetW \n        >> Wrap.runSynchronouslyS true\n        >> printfn \"%s\"\n     )\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[{"$":0,"Item":"7196e914-b38c-489b-a119-c980432ac41b"}],"id":{"$":0,"Item":"d39e3783-fb76-4963-b9fe-2da76c4b2a86"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"DO/check all ACTIONS","content":"// Just Select as predecessors all the actions you want to execute \n// and then click on Evaluate F#\n","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"5e8209e0-9203-4fe0-8289-fb4579b24038"},{"$":0,"Item":"d39e3783-fb76-4963-b9fe-2da76c4b2a86"},{"$":0,"Item":"c8c93861-321c-4d73-beb0-2fef0052bc7b"},{"$":0,"Item":"e307def4-b29d-4abf-9ec6-8744c0b8d75a"},{"$":0,"Item":"c578e375-e299-4450-957e-1596e7af2007"},{"$":0,"Item":"24394c61-747d-41ff-816e-c70e46573bb7"},{"$":0,"Item":"d5d1c9fc-856e-44fd-aa74-9a8e88c3818f"}],"id":{"$":0,"Item":"64f180f8-8781-4630-9239-b5610a6329b6"},"expanded":true,"level":0,"levelCode":0,"properties":{"DisableParse":"0"}},{"name":"FSI ZONE","content":"//model//.GetType()\n//|> printfn \"::::%A\"\n\n//FP_vs_MD_Perc.calFormulas.[1].forExpression.RuleText (model, model.modCubes.[0].cubId) |> printfn \"%s\"\n//ReportCube.cubRules.[0].AleaRule (model, model.modCubes.[0].cubId)\n//|> printfn \"%A\"\n\n//Price\n//|> printfn \"%A\"\n\n\n//open FSSGlobal.FSAutoCompleteIntermediary\n//\n//let responder = Responder2()\n//let file = \"ParseFSharp.fsx\"\n//ACMParse(file, \"let abc = 123 \\nlet xyz = abc + 3\", [|  |] ) |> responder.Respond\n//|> printfn \"%A\"\n//\n//ACMSignature(file, 2, 11) |> responder.Respond\n//|> printfn \"%A\"\n//\n//ACMFindDeclaration(file, 2, 11) |> responder.Respond\n//|> printfn \"%A\"\n//\n\nopen System.IO\n\nlet inline combinePaths path1 (path2 : string) = Path.Combine(path1, path2.TrimStart [| '\\\\'; '/' |])\n\nlet inline (</>) path1 path2 = combinePaths path1 path2\n\nlet private environVar v = System.Environment.GetEnvironmentVariable v\n\nlet private programFilesX86 =\n      let wow64 = environVar \"PROCESSOR_ARCHITEW6432\"\n      let globalArch = environVar \"PROCESSOR_ARCHITECTURE\"\n      match wow64, globalArch with\n      | \"AMD64\", \"AMD64\"\n      | null, \"AMD64\"\n      | \"x86\", \"AMD64\" -> environVar \"ProgramFiles(x86)\"\n      | _ -> environVar \"ProgramFiles\"\n      |> fun detected -> if detected = null then @\"C:\\Program Files (x86)\\\" else detected // \"\n\nlet private tryFindFile dirs file =\n    let files =\n        dirs\n        |> Seq.map (fun (path : string) ->\n            try\n               let path =\n                  if path.StartsWith(\"\\\"\") && path.EndsWith(\"\\\"\")\n                  then path.Substring(1, path.Length - 2)\n                  else path\n               let dir = new DirectoryInfo(path)\n               if not dir.Exists then \"\"\n               else\n                   let fi = new FileInfo(dir.FullName </> file)\n                   if fi.Exists then fi.FullName\n                   else \"\"\n            with\n            | _ -> \"\")\n        |> Seq.filter ((<>) \"\")\n        |> Seq.cache\n    if not (Seq.isEmpty files) then Some(Seq.head files)\n    else None\n\nlet referenceAssembliesPathFSharp = programFilesX86 </> @\"Reference Assemblies\\Microsoft\\FSharp\\.NETFramework\\v4.0\\\" // \"\nlet fsharpCoreVersions = [\"4.4.1.0\"; \"4.4.0.0\"; \"4.3.1.0\"; \"4.3.0.0\"]\n\nlet fsharpCoreOpt =\n    List.map (combinePaths referenceAssembliesPathFSharp) fsharpCoreVersions\n    |> List.append    [ @\"..\\packages\\FSharp.Compiler.Tools\\tools\" ]\n    |> tryFindFile <| \"FSharp.Core.dll\"\n    |> Option.map      Path.GetFullPath\n\nlet private fsharpInstallationPath =\n    [\"4.1\"; \"4.0\"; \"3.1\"; \"3.0\"]\n    |> List.map (fun v -> programFilesX86 </> @\"\\Microsoft SDKs\\F#\\\" </> v </> @\"\\Framework\\v4.0\") // \"\n    |> List.append    [ @\"..\\packages\\FSharp.Compiler.Tools\\tools\" ]\n    |> List.tryFind Directory.Exists\n    |> Option.map      Path.GetFullPath\n\nlet referenceAssembliesPath =\n     programFilesX86 </> @\"Reference Assemblies\\Microsoft\\Framework\\.NETFramework\"\n\nlet dotNetVersions () =\n    if Directory.Exists referenceAssembliesPath then\n      Directory.EnumerateDirectories referenceAssembliesPath\n      |> Seq.sort\n      |> Seq.toArray\n      |> Array.rev\n    else\n      Array.empty\n\nlet version = dotNetVersions () |> Seq.head\nlet oldRef = referenceAssembliesPath </> \"v4.0\"\nlet newRef = referenceAssembliesPath </> version\n \n\n(\n  fsharpCoreOpt\n, fsharpInstallationPath\n, oldRef, newRef   \n)|> printfn \"%A\"     \n\n","predecessors":[],"id":{"$":0,"Item":"c2fd97dd-907f-4c2e-ae68-d80f2b8caf3c"},"expanded":true,"level":0,"levelCode":0,"properties":{"Theme":"mbo","DisableWebSharper":"1"}},{"name":"","content":"PENDING:\n- Add version counter for F# Station and display it\n- When compiling FSharpStation:\nWebSharper warning: Failed to load return type 'FSSGlobal.FSAutoComplete+CommandResponse+Kind, FSAutoCompleteDll' \nto verify encoding to JSON. at FSSGlobal.FSAutoComplete.sendMessageRpc\n- Allow plugable Add in commands\n- Highlight snippets with errors\n- Add global search \n- back/forward browser functionality button (using #address preferrably)\n- add # routing to get to specific snippets\n- Flush FsiExe MailBoxProcessor if 5 messages are waiting / or add a button for flushing\n- Keep count/ increase pending Http requests to avoid blocking the server\n- Intellisense\n    - Function Helps\n    - Parameters\n- ERRORS:   \n    - Add Snippet hides children\n    - Bootstrap bleeds into WS Result\n    - TypeError: Cannot read property 'appendChild' of undefined\n    - Fix Communications issue (kind of fixed there is a discrepancy between 60 seconds timeout and 100 seconds timeout resulting in 40 dead seconds)\n    - FSAutoCompleteIntermediaryClient does not work with Demo CodeMirror\n\n- Give it an icon that says F# Station\n\n        - Allow non text entries: like images, documents, links(text?) and other resources, maybe using 64 encoding\n        - Also it could be used as input for some code (although not too clear on how to do this, it may require serving the data as a web file)\n            - To store it in server it would make sense to split the snippets as entry in a DB so the server would not need to read a whole file\n              just to serve a snippet\n- Create website load/upload/invoke/precompiled code\n- The editor could have dual mode: server DB and local file\n    - For a website definition it would need to track read/write access to snippets\n\n\n- Implement Tab(s) & Application deployment including configurable editor(s)\n- Block non local use of Evaluate F# (unless logged in and with permission)\n- add HTTPS\n- Give it a web site look\n\nSOLVED:\n            - Some snippet could be generated from others: for instance as js from F#, the snippet maintains the dependence and could also maintain the ages\n              and know when a snippet needs to be regenerated.\n        - Allow other modes for some entries: MarkDown, html, etc. \n        - That way different type of content could be integrated into code with different techniques for merging: css, html, javascript, c#, MarkDown and others\n- Have non indenting nested elements just for folder organization    \n    - it could be a flag in the name/code\n    - it could be an external attribute, like MIME type/subtype \n    - it could be related to the other type of content considered for the future\n- Use properties to enable/disable actions like Non Indent code\n- Download/Open .fsjson from Website\n- Eliminate fixit2 hack hardcoded namespace dependency\n    - Warnings in Websharper generated JavaScript are commented out this way: \\/* *\\/\n    - Buttons are hidden when pane too small\n- Use properties to enable/disable actions like Compile WS, Run WS, Evaluate F#, Parse F#\n    - Incomplete Parse when typing fast\n- Transfer server code to FSharpStation\n- Keep scroll at same level after redrawing list of snippets\n- FsTranslator loads from scratch every time, change it so it stays in memory as an agent\n- FsTranslator accumulates assemblies in memory - separate into an executable so it can be cleaned up\n- Speed up snippet list interaction: used ResetableMemoize\n- Speed up code construction for reparse\n- Separate parsing and compilation errors from output and other message windows like javascript, and F# and others\n- Click on Error Message jumps to location\n- Intellisense\n    - Jump to definition\n    - Autocompletion\n    - Code tips\n    - Make tooltips pop-up not Alert\n    - Error highlight\n- Reissue FSharpStation awaitRequestFor\n- Create splitter template: grid template with splitters included\n- Change the title so that it says F# Station\n- Implement command start: webserver + editor\n- Think how to mix WebSharper and no WebSharper code without duplicating: they can be shared and use #define WEBSHARPER to add [< JavaScript >]\n- Get rid of undefined message when running JS and maybe show possible result value\n- Get rid of no output warning when Evaluating FS and say Done!\n- Store last state in local storage:  splitter position/ execute/ file name/ dirty state\n- Create non-Javascript invocation (pure .Net F#) version for only local use.\n- Capture Asynchronous exceptions\n- Detect dirty state and not allow Load/close before saving\n    - Download ( Save as ...) with automatic extension\n- make Choose File and Load one action and one button\n- Limit undo to the current field\n- Error:\nCompiling...\nRunning...\nFailed!\nTypeError: Cannot read property 'appendChild' of undefined  // it was due to the busy CPU taking longer than 300ms to load. Changed to 600ms.\n- ERRORS:    \n    - Jump to top of document when fast editing. Fixed it with some clever counters but it feels as if there should be a better way maybe using Event and FRP\n","predecessors":[],"id":{"$":0,"Item":"b4b48226-deb9-44da-98de-e2bf5b7cd889"},"expanded":true,"level":0,"levelCode":0,"properties":{"Mode":"none","DisableParse":"1"}}]