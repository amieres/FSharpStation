[{"name":"","content":"READ ME!\n\n\n- Organize your code in snippets group them by theme, keep them all in one place, all your projects big and small\n- Use snippet predecessors to assemble your solution\n- Create one big code infrastructure that can be reused and refined over and over.\n- Code, try, test, compile, run your code\n- Intellisense (for now):\n    - Tooltips (double-click or F2)\n    - Error highlighting\n    - Auto completion\n    - Find Definition\n- Run it immediately with almost zero scaffolding\n- Produce JavaScript using Websharper and run it in your browser immediately\n- Dependencies are equivalent to `#load \"<file.fsx>\"` or include directives\n\n- Evaluate F# does not return the last value calculated, only what is printed to the output\n\n- Ctrl-Space for autocomplete\n- double click or F2 for tooltips\n- Parse F# is sometimes necessary","predecessors":[],"id":{"$":0,"Item":"bc0d0abf-9c94-48bb-b46e-92e5d539b172"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"PENDING:\n- Download/Open .fsjson from Website\n- Add version counter for F# Station and display it\n- When compiling FSharpStation:\nWebSharper warning: Failed to load return type 'FSSGlobal.FSAutoComplete+CommandResponse+Kind, FSAutoCompleteDll' \nto verify encoding to JSON. at FSSGlobal.FSAutoComplete.sendMessageRpc\n- Allow plugable Add in commands\n- Use properties to enable/disable actions like Compile WS, Run WS, Evaluate F#, Parse F#, Non Indent code\n- Highlight snippets with errors\n- Add global search \n- back/forward browser functionality button (using #address preferrably)\n- Flush FsiExe MailBoxProcessor if 5 messages are waiting / or add a button for flushing\n- Keep count/ increase pending Http requests to avoid blocking the server\n- Intellisense\n    - Function Helps\n    - Parameters\n- ERRORS:   \n    - Add Snippet hides children\n    - Buttons are hidden when pane too small\n    - Bootstrap bleeds into WS Result\n    - TypeError: Cannot read property 'appendChild' of undefined\n    - Fix Communications issue (kind of fixed there is a discrepancy between 60 seconds timeout and 100 seconds timeout resulting in 40 dead seconds)\n    - Warnings in Websharper generated JavaScript are commented out this way: \\/* *\\/\n    - FSAutoCompleteIntermediaryClient does not work with Demo CodeMirror\n\n- Give it an icon that says F# Station\n\n- Have non indenting nested elements just for folder organization    \n    - it could be a flag in the name/code\n    - it could be an external attribute, like MIME type/subtype \n    - it could be related to the other type of content considered for the future\n        - Allow non text entries: like images, documents, links(text?) and other resources, maybe using 64 encoding\n        - Allow other modes for some entries: MarkDown, html, etc. \n        - That way different type of content could be integrated into code with different techniques for merging: css, html, javascript, c#, MarkDown and others\n        - Also it could be used as input for some code (although not too clear on how to do this, it may require serving the data as a web file)\n            - To store it in server it would make sense to split the snippets as entry in a DB so the server would not need to read a whole file\n              just to serve a snippet\n            - Some snippet could be generated from others: for instance as js from F#, the snippet maintains the dependence and could also maintain the ages\n              and know when a snippet needs to be regenerated.\n- Create website load/upload/invoke/precompiled code\n- The editor could have dual mode: server DB and local file\n    - For a website definition it would need to track read/write access to snippets\n\n- Eliminate fixit2 hack hardcoded namespace dependency\n\n- Implement Tab(s) & Application deployment including configurable editor(s)\n- Block non local use of Evaluate F# (unless logged in and with permission)\n- add HTTPS\n- add # routing to get to specific snippets\n- Give it a web site look\n\nSOLVED:\n    - Incomplete Parse when typing fast\n- Transfer server code to FSharpStation\n- Keep scroll at same level after redrawing list of snippets\n- FsTranslator loads from scratch every time, change it so it stays in memory as an agent\n- FsTranslator accumulates assemblies in memory - separate into an executable so it can be cleaned up\n- Speed up snippet list interaction: used ResetableMemoize\n- Speed up code construction for reparse\n- Separate parsing and compilation errors from output and other message windows like javascript, and F# and others\n- Click on Error Message jumps to location\n- Intellisense\n    - Jump to definition\n    - Autocompletion\n    - Code tips\n    - Make tooltips pop-up not Alert\n    - Error highlight\n- Reissue FSharpStation awaitRequestFor\n- Create splitter template: grid template with splitters included\n- Change the title so that it says F# Station\n- Implement command start: webserver + editor\n- Think how to mix WebSharper and no WebSharper code without duplicating: they can be shared and use #define WEBSHARPER to add [< JavaScript >]\n- Get rid of undefined message when running JS and maybe show possible result value\n- Get rid of no output warning when Evaluating FS and say Done!\n- Store last state in local storage:  splitter position/ execute/ file name/ dirty state\n- Create non-Javascript invocation (pure .Net F#) version for only local use.\n- Capture Asynchronous exceptions\n- Detect dirty state and not allow Load/close before saving\n    - Download ( Save as ...) with automatic extension\n- make Choose File and Load one action and one button\n- Limit undo to the current field\n- Error:\nCompiling...\nRunning...\nFailed!\nTypeError: Cannot read property 'appendChild' of undefined  // it was due to the busy CPU taking longer than 300ms to load. Changed to 600ms.\n- ERRORS:    \n    - Jump to top of document when fast editing. Fixed it with some clever counters but it feels as if there should be a better way maybe using Event and FRP\n","predecessors":[],"id":{"$":0,"Item":"b4b48226-deb9-44da-98de-e2bf5b7cd889"},"expanded":true,"level":0,"properties":{}},{"name":"FSSGlobal","content":"#nowarn \"1182\"\n#nowarn \"40\"\n#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\bin\\FSharp.Core.dll\"\n#if INTERACTIVE\n//#I @\"../WebServer/bin\"\nmodule FSSGlobal   =\n#else\nnamespace FSSGlobal\n#endif\n","predecessors":[],"id":{"$":0,"Item":"bf864f3c-1370-42f2-ac8a-565a604892e8"},"expanded":true,"level":0,"properties":{}},{"name":"F# Code","content":"// Code to be evaluated using FSI: `Evaluate F#`","parent":{"$":0,"Item":"bf864f3c-1370-42f2-ac8a-565a604892e8"},"predecessors":[],"id":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"expanded":false,"level":0,"properties":{}},{"name":"open WebSharper","content":"#if WEBSHARPER\n#I @\"..\\packages\\Zafir\\lib\\net40\"\n\n#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Core.JavaScript.dll\"\n#r @\"WebSharper.Collections.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.JavaScript.dll\"\n#r @\"WebSharper.Web.dll\"\n#r @\"WebSharper.Sitelets.dll\"\n#r @\"..\\packages\\Zafir.UI.Next\\lib\\net40\\WebSharper.UI.Next.dll\"\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI.Next\nopen WebSharper.UI.Next.Client\ntype on   = WebSharper.UI.Next.Html.on\ntype attr = WebSharper.UI.Next.Html.attr\n#endif","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},"expanded":true,"level":0,"properties":{}},{"name":"Useful","content":"#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule Useful =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"expanded":false,"level":0,"properties":{}},{"name":"Result, Wrap","content":"open System\n#nowarn \"1178\"\n#if WEBSHARPER\n[<JavaScript>]\n#endif\nmodule Option =\n    let defaultValue v =\n        function\n        | Some x -> x\n        | None   -> v\n\n    let defaultWith f =\n        function\n        | Some x -> x\n        | None   -> f()\n\n    let call v = \n        function\n        | None   -> None\n        | Some f -> f v |> Some\n\n    let iterF v = \n        function\n        | None   -> ()\n        | Some f -> f v\n\n    let iterFO vO fO = \n        match vO, fO with\n        | Some v, Some f -> f v\n        | _     , _      -> ()\n\n    let apply vO fO =\n        match vO, fO with\n        | Some v, Some f -> f v |> Some\n        | _     , _      -> None\n\n    let modify modifier = Option.map (fun f -> modifier f) >> defaultValue id\n      \n\n//#nowarn \"25\"\ntype ErrMsg = \n    abstract member ErrMsg   : string\n    abstract member IsWarning: bool\n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\ntype ExceptionThrown(exn:Exception) =\n    interface ErrMsg with\n        member this.ErrMsg   : string = sprintf \"%A\" exn\n        member this.IsWarning: bool   = false\n    override this.ToString() = (this :> ErrMsg).ErrMsg\n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\ntype ErrOptionIsNone() =\n    interface ErrMsg with\n        member this.ErrMsg   : string = \"Option is None\"\n        member this.IsWarning: bool   = false\n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\ntype ErrSimple(msg, warning) =\n    interface ErrMsg with\n        member this.ErrMsg   : string = msg\n        member this.IsWarning: bool   = warning\n    override this.ToString() = (this :> ErrMsg).ErrMsg\n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\ntype Result<'TSuccess> = Result of 'TSuccess option * ErrMsg list     \n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\nmodule Result =\n    let inline succeed             x       = Result (Some x           , [  ]             )\n    let inline succeedWithMsg      x  m    = Result (Some x           , [m ]             )\n    let inline succeedWithMsgs     x  ms   = Result (Some x           ,  ms              )\n    let inline fail                   m    = Result (None             , [m ]             )\n    let inline failWithMsgs           ms   = Result (None             ,  ms              )\n    let inline map       f (Result(o, ms)) = Result (o |> Option.map f,  ms              )\n    let inline mapMsg    f (Result(o, ms)) =        (o                ,  ms |> List.map f)\n    let inline mapMsgs   f (Result(o, ms)) =        (o                ,  ms |>          f)\n    let inline getOption   (Result(o, _ )) =         o                   \n    let inline getMsgs     (Result(_, ms)) =                             ms\n    let inline mergeMsgs              ms r = Result (r |> mapMsgs   ((@) ms) )\n    let inline combine     (Result(_, ms)) = mergeMsgs ms\n    let inline bind      f (Result(o, ms)) = \n        match o with\n        | Some x   -> match f x with Result(o2, ms2) -> Result(o2, ms @ ms2)\n        | None     -> Result(None, ms)\n    let inline apply (Result(fO, fMs))  (Result(o , ms)) = \n        match fO, o with\n        | Some f, Some x -> Result(f x |> Some, fMs @ ms)\n        | _              -> Result(None       , fMs @ ms)\n\n\n    let (|Success|Failure|) =\n        function \n        | Result(Some x, ms) -> Success (x, ms) \n        | Result(None  , ms) -> Failure     ms  \n\n    let x = function\n              | Success (x, ms) -> \"yes\"\n              | Failure     ms  -> \"No\"\n\n//    let successTee f result =                           // given an RopResult, call a unit function on the success branch\n//        let fSuccess (x,msgs) =                         // and pass thru the result\n//            f (x,msgs)\n//            Success (x,msgs) \n//        either fSuccess Failure result\n//\n//    let fFailure2 f errs = \n//        f errs\n//        Failure errs \n//    let failureTee f result =                           /// given an RopResult, call a unit function on the failure branch\n//        either Success (fFailure2 f) result\n//\n//    let mapMessagesR f result =                         /// given an RopResult, map the messages to a different error type\n//        match result with \n//        | Success (x,msgs) -> \n//            let msgs' = List.map f msgs\n//            Success (x, msgs')\n//        | Failure errors -> \n//            let errors' = List.map f errors \n//            Failure errors' \n//\n//    let valueOrDefault f result =                       /// given an RopResult, in the success case, return the value.\n//        match result with                               /// In the failure case, determine the value to return by \n//        | Success (x,_) -> x                            /// applying a function to the errors in the failure case\n//        | Failure errors -> f errors\n//\n//    let failIfNone message = function                   /// lift an option to a RopResult.\n//        | Some x -> succeed x                           /// Return Success if Some\n//        | None -> fail message                          /// or the given message if None\n//\n//    let failIfNoneR message = function                  /// given an RopResult option, return it\n//        | Some rop -> rop                               /// or the given message if None\n//        | None -> fail message \n\n    let failException e = ExceptionThrown(e) :> ErrMsg\n\n///            tryCall: (exn -> Result<'b>) ->  ('a -> Result<'b>) -> 'a -> Result<'b> =\n    let inline tryCall (f:'a -> Result<'b>) (v:'a) : Result<'b> = try f v with e -> failException e |> fail\n\n    type ropBuilder() =\n        member inline this.Return     (x)                       = succeed x\n        member inline this.ReturnFrom (x)                       = x\n        member        this.Bind       (w:Result<'a>, r: 'a -> Result<'b>) = bind (tryCall r) w\n        member inline this.Using      (disposable, restOfCExpr) = using disposable restOfCExpr\n        member inline this.Zero       ()                        = succeed ()\n        member inline this.Delay      (f)                       = f()\n        member inline this.Combine    (a, b)                    = combine a b\n//        member this.Run        (f)                       = f\n//        member this.While(guard, body) =\n//            if not (guard()) \n//            then this.Zero() \n//            else this.Bind( body(), fun () -> \n//                this.While(guard, body))  \n//        member this.For(sequence:seq<_>, body) =\n//            this.Using(sequence.GetEnumerator(),fun enum -> \n//                this.While(enum.MoveNext, \n//                    this.Delay(fun () -> body enum.Current)))\n\n    let result = ropBuilder()\n//    let inline flow_ () = new ropBuilder ()\n\n    let fromChoice context c =\n        match c with | Choice1Of2 v -> succeed v\n                     | Choice2Of2 e -> fail    e\n\n    let fromOption m =\n        function | None   -> fail    m\n                 | Some v -> succeed v\n\n    let toOption (Result(o, _)) = o\n\n    let tryProtection() : Result<unit> = succeed ()\n\n    let failIfFalse m v : Result<unit>  = if v then succeed () else m |> fail \n    let failIfTrue  m v : Result<unit>  = if v then m |> fail  else succeed () \n            \n    let ifError   def (Result(o, _ )) = o |> Option.defaultValue            def\n    let withError f   (Result(o, ms)) = o |> Option.defaultWith  (fun () -> f ms)\n\n//    let processMessages mtype (msgs: PossibleMessages list) =\n//        msgs\n//        |> List.iter (fun o -> WebSharper.JavaScript.JS.Alert     <| mtype + \": \" + (sprintf \"%A\" o)\n//                               WebSharper.JavaScript.Console.Log o)\n//\n//    let notifyMessages R =\n//        match R with | Success (_, m) -> processMessages \"N\" m\n//                     | Failure     m  -> processMessages \"E\" m\n//\n//    let messagesDo f =\n//        function | Success (_, ms) -> f false ms\n//                 | Failure     ms  -> f true  ms\n\n    let seqCheck s = \n        s \n        |> (fun elems -> match      elems |> Seq.exists(function | Failure _    -> true    | _ -> false) with\n                         | true  -> elems |> Seq.pick  (function | Failure ms   -> Some ms | _ -> None ) |> failWithMsgs\n                         | false -> elems |> Seq.map   (function | Result (vO,_)-> vO.Value            ) |> succeed\n        )\n\n    let getMessages   (ms: ErrMsg list) = ms |> List.map (fun m -> m.ErrMsg) |> String.concat \"\\n\"\n    let countMessages (ms: ErrMsg list) =\n        if ms = [] then \"\" else\n        let errors   = ms |> List.filter(fun m -> m.IsWarning |> not)\n        let warnings = ms |> List.filter(fun m -> m.IsWarning       )\n        match errors.Length, warnings.Length with\n        | 0, 0 -> sprintf \"%s\"\n        | 1, 0 -> sprintf \"%s\"\n        | 0, 1 -> sprintf \"%s\"\n        | 1, 1 -> sprintf \"1 error, 1 warning\\n%s\"\n        | e, 0 -> sprintf \"%d errors\\n%s\" e\n        | 0, w -> sprintf \"%d warnings\\n%s\" w\n        | e, w -> sprintf \"%d errors, %d warnings\\n%s\" e w\n        <| getMessages ms\n \nopen Result\n\ntype Wrap<'T> =\n| WResult of Result<'T>\n| WAsync  of Async<'T>\n| WAsyncR of Async<Result<'T>>\n| WSimple of 'T\n| WOption of 'T option\n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\nmodule Wrap =\n    let errOptionIsNone = ErrOptionIsNone() :> ErrMsg\n\n    let wb2arb ms = \n        function\n        | WAsync       ab  -> async { let!   b = ab\n                                      return succeedWithMsgs b                   ms }\n        | WAsyncR     arb  -> async { let!   rb = arb                               \n                                      return rb |> mergeMsgs                     ms }\n        | WResult      rb  -> async { return rb |> mergeMsgs                     ms }\n        | WSimple       b                                                           \n        | WOption (Some b) -> async { return succeedWithMsgs b                   ms }\n        | WOption None     -> async { return failWithMsgs      (errOptionIsNone::ms)}\n\n    let tryCall (f: 'a -> Wrap<'b>) (a:'a) = \n        try f a \n        with e -> failException e |> fail |> WResult\n\n    let bind (f: 'a -> Wrap<'b>) (wa: Wrap<'a>) :Wrap<'b> =\n        match wa with\n        | WSimple         a       \n        | WOption(Some    a)       \n        | WResult(Success(a, [])) -> tryCall f a\n        | WOption None            -> None            |> WOption\n        | WResult(Failure    ms ) -> failWithMsgs ms |> WResult \n        | WResult(Success(a, ms)) -> tryCall f a\n                                     |> function\n                                     | WSimple         b              \n                                     | WOption(Some    b     ) -> succeedWithMsgs b  ms             |> WResult \n                                     | WOption None            -> failWithMsgs (errOptionIsNone::ms)|> WResult\n                                     | WResult(Success(b, [])) -> succeedWithMsgs b  ms             |> WResult \n                                     | WResult(Success(b, m2)) -> succeedWithMsgs b (ms @ m2)       |> WResult \n                                     | WResult(Failure    m2)  -> failWithMsgs      (ms @ m2)       |> WResult \n                                     | WAsync  ab              -> async { let!  b = ab\n                                                                          return succeedWithMsgs b ms\n                                                                  } |> WAsyncR\n                                     | WAsyncR arb             -> async { let! rb = arb\n                                                                          return mergeMsgs ms rb\n                                                                  } |> WAsyncR\n        | WAsync         aa       -> async {\n                                         let! a  = aa\n                                         return! tryCall f a |> wb2arb []\n                                     } |> WAsyncR\n        | WAsyncR       ara       -> async {\n                                         let! ar  = ara\n                                         let  arb = match ar with\n                                                    | Success(a, ms) -> tryCall f a |> wb2arb ms\n                                                    | Failure    ms  -> async { return failWithMsgs ms }\n                                         return! arb\n                                     } |> WAsyncR\n    let Return = WSimple \n    let map  (f: 'a -> 'b  ) = bind (f >> Return)     \n\n    let wrapper2Async (f: 'a -> Wrap<'b>) a : Async<Result<'b>> =\n        let wb = tryCall f a\n        match wb with\n        | WSimple _\n        | WOption _               -> wb |> wb2arb []\n        | WResult (Result(_, ms)) -> wb |> wb2arb ms\n        | WAsync  ab              -> async { let!   b = ab\n                                             return succeed b }\n        | WAsyncR arb              -> arb\n\n    let addMsgs errOptionIsNone ms wb =\n        if ms = [] then wb else\n        match wb with\n        | WSimple          v       \n        | WOption (Some    v)      -> WResult (succeedWithMsgs                        v ms)\n        | WOption (None     )      -> WResult (fail errOptionIsNone |> Result.mergeMsgs ms)\n        | WResult r                -> WResult (r                    |> Result.mergeMsgs ms)\n        | WAsync           va      -> async {\n                                        let! v = va\n                                        return succeedWithMsgs v ms\n                                      } |> WAsyncR\n        | WAsyncR          vra     -> async {\n                                        let! vr = vra\n                                        return vr                    |> Result.mergeMsgs ms\n                                      } |> WAsyncR\n\n    let combine errOptionIsNone wa wb =\n        match wa with\n        | WSimple          _\n        | WOption (Some    _)\n        | WResult (Result (_, []))\n        | WAsync           _       -> wb\n        | WAsyncR          _       -> wb\n        | WOption (None     )      -> wb |> addMsgs errOptionIsNone [errOptionIsNone]\n        | WResult (Result(_, ms))  -> wb |> addMsgs errOptionIsNone ms\n\n    type Builder() =\n//        member        this.Bind (wrapped: Async<Result<'a>>, restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WAsyncR |> bind restOfCExpr //<< cannot differentiate from next \n        member        this.Bind (wrapped: Wrap<'a>         , restOfCExpr: 'a -> Wrap<'b>) = wrapped            |> bind restOfCExpr \n        member        this.Bind (wrapped: Async<'a>        , restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WAsync  |> bind restOfCExpr  \n        member        this.Bind (wrapped: Result<'a>       , restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WResult |> bind restOfCExpr \n        member        this.Bind (wrapped: 'a option        , restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WOption |> bind restOfCExpr \n        member inline this.Zero         ()  = WSimple ()\n        member inline this.Return       (x) = WSimple x\n        member inline this.ReturnFrom   (w) = w\n//        member inline this.ReturnFrom   (w) = WAsync  w\n//        member inline this.ReturnFrom   (w) = WResult w\n//        member inline this.ReturnFrom   (w) = WOption w        \n        member inline this.Delay        (f) = f()\n        member        this.Combine   (a, b) = combine errOptionIsNone a b\n        member        this.Using (resource, body: 'a -> Wrap<'b>) =\n            async.Using(resource, wrapper2Async body) |> WAsyncR\n                    \n    let wrapper = Builder()\n\n    let getResult callback (wb: Wrap<'T>) =\n        match wb with\n        | WSimple      s  -> s               |> succeed                                      |> callback\n        | WOption(Some s) -> s               |> succeed                                      |> callback\n        | WOption None    -> errOptionIsNone |> fail                                         |> callback\n        | WResult      rb -> rb                                                              |> callback\n        | WAsync       ab -> Async.StartWithContinuations(ab , (fun v   -> succeed v         |> callback), \n                                                               (fun exc -> failException exc |> fail |> callback), \n                                                                fun can -> failException can |> fail |> callback)\n        | WAsyncR     arb -> Async.StartWithContinuations(arb,                                          callback , \n                                                               (fun exc -> failException exc |> fail |> callback), \n                                                                fun can -> failException can |> fail |> callback)\n\n    let inline getAsyncR (wb: Wrap<'T>) =\n        match wb with\n        | WAsync      va  -> async {\n                               let! v = va\n                               return      succeed                           v}\n        | WSimple     v   -> async.Return (succeed                           v)\n        | WOption     v   -> async.Return (Result.fromOption errOptionIsNone v)\n        | WResult     v   -> async.Return                                    v\n        | WAsyncR     vra -> vra\n        \n    let inline getAsyncWithDefault f (wb: Wrap<'T>) = \n        async {\n            let!   vR = getAsyncR wb\n            return vR |> Result.withError f\n        }\n\n    let inline getAsync w =\n        match w with\n        | WAsync      va  ->              va\n        | WSimple     v   -> async.Return v\n        | WOption     vo  -> async {\n                                return\n                                    match vo with \n                                    | Some v         -> v\n                                    | None           -> raise (exn(getMessages [errOptionIsNone]))\n                             }\n        | WResult     vr  -> async {\n                                return\n                                    match vr with \n                                    | Success (v, _) -> v\n                                    | Failure ms     -> raise (exn(getMessages ms))\n                             }\n        | WAsyncR     vra -> async {\n                                let! vr = vra\n                                return\n                                    match vr with \n                                    | Success (v, _) -> v\n                                    | Failure ms     -> raise (exn(getMessages ms))\n                             }\n//    let call wb = wb |> getR Rop.notifyMessages\n    let startV (processVal: ('t option * string) ->unit) (w: Wrap<'t>) =\n        w\n        |> getAsyncR\n        |> fun asy -> Async.StartWithContinuations\n                        (asy \n                       , Result.mapMsgs Result.getMessages  >> processVal\n                       , sprintf \"%A\" >> (fun m -> None, m) >> processVal\n                       , sprintf \"%A\" >> (fun m -> None, m) >> processVal)\n                       \n    let start (printMsg: string->unit) (w: Wrap<unit>) = \n        startV (function\n                | Some (), msgs ->               msgs |> printMsg \n                | None   , msgs -> \"Failed!\\n\" + msgs |> printMsg) w\n\n#if WEBSHARPER\n    [< Inline \"console.log('runSynchronously should not be used in Javascript')\" >]                       \n#endif\n    let runSynchronouslyR (w: Wrap<_>) =\n        w\n        |> getAsyncR\n        |> Async.RunSynchronously\n    let runSynchronouslyO count (w: Wrap<_>) =\n        w\n        |> runSynchronouslyR\n        |> (Result.mapMsgs (if count then Result.countMessages else Result.getMessages))\n    let runSynchronouslyS count (w: Wrap<_>) =\n        w\n        |> runSynchronouslyO count\n        |> function\n           | Some r, msgs -> sprintf \"%O\\n%s\" r    msgs\n           | None  , msgs -> sprintf \"Failed!\\n%s\" msgs\n           \n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\ntype Wrap<'T> with\n    static member Start           (w:Wrap<_   >,           ?cancToken) = Async.Start           (Wrap.getAsync  w,                                ?cancellationToken= cancToken)\n    static member StartAsTask     (w:Wrap<'T  >, ?options, ?cancToken) = Async.StartAsTask     (Wrap.getAsyncR w, ?taskCreationOptions= options, ?cancellationToken= cancToken)\n#if WEBSHARPER\n    [< Inline \"console.log('RunSynchronously should not be used in Javascript')\" >]                       \n#endif\n    static member RunSynchronously(w:Wrap<'T  >, ?timeout, ?cancToken) = Async.RunSynchronously(Wrap.getAsyncR w, ?timeout            = timeout, ?cancellationToken= cancToken)\n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},"expanded":true,"level":0,"properties":{}},{"name":"extract, now, Async","content":"let extract n (s:string) = s.Substring(0, min n s.Length)\n\n#if WEBSHARPER\n[< Inline \"(function (n) { return n.getFullYear() + '-' +(n.getMonth() + 1) + '-' +  n.getDate() + ' '+n.getHours()+ ':'+n.getMinutes()+ ':'+n.getSeconds()+ ':'+n.getMilliseconds() })(new Date(Date.now()))\" >]\n#endif\nlet nowStamp() = System.DateTime.UtcNow.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n\nmodule Async =\n    let map f va = \n        async { \n            let! a = va\n            return f a \n        } ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"7a655466-e218-4121-a7b6-f9c70a922e07"},"expanded":true,"level":0,"properties":{}},{"name":"parseInt","content":"let tryParseWith tryParseFunc = tryParseFunc >> function\n        | true, v    -> Some v\n        | false, _   -> None\n\nlet parseDate   = tryParseWith System.DateTime.TryParse\nlet parseInt    = tryParseWith System.Int32.TryParse\nlet parseSingle = tryParseWith System.Single.TryParse\nlet parseDouble = tryParseWith System.Double.TryParse\n// etc.\n\n// active patterns for try-parsing strings\nlet (|Date|_|)   = parseDate\nlet (|Int|_|)    = parseInt\nlet (|Single|_|) = parseSingle\nlet (|Double|_|) = parseDouble","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"af2b60c6-a99f-433d-b938-f59fefe66c01"},"expanded":true,"level":0,"properties":{}},{"name":"REGEX","content":"#if WEBSHARPER\n\nlet (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n    if value = null then None else\n    try \n        match JavaScript.String(value).Match(RegExp(expr, opt)) with\n        | null         -> None\n        | [| |]        -> None\n        | m            -> Some m\n    with e -> None\n#endif\n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},"expanded":true,"level":0,"properties":{}},{"name":"swap","content":"let inline swap f a b = f b a\n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"657c8f34-c917-4659-825d-c9ead206efcf"},"expanded":true,"level":0,"properties":{}},{"name":"memoize","content":"#if WEBSHARPER\n[< Inline >]\n#endif\nlet memoize f = \n    let cache = System.Collections.Generic.Dictionary<_, _>()\n    fun x -> \n        let mutable res = Unchecked.defaultof<_>\n        let ok = cache.TryGetValue(x, &res)\n        if ok then res \n        else let res = f x\n             cache.[x] <- res\n             res\n             \ntype ResetableMemoize(f) =             \n    let cache = System.Collections.Generic.Dictionary<_, _>()\n    member this.ClearCache() = cache.Clear()\n    #if WEBSHARPER\n    [< Inline >]\n    #endif\n    member this.Call x =\n        let mutable res = Unchecked.defaultof<_>\n        let ok = cache.TryGetValue(x, &res)\n        if ok then res \n        else let res = f x\n             cache.[x] <- res\n             res\n    ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"8efdcd5a-95c4-4212-9c75-1ebedce83dd8"},"expanded":true,"level":0,"properties":{}},{"name":"separateDirectives","content":"type PreproDirective =\n| PrepoR      of string\n| PrepoDefine of string\n| PrepoLoad   of string\n| PrepoLine   of string //* int\n| PrepoNoWarn of string\n| PrepoI      of string\n| PrepoIf     of string\n| PrepoElse   \n| PrepoEndIf\n| PrepoLight  of bool\n| PrepoOther  of string\n| NoPrepo\n\nlet separatePrepros removePrepoLine (code:string[]) =\n    let  quoted (line:string) = line.Trim().Split([| \"\\\"\"       |], System.StringSplitOptions.RemoveEmptyEntries) |> Seq.tryLast |> Option.defaultValue line\n    let  define (line:string) = line.Trim().Split([| \"#define \" |], System.StringSplitOptions.RemoveEmptyEntries) |> Seq.tryHead |> Option.defaultValue \"\"\n    let  comment = ((+)\"//\") \n    let  preL    = if removePrepoLine then comment else id \n    let  prepro (line:string) = match true with \n                                | true when line.StartsWith(\"#define\") -> (comment line, line |> define |> PrepoDefine)\n                                | true when line.StartsWith(\"#r\"     ) -> (comment line, line |> quoted |> PrepoR     )\n                                | true when line.StartsWith(\"#load\"  ) -> (comment line, line |> quoted |> PrepoLoad  )\n                                | true when line.StartsWith(\"#nowarn\") -> (comment line, line |> quoted |> PrepoNoWarn)\n                                | true when line.StartsWith(\"# \"     ) -> (preL    line, line |> quoted |> PrepoLine  )\n                                | true when line.StartsWith(\"#line\"  ) -> (preL    line, line |> quoted |> PrepoLine  )\n                                | true when line.StartsWith(\"#I\"     ) -> (comment line, line |> quoted |> PrepoI     )\n                                | true when line.StartsWith(\"#if\"    ) -> (        line, line           |> PrepoIf    )\n                                | true when line.StartsWith(\"#else\"  ) -> (        line,                   PrepoElse  )\n                                | true when line.StartsWith(\"#endif\" ) -> (        line,                   PrepoEndIf )\n                                | true when line.StartsWith(\"#light\" ) -> (        line, false          |> PrepoLight )\n                                | true when line.StartsWith(\"#\"      ) -> (comment line, line           |> PrepoOther )\n                                | _                                    -> (        line,                   NoPrepo    ) \n    code |> Array.map prepro\n    \nlet separateDirectives (fsNass:(string * PreproDirective) seq) =\n    let  assembs  = fsNass |> Seq.choose (snd >> (function | PrepoR assemb -> Some assemb | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  defines  = fsNass |> Seq.choose (snd >> (function | PrepoDefine d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  prepoIs  = fsNass |> Seq.choose (snd >> (function | PrepoI      d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  nowarns  = fsNass |> Seq.choose (snd >> (function | PrepoNoWarn d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  code     = fsNass |> Seq.map     fst                                                                           |> Seq.toArray\n    code, assembs, defines, prepoIs, nowarns\n\n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"ace1fc12-3dfb-4db8-80c9-5bde1e7d0597"},"expanded":true,"level":0,"properties":{}},{"name":"Save File","content":"open System.IO\n\nlet backupFile file = \n    try File.Delete(      file + \".bak\") with _ -> ()\n    try File.Copy  (file, file + \".bak\") with _ -> ()\n\nlet inline saveFile (file:string) (content: string) =\n    Wrap.wrapper {\n        do! Result.tryProtection()\n        backupFile file\n        File.WriteAllText(file, content)\n    } \n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"let doSTA act =\n    let thread = System.Threading.Thread(System.Threading.ThreadStart act)\n    thread.SetApartmentState(System.Threading.ApartmentState.STA)\n    thread.Start()\n    \nlet sCopy       txt = \n    doSTA (fun () -> System.Windows.Forms.Clipboard.SetText txt)\n    sprintf \"Copied to clipboard: %s... (%d characters)\\n\\n\" <| txt.[..min (txt.Length - 1) 100 ] <| txt.Length \n    \nlet Copy        txt = \n    sCopy txt\n    |> printf \"%s\"\n    \nlet Paste f        = doSTA (fun () -> f System.Windows.Forms.Clipboard.GetText)   ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"c7e56d1e-aea8-483a-a99a-23b7e056de0d"},"expanded":true,"level":0,"properties":{}},{"name":"type ActionBar","content":"open System\nopen System.Text\nopen System.Drawing\nopen System.Windows.Forms\nopen System.ComponentModel\n\ntype GrowLabel (maxHeight:int) =\n  inherit Label() \n  let mutable mGrowing  = false\n  do base.AutoSize     <- false\n  member this.resizeLabel() =\n    if mGrowing then () else\n    try \n      mGrowing <- true\n      let sz       = new Size(base.Width, Int32.MaxValue)\n      let sz2      = TextRenderer.MeasureText(base.Text, base.Font, sz, TextFormatFlags.WordBreak)\n      base.Height <- min sz2.Height maxHeight\n    finally\n      mGrowing <- false\n  override this.OnTextChanged( e) = \n    base.OnTextChanged e\n    this.resizeLabel()\n  override this.OnFontChanged( e) =\n    base.OnFontChanged e\n    this.resizeLabel()\n  override this.OnSizeChanged( e) =\n    base.OnSizeChanged e\n    this.resizeLabel()\n\ntype ActionBar(actions:(string * (unit -> string)) seq) =\n    let label1 = new GrowLabel (Text = \"\", Width = 300, maxHeight = 100)\n    let newButton (txt:string) act =\n        let width = 300\n        if txt.StartsWith \"---\" || txt.StartsWith \"===\" then\n            let lbl = new Label(Text = txt, Width = width)\n            lbl :> Control\n        else\n            let btn = new Button(Text = txt, Width = width)\n            btn.Click.Add act\n            btn :> Control\n    \n    let form = new Form(Text = \"Select Action:\", Width = 400, Height = 800)\n    let panel1 = new Panel(Dock = DockStyle.Fill)\n    do  actions \n        |> Seq.map (fun (txt, f) -> newButton txt (fun _ -> label1.Text <- sprintf \"Processing %s ...\" txt\n                                                            form.Refresh()\n                                                            label1.Text <- f() ))\n        |> Seq.append [ label1 :> Control ]\n        |> Seq.toArray\n        |> panel1.Controls.AddRange\n        let reposition () =\n            panel1.Controls\n            |> Seq.cast\n            |> Seq.fold (fun (height, width) (cts: Control) -> \n                cts.Left <- 20 \n                cts.Top  <- height + 5\n                (height + cts.Height + 5, (max width cts.Width)) ) (0, 0)\n            |> (fun (height, width) -> form.Height <- height + 50 ; form.Width <- width + 50)\n        reposition ()\n        label1.Resize.Add (fun _ -> reposition () )\n        panel1.DockPadding.All <- 10\n        form.Controls.Add(panel1)\n        form.Activated.AddHandler(System.EventHandler (fun _ _ -> form.TopMost <- true(*; form.TopMost <- false*) ))\n        async {\n          do Application.Run(form) \n        } |> Async.Start\n       ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"16f618b6-0483-44dc-9c54-550f4f5b725d"},"expanded":true,"level":0,"properties":{}},{"name":"UsefulDotNet","content":"module UsefulDotNet =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"expanded":false,"level":0,"properties":{}},{"name":"Regex, Regexs","content":"#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\nopen System.Text.RegularExpressions\n\nlet (|Regex|_|) pattern input =\n    if input = null then None else\n    try \n        let m = Regex.Match(input, pattern)\n        if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])\n        else None\n    with e -> None\n\nlet (|Regexs|) pattern input =\n    if input = null then [| |] else\n    try \n        let ms = Regex.Matches(input, pattern)\n        [| for m in ms do yield m.Value |] \n    with e -> [| |]\n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[],"id":{"$":0,"Item":"7646acbc-2c28-4159-98b1-2365d19fc97c"},"expanded":true,"level":0,"properties":{}},{"name":"fSharpError2TranspilerError","content":"open Microsoft.FSharp.Compiler.SourceCodeServices\nopen Microsoft.FSharp.Compiler\nopen Useful\n\ntype FSharpErrors =\n    | WarningFSharp                 of string\n    | ErrFSharp                     of string\nwith interface ErrMsg with\n        member this.ErrMsg    = sprintf \"%A\"this\n        member this.IsWarning = match this with | WarningFSharp _ -> true | _ -> false\n\nlet getIndentFile input =\n    match input with\n    | Regex \"^\\\\((\\\\d+)\\\\)\\\\s(.*)$\" [_ ; indent ; file] -> int indent, file\n    | _                                                 -> 0         , input\n   \nlet fSharpError2TranspilerError (error : FSharpErrorInfo) =\n    let indent, file = System.IO.Path.GetFileNameWithoutExtension error.FileName |> getIndentFile  \n    sprintf \"%s (%d,%d) - (%d,%d) %s %d: %s\" \n       file \n       error.StartLineAlternate (error.StartColumn - indent) \n       error.EndLineAlternate   (error.EndColumn   - indent) \n       error.Subcategory error.ErrorNumber error.Message\n    |> (if   error.Severity = FSharpErrorSeverity.Error  \n        then ErrFSharp     \n        else WarningFSharp\n       )\n    :> ErrMsg\n    \n    ","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"7646acbc-2c28-4159-98b1-2365d19fc97c"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"9becc68c-9cc2-4f29-82df-e510d10226db"},"expanded":true,"level":0,"properties":{}},{"name":"ResourceAgent","content":"open Useful\n\ntype ResourceAgent<'T, 'C when 'C : equality>(restartAfter:int, ctor: 'C option ->'T, ?cleanup, ?isAlive, ?configuration: 'C) =\n    let mutable configuration = configuration\n    let mutable resource = ctor configuration\n    let respawn() =\n        cleanup |> Option.iter (fun clean -> clean resource) \n        resource <- ctor configuration\n    let agent    = \n        MailboxProcessor.Start(fun inbox ->\n            async {\n               while true do\n                 try\n                     for i in 1 .. restartAfter do\n                         let! config, work = inbox.Receive()\n                         isAlive |> Option.iter (fun alive -> if not (alive resource) then respawn())\n                         if config <> configuration then\n                            configuration <- config\n                            respawn()\n                         do!  work resource\n                     respawn()\n                 with _ -> respawn() \n            }\n        )\n    do agent.Error.AddHandler <| Handler (fun _ _ -> respawn())\n    member x.Process (work:'T -> Wrap<'a>, ?config) =\n        agent.PostAndAsyncReply\n            (fun reply ->\n                 (config, fun resource ->\n                          async {\n                               let! res = work resource |> Wrap.getAsyncR\n                               reply.Reply res\n                          } \n                 )\n            )\n    interface System.IDisposable with\n        member this.Dispose () =\n            try cleanup |> Option.iter (fun clean -> clean resource) with _ -> ()\n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"f930dc48-39e8-453c-8c77-18a2cd73637a"},"expanded":true,"level":0,"properties":{}},{"name":"TempFileName","content":"type TempFileName(fn) =\n    new () = new TempFileName(System.IO.Path.GetTempFileName())\n    member this.Name = fn\n    interface System.IDisposable with\n        member this.Dispose() = if System.IO.File.Exists fn then System.IO.File.Delete fn\n        \n        ","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[],"id":{"$":0,"Item":"4137cad8-fd64-426e-98de-16a92a56388d"},"expanded":true,"level":0,"properties":{}},{"name":"runProcess","content":"open System.Diagnostics\nopen System.Text\nopen Useful\n\nlet runProcess p ops =\n    let procStart   = ProcessStartInfo(p, ops)\n    let proc        = new Process()\n    proc.StartInfo <- procStart\n    proc.Start() \n\ntype ShellExError =\n    | ShellExitCode              of int\n    | ShellOutput                of string\n    | ShellErrors                of string\n    | ShellFailWithMessage       of string\n    | ShellFinishedWithNoMessage \n    | ShellDidNotStart \n    | ShellCrashed               of string\nwith interface ErrMsg with\n        member this.ErrMsg    = \n            match this with \n            | ShellFailWithMessage msg   -> msg  \n            | ShellFinishedWithNoMessage -> \"warning - No output\"\n            | ShellOutput          msg   -> msg\n            | ShellCrashed         msg   -> \"Crashed \" + msg\n            | msg                        -> sprintf \"%A\" msg\n        member this.IsWarning =\n            match this with \n            | ShellFinishedWithNoMessage\n            | ShellOutput _              -> true\n            | _                          -> false \n\n\ntype ShellEx(startInfo: ProcessStartInfo) =\n    let proc                              = new Process()\n    let bufferOutput                      = new StringBuilder()\n    let bufferError                       = new StringBuilder()\n    let consume (sb: StringBuilder)       = \n        let v = sb.ToString()\n        sb.Clear() |> ignore\n        v\n    do  startInfo.RedirectStandardInput  <- true\n        startInfo.RedirectStandardOutput <- true\n        startInfo.RedirectStandardError  <- true\n        startInfo.UseShellExecute        <- false\n        proc.StartInfo                   <- startInfo\n        proc.EnableRaisingEvents         <- true\n        proc.OutputDataReceived.AddHandler(DataReceivedEventHandler(fun sender args -> try bufferOutput.Append(args.Data + \"\\n\") |> ignore with _ -> () ))\n        proc.ErrorDataReceived .AddHandler(DataReceivedEventHandler(fun sender args -> try bufferError .Append(args.Data + \"\\n\") |> ignore with _ -> () ))\n//        proc.Exited            .AddHandler(System.EventHandler     (fun sender args -> try proc.Close()                                    with _ -> () ))\n    new (program, args) =             \n        let startInfo                         = new ProcessStartInfo()\n        do  startInfo.FileName               <- program\n            startInfo.Arguments              <- args\n        new ShellEx(startInfo)\n    member this.Start() = \n        let r = proc.Start() \n        proc.BeginOutputReadLine()\n        proc.BeginErrorReadLine ()\n        r\n    member this.StartAndWait() =\n        let started = this.Start()\n        proc.WaitForExit()\n        let    output  = (consume bufferOutput).Trim()\n        let    error   = (consume bufferError ).Trim()\n        (output, error, if proc.HasExited then proc.ExitCode else -99999)\n    member this.StartAndWaitR() =\n        let out, errs, exit = this.StartAndWait()\n        if exit <> 0\n        then Result.failWithMsgs\n                [ if out  <> \"\"              then yield ErrSimple (\"stdout: \" + out           , true ) :> ErrMsg\n                  if errs <> \"\"              then yield ErrSimple (errs                       , false) :> ErrMsg\n                  if errs  = \"\" || exit <> 1 then yield ErrSimple (sprintf \"ExitCode: %d\" exit, false) :> ErrMsg\n                ]\n        else Result.succeedWithMsgs out \n                [ if errs <> \"\"              then yield ErrSimple (errs                       , false) :> ErrMsg ]\n    member this.Send(txt: string)   = proc.StandardInput.WriteLine txt\n    member this.Output  ()          = consume bufferOutput\n    member this.Error   ()          = consume bufferError\n    member this.Response(out:string, err:string)  = \n        match out.Trim(), err.Trim() with\n//        | \"\"  , \"\"  -> None\n        | good, \"\"  -> Some( Result.succeed        good                             )\n        | \"\"  , bad -> Some( Result.fail                <| ShellFailWithMessage bad )\n        | good, bad -> Some( Result.succeedWithMsg good <| ShellFailWithMessage bad )\n    member this.Response()          = this.Response(this.Output(), this.Error())\n    member this.SendAndWait(send, wait, ?onError) =\n        let eventWait = \n            if defaultArg onError false then proc.ErrorDataReceived else proc.OutputDataReceived\n            |> Event.choose (fun evArgs -> try evArgs.Data |> (fun v -> if v.Contains wait then Some <| Result.succeed v else None) with _ -> None)\n        let eventAll = Event.merge eventWait  (Event.map (fun _ -> Result.fail <| ShellCrashed startInfo.FileName) proc.Exited)\n        Wrap.wrapper {\n            do! Result.tryProtection()\n            async { \n                do!    Async.Sleep 20 \n                this.Send send        } |> Async.Start\n            let!   waitedR = Async.AwaitEvent eventAll\n            let!   waited  = waitedR\n            do!    Async.Sleep 200\n            let!   res =\n                   if defaultArg onError false then \n                       this.Response(this.Output(), this.Error() |> fun msg -> msg.Split([| waited |], System.StringSplitOptions.None) |> Array.head)\n                   else this.Response()\n                   |> Option.defaultWith (fun () -> Result.succeedWithMsg \"\" ShellFinishedWithNoMessage)\n            return res\n        }\n    member this.HasExited = try proc.HasExited with _ -> true\n    interface System.IDisposable with\n        member this.Dispose () =\n            try proc.Kill   () with _ -> ()\n            try proc.Close  () with _ -> ()\n            try proc.Dispose() with _ -> ()\n\n\nlet runProcess2 p ops =\n    let procStart   = ProcessStartInfo(p, ops)\n    let shell       = new ShellEx(procStart)\n    shell.StartAndWaitR() \n\n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},"expanded":true,"level":0,"properties":{}},{"name":"copyIfMust","content":"open System.IO\n\nlet copyIfNotExistsToFile from dest =\n    let fit = FileInfo dest\n    if not fit.Exists then\n        File.Copy(from, dest, true )\n\nlet copyIfMustToFile from dest =\n    let fit = FileInfo dest\n    let must = \n        match fit.Exists with \n        | false -> true\n        | true  ->\n            let fif = FileInfo dest\n            fif.Length <> fit.Length || fif.LastWriteTime <> fit.LastWriteTime\n    if must then\n        File.Copy(from, dest, true )\n\nlet copyIfMustToDir from destDir =\n    let dest = Path.Combine(destDir, Path.GetFileName(from))\n    copyIfMustToFile from dest\n    ","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[],"id":{"$":0,"Item":"ab5ab0ca-eb45-4851-affe-4690bb75d055"},"expanded":true,"level":0,"properties":{}},{"name":"Path.Combine","content":"let inline (+/+) a b = System.IO.Path.Combine(a, b)","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[],"id":{"$":0,"Item":"15cf771f-22b1-4796-8e34-6c16f35d6506"},"expanded":true,"level":0,"properties":{}},{"name":"CompOptions","content":"module CompOptionsModule = // needs to be in a module so (?) operator does not collide with websharper\n    \n    type CompOptionClass = \n        | OpFSharp\n        | OpWebSharper\n        | OpInternal\n    \n    type CompOption = \n        {\n            name   : string\n            unique : bool\n            opClass: CompOptionClass  \n            prefix : string\n        }\n    with\n        static member (/=) (op: CompOption, v: CompOptionValue) = op,           v\n        static member (/=) (op: CompOption, v                 ) = op, OpVText   v\n        static member (/=) (op: CompOption, v                 ) = op, OpVTextOF v\n    \n    and CompOptionValue =\n        | OpVText   of                string\n        | OpVTextOF of (CompOptions -> string)\n    with \n        member this.Value ops = \n            match this with\n            | OpVText   v  -> v\n            | OpVTextOF fo -> fo ops\n    \n    and CompOptions = CompOptions of (CompOption * CompOptionValue) []\n    with\n        member this.Pairs             =  this |> function CompOptions ops ->  ops\n        member this.Exists   f        =  this.Pairs |> Array.exists f \n        member this.Find     name     =  this.Pairs |> Array.find (fun (opT, opV) -> name = opT.name)\n        member this.FindV    name     = (this.Find name |> snd).Value this\n        member this.Contains co       =  this.Exists (fun (opT, opV) -> co   = opT                           )\n        member this.Contains v        =  this.Exists (fun (opT, opV) -> v    = opT.prefix + (opV.Value this) )\n        member this.Get      f        =  this.Pairs |> Array.filter f |> Array.map (fun (opT, opV) ->        opT.prefix + (opV.Value this) )\n        static member FSharpOptions   = fun ({opClass=cls}, _) -> cls = OpFSharp\n        static member WSharperOptions = fun ({opClass=cls}, _) -> cls = OpFSharp || cls = OpWebSharper\n        static member (?) (ops: CompOptions, name: string) = ops.FindV name\n        static member (+) (os1: CompOptions, a2: (CompOption * CompOptionValue) seq) = \n            match os1 with \n            | CompOptions a1 -> \n                a1\n                |> Array.filter (fun (opT, _) -> (not opT.unique) || (a2 |> Seq.exists (fst >> (=) opT) |> not) )\n                |> Seq.append <| a2\n                |> Seq.toArray\n                |> CompOptions\n        static member (+) (ops: CompOptions, o:   CompOption * CompOptionValue      ) = ops + [| o |]\n        static member (+) (os1: CompOptions, os2: CompOptions                       ) = match os2 with | CompOptions a2 -> os1 + a2\n    \n    let (?) (ops:CompOptions) name = ops.FindV name\n    \n    let opSnippet     = { name = \"Snippet\"     ; unique = true  ; opClass = OpInternal   ; prefix = \"++snippet:\"   }\n    let opDirectory   = { name = \"Directory\"   ; unique = true  ; opClass = OpInternal   ; prefix = \"++directory:\" }\n    let opName        = { name = \"Name\"        ; unique = true  ; opClass = OpInternal   ; prefix = \"++name:\"      }\n    let opExtension   = { name = \"Extension\"   ; unique = true  ; opClass = OpInternal   ; prefix = \"++extension:\" }\n    let opFileName    = { name = \"Filename\"    ; unique = true  ; opClass = OpInternal   ; prefix = \"++filename:\"  }\n    let opConfig      = { name = \"Config\"      ; unique = true  ; opClass = OpInternal   ; prefix = \"++config:\"    }\n    let opGenInternal = { name = \"GenInternal\" ; unique = false ; opClass = OpInternal   ; prefix = \"++\"           }\n    let opWebSharper  = { name = \"WebSharper\"  ; unique = true  ; opClass = OpInternal   ; prefix = \"++websharper:\"}\n        \n    let opIOption     = { name = \"IOption\"     ; unique = false ; opClass = OpFSharp     ; prefix = \"-I:\"          }\n    let opReference   = { name = \"Reference\"   ; unique = false ; opClass = OpFSharp     ; prefix = \"-r:\"          }\n    let opSource      = { name = \"Source\"      ; unique = false ; opClass = OpFSharp     ; prefix = \"\"             }\n    let opTarget      = { name = \"Target\"      ; unique = true  ; opClass = OpFSharp     ; prefix = \"--target:\"    }\n    let opOutput      = { name = \"Output\"      ; unique = true  ; opClass = OpFSharp     ; prefix = \"-o:\"          }\n    let opDebug       = { name = \"Debug\"       ; unique = true  ; opClass = OpFSharp     ; prefix = \"--debug:\"     }\n    let opDefine      = { name = \"Define\"      ; unique = false ; opClass = OpFSharp     ; prefix = \"--define:\"    }\n    let opGenFSharp1  = { name = \"GenFSharp1\"  ; unique = false ; opClass = OpFSharp     ; prefix = \"-\"            }\n    let opGenFSharp2  = { name = \"GenFSharp2\"  ; unique = false ; opClass = OpFSharp     ; prefix = \"--\"           }\n    \n    let opWebSite     = { name = \"Website\"     ; unique = true  ; opClass = OpWebSharper ; prefix = \"--wsoutput:\"  }\n    let opGenWSharper = { name = \"GenWSharper\" ; unique = false ; opClass = OpWebSharper ; prefix = \"--\"           }\n    \n    let dllOptions     = CompOptions [| opTarget      /= \"library\"                                                                     |]  \n    let exeOptions     = CompOptions [| opTarget      /= \"exe\"     ; opGenInternal /= \"copyassemblies\" ; opGenInternal /= \"copyconfig\" |]\n    let winExeOptions  = CompOptions [| opTarget      /= \"winexe\"  ; opGenInternal /= \"copyassemblies\" ; opGenInternal /= \"copyconfig\" |]\n    \n    let genericOptions = \n      CompOptions\n        [|\n           opSnippet     /= \"Test\"\n           opName        /= fun os -> (os?Snippet : string).Split('/') |> Array.last\n           opDirectory   /= fun os -> \"Compiled\" +/+ os?Name\n           opExtension   /= fun os -> match os?Target with | \"library\" -> \"dll\" | _ -> \"exe\"\n           opFileName    /= fun os -> os?Directory +/+ os?Name + \".fs\"\n           opSource      /= fun os -> os?Filename\n           opOutput      /= fun os -> System.IO.Path.ChangeExtension(os?Source, os?Extension)\n           opConfig      /= fun os -> os?Output + \".config\"\n           opWebSharper  /= fun os -> if (os:CompOptions).Exists (fun (opT, opV) -> opT.opClass = OpWebSharper) then \"1\" else \"0\"\n        |]\n        \n    let siteOptions =\n      CompOptions\n        [|\n           opGenWSharper /= \"ws:Site\"\n           opWebSite     /= fun os -> os?Directory +/+ \"website\"\n           opGenWSharper /= fun os -> sprintf \"project:%s\"  os?Name\n        |] \n     \n    let wsProjectOptions =\n      CompOptions\n        [|\n           opGenWSharper /= fun os -> sprintf \"project:%s\"  os?Name\n        |] \n     \n    let debugOptions = \n      CompOptions\n        [|\n           opGenFSharp1  /= \"g\"\n           opDebug       /= \"full\"\n           opDefine      /= \"DEBUG\"\n           opDefine      /= \"TRACE\"\n           opGenFSharp2  /= \"optimize-\"\n           opGenFSharp2  /= \"tailcalls-\"\n        |]\n    \n    let otherOptions =\n      CompOptions\n        [|\n           //@\"--noframework\"\n           opGenFSharp2  /= \"warn:3\"\n           opGenFSharp2  /= \"warnaserror:76\"\n           opGenFSharp2  /= \"vserrors\"\n           opGenFSharp2  /= \"utf8output\"\n           opGenFSharp2  /= \"fullpaths\"\n           opGenFSharp2  /= \"flaterrors\"\n           opGenFSharp2  /= \"subsystemversion:6.00\"\n           opGenFSharp2  /= \"highentropyva+\"\n           opGenInternal /= \"removelinedirectives\"\n        |]\n    \n    let compileOptionsDll (snp:string) = \n        genericOptions\n        + dllOptions\n        + otherOptions\n        + opSnippet     /= snp\n        \n    let compileOptionsDllDebug (snp:string) = compileOptionsDll snp + debugOptions        \n    let compileOptionsExeDebug    snp = compileOptionsDllDebug snp + exeOptions   \n    let compileOptionsWinExeDebug snp = compileOptionsDllDebug snp + winExeOptions\n        \n    let prepOptions (options:CompOptions) (code : string [], assembs : string [], defines : string [], prepoIs : string [], nowarns : string []) =\n        let  code2 =\n           [\n              yield! nowarns |> Seq.distinct |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\")\n              yield! code \n           ] |> String.concat \"\\n\"\n        let  fileName = options?Filename\n        do   System.IO.File.WriteAllText(fileName, code2)\n        let  options2 = \n             options  + [|\n                           yield! prepoIs |> Array.map ((/=) opIOption  ) \n                           yield! assembs |> Array.map ((/=) opReference)\n                           yield! defines |> Array.map ((/=) opDefine   )\n                           if options.Contains \"++staticlinkall\" then \n                               yield! assembs |> Array.map (System.IO.Path.GetFileNameWithoutExtension >> ((+) \"staticlink:\") >> ((/=) opGenFSharp2 ))         \n                        |]\n        if options.Contains \"++copyassemblies\" then \n            assembs |> Array.iter (fun f -> System.IO.Path.GetDirectoryName(fileName) |> copyIfMustToDir f)      \n        if options2.Contains \"++showoptions\"    then printfn \"%s\" (options2.Get (fun _ -> true) |> String.concat \"\\n\")               \n        options2\n    \n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"ab5ab0ca-eb45-4851-affe-4690bb75d055"},{"$":0,"Item":"15cf771f-22b1-4796-8e34-6c16f35d6506"}],"id":{"$":0,"Item":"ef053bdf-997b-49c8-a401-1611a568bd8a"},"expanded":true,"level":0,"properties":{}},{"name":"RemotingDll","content":"#r @\"..\\packages\\FSharp.Data\\lib\\net40\\FSharp.Data.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net40\\FSharp.Data.DesignTime.dll\"\n\n#define WEBSHARPER\n#define FSS_SERVER\n\nopen System\nopen System.Net\nopen System.Text\nopen System.IO\nopen WebSharper\n//open WebSharper.Remoting\n//open WebSharper.JavaScript\n\n#if FSS_SERVER\nlet sendRequestRpcEP     = \"RemotingDll:FSSGlobal.UsefulDotNet.sendRequest:-426626804\"\nlet awaitRequestForRpcEP = \"RemotingDll:FSSGlobal.UsefulDotNet.awaitRequestFor:-439983525\"\nlet replyToRpcEP         = \"RemotingDll:FSSGlobal.UsefulDotNet.replyTo:-1092841374\"\n#else\nlet sendRequestRpcEP     = \"Remote:CIPHERPrototype.Messaging.sendRequest:1096816393\"\nlet awaitRequestForRpcEP = \"Remote:CIPHERPrototype.Messaging.awaitRequestFor:278590570\"\nlet replyToRpcEP         = \"Remote:CIPHERPrototype.Messaging.replyTo:-1092841374\"\n#endif\n\n\n#if WEBSHARPER\n[< JavaScript >]\n#endif\nmodule Messaging =\n    type AddressId = AddressId of string\n    \n    type Request = {\n        toId              : AddressId\n        fromId            : AddressId\n        content           : string\n        mutable messageId : Guid option\n    }\n    \n    type MBMessage =\n    | Listener of AddressId * (Request->unit) * (exn->unit) * (OperationCanceledException->unit)\n    | Request  of Request   * (string ->unit) * (exn->unit) * (OperationCanceledException->unit)\n    | Reply    of Guid      *  string\n    \n    type POMessage =\n    | POIdentification\n    | POEcho   of string\n    | POListeners\n    | POPendingRequests\n    | POPendingReplys\n    \n    type POResponse =\n    | POString  of string\n    | POStrings of string[]\n\nopen Messaging\n\nlet extract n (s:string) = s.Substring(0, min n s.Length)\nlet now() = System.DateTime.UtcNow.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n\ntype PostOffice() =\n    let mutable listeners = [| |]\n    let mutable requests  = [| |]\n    let mutable sent      = [| |]\n    let agent = MailboxProcessor.Start(fun mail ->\n        async {\n            while true do\n                let! mbMsg = mail.Receive()\n                match mbMsg with\n                | Listener                    (listener, lfs, lfe, lfc)  ->\n                    requests\n                    |> Array.indexed\n                    |> Array.tryPick (fun (i, (request , rfs, rfe, rfc)) -> \n                        if request.toId <> listener then None else\n                        requests <- Array.append requests .[0..i-1]  requests .[i+1..requests .Length - 1]\n                        Some(lfs, request, rfs))\n                    |> (fun v -> (if v.IsNone then \n                                    listeners <- \n                                        listeners \n                                        |> Array.filter(fun (lnr, lfs, exn, cen) -> \n                                            if lnr = listener then\n                                                //exn <| DivideByZeroException ()\n                                                //exn <| TimeoutException ()\n                                                lfs <| {\n                                                            toId      = AddressId \"\"\n                                                            fromId    = AddressId \"\"\n                                                            content   = \"{\\\"$\\\":0}\"\n                                                            messageId = None\n                                                        }\n                                                false\n                                            else true) \n                                        |> Array.append [| listener, lfs, lfe, lfc |]); v)\n                | Request                     (request , rfs, rfe, rfc)  ->\n                    listeners\n                    |> Array.indexed\n                    |> Array.tryPick (fun (i, (listener, lfs, lfe, lfc)) -> \n                        if request.toId <> listener then None else \n                        listeners <- Array.append listeners.[0..i-1] listeners.[i+1..listeners.Length - 1]\n                        Some(lfs, request, rfs))\n                    |> (fun v -> (if v.IsNone then requests  <- requests  |> Array.append [| request , rfs, rfe, rfc |]); v)\n                | Reply                       (reply   , response)  ->\n                    sent\n                    |> Array.indexed\n                    |> Array.pick (fun (i, (request , rfs)) -> \n                        if request.messageId.Value <> reply then None else\n                        sent      <- Array.append sent     .[0..i-1] sent     .[i+1..sent     .Length - 1]\n                        rfs response\n                        Some ())\n                    None\n                |> Option.iter (fun (lfs, request, rfs) -> \n                    request.messageId <- Some <| Guid.NewGuid()\n                    sent <- sent |> Array.append [| request, rfs |]\n                    lfs request\n                )\n        }\n    )\n    with\n        member this.AwaitRequest    listener  fs fe fc = agent.Post <| Listener (listener, fs, fe, fc)\n        member this.SendRequest     request   fs fe fc = \n            printfn \"%s Request: %A %A %A\" (now()) request.toId request.fromId (extract 80 request.content)\n            agent.Post <| Request  (request , fs, fe, fc)\n        member this.ReplyTo         request   response = \n            printfn \"%s Reply:   %s\"       (now()) (extract 100 response)\n            agent.Post <| Reply    (request , response  )\n        member this.Listeners       ()                 = listeners |> Array.map (function | AddressId id, _, _, _ -> id)\n        member this.Requests        ()                 = requests  |> Array.map (sprintf \"%A\")\n        member this.Sent            ()                 = sent      |> Array.map (sprintf \"%A\")\n\nlet postOffice = PostOffice()\n\n[< Rpc >]\nlet awaitRequestFor (listener:AddressId) =\n    let startAsync (fs, fe, fc) = postOffice.AwaitRequest listener fs fe fc\n    Async.FromContinuations startAsync\n\n[< Rpc >]\nlet replyTo    (reply:Guid) response =\n    async {\n        postOffice.ReplyTo reply response\n    }\n\nopen FSharp.Data\nopen FSharp.Data.JsonExtensions\n\n[< Rpc >]\nlet sendRequest  toId fromId content =\n    if toId = AddressId \"WebServer:PostOffice\" then\n        async {\n            let msg = Json.Deserialize<POMessage> content\n            return\n                match msg with\n                | POIdentification  -> POString     \"WebServer:PostOffice\"\n                | POEcho        txt -> POString     txt\n                | POListeners       -> POStrings <| postOffice.Listeners()\n                | POPendingRequests -> POStrings <| postOffice.Requests ()\n                | POPendingReplys   -> POStrings <| postOffice.Sent     ()\n                |> Json.Serialize \n        }\n    else\n    let startAsync (fs, fe, fc) = postOffice.SendRequest   \n                                    { toId      = toId   \n                                      fromId    = fromId \n                                      content   = content \n                                      messageId = None }\n                                    fs fe fc\n    Async.FromContinuations startAsync\n\nlet RpcCall (url:string) method (data:string) =\n    async {\n        //printfn \"RpcCall %s\" (extract 100 data)\n        let req = WebRequest.Create(url) :?> HttpWebRequest \n        req.Timeout         <- 300_000\n        req.ProtocolVersion <- HttpVersion.Version10\n        req.Method          <- \"POST\"\n        req.ContentType     <- \"application/json\"\n        req.Headers.Add(\"x-websharper-rpc\", method            )\n        let postBytes = Encoding.ASCII.GetBytes(data)\n        req.ContentLength <- int64 postBytes.Length\n        let reqStream = req.GetRequestStream() \n        reqStream.Write(postBytes, 0, postBytes.Length);\n        reqStream.Close()\n        \n        // Obtain response and download the resulting page \n        // (The sample contains the first & last name from POST data)\n        use resp   = req.GetResponse() \n        use stream = resp.GetResponseStream() \n        use reader = new StreamReader(stream)\n        let msg    = reader.ReadToEnd()\n        //printfn \"RpcCallResponse %s\" (extract 100 msg)\n        let json   = JsonValue.Parse msg\n        return       json.[\"$DATA\"]\n    }\n\nlet serializeAddressId aId =\n    match aId with\n    | AddressId v -> sprintf \"\"\"{\"$\":0,\"$0\":\"%s\"}\"\"\" v\n\nlet sendRequestRpc (toId: AddressId) (fromId: AddressId) (content: string): Async<string> =\n    async {\n        let! msg =\n            [| serializeAddressId toId ; serializeAddressId fromId ; Json.Serialize content |]\n            |> String.concat \", \"\n            |> sprintf \"[%s]\"\n            |> RpcCall WebSharper.Remoting.EndPoint sendRequestRpcEP\n        return msg.AsString()\n    }\n\nlet awaitRequestForRpc (listener:AddressId) =\n    async {\n        let! msg =\n            [| serializeAddressId listener |]\n            |> String.concat \", \"\n            |> sprintf \"[%s]\"\n            |> RpcCall WebSharper.Remoting.EndPoint awaitRequestForRpcEP\n        let  v = msg.[\"$V\"]\n        let req    =\n            {\n                toId      = AddressId <| v?toId  .[\"$V\"].[\"$0\"].AsString()\n                fromId    = AddressId <| v?fromId.[\"$V\"].[\"$0\"].AsString()\n                content   = v?content                          .AsString()\n                messageId = Some <| v?messageId  .[\"$V\"].[\"$0\"].AsGuid  ()\n            }\n        return req\n    }\n\nlet replyToRpc (reply:Guid) response =\n    async {\n        let! msg =\n            [| sprintf \"\\\"%s\\\"\" <| reply.ToString() ; Json.Serialize response |]\n            |> String.concat \", \"\n            |> sprintf \"[%s]\"\n            |> RpcCall WebSharper.Remoting.EndPoint replyToRpcEP\n        return ()\n    }\n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"82ab58ca-79e8-47f9-8917-f444d3320751"},"expanded":true,"level":0,"properties":{}},{"name":"FsEvaluator","content":"module FsEvaluator =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"a70b4838-75d6-40c3-9a0c-5bd03c57cce5"},"expanded":false,"level":0,"properties":{}},{"name":"evalFsiExe","content":"open Useful\n\nmodule Evaluator =\n    open System.Diagnostics\n    open UsefulDotNet\n    \n    type FsiExe(config) =\n        let startInfo                 = ProcessStartInfo(@\"fsiAnyCPU.exe\", config |> String.concat \" \")             \n        let shell                     = new ShellEx(startInfo)  // --noninteractive\n        let endToken                  = \"xXxY\" + \"yYyhH\"\n        do  startInfo.CreateNoWindow <- false\n            shell.Start() |> ignore\n        member this.Eval txt =\n            Wrap.wrapper {\n                do! Result.tryProtection()\n                shell.Send txt \n                shell.Send \";;\"\n                let! res = shell.SendAndWait(endToken + \";;\", endToken, true)\n                return res\n            }\n        member this.IsAlive = not shell.HasExited\n        interface System.IDisposable with\n            member this.Dispose () = \n                (shell :> System.IDisposable).Dispose()\n    \n    let fsiExe = lazy new ResourceAgent<_, string> (20, (fun config -> new FsiExe([\"--nologo\" ; \"--quiet\" ; defaultArg config \"\"] )), (fun fsi -> (fsi :> System.IDisposable).Dispose()), (fun fsi -> fsi.IsAlive), \"\")\n\n    let extractConfig (code:string[]) = if code.[0].StartsWith \"////-d:\" then code.[0].[4..] else \"\"\n\n    let evalFsiExe (code:string) =\n        Wrap.wrapper {\n            let config = extractConfig (code.Split '\\n')\n            let! resR = fsiExe.Value.Process(fun fsi -> \n                Wrap.wrapper {\n                  do! Result.tryProtection()\n                  let! res = fsi.Eval code \n                  return res\n                }\n            , config)\n            let! res = resR\n            return res\n        }\n\n#define WEBSHARPER\nopen WebSharper\n\n[< Rpc >]\nlet evaluateAS source =\n    async {\n        let!    res  = Evaluator.evalFsiExe source |> Wrap.getAsyncR \n        return  res |> Result.mapMsgs (Seq.map (fun (e:ErrMsg) -> e.ErrMsg, e.IsWarning) >> Seq.toArray)\n    }\n    \n[< JavaScript >]\nlet evaluateAR source =\n    async {\n        let!   vO, msgs = evaluateAS source\n        return  Result (vO,  msgs |> Seq.map (fun (msg, wrn) -> ErrSimple(msg, wrn) :> ErrMsg) |> Seq.toList)\n    }\n    ","parent":{"$":0,"Item":"a70b4838-75d6-40c3-9a0c-5bd03c57cce5"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},{"$":0,"Item":"f930dc48-39e8-453c-8c77-18a2cd73637a"},{"$":0,"Item":"b7c2d8cd-7246-4ad1-af46-ffbb7acde6e0"},{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"}],"id":{"$":0,"Item":"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"},"expanded":true,"level":0,"properties":{}},{"name":"FsStationShared","content":"#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule FsStationShared =\n","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"expanded":false,"level":0,"properties":{}},{"name":"MessagingClient","content":"#define FSS_SERVER\n\n#if FSS_SERVER\nopen FSSGlobal.UsefulDotNet\nopen FSSGlobal.UsefulDotNet.Messaging\n#r @\"Compiled\\RemotingDll\\RemotingDll.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net40\\FSharp.Data.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net40\\FSharp.Data.DesignTime.dll\"\n#else\n\n//#r \"remote.dll\"\nopen CIPHERPrototype.Messaging\n#endif\nopen WebSharper\nopen Useful\n//open UsefulFewJS\n//open UsefulFewJS.Messaging\n\n#if WEBSHARPER\n[< Inline \"true\" >]\n#endif          \nlet inJavaScript = false\n\nlet selectF fj fn =\n    match inJavaScript with\n    | true  -> fj\n    | false -> fn\n    \n#if WEBSHARPER\nlet AsyncStart asy     = Async.StartWithContinuations(asy, id, (fun e -> JS.Alert(e.ToString()) ), fun c -> JS.Alert(c.ToString()))    \n[< Inline \"\" >]\nlet awaitRequestForRpc = awaitRequestForRpc\n[< Inline \"\" >]\nlet sendRequestRpc     = sendRequestRpc\n[< Inline \"\" >]\nlet replyToRpc         = replyToRpc\n#else\nlet AsyncStart asy = Async.Start asy\n#endif          \n\nlet  AddressId = AddressId\n\nlet awaitRequestForF = selectF awaitRequestFor awaitRequestForRpc\nlet sendRequestF     = selectF sendRequest         sendRequestRpc\nlet replyToF         = selectF replyTo                 replyToRpc\nlet AsyncStartF      = selectF AsyncStart             Async.Start\n\ntype MessagingClient(clientId, ?timeout, ?endPoint:string) =\n    let wsEndPoint = endPoint    |> Option.defaultValue \"##FSHARPSTATION_ENDPOINT##\"\n    let tout       = timeout     |> Option.defaultValue 100_000\n    let fromId     = AddressId clientId\n    do WebSharper.Remoting.EndPoint <- wsEndPoint \n    let awaitMessage respond =\n        async {\n            while true do\n                printfn \"%s awaitRequest %s\" (nowStamp()) clientId\n                let! msgA  = Async.StartChild(awaitRequestForF fromId, tout)\n                try\n                    let! msg   = msgA\n                    let! resp  = respond clientId msg.content\n                    do!          replyToF msg.messageId.Value resp\n                with \n                | :? System.TimeoutException -> ()\n                | e                          -> printfn \"%A\" e\n        } \n        |> AsyncStartF\n    let sendMessage  toId msg = sendRequestF toId fromId msg\n    let poMsg checkResponse msg =\n        async {\n            let! resp = sendMessage (AddressId \"WebServer:PostOffice\") (Json.Serialize<POMessage> msg)\n            return checkResponse (Json.Deserialize<POResponse> resp)\n        }\n    let poString resp =\n                match resp with\n                | POString  v  -> v\n                | POStrings vs -> sprintf \"%A\" vs\n    let poStrings resp =\n                match resp with\n                | POString  v  -> [| sprintf \"unexpected response: %s\" v |]\n                | POStrings vs -> vs\n  with \n    member this.AwaitMessage respond  = awaitMessage (fun clientId request -> async { return respond clientId request })\n    member this.AwaitMessage respondA = awaitMessage respondA\n    member this.SendMessage toId msg  = sendMessage toId msg\n    member this.POMessage        msg  = poMsg id        msg\n    member this.POListeners      ()   = poMsg poStrings POListeners\n    member this.EndPoint              = wsEndPoint\n    member this.ClientId              = clientId\n    static member EndPoint_           = \"##FSHARPSTATION_ENDPOINT##\"\n    ","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"7a655466-e218-4121-a7b6-f9c70a922e07"}],"id":{"$":0,"Item":"eb54ba64-3d11-4347-97c8-aeae9e3e3121"},"expanded":true,"level":0,"properties":{}},{"name":"CodeSnippet","content":"open Useful\n\nlet snippetName name (content: string) =\n    if name <> \"\" then name else \n    content.Split([| '\\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n    |> Seq.map    (fun l -> l.Trim())\n    |> Seq.filter (fun l -> not (l.StartsWith(\"#\") || l.StartsWith(\"[<\") || l.StartsWith(\"//\")))\n    |> Seq.tryHead\n    |> Option.defaultValue \"<empty>\"\n\nlet sanitize n =\n    let illegal = [|'\"'   ; '<'   ; '>'   ; '|'   ; '\\000'; '\\001'; '\\002'; '\\003'; '\\004'; '\\005'; '\\006';\n                    '\\007'; '\\b'  ; '\\009'; '\\010'; '\\011'; '\\012'; '\\013'; '\\014'; '\\015';\n                    '\\016'; '\\017'; '\\018'; '\\019'; '\\020'; '\\021'; '\\022'; '\\023'; '\\024';\n                    '\\025'; '\\026'; '\\027'; '\\028'; '\\029'; '\\030'; '\\031'; ':'   ; '*'   ; '?';\n                    '\\\\'  ; '/'|] //\"\n    n |> String.filter (fun c -> not <| Array.contains c illegal)\n\ntype CodeSnippetId = CodeSnippetId of System.Guid   \nwith static member New = CodeSnippetId <| System.Guid.NewGuid()\n     member this.Text  = match this with CodeSnippetId guid -> guid.ToString()\n\ntype CodeSnippet = {\n    name         : string\n    content      : string\n    parent       : CodeSnippetId option\n    predecessors : CodeSnippetId list\n    id           : CodeSnippetId\n    expanded     : bool\n    level        : int\n    properties   : Map<string, string>\n} with\n    member this.Name = snippetName this.name this.content\n    member this.NameSanitized =\n        this.Name\n        |> sanitize\n        |> (fun c -> this.id.Text + \" \" + c + \".fsx\")\n//    member this.ContentIndented addLinePrepos =\n//        let indent        = this.level * 2\n//        let indentF, prfx = if indent = 0         then (id, \"\") else (Array.map    (fun (l, pr) -> String.replicate indent \" \" + l, pr), sprintf\"(%d)\" indent)\n//        let addLinePs     = if not addLinePrepos  then  id      else  Array.append [| sprintf \"# 1 @\\\"%s%s\\\"\" prfx this.NameSanitized |] \n//        this.content.Split('\\n') \n//        |> addLinePs\n//        |> separatePrepros (not addLinePrepos)\n//        |> indentF\n//      , indent\n\n// tail recursion does not optimize\nlet rec preds fetcher outs (ins : CodeSnippetId list) : CodeSnippetId list =\n    match ins with\n    | []         -> outs\n    | hd :: rest -> List.collect id [ rest ; hd |> fetcher |> Option.toList |> List.collect (fun s -> s.parent |> Option.toList |> List.append <| s.predecessors) ]\n                    |> preds fetcher (if outs |> Seq.contains hd then outs else hd::outs)\n\nlet predsL fetcher (ins : CodeSnippetId list) : CodeSnippetId list =\n    let mutable ins  = ins \n    let mutable outs = []\n    while not ins.IsEmpty do\n        match ins with\n        | []         -> ()\n        | hd :: rest -> if outs |> Seq.contains hd then\n                            ins  <- rest\n                        else\n                            ins  <- List.collect id [ rest ; hd |> fetcher |> Option.toList |> List.collect (fun s -> s.parent |> Option.toList |> List.append <| s.predecessors) ]\n                            outs <- hd::outs\n    outs\n\ntype CodeSnippet with\n    member this.UniquePredecessors (fetcher: CodeSnippetId -> CodeSnippet option) = predsL fetcher [ this.id ]        \n    static member TryFindByKey  snps key = snps |> Seq.tryFind (fun snp        -> snp.id = key)\n    member this.SeparateCode addLinePrepos =\n        let indent        = this.level * 2\n        let indentF, prfx = if indent = 0         then (id, \"\") else (Array.map    (fun (l, pr) -> String.replicate indent \" \" + l, pr), sprintf\"(%d)\" indent)\n        let addLinePs     = if not addLinePrepos  then  id      else  Array.append [| sprintf \"# 1 @\\\"%s%s\\\"\" prfx this.NameSanitized |]\n        let code, assembs, defines, prepIs, nowarns  =\n            this.content.Split('\\n') \n            |> addLinePs\n            |> separatePrepros (not addLinePrepos)\n            |> indentF\n            |> separateDirectives\n        [| this.NameSanitized, code.Length, indent |] , code, assembs, defines, prepIs, nowarns\n    static member AddSeps (lines1:(string*int*int)[], code1:string[], assembs1:string[], defines1:string[], prepIs1:string[], nowarns1:string[])\n                          (lines2:(string*int*int)[], code2:string[], assembs2:string[], defines2:string[], prepIs2:string[], nowarns2:string[]) =\n        Array.append lines1   lines2\n      , Array.append code1    code2\n      , Seq  .append assembs1 assembs2 |> Seq.distinct |> Seq.toArray\n      , Seq  .append defines1 defines2 |> Seq.distinct |> Seq.toArray\n      , Seq  .append prepIs1  prepIs2  |> Seq.distinct |> Seq.toArray\n      , Seq  .append nowarns1 nowarns2 |> Seq.distinct |> Seq.toArray\n    static member ReducedCode  addLinePrepos (snippets: CodeSnippet seq) =\n        snippets\n        |> Seq.map(fun snp -> snp.SeparateCode addLinePrepos)\n        |> fun snps -> if snps |> Seq.isEmpty then seq [ [||],  [||],  [||],  [||],  [||],  [||] ] else snps\n        |> Seq.reduce CodeSnippet.AddSeps\n        |> fun (lines, code, assembs, defines, prepIs, nowarns) ->\n           (lines, code |> String.concat \"\\n\" |> Array.singleton, assembs, defines, prepIs, nowarns)\n    static member FinishCode addLinePrepos (lines:(string*int*int)[],code:string[], assembs:string[], defines:string[], prepIs:string[], nowarns:string[]) =\n        let config = defines |> Seq.sort |> Seq.map ((+)\"-d:\") |> String.concat \" \"\n        let part1  =\n          [ if config <> \"\" then yield \"////\" + config\n            yield! prepIs  |> Seq.map (sprintf \"#I @\\\"%s\\\"\"    )\n            yield! assembs |> Seq.map (sprintf \"#r @\\\"%s\\\"\"    )\n            if addLinePrepos && (nowarns |> Seq.isEmpty |> not) then yield \"# 1 \\\"required for nowarns to work\\\"\"\n            yield! nowarns |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\")\n          ]\n        Seq.append part1 code |> String.concat \"\\n\"\n      , lines \n        |> Seq.mapFold (fun firstLine (name, len, ind) -> (name, (ind, firstLine, firstLine + len)), firstLine + len) part1.Length\n        |> fst\n        |> Seq.toArray\n    static member CodeAndStarts   addLinePrepos (snippets:CodeSnippet seq) =\n        CodeSnippet.ReducedCode   addLinePrepos snippets\n        |> CodeSnippet.FinishCode addLinePrepos\n    static member CodeFsx         addLinePrepos snps = CodeSnippet.CodeAndStarts addLinePrepos snps |> fst\n//    static member CodeMerged  addLinePrepos (snippets: CodeSnippet seq) =\n//        let bySnippet = \n//            snippets\n//            |> Seq.map(fun snp -> \n//                let code, indent = snp.ContentIndented addLinePrepos\n//                snp, indent, code\n//            )\n//        (bySnippet, bySnippet |> Seq.collect (function _, _, code -> code))\n//    static member CodeParts addLinePrepos snippets =\n//        let bySnippet, merged                        = CodeSnippet.CodeMerged addLinePrepos snippets\n//        let code, assembs, defines, prepIs, nowarns  = separateDirectives merged\n//        let config = defines |> Seq.distinct |> Seq.sort |> Seq.map ((+)\"-d:\")             |> String.concat \" \"\n//        [   if config <> \"\" then yield \"////\" + config\n//            yield! prepIs  |> Seq.distinct             |> Seq.map (sprintf \"#I @\\\"%s\\\"\"    )\n//            yield! assembs |> Seq.distinct             |> Seq.map (sprintf \"#r @\\\"%s\\\"\"    )\n//            if addLinePrepos && (nowarns |> Seq.isEmpty |> not) then yield \"# 1 \\\"required for nowarns to work\\\"\"\n//            yield! nowarns |> Seq.distinct             |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\")\n//        ], code, bySnippet\n//    static member CodeFsx0 addLinePrepos (cur, snippets) =\n//        let part1, part2, bySnippet = CodeSnippet.CodeParts addLinePrepos (Array.append snippets [| cur |])\n//        [ yield! part1 ; yield! part2 ] |> String.concat \"\\n\"\n\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"657c8f34-c917-4659-825d-c9ead206efcf"},{"$":0,"Item":"b59aa3c7-13d9-4f78-98ea-307182bf4bd4"},{"$":0,"Item":"ace1fc12-3dfb-4db8-80c9-5bde1e7d0597"}],"id":{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"},"expanded":true,"level":0,"properties":{}},{"name":"FSMessage,FSResponse","content":"type FSMessage =\n    | GetIdentification\n    | GenericMessage        of string\n    | GetSnippetContentById of CodeSnippetId\n    | GetSnippetCodeById    of CodeSnippetId\n    | GetSnippetPredsById   of CodeSnippetId\n    | GetSnippetById        of CodeSnippetId\n    | GetSnippetContent     of string []\n    | GetSnippetCode        of string []\n    | GetSnippetPreds       of string []\n    | GetSnippet            of string []\n    | GetSnippetJSCode      of string []\n    | GetWholeFile\n    | RunSnippetUrlJSById   of CodeSnippetId * string\n    | RunSnippetUrlJS       of string []     * string\n\ntype FSSeverity =\n    | FSError\n    | FSWarning\n    | FSInfor\n\ntype FSResponse =\n    | IdResponse        of string\n    | StringResponse    of string option\n    | SnippetResponse   of CodeSnippet option\n    | SnippetsResponse  of CodeSnippet []\n    | StringResponseR   of string option * (string * FSSeverity)[]\n\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"}],"id":{"$":0,"Item":"f6ebdffc-049c-4493-8de8-e32072419479"},"expanded":true,"level":0,"properties":{}},{"name":"FsStationClient","content":"\ntype FsStationClientErr =\n    | FSMessage             of string * FSSeverity\n    | ``Snippet Not Found`` of string\nwith interface ErrMsg with\n        member this.ErrMsg    = \n            match this with \n            | FSMessage (msg, sev    )   -> sprintf \"%A %s\" sev msg\n            | msg                        -> sprintf \"%A\"        msg\n        member this.IsWarning =     \n            match this with \n            | FSMessage (_  , FSError)   -> true\n            | msg                        -> false\n\ntype FsStationClient(clientId, ?fsStationId:string, ?timeout, ?endPoint) =\n    let fsIds      = fsStationId |> Option.defaultValue \"##FSHARPSTATION_ID##\"\n    let msgClient  = MessagingClient(clientId, ?timeout= timeout, ?endPoint= endPoint)\n    let toId       = AddressId fsIds\n    let stringResponseR response =\n        match response with\n        | StringResponseR (Some code, msgs) -> Result.succeedWithMsgs code (msgs |> Seq.map (fun v -> FSMessage v :> ErrMsg) |> Seq.toList)\n        | _                                 -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let stringResponse  response =\n        match response with\n        | StringResponse (Some code)    -> Result.succeed code\n        | _                             -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let snippetsResponse response =\n        match response with\n        | SnippetsResponse snps         -> Result.succeed snps\n        | _                             -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let snippetResponse response =\n        match response with\n        | SnippetResponse  snp          -> Result.succeed snp\n        | _                             -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    [< Inline >]\n    let sendMsg toId (msg: FSMessage) (checkResponse: FSResponse -> Result<'a>) =\n        Wrap.wrapper {\n            let!   response = msgClient.SendMessage toId (msg |> Json.Serialize)\n            let!   resp     = checkResponse (Json.Deserialize<FSResponse> response)\n            return resp\n        } \n  with \n    member this.SendMessage     (toId2,  msg:FSMessage) = sendMsg toId2  msg    Result.succeed   \n    member this.SendMessage     (        msg:FSMessage) = sendMsg toId   msg    Result.succeed   \n    member this.RequestSnippet  (    snpPath:string   ) = sendMsg toId  (GetSnippet          (snpPath.Split '/'     ))    snippetResponse  \n    member this.RequestCode     (    snpPath:string   ) = sendMsg toId  (GetSnippetCode      (snpPath.Split '/'     ))    stringResponse   \n    member this.RequestJSCode   (    snpPath:string   ) = sendMsg toId  (GetSnippetJSCode    (snpPath.Split '/'     ))    stringResponseR  \n    member this.RequestPreds    (    snpPath:string   ) = sendMsg toId  (GetSnippetPreds     (snpPath.Split '/'     ))    snippetsResponse \n    member this.RequestPredsById(      snpId          ) = sendMsg toId  (GetSnippetPredsById  snpId                  )    snippetsResponse \n    member this.RequestWholeFile(                     ) = sendMsg toId   GetWholeFile                                     stringResponse   \n    member this.GenericMessage  (        txt:string   ) = sendMsg toId  (GenericMessage       txt                    )    stringResponse   \n    member this.RunSnippet      (url,snpPath:string   ) = sendMsg toId  (RunSnippetUrlJS     (snpPath.Split '/', url))    stringResponseR\n    member this.FSStationId                             = fsIds\n    member this.MessagingClient                         = msgClient    \n    static member FSStationId_                          = \"##FSHARPSTATION_ID##\"\n\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"eb54ba64-3d11-4347-97c8-aeae9e3e3121"},{"$":0,"Item":"f6ebdffc-049c-4493-8de8-e32072419479"}],"id":{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"},"expanded":true,"level":0,"properties":{}},{"name":"FsStationClient Save Extension","content":"//open CIPHERPrototype.Messaging\nopen Useful\nopen System.IO\n\nlet backupFile file = \n    try File.Delete(      file + \".bak\") ; printfn \"Deleted %s.bak\" file with _ -> ()\n    try File.Copy  (file, file + \".bak\") with _ -> ()\n\ntype FsStationClient with\n    member this.Save(contentW:Wrap<string>, msgBefore, path, file, printMsg) =\n        Wrap.wrapper {\n            printMsg <| sprintf \"%s\" msgBefore\n            let! content = contentW\n            let fullName = Path.Combine(path, file)\n            backupFile fullName\n            File.WriteAllText(fullName, content)\n            printMsg <| sprintf \"Saved %s.\" fullName\n        } |> Wrap.runSynchronouslyS false |> printMsg\n    member this.Save(contentW:Wrap<string>, msgBefore, path, file) = this.Save(contentW, msgBefore, path, file, printfn \"%s\")\n    member this.SaveSnippetJS  path snippet = this.Save(this.RequestJSCode snippet, sprintf \"Compiling %s to JavaScript\" snippet, path, (snippet.Split '/' |> Seq.last) + \".js\" )\n    member this.SaveSnippetFsx path snippet = this.Save(this.RequestCode   snippet, sprintf \"Saving %s to F#\"            snippet, path, (snippet.Split '/' |> Seq.last) + \".fsx\")\n    member this.SaveWholeFile  path name    = this.Save(this.RequestWholeFile()   , sprintf \"Saving to %s.fsjson\"        name   , path, name + \".fsjson\"                        )\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"},{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"}],"id":{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},"expanded":true,"level":0,"properties":{}},{"name":"FsStationClient Compile Extension","content":"#r @\"..\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.CompOptionsModule\nopen System.IO\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n\ntype CodeSnippet with\n    static member PrepareCompileOptions (options1: CompOptions) (snps: CodeSnippet seq) =\n        let  addLinePrepos =  options1.Contains \"++removelinedirectives\" |> not\n        let  lines, code, assembs, defines, prepoIs, nowarns = CodeSnippet.ReducedCode addLinePrepos snps\n        let  options2      = prepOptions options1 (code, assembs, defines, prepoIs, nowarns)\n        options2\n\ntype FsStationClient with\n    member this.PrepareCompileOptions(options1) = \n        Wrap.wrapper {\n            let  snpPath   = options1?Snippet\n            let!   preds   = this.RequestPreds snpPath\n            let    options = CodeSnippet.PrepareCompileOptions options1 preds\n            return options\n        }\n    member this.CompileFSharpW(options:CompOptions) = \n        Wrap.wrapper {\n            let! msgs, exit = options.Get CompOptions.FSharpOptions \n                              |> Array.append [| \"IGNORED_Fsc.exe\" |] \n                              |> FSharpChecker.Create().Compile\n            let  errs       = [ yield! msgs |> Array.map fSharpError2TranspilerError\n                                if exit <> 0 && (exit <> 1 || msgs.Length = 0) then yield ErrSimple (sprintf \"ExitCode: %d\" exit, false) :> ErrMsg\n                              ]\n            let! res        = if   exit <> 0\n                              then Result.failWithMsgs                errs\n                              else Result.succeedWithMsgs \"Compiled!\" errs\n            return res\n        }\n    member this.CompileWebSharperW(options:CompOptions) =\n        Wrap.wrapper {\n            if options.Contains opWebSite then\n                let  site     = options?Website\n                if options.Contains \"++createdirectory\"     then Directory.CreateDirectory(site) |> ignore\n            let! res          = options.Get CompOptions.WSharperOptions\n                                 |> Seq.map (sprintf \"%A\")\n                                 |> String.concat \"  \"\n                                 |> fun ops -> (new ShellEx(@\"WsFsc.exe\", ops)).StartAndWaitR()\n            return if res = \"\" then \"Compiled!\" else res\n        }\n    member this.CompileSnippetW options  = \n        Wrap.wrapper {\n            let  snpPath      = options?Snippet\n            let  config       = options?Config\n            let  directory    = options?Directory\n            do   Directory.CreateDirectory(directory) |> ignore\n            let! options2     = this.PrepareCompileOptions options\n            let  compiler     = if options2.Contains \"++websharper:1\" then this.CompileWebSharperW else this.CompileFSharpW\n            let! res          = compiler options2\n            if options2.Contains \"++copyassemblies\" then copyIfMustToDir        \"FSharp.Core.dll\"          directory\n            if options2.Contains \"++copyconfig\"     then copyIfNotExistsToFile  \"FSharpStation.exe.config\" config\n            return res\n        }\n        \n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"9becc68c-9cc2-4f29-82df-e510d10226db"},{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},{"$":0,"Item":"ef053bdf-997b-49c8-a401-1611a568bd8a"},{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},{"$":0,"Item":"15cf771f-22b1-4796-8e34-6c16f35d6506"},{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"},{"$":0,"Item":"ab5ab0ca-eb45-4851-affe-4690bb75d055"}],"id":{"$":0,"Item":"56e5bc09-e528-49cc-9d42-6359b32a0cc9"},"expanded":true,"level":0,"properties":{}},{"name":"WebSite","content":"#define WEBSHARPER\nopen WebSharper.Sitelets\nopen WebSharper.UI.Next.Server\n\ntype EndPoint = EP\n\nlet content (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n    Content.Page( Html.html [ Html.body [ Html.h1 [ Html.text \"Hello Dolly\" ] ]])\n\nlet site = Application.MultiPage content\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"47912c89-9605-41df-9425-7facea3d6b50"},"expanded":true,"level":0,"properties":{}},{"name":"SelfHostedServer","content":"#r @\"Owin.dll\"\n#r @\"Microsoft.Owin.dll\"\n#r @\"Microsoft.Owin.Hosting.dll\"\n#r @\"Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"Microsoft.Owin.StaticFiles.dll\"\n#r @\"Microsoft.Owin.FileSystems.dll\"\n#r @\"WebSharper.Owin.dll\"\n\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://localhost\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://*\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"file://\"\nWebSharper.Web.Remoting.DisableCsrfProtection()\n\nmodule SelfHostedServer =\n\n    open global.Owin\n    open Microsoft.Owin.Hosting\n    open Microsoft.Owin.StaticFiles\n    open Microsoft.Owin.FileSystems\n    open WebSharper.Owin\n\n    [<EntryPoint>]\n    let Main args =\n        let rootDirectory, url =\n            match args with\n            | [| rootDirectory; url |] -> rootDirectory, url\n            | [| url                |] -> \"..\"         , url\n            | [|                    |] -> \"..\"         , \"http://localhost:9001/\"\n            | _ -> eprintfn \"Usage: WebServer ROOT_DIRECTORY URL\"; exit 1\n        use server = \n            WebApp.Start(url, fun appB ->\n                appB.UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(rootDirectory)))\n                    .UseWebSharper(WebSharperOptions(ServerRootDirectory = rootDirectory\n                                                   , Sitelet             = Some site\n                                                   , BinDirectory        = \".\"\n                                                   , Debug               = true))\n                |> ignore\n                let listener = appB.Properties.[\"Microsoft.Owin.Host.HttpListener.OwinHttpListener\"] |> unbox<Microsoft.Owin.Host.HttpListener.OwinHttpListener>\n                let maxA = ref 0\n                let maxB = ref 0\n                listener.SetRequestProcessingLimits(1000, 1000)\n                listener.GetRequestProcessingLimits(maxA, maxB)\n                printfn \"Accepts: %d Requests:%d\" !maxA !maxB\n                )\n        stdout.WriteLine(\"Serving {0}\", url)\n        stdin.ReadLine() |> ignore\n        0\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"47912c89-9605-41df-9425-7facea3d6b50"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"2071bfaf-8f65-47a7-98e6-7ec138e9f905"},"expanded":true,"level":0,"properties":{}},{"name":"FsTranslator","content":"module FsTranslator =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"expanded":false,"level":0,"properties":{}},{"name":"FsTranslator","content":"#r @\"..\\packages\\Zafir.FSharp\\tools\\System.Reflection.Metadata.dll\"\n#r @\"..\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n#r @\"..\\packages\\Zafir.Compiler\\lib\\net45\\WebSharper.Compiler.dll\"\n#r @\"..\\packages\\Zafir.Compiler\\lib\\net45\\WebSharper.Compiler.FSharp.dll\"\n#r @\"..\\packages\\Mono.Cecil\\lib\\net40\\Mono.Cecil.dll\"\n#r @\"..\\packages\\Mono.Cecil\\lib\\net40\\Mono.Cecil.Pdb.dll\"\n#r @\"..\\packages\\Mono.Cecil\\lib\\net40\\Mono.Cecil.Mdb.dll\"\n//#r @\"System.Reflection.Metadata.dll\"\n\nmodule Translator =\n    open Useful\n    open UsefulDotNet\n    open System\n    open System.IO\n    open System.Reflection\n    \n    module Re = WebSharper.Core.Resources\n    module P  = WebSharper.PathConventions\n    open WebSharper.Compiler\n    open WebSharper.Compiler.FrontEnd\n    open WebSharper.Core\n    open WebSharper.Core.Resources\n    open WebSharper.Compile.CommandTools\n    open Microsoft.FSharp.Compiler.SourceCodeServices\n    open Microsoft.FSharp.Compiler\n    \n    type WebSharperError = AST.SourcePos option * CompilationError\n    type TranslatorError =\n        | MustProvideAssemblyOutputPath\n        | MustProvideProjectPath\n        | ErrWebSharper                 of string\n        | NothingToTranslateToJavaScript\n        | OutputAssemblyNotFound        of string\n    with interface ErrMsg with\n            member this.ErrMsg =\n                if this = NothingToTranslateToJavaScript then \"WebSharper found nothing that required translation to JavaScript. Possibly a [< JavaScript >] attribute is missing.\" else\n                sprintf \"%A\"this\n            member this.IsWarning = false\n    \n    let webSharperError2TranspilerError: WebSharperError -> ErrMsg =\n        fun                              (posO, error)   ->\n            posO \n            |> Option.map (fun pos -> sprintf \"%s %A - %A \" pos.FileName pos.Start pos.End )\n            |> Option.defaultValue \"\"\n            |>  sprintf \"%s%s\" <| error.ToString()\n            |> ErrWebSharper\n            :> ErrMsg\n    \n    let CompileToJsW: WsConfig -> Wrap<string> =\n        fun           config   -> Wrap.wrapper {\n            do!  config.ProjectFile  = null       |> Result.failIfTrue  MustProvideProjectPath\n            do!  config.AssemblyFile = null       |> Result.failIfTrue  MustProvideAssemblyOutputPath\n            let  fsharpChecker       = FSharpChecker.Create(keepAssemblyContents = true)\n            let! errors, exitCode    = fsharpChecker.Compile(config.CompilerArgs)\n            let  fsErrors            = errors |> Array.map fSharpError2TranspilerError |> List.ofArray\n            do!  (if exitCode = 0 then Result.succeedWithMsgs () else Result.failWithMsgs) <| fsErrors\n            do!  File.Exists config.AssemblyFile  |> Result.failIfFalse (OutputAssemblyNotFound config.AssemblyFile)\n            let  assemblyBytes       = File.ReadAllBytes config.AssemblyFile\n            do   System.IO.File.Delete config.AssemblyFile\n            let  paths               = [   for r in config.References -> \n                                               Path.GetFullPath r\n                                           yield Path.GetFullPath config.AssemblyFile\n                                       ]        \n            let  aR                  = AssemblyResolver.Create().SearchPaths(paths)\n            let  loader              = Loader.Create aR (printfn \"%s\")\n            let  refs                = [ for r in config.References -> loader.LoadFile(r, false) ]\n            let  refMeta             =\n                 System.Threading.Tasks.Task.Run(fun () ->\n                     let refErrors = ref false\n                     let metas = refs |> List.choose (fun r -> \n                         try ReadFromAssembly FullMetadata r\n                         with e ->\n                             eprintfn \"WebSharper error %s\" e.Message\n                             refErrors := true\n                             None\n                     )\n                     if !refErrors then None\n                     elif List.isEmpty metas then Some WebSharper.Core.Metadata.Info.Empty \n                     else\n                         try\n                             Some { \n                                 WebSharper.Core.Metadata.Info.UnionWithoutDependencies metas with\n                                     Dependencies = WebSharper.Core.DependencyGraph.Graph.NewWithDependencyAssemblies(metas |> Seq.map (fun m -> m.Dependencies)).GetData()\n                             }\n                         with e ->\n                             eprintfn \"WebSharper error Error merging WebSharper metadata: %s\" e.Message\n                             None\n                 )\n            let  referencedAsmNames     = paths\n                                          |> Seq.map (fun i -> \n                                              let n = Path.GetFileNameWithoutExtension(i)\n                                              n, i\n                                          ) |> Map.ofSeq\n            let  thisName               = Path.GetFileNameWithoutExtension config.AssemblyFile\n            let  assemblyResolveHandler = ResolveEventHandler(fun _ e ->\n                    //printfn \"assemblyResolveHandler %s\" e.Name\n                    let assemblyName    = AssemblyName(e.Name).Name\n                    match Map.tryFind assemblyName referencedAsmNames with\n                    | Some p when assemblyName = \"FSharp.Core\" -> typeof<option<_>>.Assembly\n                    | Some p when assemblyName = thisName      -> Assembly.Load assemblyBytes\n                    | Some p                                   -> Assembly.LoadFrom(p)\n                    | _                                        -> null\n                )\n            System.AppDomain.CurrentDomain.add_AssemblyResolve(assemblyResolveHandler)\n            let! comp        = WebSharper.Compiler.FSharp.WebSharperFSharpCompiler(printfn \"%s\", fsharpChecker)\n                                        .Compile(refMeta, config.CompilerArgs, \".\", config.ProjectFile) \n            let  wsErrors    = comp.Errors |> List.map webSharperError2TranspilerError\n            do! if wsErrors.IsEmpty then Result.succeed () else\n                Result.failWithMsgs wsErrors\n            let  assem       = loader.LoadRaw assemblyBytes None\n            let! js          = ModifyAssembly (Some comp) \n                                              (refMeta.Result |> Option.defaultValue WebSharper.Core.Metadata.Info.Empty) \n                                              (comp.ToCurrentMetadata(config.WarnOnly)) \n                                              config.SourceMap config.AnalyzeClosures assem\n                               |> Result.fromOption NothingToTranslateToJavaScript\n            let  thisProject = Path.GetFileNameWithoutExtension config.ProjectFile\n            use  stringW     = new System.IO.StringWriter()\n            use  writer      = new System.Web.UI.HtmlTextWriter(stringW)\n            let  pu          = P.PathUtility.VirtualPaths(\"/\")\n            let ctx : Resources.Context =\n                {\n                    DebuggingEnabled        = true\n                    DefaultToHttp           = false\n                    GetSetting              = fun (name: string) -> None //printfn \"GetSetting %s\" name ; None\n\n                    GetAssemblyRendering    = fun name ->\n                        //printfn \"GetAssemblyRendering %s\" name\n                        if name = thisProject || name = config.ProjectFile\n                        then WebSharper.Core.Resources.Rendering.Skip else\n                        name\n                        |> P.AssemblyId.Create\n                        |> pu.JavaScriptPath \n                        |> Re.RenderLink\n                    GetWebResourceRendering = fun ty resource ->\n                        //printfn \"GetWebResourceRendering %A\" ty\n                        let id = P.AssemblyId.Create(ty)\n                        let kind =\n                            if resource.EndsWith(\".js\") || resource.EndsWith(\".ts\")\n                                then P.ResourceKind.Script\n                                else P.ResourceKind.Content\n                        P.EmbeddedResource.Create(kind, id, resource)\n                        |> pu.EmbeddedPath\n                        |> Re.RenderLink\n                    RenderingCache          = System.Collections.Concurrent.ConcurrentDictionary()\n                    ResourceDependencyCache = System.Collections.Concurrent.ConcurrentDictionary()\n                }            \n            comp.Graph.Nodes |> comp.Graph.GetDependencies |> comp.Graph.GetResources |> Seq.iter(fun r -> r.Render ctx (fun _ -> writer) )\n            //js.RenderDependencies(ctx, writer)\n            let  includes = stringW.ToString()\n            let  incs     = includes.Split([| \"src=\"; \"href=\" ; \"<\" ; \">\" |], System.StringSplitOptions.RemoveEmptyEntries)\n                            |> Seq.choose(fun v -> if v.[0] = '\"' then v.Split([| '\"' |], System.StringSplitOptions.RemoveEmptyEntries).[0] |> sprintf \"%A\" |> Some else None)\n                            |> String.concat \", \"\n            let! f        = Result.succeedWithMsgs js.[1..js.Length - 7] (comp.Warnings |> List.map (fun v -> (sprintf \"%A\" v, true) |> ErrSimple :> ErrMsg))\n            return          sprintf \"CIPHERSpaceLoadFiles([%s], %s);\" incs f\n        }\n    \n    let compileMainW: string[] -> Wrap<string> =\n      fun             argv     ->\n        let wsArgs    = ref WsConfig.Empty\n        let refs      = ResizeArray()\n        let resources = ResizeArray()\n        let fscArgs   = ResizeArray()\n        let cArgv     =\n            [|\n                let isRNext = ref false\n                for a in argv do\n                    match a with\n                    | \"-r\" ->\n                        isRNext := true\n                    | _ ->\n                        if !isRNext then\n                            isRNext := false   \n                            yield \"-r:\" + a\n                        else\n                            yield a\n            |]\n        for a in cArgv do\n            let setProjectType t = wsArgs := { !wsArgs with ProjectType = Some t }\n            try\n                match a with\n                | \"--wig\"                          -> setProjectType WIG\n                | \"--bundle\"                       -> setProjectType Bundle\n                | \"--html\"                         -> setProjectType Html\n                | \"--site\"                         -> setProjectType Website\n                | StartsWith \"--ws:\" wsProjectType ->\n                    match wsProjectType.ToLower() with\n                    | \"site\" \n                    | \"web\" \n                    | \"website\" \n                    | \"export\"                     -> setProjectType Website\n                    | \"extension\"                  \n                    | \"interfacegenerator\"         -> setProjectType WIG\n                    | \"bundle\"                     -> setProjectType Bundle\n                    | \"html\"                       -> setProjectType Html\n                    | \"ignore\"                     -> ()\n                    | \"library\"                    -> ()\n                    | _                            -> invalidArg \"type\" (\"Invalid project type: \" + wsProjectType)\n                | StartsWith \"--project:\"        p -> wsArgs := { !wsArgs with ProjectFile   = p      } //Path.Combine(Directory.GetCurrentDirectory(), p) }\n                | StartsWith \"--wsoutput:\"       o -> wsArgs := { !wsArgs with OutputDir     = Some o }\n                | StartsWith \"--keyfile:\"        k -> wsArgs := { !wsArgs with KeyFile       = Some k }\n                | \"--jsmap\"                        -> wsArgs := { !wsArgs with SourceMap     = true   } \n                | \"--dts\"                          -> wsArgs := { !wsArgs with TypeScript    = true   } \n                | \"--wswarnonly\"                   -> wsArgs := { !wsArgs with WarnOnly      = true   } \n                | \"--printjs\"                      -> wsArgs := { !wsArgs with PrintJS       = true   }\n                | \"--debug\"                      \n                | \"--debug+\"                     \n                | \"--debug:full\"                 \n                | \"-g\"                           \n                | \"-g+\"                          \n                | \"-g:full\"                        -> wsArgs := { !wsArgs with IsDebug       = true   } ; fscArgs.Add a\n                | \"--vserrors\"                     -> wsArgs := { !wsArgs with VSStyleErrors = true   } ; fscArgs.Add a\n                | StartsWith \"-o:\"               o \n                | StartsWith \"--out:\"            o -> wsArgs := { !wsArgs with AssemblyFile = o       } ; fscArgs.Add a\n                | StartsWith \"--doc:\"            d -> wsArgs := { !wsArgs with Documentation = Some d } ; fscArgs.Add a\n                | StartsWith \"-r:\"               r             \n                | StartsWith \"--reference:\"      r -> refs.Add      r                                   ; fscArgs.Add a\n                | StartsWith \"--resource:\"       r -> resources.Add r                                   ; fscArgs.Add a\n                | _                                ->                                                     fscArgs.Add a  \n            with e ->\n                failwithf \"Parsing argument failed: '%s' - %s\" a e.Message\n        fscArgs.Add \"--define:FSHARP41\"\n        wsArgs := \n            { !wsArgs with \n                References   = refs |> Seq.map (fun s -> s.ToLower()) |> Seq.distinct |> Array.ofSeq\n                Resources    = resources.ToArray()\n                CompilerArgs = fscArgs  .ToArray() \n            }\n        CompileToJsW !wsArgs\n\n    let Process args =  \n        compileMainW args \n        |> Wrap.runSynchronouslyR\n        |> fun (Result(jsO, msgs)) -> \n               jsO |> Option.iter (printfn \"%s\")\n               if not msgs.IsEmpty then Result.getMessages msgs |> eprintfn \"%O\"\n               match jsO with\n               | Some js -> 0\n               | None    -> 1\n               \n    let endToken = sprintf \"//---------------%s-----------------\" \"EOF\"\n\n    [< EntryPoint >]\n    let Main args =\n        Console.SetIn(new StreamReader(Console.OpenStandardInput 30000))\n        let mutable cycle = true\n        if args = [| \"++loop\" |] \n        then while cycle do\n               let line = Console.ReadLine()\n               if line = null ||  line = \"++end\" then cycle <- false else\n               let argsL = match line with Regexs \"(\\\".*?\\\"|\\S+)\" ms -> ms |> Array.map (function | Regex \"(\\\"(.*)\\\")\" [_ ; m] | m -> m)\n               if Process argsL = 0 then \"success\" else \"fail\"\n               |> printfn \"//%s\"\n               eprintfn \"%s\" endToken\n             0\n        else Process args \n","parent":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"predecessors":[{"$":0,"Item":"7646acbc-2c28-4159-98b1-2365d19fc97c"},{"$":0,"Item":"9becc68c-9cc2-4f29-82df-e510d10226db"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},{"$":0,"Item":"b7c2d8cd-7246-4ad1-af46-ffbb7acde6e0"}],"id":{"$":0,"Item":"cfe0b3ef-9176-4f30-853c-27177faef6b0"},"expanded":true,"level":0,"properties":{}},{"name":"TranslatorCaller","content":"module TranslatorCaller =\n    open Useful\n    open UsefulDotNet\n    open CompOptionsModule\n    open System\n    open System.IO\n    open System.Diagnostics\n    \n    type TranslatorExe(config) =\n        let startInfo                 = ProcessStartInfo(@\"Compiled\\FsTranslator\\FsTranslator.exe\", config |> String.concat \" \")             \n        let shell                     = new ShellEx(startInfo)  // --noninteractive\n        let endToken                  = sprintf \"//---------------%s-----------------\" \"EOF\"\n        do  startInfo.CreateNoWindow <- false\n            shell.Start() |> ignore\n        member this.Translate txt =\n            Wrap.wrapper {\n                do! Result.tryProtection()\n                let! res1 = shell.SendAndWait(txt, endToken, true)\n                let! res2 = if res1.EndsWith \"//success\" then Result.succeed res1 else Result.fail (ErrSimple (\"Translator Failed\", false))\n                return res2\n            }\n        member this.IsAlive = not shell.HasExited\n        interface System.IDisposable with\n            member this.Dispose () = \n                (shell :> System.IDisposable).Dispose()    \n\n    let translator = lazy new ResourceAgent<_, string> (20, (fun config -> new TranslatorExe([\"++loop\"; defaultArg config \"\"] )), (fun exe -> (exe :> System.IDisposable).Dispose()), (fun exe -> exe.IsAlive), \"\")\n    \n    let extractConfig (code:string[]) = if code.[0].StartsWith \"////-d:\" then code.[0].[4..] else \"\"\n\n    let getJSW (minified:bool) (options0 : (CompOption * CompOptionValue) seq) (fsCode:string) =\n        Wrap.wrapper {\n            do!  Result.tryProtection()\n            let  code           = fsCode.Split '\\n'\n            let  defines0       = (extractConfig code).Split([| \" \" ; \"-d:\" |], StringSplitOptions.RemoveEmptyEntries) \n            let  fs, assembs, defines1, prepIs, nowarns = separatePrepros false code |> separateDirectives\n            let  defines        = Array.append defines0 defines1\n            let  codeBase       = Path.GetFullPath \"bin\"\n            let  name           = \"Temp_\" + Path.GetFileNameWithoutExtension(Path.GetRandomFileName())\n            let  options1       = compileOptionsDll name\n                                  + opDirectory   /= Path.GetDirectoryName(codeBase)\n                                  + opGenWSharper /= \"project:FSharpStation\"\n                                 // + opIOption   /= @\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\bin\"\n                                  + options0\n            let  options2       = prepOptions options1 (fs, assembs, defines, prepIs, nowarns)\n            use  toErase        = new TempFileName(options2?Source)\n            let  ops            = options2.Get CompOptions.WSharperOptions\n                                  |> Seq.append [ \"IGNORED\" ]\n                                  |> Seq.map (sprintf \"%A\")\n                                  |> String.concat \" \"\n            let! jsR            = translator.Value.Process (fun tra -> tra.Translate ops)\n            let! js             = jsR\n            return js\n        }\n\n\n","parent":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"predecessors":[{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},{"$":0,"Item":"ef053bdf-997b-49c8-a401-1611a568bd8a"},{"$":0,"Item":"ace1fc12-3dfb-4db8-80c9-5bde1e7d0597"},{"$":0,"Item":"4137cad8-fd64-426e-98de-16a92a56388d"},{"$":0,"Item":"f930dc48-39e8-453c-8c77-18a2cd73637a"}],"id":{"$":0,"Item":"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"},"expanded":true,"level":0,"properties":{}},{"name":"Test FsTranslator.exe","content":"open Useful\nopen UsefulDotNet\nopen CompOptionsModule\n\nWrap.wrapper {\n    let    snippet = \"FSSGlobal/WebSharper Code/WebSharper Snippets1/Test mouse\"//\"FSSGlobal/F# Code/Snippets/Failed to load argument type\"\n    //let    snippet = \"FSSGlobal/F# Code/Snippets/Failed to load argument type\"\n    let!   code    = FsStationShared.FsStationClient(\"Test FsTranslator.exe\").RequestCode snippet\n    let!   js      = TranslatorCaller.getJSW false [ (* opGenInternal /= \"showoptions\" *) ] code\n    return js\n} \n|> Wrap.runSynchronouslyS false\n|> printfn \"%A\"\n","parent":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"predecessors":[{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"},{"$":0,"Item":"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"},{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},{"$":0,"Item":"ef053bdf-997b-49c8-a401-1611a568bd8a"}],"id":{"$":0,"Item":"f587e7a5-825a-4c95-ac79-a53f43ed52c8"},"expanded":true,"level":0,"properties":{}},{"name":"translateAR","content":"open Useful\nopen WebSharper\n\n[< Rpc >]\nlet translateAS source minified = \n    async {\n        let!    res  = TranslatorCaller.getJSW minified [] source |> Wrap.getAsyncR\n        return  res |> Result.mapMsgs (Seq.map (fun (e:ErrMsg) -> e.ErrMsg, e.IsWarning) >> Seq.toArray)\n    }\n    \n[< JavaScript >]\nlet translateAR source minified = \n    async {\n        let!   vO, msgs = translateAS source minified\n        return  Result (vO,  msgs |> Seq.map (fun (msg, wrn) -> ErrSimple(msg, wrn) :> ErrMsg) |> Seq.toList)\n    }\n    ","parent":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},{"$":0,"Item":"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"}],"id":{"$":0,"Item":"95a237c8-a9ff-40d1-bd72-bd298b20af8c"},"expanded":true,"level":0,"properties":{}},{"name":"SlowlyChangingDimensions","content":"//#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n#r @\"C:\\Users\\Abelardo\\OneDrive - Cipher Business Solutions\\Clientes\\Houston\\CIPHERTool\\FSharp.Data.SqlClient\\FSharp.Data.SqlClient.dll\"\n\nmodule SlowlyChangingDimensions =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[{"$":0,"Item":"c7e56d1e-aea8-483a-a99a-23b7e056de0d"}],"id":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"expanded":false,"level":0,"properties":{}},{"name":"Fields","content":"type TargetField =\n     | CURR_ASSIGNED_VEND\n     | ORIG_ASSIGNED_VEND\n     | ORIG_INV_NUM\n     | POST_DTE_KEY\n     | RECEIVABLE_CURR_BILLING_TO_DTE\n     | RECEIVABLE_CURR_DELINQ_DTE\n     | RECEIVABLE_CURR_DUE_DTE\n     | RECEIVABLE_CURR_ISSUE_DTE\n     | RECEIVABLE_CURR_TO_DTE\n     | RECEIVABLE_KEY\n     | RECEIVABLE_ORIG_BILLING_TO_DTE\n     | RECEIVABLE_ORIG_DELINQ_DTE\n     | RECEIVABLE_ORIG_DUE_DTE\n     | RECEIVABLE_ORIG_ISSUE_DTE\n     | RECEIVABLE_ORIG_TO_DTE\n     | TRANS_DTE_KEY\n     | VERS_BEG_DTE  \n     | VERS_END_DTE \n     | CURR_VERS_FLAG\n     | ITEM_KEY\n     | INCDT_KEY\n     | CUST_KEY\n     | CARRIER_KEY\n     | CARRIER_PROCEDURE_KEY\n     | COLL_PERSON_KEY\n     | EMP_KEY\n     | FIN_TRANS_TYPE_KEY\n     | DTE_KEY\n     | COH_ORG_KEY\n     | SYS_LOAD_KEY       \n     | ORIG_CUST_KEY      \n     | COLL_VEND_CONTR_KEY\n     | GL_COMBO_KEY \n     | GL_ACCT_ID\n     | FUND_ID\n     | FUND_CNTR_ID\n     | FUNC_AREA_ID\n     | ROW_CHG_RSN\n     | Nil\n\ntype FinTransViewField =\n     | INTRA_DAY_ORDER\n     | DEPT_LONG_NAME\n     | CONTR_ID\n     | CUST_PAR_ID\n     | CUST_PAR_NAME\n     | ADJ_FLAG\n     | ALLOC_TRANS_FLAG\n     | BILLED_FLAG\n     | BLK_NUM\n     | BOOT_SERIAL_NUM\n     | BUS_AREA_ID\n     | BUS_CONT_PERSON_NAME\n     | CARRIER_FIN_CLASS\n     | CARRIER_FIN_GRP\n     | CARRIER_GRP\n     | CARRIER_NAME\n     | CARRIER_PROCEDURE_BILL_CODE\n     | CARRIER_PROCEDURE_CODE\n     | CARRIER_PROCEDURE_DESCR\n     | CARRIER_PROCEDURE_SRC\n     | CARRIER_PROCEDURE_TYPE\n     | CARRIER_SRC\n     | COH_EMP_NUM\n     | COLL_PERSON_ID\n     | COLL_PERSON_NAME\n     | COLL_PERSON_TYPE\n     | CONFI_CUST_FLAG\n     | CUST_ADDR_LINE_1\n     | CUST_ADDR_LINE_2\n     | CUST_ADDR_LINE_3\n     | CUST_APT_LOT\n     | CUST_CITY\n     | CUST_CNTY\n     | CUST_CTRY\n     | CUST_EMAIL_ADDR\n     | CUST_FAX_NUM\n     | CUST_GIS_CITY\n     | CUST_GIS_LOCATR_NAME\n     | CUST_GIS_MATCH_SCORE\n     | CUST_GIS_PREFIX\n     | CUST_GIS_ST_NAME\n     | CUST_GIS_ST_NUM\n     | CUST_GIS_ST_PRETYPE\n     | CUST_GIS_ST_TYPE\n     | CUST_GIS_SUFF\n     | CUST_GIS_X\n     | CUST_GIS_Y\n     | CUST_GIS_ZIP\n     | CUST_ID\n     | CUST_IN_CITY_FLAG\n     | CUST_IS_VEND_FLAG\n     | CUST_NAME\n     | CUST_PAR_KEY\n     | CUST_PHN_NUM_1\n     | CUST_PHN_NUM_2\n     | CUST_PHN_NUM_3\n     | CUST_PREFIX\n     | CUST_SERV_LVL\n     | CUST_ST\n     | CUST_STATE\n     | CUST_ST_DIR\n     | CUST_ST_NAME\n     | CUST_ST_NUM\n     | CUST_ST_PRETYPE\n     | CUST_ST_TYPE\n     | CUST_SUFF\n     | CUST_TYPE\n     | CUST_ZIP_CODE\n     | CUST_ZIP_PLUS_4\n     | DEC_CUST_FLAG\n     | DERIVED_TRANS_FLAG\n     | DET_TRANS_CODE\n     | DET_TRANS_DESCR\n     | DIGITECH_ID\n     | DIGITECH_TRANS_TYPE\n     | DIGITECH_TRANS_TYPE_DET\n     | DIV_LONG_NAME\n     | DL_ISSUE_STATE\n     | DL_NUM\n     | DTE\n     | EMP_NAME\n     | EMP_TYPE\n     | FED_TAX_ID\n     | FIRE_ALM_AGING_RST_FLAG\n     | FIRE_ORIG_ISSUE_DTE\n     | FUNC_AREA_ID\n     | FUND_CNTR_ID\n     | FUND_ID\n     | GL_ACCT_ID\n     | HCTO_AD_VAL_ID\n     | INCDT_ADDR_LINE_1\n     | INCDT_ADDR_LINE_2\n     | INCDT_ADDR_LINE_3\n     | INCDT_APT_LOT\n     | INCDT_CAT\n     | INCDT_CITY\n     | INCDT_CNTY\n     | INCDT_CTRY\n     | INCDT_DESCR\n     | INCDT_DTE\n     | INCDT_GIS_CITY\n     | INCDT_GIS_LOCATR_NAME\n     | INCDT_GIS_MATCH_SCORE\n     | INCDT_GIS_PREFIX\n     | INCDT_GIS_ST_NAME\n     | INCDT_GIS_ST_NUM\n     | INCDT_GIS_ST_PRETYPE\n     | INCDT_GIS_ST_TYPE\n     | INCDT_GIS_SUFF\n     | INCDT_GIS_X\n     | INCDT_GIS_Y\n     | INCDT_GIS_ZIP\n     | INCDT_IN_CITY_FLAG\n     | INCDT_PREFIX\n     | INCDT_SEQ_NUM\n     | INCDT_SERV_LVL\n     | INCDT_ST\n     | INCDT_STATE\n     | INCDT_ST_DIR\n     | INCDT_ST_NAME\n     | INCDT_ST_NUM\n     | INCDT_ST_PRETYPE\n     | INCDT_ST_TYPE\n     | INCDT_SUFF\n     | INCDT_TIME\n     | INCDT_TYPE\n     | INCDT_ZIP_CODE\n     | INCDT_ZIP_PLUS_4\n     | INTRA_FUND_TRANS_AMT\n     | INTRA_FUND_TRANS_FLAG\n     | INT_EXT_EMP_FLAG\n     | INV_NUM\n     | ITEM_ADDR_LINE_1\n     | ITEM_ADDR_LINE_2\n     | ITEM_ADDR_LINE_3\n     | ITEM_APT_LOT\n     | ITEM_CITY\n     | ITEM_CNTY\n     | ITEM_CTRY\n     | ITEM_DESCR\n     | ITEM_EXMPT_FLAG\n     | ITEM_GIS_CITY\n     | ITEM_GIS_LOCATR_NAME\n     | ITEM_GIS_MATCH_SCORE\n     | ITEM_GIS_PREFIX\n     | ITEM_GIS_ST_NAME\n     | ITEM_GIS_ST_NUM\n     | ITEM_GIS_ST_PRETYPE\n     | ITEM_GIS_ST_TYPE\n     | ITEM_GIS_SUFF\n     | ITEM_GIS_X\n     | ITEM_GIS_Y\n     | ITEM_GIS_ZIP\n     | ITEM_IN_CITY_FLAG\n     | ITEM_PREFIX\n     | ITEM_SERV_LVL\n     | ITEM_ST\n     | ITEM_STAT\n     | ITEM_STATE\n     | ITEM_STAT_CHG_DTE\n     | ITEM_ST_DIR\n     | ITEM_ST_NAME\n     | ITEM_ST_NUM\n     | ITEM_ST_PRETYPE\n     | ITEM_ST_TYPE\n     | ITEM_SUFF\n     | ITEM_TYPE\n     | ITEM_ZIP_CODE\n     | ITEM_ZIP_PLUS_4\n     | JV_CUST_FLAG\n     | LOAD_DTE\n     | LOAD_TIME\n     | MAN_TRANS_FLAG\n     | MEDICAID_PAYER_CODE\n     | MEDICARE_PAYER_CODE\n     | MSTR_TRANS_TYPE\n     | NAICS_DET_CODE\n     | NAICS_DET_NAME\n     | NAICS_DIV_CODE\n     | NAICS_DIV_NAME\n     | NAICS_INDY_CODE\n     | NAICS_INDY_GRP_CODE\n     | NAICS_INDY_GRP_NAME\n     | NAICS_INDY_NAME\n     | NAICS_MAJ_GRP_CODE\n     | NAICS_MAJ_GRP_NAME\n     | ORIG_BILL_NAME\n     | PAY_METH\n     | PERMIT_IS_CURR_AT_TIME_OF_INCDT_FLAG\n     | PMAM_ADJMT_TO\n     | PMAM_ADJMT_TYPE\n     | PMAM_ID\n     | POST_DTE\n     | PRKG_METER_NUM\n     | PRKG_METER_VIO_FLAG\n     | RECEIVABLE_1ST_PAY_DTE\n     | RECEIVABLE_EVER_TRANS_FLAG\n     | RECEIVABLE_FNL_PAY_DTE\n     | RECEIVABLE_LITIGATION_DTE\n     | RECEIVABLE_MSTR_STAT\n     | RECEIVABLE_MSTR_STAT_CHG_DTE\n     | RECEIVABLE_SETTLEMENT_DTE\n     | RECEIVABLE_STAT\n     | RECEIVABLE_STAT_CHG_DTE\n     | RECEIVABLE_VERS_BILLING_TO_DTE\n     | RECEIVABLE_VERS_DELINQ_DTE\n     | RECEIVABLE_VERS_DUE_DTE\n     | RECEIVABLE_VERS_ISSUE_DTE\n     | RECEIVABLE_VERS_TO_DTE\n     | REINSTATEMENT_DTE\n     | RM_EMP_MSTR_KEY\n     | RM_LOAD_DTE\n     | RM_LOAD_TIME\n     | RSN_INCDT_NOT_BILLED\n     | SAP_BUS_ID\n     | SIC_CODE\n     | SIC_DIV_CODE\n     | SIC_DIV_NAME\n     | SIC_INDY_GRP_CODE\n     | SIC_INDY_GRP_NAME\n     | SIC_MAJ_GRP_CODE\n     | SIC_MAJ_GRP_NAME\n     | SIC_NAME\n     | SMARTCM_IS_ADJMT\n     | SMARTCM_IS_FEE\n     | SMARTCM_IS_PAY\n     | SMARTCM_OTHER_CRITERIA\n     | SMART_CM_ID\n     | SRC_CARRIER_KEY\n     | SRC_CARRIER_PROCEDURE_KEY\n     | SRC_SYS\n     | SRC_SYS_ID\n     | SRC_SYS_MOD_DTE\n     | SRC_SYS_TRANS_ID\n     | STATE_CORP_CHTR_ID\n     | STATE_SALES_TAX_ID\n     | T2_ID\n     | T2_TRANS_MISC_ITEM_CODE\n     | T2_TRANS_MISC_ITEM_DESCR\n     | T2_TRANS_ORIG_OBJ_TYPE_ID\n     | T2_TRANS_PARSED_DESCR\n     | T2_TRANS_RSN\n     | T2_TRANS_SCENARIO\n     | T2_TRANS_TYPE_CODE\n     | T2_TRANS_TYPE_DESCR\n     | TOWING_CMPNY\n     | TRANS_AMT\n     | TRANS_CNT\n     | UNK_CUST_AT_BILL_FLAG\n     | VERS_ASSIGNED_VEND\n     | VIO_CODE\n     | EMS_INCDT   \n     | DISPATCH_NUM\n     | FLAG_DIM_INCDT_EMS_DET\n     | DEST_LOC\n     | EMS_INCDT_CAT\n     | ORIGIN_LOC\n     | TXP_SERV_LVL\n     | TXP_TYPE\n     | VEH\n     | FLAG_DIM_ITEM_BURG_ALM_PERMIT_DET\n     | ALLOWABLE_NO_CHRG_INCDTS\n     | ALM_MNT_CMPNY\n     | ALM_TYPE\n     | PERMIT_EXP_DTE\n     | PERMIT_ISSUE_DTE\n     | PERMIT_NAME\n     | PERMIT_NUM\n     | REG_HOLDER_FLAG\n     | SUSPD_PERMIT_DTE\n     | SUSPD_PERMIT_RSN\n     | TYPE_OF_ALM_SITE\n     | FLAG_DIM_ITEM_FIRE_ALM_PERMIT_DET\n     | ALM_INSTL_CMPNY\n     | ALM_INSTL_DTE\n     | ALM_REG_KEY\n     | APPLICTN_RECV_DTE\n     | CURR_FIRE_ALM_PERMIT_FLAG\n     | EXCL_TYPE\n     | FIRE_ALM_PERMIT_ACTV_FLAG\n     | FIRE_ALM_PERMIT_NUM\n     | FIRE_ALM_PURPOSE\n     | FLAG_DIM_ITEM_LICENSED_VEH_DET\n     | LICENSE_PLATE_EXP_MTH\n     | LICENSE_PLATE_EXP_YR\n     | LICENSE_PLATE_NUM\n     | LICENSE_PLATE_TYPE\n     | OWNER_IS_CUST_FLAG\n     | SRC_SYS_VEH_ID\n     | VEH_COLOR\n     | VEH_ID_NUM\n     | VEH_MAKE\n     | VEH_MODEL\n     | VEH_MODEL_YR\n     | VEH_OWNER_ID\n     | VEH_OWNER_NAME\n     | VEH_TYPE\n     | FLAG_DIM_ITEM_PT_DET\n     | PT_AGE\n     | PT_GNDR\n     | FLAG_DIM_ITEM_TAXABLE_PROP_DET\n     | APPRAISAL_DISTR_ACCT_NUM\n     | CAN\n     | CC_JURIS_CODE\n     | CC_JURIS_DESCR\n     | CITY_RFPD_JURIS_CODE\n     | CITY_RFPD_JURIS_DESCR\n     | CONFI_ACCT_FLAG\n     | MUNIC_UTIL_DISTR_CODE\n     | MUNIC_UTIL_DISTR_DESCR\n     | NUM_OF_ACRES\n     | OWNERSHIP_EFF_DTE\n     | PROP_CLASS_CODE\n     | PROP_CLASS_DESCR\n     | REND_PENALTY_JURIS_CODE\n     | REND_PENALTY_JURIS_DESCR\n     | SCHOOL_JURIS_CODE\n     | SCHOOL_JURIS_DESCR\n     | SUBSTANTIAL_ERR_PENALTY\n     | TAX_DEFERRAL_END_DTE\n     | TAX_DEFERRAL_START_DTE\n     | TAX_ROLL_CODE\n     | TAX_ROLL_DESCR\n     | TAXABLE_PROP_LGL_DESCR_1\n     | TAXABLE_PROP_LGL_DESCR_2\n     | TAXABLE_PROP_LGL_DESCR_3\n     | TAXABLE_PROP_LGL_DESCR_4\n     | TAXABLE_PROP_LGL_DESCR_5\n     | TAXABLE_PROP_ROLL_TYPE\n     | FLAG_DIM_ITEM_WTR_ACCT_DET\n     | CURR_WTR_ACCT_FLAG\n     | DELINQ_DTE\n     | LAST_CUST_CONN_DTE\n     | LAST_CUST_CUTOFF_DTE\n     | LAST_CUST_DISCONN_DTE\n     | LAST_METER_INSPECT_DTE\n     | OWNER_RENTER\n     | SEN_CITIZEN_FLAG\n     | VAC_FLAG\n     | WTR_ACCT_NUM_OF_UNITS\n     | WTR_ACCT_ORIG_USE_TYPE\n     | WTR_ACCT_PROP_USE_TYPE\n     | WTR_METER_NUM\n     | FLAG_DIM_RECEIVABLE_AD_VAL_RECEIVABLE_DET\n     | ``A#3307_ATTY_FEE_DTE``\n     | ``A#3308_ATTY_FEE_DTE``\n     | ``A#3348_ATTY_FEE_DTE``\n     | AD_VAL_ACCT_LVL_ID\n     | AD_VAL_DISABLED_FLAG\n     | AD_VAL_EFF_DTE_OF_OWNERSHIP\n     | AD_VAL_HOMESTEAD_FLAG\n     | AD_VAL_OVER_66_FLAG\n     | AD_VAL_TAX_DEFERRAL_END_DTE\n     | AD_VAL_TAX_DEFERRAL_START_DTE\n     | AD_VAL_VET_FLAG\n     | COLL_LAWSUIT_NUM\n     | COLL_LGL_COND\n     | HCAD_ACCT_STAT\n     | QTRLY_PAY_FLAG\n     | FLAG_DIM_RECEIVABLE_BOOT_TOW_DET\n     | RECEIVABLE_HAS_LTR_FLAG\n     | RECEIVABLE_HAS_NOTE_FLAG\n     | RECEIVABLE_HAS_PEND_LTR_FLAG\n     | RESOLVE_DESCR\n     | RESOLVE_DTE\n     | RESOLVE_RSN\n     | RESOLVED_BY\n     | FLAG_DIM_RECEIVABLE_EMS_RECEIVABLE_DET\n     | ACTV_CARRIER\n     | ACTV_CARRIER_FIN_CLASS\n     | ACTV_CARRIER_FIN_GRP\n     | BILLING_HOLD_FLAG\n     | SIG_FLAG\n     | FLAG_DIM_RECEIVABLE_FIRE_ALM_CIT_DET\n     | VOID_CODE\n     | VOID_DESCR\n     | WORK_STAT\n     | FLAG_DIM_RECEIVABLE_PRKG_CONTRA_DET\n     | ESC_CAND_FLAG\n     | ON_ADMIN_HOLD_FLAG\n     | UNDER_APPEAL_FLAG\n     | VOID_FLAG\n     | WRITE_OFF_FLAG\n     | Nil_\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"id":{"$":0,"Item":"62d0b48f-6f54-4fa2-a455-e1f288cfd0c8"},"expanded":true,"level":0,"properties":{}},{"name":"FieldDecls","content":"let fieldDecl = [|\n    (\"3307_ATTY_FEE_DTE\", \"datetime\", 0)\n    (\"3308_ATTY_FEE_DTE\", \"datetime\", 0)\n    (\"3348_ATTY_FEE_DTE\", \"datetime\", 0)\n    (\"ACCT_GRP_DESCR\", \"varchar(30)\", 0)\n    (\"ACCT_GRP_ID\", \"varchar(4)\", 0)\n    (\"ACTV_CARRIER\", \"varchar(120)\", 0)\n    (\"ACTV_CARRIER_FIN_CLASS\", \"varchar(40)\", 0)\n    (\"ACTV_CARRIER_FIN_GRP\", \"varchar(40)\", 0)\n    (\"AD_VAL_ACCT_LVL_ID\", \"varchar(4)\", 1)\n    (\"AD_VAL_DISABLED_FLAG\", \"varchar(1)\", 0)\n    (\"AD_VAL_EFF_DTE_OF_OWNERSHIP\", \"datetime\", 0)\n    (\"AD_VAL_HOMESTEAD_FLAG\", \"varchar(1)\", 0)\n    (\"AD_VAL_OVER_66_FLAG\", \"varchar(1)\", 0)\n    (\"AD_VAL_TAX_DEFERRAL_END_DTE\", \"datetime\", 0)\n    (\"AD_VAL_TAX_DEFERRAL_START_DTE\", \"datetime\", 0)\n    (\"AD_VAL_VET_FLAG\", \"varchar(1)\", 0)\n    (\"ADDR_ID\", \"varchar(10)\", 0)\n    (\"ADJ_FLAG\", \"varchar(1)\", 0)\n    (\"ALLOC_TRANS_FLAG\", \"varchar(1)\", 0)\n    (\"ALLOWABLE_NO_CHRG_INCDTS\", \"int\", 0)\n    (\"ALM_INSTL_CMPNY\", \"varchar(50)\", 0)\n    (\"ALM_INSTL_DTE\", \"datetime\", 0)\n    (\"ALM_MNT_CMPNY\", \"varchar(50)\", 0)\n    (\"ALM_REG_KEY\", \"varchar(20)\", 0)\n    (\"ALM_TYPE\", \"varchar(2)\", 0)\n    (\"ALT_PAYEE_NUM\", \"varchar(10)\", 0)\n    (\"AM_PM\", \"varchar(2)\", 0)\n    (\"APPLICTN_RECV_DTE\", \"datetime\", 0)\n    (\"APPRAISAL_DISTR_ACCT_NUM\", \"varchar(16)\", 0)\n    (\"AUTH_GRP_ID\", \"varchar(10)\", 0)\n    (\"BAL_SHT_ACCT_FLAG\", \"varchar(1)\", 0)\n    (\"BAL_UPD_IND\", \"varchar(1)\", 0)\n    (\"BILLED_FLAG\", \"varchar(1)\", 0)\n    (\"BILLING_HOLD_FLAG\", \"varchar(1)\", 0)\n    (\"BLANK_BUD_PER_ALLOWED\", \"varchar(1)\", 0)\n    (\"BLK_NUM\", \"varchar(8)\", 0)\n    (\"BOOT_SERIAL_NUM\", \"varchar(32)\", 0)\n    (\"BUS_AREA_DESCR\", \"varchar(30)\", 0)\n    (\"BUS_AREA_FULL_NAME\", \"varchar(120)\", 0)\n    (\"BUS_AREA_ID\", \"varchar(4)\", 0)\n    (\"BUS_AREA_KEY\", \"int\", 0)\n    (\"BUS_CONT_PERSON_NAME\", \"varchar(40)\", 0)\n    (\"CAL_DAY_OF_MTH_NUM\", \"int\", 0)\n    (\"CAL_MTH\", \"varchar(15)\", 0)\n    (\"CAL_MTH_NUM\", \"int\", 0)\n    (\"CAL_PER\", \"varchar(20)\", 1)\n    (\"CAL_QTR\", \"varchar(15)\", 1)\n    (\"CAL_QTR_NUM\", \"int\", 0)\n    (\"CAL_WK_ENDING_SAT\", \"varchar(15)\", 0)\n    (\"CAL_YR\", \"int\", 0)\n    (\"CAN\", \"varchar(16)\", 1)\n    (\"CARRIER_FIN_CLASS\", \"varchar(40)\", 0)\n    (\"CARRIER_FIN_GRP\", \"varchar(40)\", 0)\n    (\"CARRIER_GRP\", \"varchar(40)\", 0)\n    (\"CARRIER_KEY\", \"int\", 0)\n    (\"CARRIER_NAME\", \"varchar(120)\", 0)\n    (\"CARRIER_PROCEDURE_BILL_CODE\", \"varchar(40)\", 0)\n    (\"CARRIER_PROCEDURE_CODE\", \"varchar(40)\", 0)\n    (\"CARRIER_PROCEDURE_DESCR\", \"varchar(120)\", 0)\n    (\"CARRIER_PROCEDURE_KEY\", \"int\", 0)\n    (\"CARRIER_PROCEDURE_SRC\", \"varchar(120)\", 0)\n    (\"CARRIER_PROCEDURE_TYPE\", \"varchar(40)\", 0)\n    (\"CARRIER_SRC\", \"varchar(120)\", 0)\n    (\"CC_JURIS_CODE\", \"varchar(13)\", 1)\n    (\"CC_JURIS_DESCR\", \"varchar(50)\", 0)\n    (\"CENTRAL_POSTING_BLK\", \"varchar(1)\", 0)\n    (\"CENTRALLY_IMPOSED_PURCH_BLK\", \"varchar(1)\", 0)\n    (\"CHGED_BY\", \"varchar(12)\", 0)\n    (\"CHGED_ON\", \"datetime\", 0)\n    (\"CHGED_ON_DTE\", \"datetime\", 0)\n    (\"CHRT_OF_ACCT_FULL_NAME\", \"varchar(120)\", 0)\n    (\"CHRT_OF_ACCT_ID\", \"varchar(4)\", 0)\n    (\"CHRT_OF_ACCT_NAME\", \"varchar(50)\", 0)\n    (\"CITY\", \"varchar(40)\", 0)\n    (\"CITY_BUS_DAY\", \"varchar(40)\", 1)\n    (\"CITY_HOL_FLAG\", \"varchar(1)\", 0)\n    (\"CITY_RFPD_JURIS_CODE\", \"varchar(13)\", 1)\n    (\"CITY_RFPD_JURIS_DESCR\", \"varchar(50)\", 0)\n    (\"CMPNY_CODE_ID\", \"varchar(4)\", 0)\n    (\"CMPNY_CODE_NAME\", \"varchar(25)\", 0)\n    (\"COH\", \"varchar(20)\", 1)\n    (\"COH_EMP_NUM\", \"varchar(8)\", 0)\n    (\"COH_ORG_KEY\", \"int\", 0)\n    (\"COLL_BID_NUM\", \"varchar(10)\", 0)\n    (\"COLL_LAWSUIT_NUM\", \"varchar(7)\", 0)\n    (\"COLL_LGL_COND\", \"varchar(100)\", 0)\n    (\"COLL_PERSON_ID\", \"varchar(20)\", 0)\n    (\"COLL_PERSON_KEY\", \"int\", 0)\n    (\"COLL_PERSON_NAME\", \"varchar(120)\", 0)\n    (\"COLL_PERSON_TYPE\", \"varchar(40)\", 0)\n    (\"COLL_VEND_CONTR_KEY\", \"int\", 0)\n    (\"CONFI_ACCT_FLAG\", \"varchar(2)\", 1)\n    (\"CONFI_CUST_FLAG\", \"varchar(1)\", 0)\n    (\"CONTR_DESCR\", \"varchar(1000)\", 1)\n    (\"CONTR_ID\", \"varchar(10)\", 0)\n    (\"CONTR_KEY\", \"int\", 0)\n    (\"CONTR_LIFE_PRIOD\", \"int\", 0)\n    (\"CONTR_PER_KEY\", \"int\", 0)\n    (\"CONTR_REV_STREAM\", \"varchar(50)\", 1)\n    (\"CONTR_YR\", \"varchar(15)\", 0)\n    (\"CONTR_YR_PER\", \"varchar(15)\", 0)\n    (\"CR_INFO_ID\", \"varchar(11)\", 0)\n    (\"CREATE_DTE\", \"datetime\", 0)\n    (\"CREATED_BY\", \"varchar(12)\", 0)\n    (\"CTRL_AREA_DESCR\", \"varchar(20)\", 0)\n    (\"CTRL_AREA_ID\", \"varchar(4)\", 0)\n    (\"CTRY_ID\", \"varchar(3)\", 0)\n    (\"CTRY_NAME\", \"varchar(15)\", 0)\n    (\"CURR_ASSIGNED_VEND\", \"varchar(120)\", 1)\n    (\"CURR_FIRE_ALM_PERMIT_FLAG\", \"varchar(1)\", 0)\n    (\"CURR_VERS_FLAG\", \"varchar(1)\", 0)\n    (\"CURR_WTR_ACCT_FLAG\", \"varchar(1)\", 0)\n    (\"CUST_ADDR_LINE_1\", \"varchar(200)\", 0)\n    (\"CUST_ADDR_LINE_2\", \"varchar(200)\", 0)\n    (\"CUST_ADDR_LINE_3\", \"varchar(200)\", 0)\n    (\"CUST_APT_LOT\", \"varchar(20)\", 0)\n    (\"CUST_CITY\", \"varchar(40)\", 1)\n    (\"CUST_CNTY\", \"varchar(20)\", 0)\n    (\"CUST_CTRY\", \"varchar(32)\", 1)\n    (\"CUST_EMAIL_ADDR\", \"varchar(100)\", 0)\n    (\"CUST_FAX_NUM\", \"varchar(15)\", 0)\n    (\"CUST_GIS_CITY\", \"varchar(20)\", 0)\n    (\"CUST_GIS_CMPLT_MATCH_ADDR\", \"varchar(200)\", 1)\n    (\"CUST_GIS_LAT\", \"varchar(38)\", 1)\n    (\"CUST_GIS_LOCATR_NAME\", \"varchar(40)\", 0)\n    (\"CUST_GIS_LONG\", \"varchar(38)\", 1)\n    (\"CUST_GIS_MATCH_SCORE\", \"varchar(10)\", 1)\n    (\"CUST_GIS_PREFIX\", \"varchar(12)\", 1)\n    (\"CUST_GIS_ST_NAME\", \"varchar(60)\", 1)\n    (\"CUST_GIS_ST_NUM\", \"varchar(12)\", 1)\n    (\"CUST_GIS_ST_PRETYPE\", \"varchar(40)\", 1)\n    (\"CUST_GIS_ST_TYPE\", \"varchar(40)\", 1)\n    (\"CUST_GIS_SUFF\", \"varchar(12)\", 1)\n    (\"CUST_GIS_X\", \"varchar(21)\", 1)\n    (\"CUST_GIS_Y\", \"varchar(17)\", 1)\n    (\"CUST_GIS_ZIP\", \"varchar(5)\", 0)\n    (\"CUST_ID\", \"varchar(120)\", 0)\n    (\"CUST_IN_CITY_FLAG\", \"varchar(1)\", 0)\n    (\"CUST_IS_VEND_FLAG\", \"varchar(1)\", 0)\n    (\"CUST_KEY\", \"int\", 0)\n    (\"CUST_NAME\", \"varchar(120)\", 0)\n    (\"CUST_PAR_ADDR_LINE_1\", \"varchar(200)\", 0)\n    (\"CUST_PAR_ADDR_LINE_2\", \"varchar(200)\", 0)\n    (\"CUST_PAR_ADDR_LINE_3\", \"varchar(200)\", 0)\n    (\"CUST_PAR_APT_LOT\", \"varchar(20)\", 0)\n    (\"CUST_PAR_CITY\", \"varchar(20)\", 0)\n    (\"CUST_PAR_CNTY\", \"varchar(20)\", 0)\n    (\"CUST_PAR_CTRY\", \"varchar(20)\", 0)\n    (\"CUST_PAR_GIS_CITY\", \"varchar(20)\", 0)\n    (\"CUST_PAR_GIS_LOCATR_NAME\", \"varchar(40)\", 0)\n    (\"CUST_PAR_GIS_MATCH_SCORE\", \"varchar(3)\", 1)\n    (\"CUST_PAR_GIS_PREFIX\", \"varchar(2)\", 0)\n    (\"CUST_PAR_GIS_ST_NAME\", \"varchar(35)\", 0)\n    (\"CUST_PAR_GIS_ST_NUM\", \"varchar(7)\", 0)\n    (\"CUST_PAR_GIS_ST_PRETYPE\", \"varchar(15)\", 0)\n    (\"CUST_PAR_GIS_ST_TYPE\", \"varchar(4)\", 0)\n    (\"CUST_PAR_GIS_SUFF\", \"varchar(2)\", 0)\n    (\"CUST_PAR_GIS_X\", \"varchar(17)\", 1)\n    (\"CUST_PAR_GIS_Y\", \"varchar(17)\", 1)\n    (\"CUST_PAR_GIS_ZIP\", \"varchar(5)\", 0)\n    (\"CUST_PAR_ID\", \"varchar(40)\", 0)\n    (\"CUST_PAR_IN_CITY_FLAG\", \"varchar(1)\", 0)\n    (\"CUST_PAR_KEY\", \"int\", 0)\n    (\"CUST_PAR_NAME\", \"varchar(40)\", 0)\n    (\"CUST_PAR_PREFIX\", \"varchar(2)\", 1)\n    (\"CUST_PAR_SERV_LVL\", \"varchar(40)\", 0)\n    (\"CUST_PAR_ST\", \"varchar(100)\", 0)\n    (\"CUST_PAR_ST_DIR\", \"varchar(4)\", 0)\n    (\"CUST_PAR_ST_NAME\", \"varchar(35)\", 0)\n    (\"CUST_PAR_ST_NUM\", \"varchar(7)\", 0)\n    (\"CUST_PAR_ST_PRETYPE\", \"varchar(15)\", 0)\n    (\"CUST_PAR_ST_TYPE\", \"varchar(4)\", 0)\n    (\"CUST_PAR_STATE\", \"varchar(25)\", 0)\n    (\"CUST_PAR_SUFF\", \"varchar(2)\", 0)\n    (\"CUST_PAR_ZIP_CODE\", \"varchar(6)\", 0)\n    (\"CUST_PAR_ZIP_PLUS_4\", \"varchar(11)\", 0)\n    (\"CUST_PHN_NUM_1\", \"varchar(20)\", 1)\n    (\"CUST_PHN_NUM_2\", \"varchar(20)\", 1)\n    (\"CUST_PHN_NUM_3\", \"varchar(20)\", 1)\n    (\"CUST_PREFIX\", \"varchar(2)\", 1)\n    (\"CUST_SERV_LVL\", \"varchar(40)\", 0)\n    (\"CUST_ST\", \"varchar(100)\", 0)\n    (\"CUST_ST_DIR\", \"varchar(4)\", 0)\n    (\"CUST_ST_NAME\", \"varchar(35)\", 0)\n    (\"CUST_ST_NUM\", \"varchar(7)\", 0)\n    (\"CUST_ST_PRETYPE\", \"varchar(15)\", 0)\n    (\"CUST_ST_TYPE\", \"varchar(4)\", 0)\n    (\"CUST_STATE\", \"varchar(25)\", 0)\n    (\"CUST_SUFF\", \"varchar(2)\", 0)\n    (\"CUST_TYPE\", \"varchar(13)\", 1)\n    (\"CUST_ZIP_CODE\", \"varchar(32)\", 1)\n    (\"CUST_ZIP_PLUS_4\", \"varchar(13)\", 1)\n    (\"DAY_OF_WK\", \"varchar(9)\", 0)\n    (\"DAY_OF_WK_NUM\", \"int\", 0)\n    (\"DEC_CUST_FLAG\", \"varchar(1)\", 0)\n    (\"DEL_FLAG\", \"varchar(1)\", 0)\n    (\"DELINQ_DTE\", \"datetime\", 0)\n    (\"DELIV_POLICY_FLAG\", \"varchar(1)\", 0)\n    (\"DEPT_LONG_NAME\", \"varchar(120)\", 1)\n    (\"DEPT_NAME\", \"varchar(30)\", 1)\n    (\"DERIVED_NODE_FLAG\", \"varchar(1)\", 0)\n    (\"DERIVED_PAR_CUST_FLAG\", \"varchar(1)\", 0)\n    (\"DERIVED_TRANS_FLAG\", \"varchar(1)\", 0)\n    (\"DEST_LOC\", \"varchar(120)\", 0)\n    (\"DET_TRANS_CODE\", \"varchar(20)\", 0)\n    (\"DET_TRANS_DESCR\", \"varchar(50)\", 0)\n    (\"DIGITECH_ID\", \"varchar(20)\", 1)\n    (\"DIGITECH_TRANS_TYPE\", \"varchar(40)\", 1)\n    (\"DIGITECH_TRANS_TYPE_DET\", \"varchar(120)\", 1)\n    (\"DISASTER_FLAG\", \"varchar(1)\", 0)\n    (\"DISPATCH_NUM\", \"varchar(40)\", 0)\n    (\"DISTR\", \"varchar(40)\", 0)\n    (\"DIV_LONG_NAME\", \"varchar(120)\", 1)\n    (\"DIV_NAME\", \"varchar(30)\", 1)\n    (\"DL_ISSUE_STATE\", \"varchar(20)\", 0)\n    (\"DL_NUM\", \"varchar(20)\", 0)\n    (\"DST_EX_MIN_FLAG\", \"varchar(1)\", 0)\n    (\"DTE\", \"date\", 0)\n    (\"DTE_FISC_PER_KEY\", \"int\", 0)\n    (\"DTE_KEY\", \"int\", 0)\n    (\"EMP_KEY\", \"int\", 0)\n    (\"EMP_NAME\", \"varchar(120)\", 0)\n    (\"EMP_TYPE\", \"varchar(40)\", 0)\n    (\"EMS_INCDT\", \"varchar(40)\", 0)\n    (\"EMS_INCDT_CAT\", \"varchar(120)\", 0)\n    (\"ENTRY_DTE\", \"datetime\", 0)\n    (\"ESC_CAND_FLAG\", \"varchar(1)\", 0)\n    (\"ETL_PROC_USED\", \"varchar(50)\", 0)\n    (\"EXCH_RATE_LOCAL\", \"numeric\", 0)\n    (\"EXCL_TYPE\", \"varchar(50)\", 0)\n    (\"EXP_DTE\", \"datetime\", 0)\n    (\"EXTRACT_DTE_TIME\", \"datetime\", 0)\n    (\"EXTRACT_PROC_USED\", \"varchar(50)\", 0)\n    (\"FAX\", \"varchar(40)\", 0)\n    (\"FED_FISC_PER\", \"varchar(15)\", 0)\n    (\"FED_FISC_PER_NUM\", \"int\", 0)\n    (\"FED_FISC_QTR\", \"varchar(15)\", 1)\n    (\"FED_FISC_QTR_NUM\", \"int\", 0)\n    (\"FED_FISC_YR\", \"varchar(15)\", 1)\n    (\"FED_TAX_ID\", \"varchar(40)\", 0)\n    (\"FG_FIN_TRANS_KEY\", \"int\", 0)\n    (\"FIN_MGMT_AREA\", \"varchar(4)\", 0)\n    (\"FIN_MGMT_AREA_DESCR\", \"varchar(25)\", 0)\n    (\"FIN_TRANS_TYPE_KEY\", \"int\", 0)\n    (\"FIRE_ALM_AGING_RST_FLAG\", \"varchar(1)\", 0)\n    (\"FIRE_ALM_PERMIT_ACTV_FLAG\", \"varchar(1)\", 0)\n    (\"FIRE_ALM_PERMIT_NUM\", \"varchar(20)\", 0)\n    (\"FIRE_ALM_PURPOSE\", \"varchar(50)\", 0)\n    (\"FIRE_ORIG_ISSUE_DTE\", \"datetime\", 0)\n    (\"FISC_PER\", \"varchar(15)\", 0)\n    (\"FISC_PER_ANNUAL_SORT_ORD\", \"int\", 0)\n    (\"FISC_PER_NUM\", \"int\", 0)\n    (\"FISC_QTR\", \"varchar(15)\", 0)\n    (\"FISC_QTR_NUM\", \"int\", 0)\n    (\"FISC_YR\", \"int\", 0)\n    (\"FISC_YR_VARIANT\", \"varchar(2)\", 0)\n    (\"FM_AUTH_GRP\", \"varchar(10)\", 0)\n    (\"FM_FINUSE\", \"varchar(16)\", 0)\n    (\"FM_SPONSER\", \"varchar(10)\", 0)\n    (\"FUNC_AREA_DESCR\", \"varchar(30)\", 0)\n    (\"FUNC_AREA_FULL_NAME\", \"varchar(120)\", 0)\n    (\"FUNC_AREA_ID\", \"varchar(16)\", 0)\n    (\"FUNC_AREA_KEY\", \"int\", 0)\n    (\"FUNC_THAT_WILL_BE_BLKED\", \"varchar(2)\", 1)\n    (\"FUND_BUD_PROF\", \"varchar(6)\", 0)\n    (\"FUND_CNTR_DESCR\", \"varchar(40)\", 0)\n    (\"FUND_CNTR_FULL_NAME\", \"varchar(120)\", 0)\n    (\"FUND_CNTR_ID\", \"varchar(16)\", 0)\n    (\"FUND_CNTR_KEY\", \"int\", 0)\n    (\"FUND_CNTR_NAME\", \"varchar(20)\", 0)\n    (\"FUND_DESCR\", \"varchar(40)\", 0)\n    (\"FUND_ID\", \"varchar(10)\", 0)\n    (\"FUND_KEY\", \"int\", 0)\n    (\"FUND_NAME\", \"varchar(20)\", 0)\n    (\"FUND_SUBSTR1\", \"varchar(10)\", 0)\n    (\"FUND_SUBSTR2\", \"varchar(10)\", 0)\n    (\"FUND_TYPE_DESCR\", \"varchar(35)\", 0)\n    (\"FUND_TYPE_ID\", \"varchar(6)\", 0)\n    (\"GL_ACCT_FULL_NAME\", \"varchar(120)\", 0)\n    (\"GL_ACCT_GRP\", \"varchar(4)\", 0)\n    (\"GL_ACCT_ID\", \"varchar(30)\", 0)\n    (\"GL_ACCT_KEY\", \"int\", 0)\n    (\"GL_ACCT_MSTR_DESCR\", \"varchar(64)\", 0)\n    (\"GL_COMBO_KEY\", \"int\", 0)\n    (\"GRP_ACCT_NUM\", \"varchar(10)\", 0)\n    (\"HCAD_ACCT_STAT\", \"varchar(100)\", 0)\n    (\"HCTO_AD_VAL_ID\", \"varchar(22)\", 1)\n    (\"HCTO_DET_TRANS_DESCR\", \"varchar(50)\", 1)\n    (\"HCTO_FISC_PER\", \"varchar(15)\", 0)\n    (\"HCTO_FISC_PER_NUM\", \"int\", 0)\n    (\"HCTO_FISC_QTR\", \"varchar(15)\", 1)\n    (\"HCTO_FISC_QTR_NUM\", \"int\", 0)\n    (\"HCTO_FISC_YR\", \"varchar(15)\", 1)\n    (\"HH\", \"varchar(2)\", 0)\n    (\"HIER_ID\", \"varchar(30)\", 0)\n    (\"HOL_DESCR\", \"varchar(40)\", 1)\n    (\"HOUSE_NUM\", \"varchar(10)\", 0)\n    (\"INCDT_ADDR_LINE_1\", \"varchar(200)\", 0)\n    (\"INCDT_ADDR_LINE_2\", \"varchar(200)\", 0)\n    (\"INCDT_ADDR_LINE_3\", \"varchar(200)\", 0)\n    (\"INCDT_APT_LOT\", \"varchar(20)\", 0)\n    (\"INCDT_CAT\", \"varchar(40)\", 0)\n    (\"INCDT_CITY\", \"varchar(20)\", 0)\n    (\"INCDT_CNTY\", \"varchar(20)\", 0)\n    (\"INCDT_CTRY\", \"varchar(20)\", 0)\n    (\"INCDT_DESCR\", \"varchar(40)\", 0)\n    (\"INCDT_DTE\", \"datetime\", 0)\n    (\"INCDT_GIS_CITY\", \"varchar(20)\", 0)\n    (\"INCDT_GIS_CMPLT_MATCH_ADDR\", \"varchar(200)\", 1)\n    (\"INCDT_GIS_LAT\", \"varchar(38)\", 1)\n    (\"INCDT_GIS_LOCATR_NAME\", \"varchar(40)\", 0)\n    (\"INCDT_GIS_LONG\", \"varchar(38)\", 1)\n    (\"INCDT_GIS_MATCH_SCORE\", \"varchar(10)\", 1)\n    (\"INCDT_GIS_PREFIX\", \"varchar(12)\", 1)\n    (\"INCDT_GIS_ST_NAME\", \"varchar(60)\", 1)\n    (\"INCDT_GIS_ST_NUM\", \"varchar(12)\", 1)\n    (\"INCDT_GIS_ST_PRETYPE\", \"varchar(40)\", 1)\n    (\"INCDT_GIS_ST_TYPE\", \"varchar(40)\", 1)\n    (\"INCDT_GIS_SUFF\", \"varchar(12)\", 1)\n    (\"INCDT_GIS_X\", \"varchar(21)\", 1)\n    (\"INCDT_GIS_Y\", \"varchar(17)\", 0)\n    (\"INCDT_GIS_ZIP\", \"varchar(5)\", 0)\n    (\"INCDT_IN_CITY_FLAG\", \"varchar(1)\", 0)\n    (\"INCDT_KEY\", \"int\", 0)\n    (\"INCDT_PREFIX\", \"varchar(2)\", 0)\n    (\"INCDT_SEQ_NUM\", \"varchar(10)\", 0)\n    (\"INCDT_SERV_LVL\", \"varchar(120)\", 0)\n    (\"INCDT_ST\", \"varchar(100)\", 0)\n    (\"INCDT_ST_DIR\", \"varchar(4)\", 0)\n    (\"INCDT_ST_NAME\", \"varchar(35)\", 0)\n    (\"INCDT_ST_NUM\", \"varchar(7)\", 0)\n    (\"INCDT_ST_PRETYPE\", \"varchar(15)\", 0)\n    (\"INCDT_ST_TYPE\", \"varchar(4)\", 0)\n    (\"INCDT_STATE\", \"varchar(25)\", 0)\n    (\"INCDT_SUFF\", \"varchar(2)\", 0)\n    (\"INCDT_TIME\", \"varchar(8)\", 0)\n    (\"INCDT_TYPE\", \"varchar(40)\", 0)\n    (\"INCDT_ZIP_CODE\", \"varchar(6)\", 0)\n    (\"INCDT_ZIP_PLUS_4\", \"varchar(11)\", 0)\n    (\"INDY_DESCR\", \"varchar(20)\", 0)\n    (\"INDY_ID\", \"varchar(4)\", 0)\n    (\"INT_EXT_EMP_FLAG\", \"varchar(1)\", 0)\n    (\"INTER_CMPNY_TERM02_NAME\", \"varchar(28)\", 0)\n    (\"INTRA_FUND_TRANS_AMT\", \"money\", 1)\n    (\"INTRA_FUND_TRANS_FLAG\", \"varchar(1)\", 0)\n    (\"INV_NUM\", \"varchar(40)\", 0)\n    (\"INVALID INPUT\", \"nvarchar(100)\", 1)\n    (\"INVALID INPUT ERROR DESCRIPTION\", \"nvarchar(1000)\", 1)\n    (\"ITEM_ADDR_LINE_1\", \"varchar(200)\", 0)\n    (\"ITEM_ADDR_LINE_2\", \"varchar(200)\", 0)\n    (\"ITEM_ADDR_LINE_3\", \"varchar(200)\", 0)\n    (\"ITEM_APT_LOT\", \"varchar(20)\", 0)\n    (\"ITEM_CITY\", \"varchar(20)\", 0)\n    (\"ITEM_CNTY\", \"varchar(20)\", 0)\n    (\"ITEM_CTRY\", \"varchar(20)\", 0)\n    (\"ITEM_DESCR\", \"varchar(255)\", 1)\n    (\"ITEM_EXMPT_FLAG\", \"varchar(1)\", 0)\n    (\"ITEM_GIS_CITY\", \"varchar(20)\", 0)\n    (\"ITEM_GIS_CMPLT_MATCH_ADDR\", \"varchar(200)\", 1)\n    (\"ITEM_GIS_LAT\", \"varchar(38)\", 1)\n    (\"ITEM_GIS_LOCATR_NAME\", \"varchar(40)\", 0)\n    (\"ITEM_GIS_LONG\", \"varchar(38)\", 1)\n    (\"ITEM_GIS_MATCH_SCORE\", \"varchar(10)\", 1)\n    (\"ITEM_GIS_PREFIX\", \"varchar(12)\", 1)\n    (\"ITEM_GIS_ST_NAME\", \"varchar(60)\", 1)\n    (\"ITEM_GIS_ST_NUM\", \"varchar(12)\", 1)\n    (\"ITEM_GIS_ST_PRETYPE\", \"varchar(40)\", 1)\n    (\"ITEM_GIS_ST_TYPE\", \"varchar(40)\", 1)\n    (\"ITEM_GIS_SUFF\", \"varchar(12)\", 1)\n    (\"ITEM_GIS_X\", \"varchar(21)\", 1)\n    (\"ITEM_GIS_Y\", \"varchar(17)\", 0)\n    (\"ITEM_GIS_ZIP\", \"varchar(5)\", 0)\n    (\"ITEM_IN_CITY_FLAG\", \"varchar(1)\", 0)\n    (\"ITEM_KEY\", \"int\", 0)\n    (\"ITEM_PREFIX\", \"varchar(2)\", 0)\n    (\"ITEM_SERV_LVL\", \"varchar(40)\", 0)\n    (\"ITEM_ST\", \"varchar(100)\", 0)\n    (\"ITEM_ST_DIR\", \"varchar(4)\", 0)\n    (\"ITEM_ST_NAME\", \"varchar(35)\", 0)\n    (\"ITEM_ST_NUM\", \"varchar(13)\", 1)\n    (\"ITEM_ST_PRETYPE\", \"varchar(15)\", 0)\n    (\"ITEM_ST_TYPE\", \"varchar(4)\", 0)\n    (\"ITEM_STAT\", \"varchar(40)\", 0)\n    (\"ITEM_STAT_CHG_DTE\", \"datetime\", 0)\n    (\"ITEM_STATE\", \"varchar(25)\", 0)\n    (\"ITEM_SUFF\", \"varchar(2)\", 0)\n    (\"ITEM_TYPE\", \"varchar(40)\", 0)\n    (\"ITEM_ZIP_CODE\", \"varchar(13)\", 1)\n    (\"ITEM_ZIP_PLUS_4\", \"varchar(11)\", 0)\n    (\"JV_CUST_FLAG\", \"varchar(1)\", 0)\n    (\"LANG_ID\", \"varchar(1)\", 0)\n    (\"LAST_CUST_CONN_DTE\", \"datetime\", 0)\n    (\"LAST_CUST_CUTOFF_DTE\", \"datetime\", 0)\n    (\"LAST_CUST_DISCONN_DTE\", \"datetime\", 0)\n    (\"LAST_METER_INSPECT_DTE\", \"datetime\", 0)\n    (\"LICENSE_PLATE_EXP_MTH\", \"varchar(3)\", 0)\n    (\"LICENSE_PLATE_EXP_YR\", \"varchar(4)\", 0)\n    (\"LICENSE_PLATE_NUM\", \"varchar(10)\", 0)\n    (\"LICENSE_PLATE_TYPE\", \"varchar(20)\", 0)\n    (\"LOAD_DTE\", \"datetime\", 0)\n    (\"LOAD_DTE_TIME\", \"datetime\", 0)\n    (\"LOAD_TIME\", \"varchar(8)\", 0)\n    (\"LOGICAL_SYS\", \"varchar(10)\", 0)\n    (\"MAN_TRANS_FLAG\", \"varchar(1)\", 0)\n    (\"MEDICAID_PAYER_CODE\", \"varchar(40)\", 0)\n    (\"MEDICARE_PAYER_CODE\", \"varchar(40)\", 0)\n    (\"MIN\", \"varchar(5)\", 0)\n    (\"MSTR_REC_CNTRL_DEL_BLK\", \"varchar(1)\", 0)\n    (\"MSTR_SUBDIV_ID\", \"varchar(10)\", 0)\n    (\"MSTR_TRANS_TYPE\", \"varchar(20)\", 0)\n    (\"MUNIC_UTIL_DISTR_CODE\", \"varchar(13)\", 1)\n    (\"MUNIC_UTIL_DISTR_DESCR\", \"varchar(50)\", 0)\n    (\"NAICS_DET_CODE\", \"varchar(6)\", 0)\n    (\"NAICS_DET_NAME\", \"varchar(40)\", 0)\n    (\"NAICS_DIV_CODE\", \"varchar(2)\", 0)\n    (\"NAICS_DIV_NAME\", \"varchar(40)\", 0)\n    (\"NAICS_INDY_CODE\", \"varchar(5)\", 0)\n    (\"NAICS_INDY_GRP_CODE\", \"varchar(4)\", 0)\n    (\"NAICS_INDY_GRP_NAME\", \"varchar(40)\", 0)\n    (\"NAICS_INDY_NAME\", \"varchar(40)\", 0)\n    (\"NAICS_MAJ_GRP_CODE\", \"varchar(3)\", 0)\n    (\"NAICS_MAJ_GRP_NAME\", \"varchar(40)\", 0)\n    (\"NODE_FLAG\", \"varchar(1)\", 0)\n    (\"NUM_OF_ACRES\", \"varchar(13)\", 1)\n    (\"ON_ADMIN_HOLD_FLAG\", \"varchar(1)\", 0)\n    (\"ONE_TIME_ACCT_DESCR\", \"varchar(5)\", 0)\n    (\"ORIG_ASSIGNED_VEND\", \"varchar(120)\", 1)\n    (\"ORIG_BILL_NAME\", \"varchar(120)\", 1)\n    (\"ORIG_CUST_KEY\", \"int\", 0)\n    (\"ORIG_INV_NUM\", \"varchar(40)\", 0)\n    (\"ORIGIN_LOC\", \"varchar(120)\", 0)\n    (\"OWNER_IS_CUST_FLAG\", \"varchar(1)\", 0)\n    (\"OWNER_RENTER\", \"varchar(1)\", 0)\n    (\"OWNERSHIP_EFF_DTE\", \"datetime\", 0)\n    (\"PAY_BLK\", \"varchar(1)\", 0)\n    (\"PAY_METH\", \"varchar(15)\", 0)\n    (\"PAYROLL_PER\", \"int\", 0)\n    (\"PER_END_DTE\", \"date\", 1)\n    (\"PERMIT_EXP_DTE\", \"datetime\", 0)\n    (\"PERMIT_IS_CURR_AT_TIME_OF_INCDT_FLAG\", \"varchar(1)\", 0)\n    (\"PERMIT_ISSUE_DTE\", \"datetime\", 0)\n    (\"PERMIT_NAME\", \"varchar(120)\", 0)\n    (\"PERMIT_NUM\", \"int\", 0)\n    (\"PERSON_IN_CHRG\", \"varchar(20)\", 0)\n    (\"PERSON_IN_CHRG_ID\", \"varchar(8)\", 0)\n    (\"PHN\", \"varchar(30)\", 0)\n    (\"PL_STMNT_ACCT_TYPE\", \"varchar(2)\", 0)\n    (\"PLANT_ID\", \"varchar(4)\", 0)\n    (\"PLANT_NAME\", \"varchar(30)\", 0)\n    (\"PMAM_ADJMT_TO\", \"varchar(20)\", 1)\n    (\"PMAM_ADJMT_TYPE\", \"varchar(50)\", 1)\n    (\"PMAM_ID\", \"varchar(20)\", 0)\n    (\"POST_DTE_KEY\", \"int\", 1)\n    (\"PRKG_METER_NUM\", \"varchar(8)\", 0)\n    (\"PRKG_METER_VIO_FLAG\", \"varchar(1)\", 0)\n    (\"PROP_CLASS_CODE\", \"varchar(13)\", 1)\n    (\"PROP_CLASS_DESCR\", \"varchar(50)\", 0)\n    (\"PT_AGE\", \"varchar(3)\", 0)\n    (\"PT_GNDR\", \"varchar(10)\", 0)\n    (\"QTRLY_PAY_FLAG\", \"varchar(1)\", 0)\n    (\"RECEIVABLE_1ST_PAY_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_CURR_BILLING_TO_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_CURR_DELINQ_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_CURR_DUE_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_CURR_ISSUE_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_CURR_TO_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_EVER_TRANS_FLAG\", \"varchar(1)\", 1)\n    (\"RECEIVABLE_FNL_PAY_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_HAS_LTR_FLAG\", \"varchar(1)\", 0)\n    (\"RECEIVABLE_HAS_NOTE_FLAG\", \"varchar(1)\", 0)\n    (\"RECEIVABLE_HAS_PEND_LTR_FLAG\", \"varchar(1)\", 0)\n    (\"RECEIVABLE_KEY\", \"int\", 0)\n    (\"RECEIVABLE_LITIGATION_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_MSTR_STAT\", \"varchar(40)\", 1)\n    (\"RECEIVABLE_MSTR_STAT_CHG_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_ORIG_BILLING_TO_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_ORIG_DELINQ_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_ORIG_DUE_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_ORIG_ISSUE_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_ORIG_TO_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_SETTLEMENT_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_STAT\", \"varchar(40)\", 0)\n    (\"RECEIVABLE_STAT_CHG_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_VERS_BILLING_TO_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_VERS_DELINQ_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_VERS_DUE_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_VERS_ISSUE_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_VERS_TO_DTE\", \"datetime\", 0)\n    (\"REG_HOLDER_FLAG\", \"varchar(1)\", 0)\n    (\"REGION_ID\", \"varchar(3)\", 0)\n    (\"REGION_NAME\", \"varchar(20)\", 0)\n    (\"REINSTATEMENT_DTE\", \"datetime\", 1)\n    (\"RELE_REAL_COVER_ELIG\", \"varchar(1)\", 0)\n    (\"REND_PENALTY_JURIS_CODE\", \"varchar(13)\", 1)\n    (\"REND_PENALTY_JURIS_DESCR\", \"varchar(50)\", 0)\n    (\"RESOLVE_DESCR\", \"varchar(128)\", 0)\n    (\"RESOLVE_DTE\", \"datetime\", 1)\n    (\"RESOLVE_RSN\", \"varchar(40)\", 1)\n    (\"RESOLVED_BY\", \"varchar(120)\", 0)\n    (\"REVERSAL_DTE\", \"datetime\", 0)\n    (\"RM_EMP_MSTR_KEY\", \"varchar(16)\", 1)\n    (\"RM_LOAD_DTE\", \"datetime\", 0)\n    (\"RM_LOAD_TIME\", \"varchar(8)\", 0)\n    (\"ROW_CHG_RSN\", \"varchar(100)\", 1)\n    (\"RSN_INCDT_NOT_BILLED\", \"varchar(40)\", 0)\n    (\"SAP_BUS_ID\", \"varchar(20)\", 0)\n    (\"SCHOOL_JURIS_CODE\", \"varchar(22)\", 1)\n    (\"SCHOOL_JURIS_DESCR\", \"varchar(50)\", 0)\n    (\"SCND_TEL_NUM\", \"varchar(16)\", 0)\n    (\"SEN_CITIZEN_FLAG\", \"varchar(1)\", 0)\n    (\"SIC_CODE\", \"varchar(8)\", 0)\n    (\"SIC_DIV_CODE\", \"varchar(20)\", 0)\n    (\"SIC_DIV_NAME\", \"varchar(40)\", 0)\n    (\"SIC_INDY_GRP_CODE\", \"varchar(3)\", 0)\n    (\"SIC_INDY_GRP_NAME\", \"varchar(40)\", 0)\n    (\"SIC_MAJ_GRP_CODE\", \"varchar(2)\", 0)\n    (\"SIC_MAJ_GRP_NAME\", \"varchar(40)\", 0)\n    (\"SIC_NAME\", \"varchar(40)\", 0)\n    (\"SIG_FLAG\", \"varchar(1)\", 0)\n    (\"SMART_CM_ID\", \"varchar(20)\", 0)\n    (\"SMARTCM_IS_ADJMT\", \"varchar(1)\", 1)\n    (\"SMARTCM_IS_FEE\", \"varchar(1)\", 1)\n    (\"SMARTCM_IS_PAY\", \"varchar(1)\", 1)\n    (\"SMARTCM_OTHER_CRITERIA\", \"varchar(50)\", 1)\n    (\"SRC_CARRIER_KEY\", \"varchar(40)\", 0)\n    (\"SRC_CARRIER_PROCEDURE_KEY\", \"varchar(40)\", 0)\n    (\"SRC_SYS\", \"varchar(40)\", 0)\n    (\"SRC_SYS_ID\", \"varchar(120)\", 0)\n    (\"SRC_SYS_MOD_DTE\", \"datetime\", 1)\n    (\"SRC_SYS_TRANS_ID\", \"varchar(40)\", 1)\n    (\"SRC_SYS_VEH_ID\", \"varchar(32)\", 1)\n    (\"ST\", \"varchar(60)\", 0)\n    (\"STATE_CORP_CHTR_ID\", \"varchar(20)\", 0)\n    (\"STATE_FISC_PER\", \"varchar(15)\", 0)\n    (\"STATE_FISC_PER_NUM\", \"int\", 0)\n    (\"STATE_FISC_QTR\", \"varchar(15)\", 1)\n    (\"STATE_FISC_QTR_NUM\", \"int\", 0)\n    (\"STATE_FISC_YR\", \"varchar(15)\", 1)\n    (\"STATE_SALES_TAX_ID\", \"varchar(20)\", 0)\n    (\"SUBSTANTIAL_ERR_PENALTY\", \"varchar(1)\", 0)\n    (\"SUSPD_PERMIT_DTE\", \"datetime\", 0)\n    (\"SUSPD_PERMIT_RSN\", \"varchar(50)\", 0)\n    (\"SYS_LOAD_KEY\", \"int\", 0)\n    (\"T2_ID\", \"varchar(20)\", 0)\n    (\"T2_TRANS_MISC_ITEM_CODE\", \"varchar(20)\", 0)\n    (\"T2_TRANS_MISC_ITEM_DESCR\", \"varchar(50)\", 0)\n    (\"T2_TRANS_ORIG_OBJ_TYPE_ID\", \"varchar(10)\", 0)\n    (\"T2_TRANS_PARSED_DESCR\", \"varchar(50)\", 0)\n    (\"T2_TRANS_RSN\", \"varchar(50)\", 0)\n    (\"T2_TRANS_SCENARIO\", \"varchar(50)\", 0)\n    (\"T2_TRANS_TYPE_CODE\", \"varchar(20)\", 0)\n    (\"T2_TRANS_TYPE_DESCR\", \"varchar(50)\", 0)\n    (\"TAX_DEFERRAL_END_DTE\", \"datetime\", 0)\n    (\"TAX_DEFERRAL_START_DTE\", \"datetime\", 0)\n    (\"TAX_NUM_1\", \"varchar(16)\", 0)\n    (\"TAX_NUM_2\", \"varchar(11)\", 0)\n    (\"TAX_ROLL_CODE\", \"varchar(13)\", 1)\n    (\"TAX_ROLL_DESCR\", \"varchar(50)\", 0)\n    (\"TAXABLE_PROP_LGL_DESCR_1\", \"varchar(40)\", 0)\n    (\"TAXABLE_PROP_LGL_DESCR_2\", \"varchar(40)\", 0)\n    (\"TAXABLE_PROP_LGL_DESCR_3\", \"varchar(40)\", 0)\n    (\"TAXABLE_PROP_LGL_DESCR_4\", \"varchar(40)\", 0)\n    (\"TAXABLE_PROP_LGL_DESCR_5\", \"varchar(40)\", 0)\n    (\"TAXABLE_PROP_ROLL_TYPE\", \"varchar(50)\", 0)\n    (\"TIME_KEY\", \"int\", 0)\n    (\"TOWING_CMPNY\", \"varchar(40)\", 0)\n    (\"TRADING_PRN_ID\", \"varchar(6)\", 0)\n    (\"TRADING_PRN_NAME\", \"varchar(30)\", 0)\n    (\"TRANS_AMT\", \"money\", 1)\n    (\"TRANS_CNT\", \"int\", 1)\n    (\"TRANS_DTE_KEY\", \"int\", 0)\n    (\"TXP_SERV_LVL\", \"varchar(120)\", 0)\n    (\"TXP_TYPE\", \"varchar(40)\", 0)\n    (\"TYPE_OF_ALM_SITE\", \"varchar(1)\", 0)\n    (\"UNDER_APPEAL_FLAG\", \"varchar(1)\", 0)\n    (\"UNIQ_VEND_NAME\", \"varchar(120)\", 1)\n    (\"UNK_CUST_AT_BILL_FLAG\", \"varchar(1)\", 1)\n    (\"VAC_FLAG\", \"varchar(1)\", 0)\n    (\"VALID_FROM_DTE\", \"datetime\", 0)\n    (\"VALID_TO_DTE\", \"datetime\", 0)\n    (\"VEH\", \"varchar(40)\", 0)\n    (\"VEH_COLOR\", \"varchar(40)\", 0)\n    (\"VEH_ID_NUM\", \"varchar(24)\", 0)\n    (\"VEH_MAKE\", \"varchar(40)\", 0)\n    (\"VEH_MODEL\", \"varchar(40)\", 0)\n    (\"VEH_MODEL_YR\", \"varchar(4)\", 0)\n    (\"VEH_OWNER_ID\", \"varchar(32)\", 0)\n    (\"VEH_OWNER_NAME\", \"varchar(120)\", 0)\n    (\"VEH_TYPE\", \"varchar(40)\", 0)\n    (\"VEND_BILLER_FLAG\", \"varchar(1)\", 1)\n    (\"VEND_COLLR_FLAG\", \"varchar(1)\", 1)\n    (\"VEND_CUST_ID\", \"varchar(10)\", 0)\n    (\"VEND_CUST_NAME\", \"varchar(40)\", 0)\n    (\"VEND_FULL_NAME\", \"varchar(120)\", 0)\n    (\"VEND_GRP_KEY\", \"varchar(10)\", 0)\n    (\"VEND_ID\", \"varchar(10)\", 0)\n    (\"VEND_KEY\", \"int\", 0)\n    (\"VEND_NAME\", \"varchar(40)\", 0)\n    (\"VEND_NAME_01\", \"varchar(40)\", 0)\n    (\"VEND_NAME_02\", \"varchar(40)\", 0)\n    (\"VEND_NAME_03\", \"varchar(40)\", 0)\n    (\"VEND_NAME_04\", \"varchar(40)\", 0)\n    (\"VERS_ASSIGNED_VEND\", \"varchar(120)\", 1)\n    (\"VERS_BEG_DTE\", \"datetime\", 0)\n    (\"VERS_END_DTE\", \"datetime\", 0)\n    (\"VIO_CODE\", \"varchar(20)\", 0)\n    (\"VOID_CODE\", \"varchar(10)\", 0)\n    (\"VOID_DESCR\", \"varchar(50)\", 0)\n    (\"VOID_FLAG\", \"varchar(1)\", 0)\n    (\"WK_IN_CAL_YR\", \"int\", 0)\n    (\"WKND_FLAG\", \"varchar(1)\", 0)\n    (\"WORK_STAT\", \"varchar(50)\", 0)\n    (\"WRITE_OFF_FLAG\", \"varchar(1)\", 0)\n    (\"WTR_ACCT_NUM_OF_UNITS\", \"int\", 0)\n    (\"WTR_ACCT_ORIG_USE_TYPE\", \"varchar(120)\", 0)\n    (\"WTR_ACCT_PROP_USE_TYPE\", \"varchar(120)\", 0)\n    (\"WTR_METER_NUM\", \"varchar(50)\", 0)\n    (\"ZIP\", \"varchar(10)\", 0) |]","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"id":{"$":0,"Item":"133131ac-9ee5-47b2-8047-351746ee9e10"},"expanded":true,"level":0,"properties":{}},{"name":"FieldDefaults","content":"let fieldDefault = [|\n    (\"LOAD_DTE\"                            , \"GETDATE()\"   )\n    (\"LOAD_TIME\"                           , \"CONVERT(VARCHAR(8),GETDATE(),108)\")\n    (\"VERS_ASSIGNED_VEND\"                  , \"'CoH'\")\n    (\"MEDICARE_PAYER_CODE\"                 , \"'(SYS) UNKNOWN'\")\n    (\"MEDICAID_PAYER_CODE\"                 , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_FIN_GRP\"                     , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_FIN_CLASS\"                   , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_GRP\"                         , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_NAME\"                        , \"'(SYS) UNKNOWN'\")\n    (\"SRC_CARRIER_CODE\"                    , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_PROCEDURE_CODE\"              , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_PROCEDURE_DESCR\"             , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_PROCEDURE_TYPE\"              , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_PROCEDURE_BILL_CODE\"         , \"'(SYS) UNKNOWN'\")\n    (\"VEH\"                                 , \"'(SYS) UNKNOWN'\")\n    (\"EMS_INCDT_CAT\"                       , \"'(SYS) UNKNOWN'\")\n    (\"ACTV_CARRIER_FIN_GRP\"                , \"'(SYS) UNKNOWN'\")\n    (\"ACTV_CARRIER_FIN_CLASS\"              , \"'(SYS) UNKNOWN'\")\n    (\"ACTV_CARRIER\"                        , \"'(SYS) UNKNOWN'\")\n    (\"NAICS_DET_CODE\"                      , \"'*'\")\n    (\"NAICS_DIV_CODE\"                      , \"'*'\")\n    (\"SIC_MAJ_GRP_CODE\"                    , \"'*'\")\n    (\"DEC_CUST_FLAG\"                       , \"'*'\")\n    (\"CUST_PREFIX\"                         , \"'*'\")\n    (\"CUST_SUFF\"                           , \"'*'\")\n    (\"CUST_GIS_PREFIX\"                     , \"'*'\")\n    (\"CUST_GIS_SUFF\"                       , \"'*'\")\n    (\"ALLOC_TRANS_FLAG\"                    , \"'*'\")\n    (\"SMARTCM_OTHER_CRITERIA\"              , \"'*'\")\n    (\"SMARTCM_IS_FEE\"                      , \"'*'\")\n    (\"SMARTCM_IS_ADJMT\"                    , \"'*'\")\n    (\"SMARTCM_IS_PAY\"                      , \"'*'\")\n    (\"PERMIT_IS_CURR_AT_TIME_OF_INCDT_FLAG\", \"'*'\")\n    (\"PRKG_METER_VIO_FLAG\"                 , \"'*'\")\n    (\"INCDT_PREFIX\"                        , \"'*'\")\n    (\"INCDT_SUFF\"                          , \"'*'\")\n    (\"INCDT_IN_CITY_FLAG\"                  , \"'*'\")\n    (\"INCDT_GIS_PREFIX\"                    , \"'*'\")\n    (\"INCDT_GIS_SUFF\"                      , \"'*'\")\n    (\"ITEM_EXMPT_FLAG\"                     , \"'*'\")\n    (\"ITEM_PREFIX\"                         , \"'*'\")\n    (\"ITEM_SUFF\"                           , \"'*'\")\n    (\"ITEM_GIS_PREFIX\"                     , \"'*'\")\n    (\"ITEM_GIS_SUFF\"                       , \"'*'\")\n    (\"FIRE_ALM_AGING_RST_FLAG\"             , \"'*'\")\n    (\"AD_VAL_VET_FLAG\"                     , \"'*'\")\n    (\"AD_VAL_DISABLED_FLAG\"                , \"'*'\")\n    (\"AD_VAL_OVER_66_FLAG\"                 , \"'*'\")\n    (\"AD_VAL_HOMESTEAD_FLAG\"               , \"'*'\")\n    (\"QTRLY_PAY_FLAG\"                      , \"'*'\")\n    (\"SRC_CARRIER_KEY\"                     , \"'***'\")\n    (\"SRC_CARRIER_PROCEDURE_KEY\"           , \"'***'\")\n    (\"COLL_PERSON_ID\"                      , \"'***'\")\n    (\"T2_ID\"                               , \"'***'\")\n    (\"PMAM_ID\"                             , \"'***'\")\n    (\"SMART_CM_ID\"                         , \"'***'\")\n    (\"HCTO_AD_VAL_ID\"                      , \"'***'\")\n    (\"COLL_PERSON_COH_EMP_NUM\"             , \"'***'\")\n    (\"CUST_EMAIL_ADDR\"                     , \"'***'\")\n    (\"CUST_PHN_NUM_1\"                      , \"'***'\")\n    (\"CUST_FAX_NUM\"                        , \"'***'\")\n    (\"FED_TAX_ID\"                          , \"'***'\")\n    (\"BUS_CONT_PERSON_NAME\"                , \"'***'\")\n    (\"STATE_CORP_CHTR_ID\"                  , \"'***'\")\n    (\"STATE_SALES_TAX_ID\"                  , \"'***'\")\n    (\"SAP_BUS_ID\"                          , \"'***'\")\n    (\"NAICS_INDY_CODE\"                     , \"'***'\")\n    (\"NAICS_INDY_GRP_CODE\"                 , \"'***'\")\n    (\"NAICS_MAJ_GRP_CODE\"                  , \"'***'\")\n    (\"SIC_INDY_GRP_CODE\"                   , \"'***'\")\n    (\"SIC_DIV_CODE\"                        , \"'***'\")\n    (\"DL_ISSUE_STATE\"                      , \"'***'\")\n    (\"DL_NUM\"                              , \"'***'\")\n    (\"CUST_ADDR_LINE_1\"                    , \"'***'\")\n    (\"CUST_ADDR_LINE_2\"                    , \"'***'\")\n    (\"CUST_ADDR_LINE_3\"                    , \"'***'\")\n    (\"CUST_ST_NUM\"                         , \"'***'\")\n    (\"CUST_ST_PRETYPE\"                     , \"'***'\")\n    (\"CUST_ST_NAME\"                        , \"'***'\")\n    (\"CUST_ST_TYPE\"                        , \"'***'\")\n    (\"CUST_SERV_LVL\"                       , \"'***'\")\n    (\"CUST_CITY\"                           , \"'***'\")\n    (\"CUST_STATE\"                          , \"'***'\")\n    (\"CUST_CTRY\"                           , \"'***'\")\n    (\"CUST_ST_DIR\"                         , \"'***'\")\n    (\"CUST_ST\"                             , \"'***'\")\n    (\"CUST_CNTY\"                           , \"'***'\")\n    (\"CUST_APT_LOT\"                        , \"'***'\")\n    (\"CUST_GIS_MATCH_SCORE\"                , \"'***'\")\n    (\"CUST_GIS_ST_NUM\"                     , \"'***'\")\n    (\"CUST_GIS_ST_PRETYPE\"                 , \"'***'\")\n    (\"CUST_GIS_ST_NAME\"                    , \"'***'\")\n    (\"CUST_GIS_ST_TYPE\"                    , \"'***'\")\n    (\"CUST_GIS_CITY\"                       , \"'***'\")\n    (\"CUST_GIS_ZIP\"                        , \"'***'\")\n    (\"CUST_GIS_X\"                          , \"'***'\")\n    (\"CUST_GIS_Y\"                          , \"'***'\")\n    (\"CUST_ZIP_CODE\"                       , \"'***'\")\n    (\"CUST_ZIP_PLUS_4\"                     , \"'***'\")\n    (\"CUST_GIS_LOCATR_NAME\"                , \"'***'\")\n    (\"SIC_CODE\"                            , \"'***'\")\n    (\"NAICS_DET_NAME\"                      , \"'***'\")\n    (\"NAICS_INDY_NAME\"                     , \"'***'\")\n    (\"NAICS_INDY_GRP_NAME\"                 , \"'***'\")\n    (\"NAICS_MAJ_GRP_NAME\"                  , \"'***'\")\n    (\"NAICS_DIV_NAME\"                      , \"'***'\")\n    (\"SIC_NAME\"                            , \"'***'\")\n    (\"SIC_INDY_GRP_NAME\"                   , \"'***'\")\n    (\"SIC_MAJ_GRP_NAME\"                    , \"'***'\")\n    (\"SIC_DIV_NAME\"                        , \"'***'\")\n    (\"CUST_PHN_NUM_2\"                      , \"'***'\")\n    (\"CUST_PHN_NUM_3\"                      , \"'***'\")\n    (\"CUST_PAR_ID\"                         , \"'***'\")\n    (\"CUST_PAR_NAME\"                       , \"'***'\")\n    (\"COH_EMP_NUM\"                         , \"'***'\")\n    (\"RM_LOAD_TIME\"                        , \"'***'\")\n    (\"RM_EMP_MSTR_KEY\"                     , \"'***'\")\n    (\"PAY_METH\"                            , \"'***'\")\n    (\"DET_TRANS_CODE\"                      , \"'***'\")\n    (\"T2_TRANS_TYPE_CODE\"                  , \"'***'\")\n    (\"T2_TRANS_TYPE_DESCR\"                 , \"'***'\")\n    (\"T2_TRANS_RSN\"                        , \"'***'\")\n    (\"T2_TRANS_PARSED_DESCR\"               , \"'***'\")\n    (\"T2_TRANS_MISC_ITEM_CODE\"             , \"'***'\")\n    (\"T2_TRANS_MISC_ITEM_DESCR\"            , \"'***'\")\n    (\"T2_TRANS_SCENARIO\"                   , \"'***'\")\n    (\"T2_TRANS_ORIG_OBJ_TYPE_ID\"           , \"'***'\")\n    (\"PMAM_ADJMT_TO\"                       , \"'***'\")\n    (\"PMAM_ADJMT_TYPE\"                     , \"'***'\")\n    (\"DIGITECH_TRANS_TYPE_DET\"             , \"'***'\")\n    (\"RSN_INCDT_NOT_BILLED\"                , \"'***'\")\n    (\"VIO_CODE\"                            , \"'***'\")\n    (\"TOWING_CMPNY\"                        , \"'***'\")\n    (\"BOOT_SERIAL_NUM\"                     , \"'***'\")\n    (\"PRKG_METER_NUM\"                      , \"'***'\")\n    (\"INCDT_SEQ_NUM\"                       , \"'***'\")\n    (\"INCDT_ADDR_LINE_1\"                   , \"'***'\")\n    (\"INCDT_ADDR_LINE_2\"                   , \"'***'\")\n    (\"INCDT_ADDR_LINE_3\"                   , \"'***'\")\n    (\"INCDT_ST_NUM\"                        , \"'***'\")\n    (\"INCDT_ST_PRETYPE\"                    , \"'***'\")\n    (\"INCDT_ST_NAME\"                       , \"'***'\")\n    (\"INCDT_ST_TYPE\"                       , \"'***'\")\n    (\"INCDT_SERV_LVL\"                      , \"'***'\")\n    (\"INCDT_CITY\"                          , \"'***'\")\n    (\"INCDT_STATE\"                         , \"'***'\")\n    (\"INCDT_CTRY\"                          , \"'***'\")\n    (\"INCDT_ST_DIR\"                        , \"'***'\")\n    (\"INCDT_ST\"                            , \"'***'\")\n    (\"INCDT_CNTY\"                          , \"'***'\")\n    (\"INCDT_APT_LOT\"                       , \"'***'\")\n    (\"INCDT_GIS_MATCH_SCORE\"               , \"'***'\")\n    (\"INCDT_GIS_ST_NUM\"                    , \"'***'\")\n    (\"INCDT_GIS_ST_PRETYPE\"                , \"'***'\")\n    (\"INCDT_GIS_ST_NAME\"                   , \"'***'\")\n    (\"INCDT_GIS_ST_TYPE\"                   , \"'***'\")\n    (\"INCDT_GIS_CITY\"                      , \"'***'\")\n    (\"INCDT_GIS_ZIP\"                       , \"'***'\")\n    (\"INCDT_GIS_X\"                         , \"'***'\")\n    (\"INCDT_GIS_Y\"                         , \"'***'\")\n    (\"INCDT_ZIP_CODE\"                      , \"'***'\")\n    (\"INCDT_ZIP_PLUS_4\"                    , \"'***'\")\n    (\"INCDT_GIS_LOCATR_NAME\"               , \"'***'\")\n    (\"BLK_NUM\"                             , \"'***'\")\n    (\"TXP_ID\"                              , \"'***'\")\n    (\"TXP_SERV_LVL\"                        , \"'***'\")\n    (\"TXP_TYPE\"                            , \"'***'\")\n    (\"ORIGIN_LOC\"                          , \"'***'\")\n    (\"DEST_LOC\"                            , \"'***'\")\n    (\"ITEM_STAT\"                           , \"'***'\")\n    (\"ITEM_ADDR_LINE_1\"                    , \"'***'\")\n    (\"ITEM_ADDR_LINE_2\"                    , \"'***'\")\n    (\"ITEM_ADDR_LINE_3\"                    , \"'***'\")\n    (\"ITEM_ST_NUM\"                         , \"'***'\")\n    (\"ITEM_ST_PRETYPE\"                     , \"'***'\")\n    (\"ITEM_ST_NAME\"                        , \"'***'\")\n    (\"ITEM_ST_TYPE\"                        , \"'***'\")\n    (\"ITEM_SERV_LVL\"                       , \"'***'\")\n    (\"ITEM_CITY\"                           , \"'***'\")\n    (\"ITEM_STATE\"                          , \"'***'\")\n    (\"ITEM_CTRY\"                           , \"'***'\")\n    (\"ITEM_ST_DIR\"                         , \"'***'\")\n    (\"ITEM_ST\"                             , \"'***'\")\n    (\"ITEM_CNTY\"                           , \"'***'\")\n    (\"ITEM_APT_LOT\"                        , \"'***'\")\n    (\"ITEM_GIS_MATCH_SCORE\"                , \"'***'\")\n    (\"ITEM_GIS_ST_NUM\"                     , \"'***'\")\n    (\"ITEM_GIS_ST_PRETYPE\"                 , \"'***'\")\n    (\"ITEM_GIS_ST_NAME\"                    , \"'***'\")\n    (\"ITEM_GIS_ST_TYPE\"                    , \"'***'\")\n    (\"ITEM_GIS_CITY\"                       , \"'***'\")\n    (\"ITEM_GIS_ZIP\"                        , \"'***'\")\n    (\"ITEM_GIS_X\"                          , \"'***'\")\n    (\"ITEM_GIS_Y\"                          , \"'***'\")\n    (\"ITEM_ZIP_CODE\"                       , \"'***'\")\n    (\"ITEM_ZIP_PLUS_4\"                     , \"'***'\")\n    (\"ITEM_GIS_LOCATR_NAME\"                , \"'***'\")\n    (\"HCAD_ACCT_STAT\"                      , \"'***'\")\n    (\"AD_VAL_ACCT_LVL_ID\"                  , \"'***'\")\n    (\"COLL_LGL_COND\"                       , \"'***'\")\n    (\"COLL_LAWSUIT_NUM\"                    , \"'***'\")\n    (\"GL_ACCT_ID\"                          , \"'0000247130'\")\n    (\"INCDT_TIME\"                          , \"'00:00:00'\")\n    (\"FUND_ID\"                             , \"'1000'\")\n    (\"EMS_INCDT\"                           , \"'***'\")\n    (\"DISPATCH_NUM\"                        , \"'100073'\")\n    (\"FUND_CNTR_ID\"                        , \"'1200030003'\")\n    (\"CONTR_ID\"                            , \"'4600012363'\")\n    (\"PT_AGE\"                              , \"'***'\")\n    (\"BUS_AREA_ID\"                         , \"'6400'\")\n    (\"RECEIVABLE_STAT\"                     , \"'ACTIVE'\")\n    (\"DET_TRANS_DESCR\"                     , \"'Base Amount Billed'\")\n    (\"MSTR_TRANS_TYPE\"                     , \"'Billed'\")\n    (\"CUST_NAME\"                           , \"'***'\")\n    (\"ORIG_BILL_NAME\"                      , \"'***'\")\n    (\"COLL_PERSON_TYPE\"                    , \"'COH Contractor'\")\n    (\"EMP_NAME\"                            , \"'***'\")\n    (\"ITEM_TYPE\"                           , \"'***'\")\n    (\"ITEM_DESCR\"                          , \"'***'\")\n    (\"INCDT_TYPE\"                          , \"'***'\")\n    (\"INCDT_CAT\"                           , \"'***'\")\n    (\"DIV_LONG_NAME\"                       , \"'***'\")\n    (\"INCDT_DESCR\"                         , \"'***'\")\n    (\"EMP_TYPE\"                            , \"'Employee'\")\n    (\"FUNC_AREA_ID\"                        , \"'GEGO-00-00000000'\")\n    (\"DEPT_LONG_NAME\"                      , \"'***'\")\n    (\"CUST_TYPE\"                           , \"'Individual'\")\n    (\"PT_GNDR\"                             , \"'***'\")\n    (\"COLL_PERSON_NAME\"                    , \"'Employee'\")\n    (\"DIGITECH_ID\"                         , \"'***'\")\n    (\"CARRIER_SRC\"                         , \"'***'\")\n    (\"CARRIER_PROCEDURE_SRC\"               , \"'***'\")\n    (\"CUST_IS_VEND_FLAG\"                   , \"'N'\")\n    (\"JV_CUST_FLAG\"                        , \"'N'\")\n    (\"MAN_TRANS_FLAG\"                      , \"'N'\")\n    (\"DERIVED_TRANS_FLAG\"                  , \"'N'\")\n    (\"INTRA_FUND_TRANS_FLAG\"               , \"'N'\")\n    (\"ADJ_FLAG\"                            , \"'N'\")\n    (\"UNK_CUST_AT_BILL_FLAG\"               , \"'N'\")\n    (\"BILLING_HOLD_FLAG\"                   , \"'N'\")\n    (\"SIG_FLAG\"                            , \"'N'\")\n    (\"RECEIVABLE_MSTR_STAT\"                , \"'Open'\")\n    (\"DIGITECH_TRANS_TYPE\"                 , \"'PROCS'\")\n    (\"INT_EXT_EMP_FLAG\"                    , \"'Y'\")\n    (\"CONFI_CUST_FLAG\"                     , \"'Y'\")\n    (\"CUST_IN_CITY_FLAG\"                   , \"'Y'\")\n    (\"BILLED_FLAG\"                         , \"'Y'\")\n    (\"ITEM_IN_CITY_FLAG\"                   , \"'Y'\")\n    (\"RECEIVABLE_EVER_TRANS_FLAG\"          , \"'Y'\")\n    (\"CUST_PAR_KEY\"                        , \"1\")\n    (\"TRANS_CNT\"                           , \"1\")\n    (\"SRC_SYS_MOD_DTE\"                     , \"'1900-01-01'\")\n    (\"RM_LOAD_DTE\"                         , \"'1900-01-01'\")\n    (\"ITEM_STAT_CHG_DTE\"                   , \"'1900-01-01'\")\n    (\"RECEIVABLE_STAT_CHG_DTE\"             , \"'1900-01-01'\")\n    (\"FIRE_ORIG_ISSUE_DTE\"                 , \"'1900-01-01'\")\n    (\"RECEIVABLE_MSTR_STAT_CHG_DTE\"        , \"'1900-01-01'\")\n    (\"AD_VAL_TAX_DEFERRAL_START_DTE\"       , \"'1900-01-01'\")\n    (\"AD_VAL_TAX_DEFERRAL_END_DTE\"         , \"'1900-01-01'\")\n    (\"AD_VAL_EFF_DTE_OF_OWNERSHIP\"         , \"'1900-01-01'\")\n    (\"3348_ATTY_FEE_DTE\"                   , \"'1900-01-01'\")\n    (\"3308_ATTY_FEE_DTE\"                   , \"'1900-01-01'\")\n    (\"3307_ATTY_FEE_DTE\"                   , \"'1900-01-01'\")\n    (\"RECEIVABLE_VERS_DELINQ_DTE\"          , \"'1900-01-01'\")\n    (\"RECEIVABLE_VERS_DUE_DTE\"             , \"'1900-01-01'\")\n    (\"RECEIVABLE_VERS_TO_DTE\"              , \"'1900-01-01'\")\n    (\"RECEIVABLE_VERS_BILLING_TO_DTE\"      , \"'1900-01-01'\")\n    (\"INCDT_DTE\"                           , \"'1900-01-01'\")\n    (\"RECEIVABLE_VERS_ISSUE_DTE\"           , \"'1900-01-01'\")\n    (\"INTRA_FUND_TRANS_AMT\"                , \"NULL\"        )\n    (\"RECEIVABLE_1ST_PAY_DTE\"              , \"'1900-01-01'\")\n    (\"RECEIVABLE_FNL_PAY_DTE\"              , \"'1900-01-01'\")\n    (\"RECEIVABLE_LITIGATION_DTE\"           , \"'1900-01-01'\")\n    (\"RECEIVABLE_SETTLEMENT_DTE\"           , \"'1900-01-01'\")\n    (\"REINSTATEMENT_DTE\"                   , \"'1900-01-01'\")\n    (\"SRC_SYS_TRANS_ID\"                    , \"'***'\"       )\n\n    (\"ALLOWABLE_NO_CHRG_INCDTS\"            , \"0\"           )\n    (\"ALM_INSTL_CMPNY\"                     , \"'***'\"       )\n    (\"ALM_INSTL_DTE\"                       , \"'1900-01-01'\")\n    (\"ALM_MNT_CMPNY\"                       , \"'***'\"       )\n    (\"ALM_REG_KEY\"                         , \"'***'\"       )\n    (\"ALM_TYPE\"                            , \"'*'\"         )\n    (\"APPLICTN_RECV_DTE\"                   , \"'1900-01-01'\")\n    (\"APPRAISAL_DISTR_ACCT_NUM\"            , \"'***'\"       )\n    (\"CC_JURIS_DESCR\"                      , \"'***'\"       )\n    (\"CITY_RFPD_JURIS_DESCR\"               , \"'***'\"       )\n    (\"CURR_FIRE_ALM_PERMIT_FLAG\"           , \"'*'\"         )\n    (\"CURR_WTR_ACCT_FLAG\"                  , \"'*'\"         )\n    (\"CUST_ID\"                             , \"'***'\"       )\n    (\"DELINQ_DTE\"                          , \"'1900-01-01'\")\n    (\"DTE\"                                 , \"'1900-01-01'\")\n    (\"ESC_CAND_FLAG\"                       , \"'*'\"         )\n    (\"EXCL_TYPE\"                           , \"'***'\"       )\n    (\"FIRE_ALM_PERMIT_ACTV_FLAG\"           , \"'*'\"         )\n    (\"FIRE_ALM_PERMIT_NUM\"                 , \"'***'\"       )\n    (\"FIRE_ALM_PURPOSE\"                    , \"'***'\"       )\n    (\"INV_NUM\"                             , \"'***'\"       )\n    (\"LAST_CUST_CONN_DTE\"                  , \"'1900-01-01'\")\n    (\"LAST_CUST_CUTOFF_DTE\"                , \"'1900-01-01'\")\n    (\"LAST_CUST_DISCONN_DTE\"               , \"'1900-01-01'\")\n    (\"LAST_METER_INSPECT_DTE\"              , \"'1900-01-01'\")\n    (\"LICENSE_PLATE_EXP_MTH\"               , \"'***'\"       )\n    (\"LICENSE_PLATE_EXP_YR\"                , \"'***'\"       )\n    (\"LICENSE_PLATE_NUM\"                   , \"'***'\"       )\n    (\"LICENSE_PLATE_TYPE\"                  , \"'***'\"       )\n    (\"MUNIC_UTIL_DISTR_DESCR\"              , \"'***'\"       )\n    (\"ON_ADMIN_HOLD_FLAG\"                  , \"'*'\"         )\n    (\"OWNERSHIP_EFF_DTE\"                   , \"'1900-01-01'\")\n    (\"OWNER_IS_CUST_FLAG\"                  , \"'*'\"         )\n    (\"OWNER_RENTER\"                        , \"'*'\"         )\n    (\"PERMIT_EXP_DTE\"                      , \"'1900-01-01'\")\n    (\"PERMIT_ISSUE_DTE\"                    , \"'1900-01-01'\")\n    (\"PERMIT_NAME\"                         , \"'***'\"       )\n    (\"PERMIT_NUM\"                          , \"0\"           )\n    (\"PROP_CLASS_DESCR\"                    , \"'***'\"       )\n    (\"RECEIVABLE_HAS_LTR_FLAG\"             , \"'*'\"         )\n    (\"RECEIVABLE_HAS_NOTE_FLAG\"            , \"'*'\"         )\n    (\"RECEIVABLE_HAS_PEND_LTR_FLAG\"        , \"'*'\"         )\n    (\"REG_HOLDER_FLAG\"                     , \"'*'\"         )\n    (\"REND_PENALTY_JURIS_DESCR\"            , \"'***'\"       )\n    (\"RESOLVED_BY\"                         , \"'***'\"       )\n    (\"RESOLVE_DESCR\"                       , \"'***'\"       )\n    (\"SCHOOL_JURIS_DESCR\"                  , \"'***'\"       )\n    (\"SEN_CITIZEN_FLAG\"                    , \"'*'\"         )\n    (\"SRC_SYS\"                             , \"'***'\"       )\n    (\"SRC_SYS_ID\"                          , \"'***'\"       )\n    (\"SUBSTANTIAL_ERR_PENALTY\"             , \"'*'\"         )\n    (\"SUSPD_PERMIT_DTE\"                    , \"'1900-01-01'\")\n    (\"SUSPD_PERMIT_RSN\"                    , \"'***'\"       )\n    (\"TAXABLE_PROP_LGL_DESCR_1\"            , \"'***'\"       )\n    (\"TAXABLE_PROP_LGL_DESCR_2\"            , \"'***'\"       )\n    (\"TAXABLE_PROP_LGL_DESCR_3\"            , \"'***'\"       )\n    (\"TAXABLE_PROP_LGL_DESCR_4\"            , \"'***'\"       )\n    (\"TAXABLE_PROP_LGL_DESCR_5\"            , \"'***'\"       )\n    (\"TAXABLE_PROP_ROLL_TYPE\"              , \"'***'\"       )\n    (\"TAX_DEFERRAL_END_DTE\"                , \"'1900-01-01'\")\n    (\"TAX_DEFERRAL_START_DTE\"              , \"'1900-01-01'\")\n    (\"TAX_ROLL_DESCR\"                      , \"'***'\"       )\n    (\"TYPE_OF_ALM_SITE\"                    , \"'*'\"         )\n    (\"UNDER_APPEAL_FLAG\"                   , \"'*'\"         )\n    (\"VAC_FLAG\"                            , \"'*'\"         )\n    (\"VEH_COLOR\"                           , \"'***'\"       )\n    (\"VEH_ID_NUM\"                          , \"'***'\"       )\n    (\"VEH_MAKE\"                            , \"'***'\"       )\n    (\"VEH_MODEL\"                           , \"'***'\"       )\n    (\"VEH_MODEL_YR\"                        , \"'***'\"       )\n    (\"VEH_OWNER_ID\"                        , \"'***'\"       )\n    (\"VEH_OWNER_NAME\"                      , \"'***'\"       )\n    (\"VEH_TYPE\"                            , \"'***'\"       )\n    (\"VOID_CODE\"                           , \"'***'\"       )\n    (\"VOID_DESCR\"                          , \"'***'\"       )\n    (\"VOID_FLAG\"                           , \"'*'\"         )\n    (\"WORK_STAT\"                           , \"'***'\"       )\n    (\"WRITE_OFF_FLAG\"                      , \"'*'\"         )\n    (\"WTR_ACCT_NUM_OF_UNITS\"               , \"0\"           )\n    (\"WTR_ACCT_ORIG_USE_TYPE\"              , \"'***'\"       )\n    (\"WTR_ACCT_PROP_USE_TYPE\"              , \"'***'\"       )\n    (\"WTR_METER_NUM\"                       , \"'***'\"       )\n\n|]","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"id":{"$":0,"Item":"b67af98c-895c-4d9c-bee1-2c43359c6885"},"expanded":true,"level":0,"properties":{}},{"name":"SlowlyChangingDimensions","content":"#define SLOWLY_CHANGING_DIMENSIONS \nopen System.Text.RegularExpressions\nopen Microsoft.FSharp.Reflection\n\nlet padName: int -> string -> string =\n         fun len    name   -> name.PadRight len\n\nlet pad4 = padName 40\nlet pad2 = padName 20\n\nlet defaultValue v opt = match opt with\n                         | Some x -> x\n                         | None   -> v\n\nlet aNumeral (s : string) = if s.StartsWith \"A#\" then s.[2..] else s\n\nlet toString (x:'a) = \n    match FSharpValue.GetUnionFields(x, typeof<'a>) with\n    | case, _ -> case.Name\n    |> aNumeral\n\nlet fromString<'a> (s:string) =\n    match FSharpType.GetUnionCases typeof<'a> |> Array.filter (fun case -> case.Name = s) with\n    |[|case|] -> Some(FSharpValue.MakeUnion(case,[||]) :?> 'a)\n    |_ -> None\n\ntype sqlObjectType = | PROCEDURE | VIEW | TRIGGER\nwith\n     member this.Name      = toString this\n     member this.Condition = match    this with\n                             | PROCEDURE -> \"IN ( N'P', N'PC' )\"\n                             | VIEW      -> \"=    N'V' \"\n                             | TRIGGER   -> \"=    N'TR'\"\n\nlet sqlDropCreate: sqlObjectType -> string -> string =\n               fun sqlType          name   -> sprintf \"\"\"\nIF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'%s') AND type %s)\n    DROP %s %s;\nGO\n-- Machine-generated-code, DO NOT MODIFY HERE\n-- %s 'HPL', '2017-03-01'\nCREATE %s %s\n\"\"\"                                                name         sqlType.Condition \n                                                   sqlType.Name name \n                                                   name \n                                                   sqlType.Name name\n\n\nlet regexIdentifier = Regex @\"^[\\p{L}_][\\p{L}\\p{N}@$#_]{0,127}$|^\\[.+\\]$\"\n                                                \nlet isIdentifier: string -> bool =\n              fun txt    -> regexIdentifier.IsMatch txt\n\nlet nameS fName = \n    if isIdentifier fName \n    then fName \n    else sprintf \"[%s]\" fName\n\ntype TargetField\nwith\n     member this.Name = toString this\n\ntype FinTransViewField\nwith\n     member this.Name = toString this\n\ntype Field =\n    | SurrogateKey   of TargetField\n    | BusinessKey    of FinTransViewField\n    | SourceDate     of FinTransViewField\n    | IntraDayOrder  of  FinTransViewField\n    | SCD2BeginDate  of TargetField\n    | SCD2EndDate    of TargetField\n    | SCD2Current    of TargetField\n    | ChangeReason   of TargetField\n    | SCD2           of FinTransViewField * scd1:TargetField option * scd0:TargetField option /// Version  value\n    | SCD1           of FinTransViewField * scd0:TargetField option                           /// Current  value\n    | SCD0           of FinTransViewField                               /// SCD0 without accompanying SCD1 or 2\nwith member this.Name0 = \n        match this with\n        | SurrogateKey   tfield\n        | SCD2BeginDate  tfield\n        | SCD2EndDate    tfield\n        | ChangeReason   tfield\n        | SCD2Current    tfield        -> tfield.Name\n        | BusinessKey    sfield\n        | SourceDate     sfield\n        | IntraDayOrder  sfield\n        | SCD2          (sfield, _, _) \n        | SCD1          (sfield, _   ) \n        | SCD0           sfield        -> sfield.Name\n     member this.Name = this.Name0 |> nameS\n\nlet strOption: string -> string option =\n           fun txt    -> match txt.Trim() with\n                         | \"\" -> None\n                         | f  -> Some f\n\nlet tfldOption: TargetField -> TargetField option =\n            fun fld         -> match fld with | Nil  -> None | _ -> Some fld\n\nlet sfldOption: FinTransViewField -> FinTransViewField option =\n            fun fld         -> match fld with | Nil_ -> None | _ -> Some fld\n\nlet SurrogateKey  name           : Field =  name                   |> SurrogateKey \nlet BusinessKey   name           : Field =  name                   |> BusinessKey  \nlet SourceDate    name           : Field =  name                   |> SourceDate   \nlet IntraDayOrder name           : Field =  name                   |> IntraDayOrder   \nlet SCD2BeginDate name           : Field =  name                   |> SCD2BeginDate\nlet SCD2EndDate   name           : Field =  name                   |> SCD2EndDate  \nlet SCD2Current   name           : Field =  name                   |> SCD2Current  \nlet ChangeReason  name           : Field =  name                   |> ChangeReason  \nlet SCD0          name           : Field =  name                   |> SCD0         \nlet SCD1          name      scd0 : Field = (name, tfldOption scd0) |> SCD1         \nlet SCD2          name scd1 scd0 : Field = (name, tfldOption scd1                   \n                                                , tfldOption scd0) |> SCD2\n    \nlet fieldNames      :  Field -> string list =\n                   fun f     -> match f with \n                                | SCD2         (_, Some scd1, Some scd0) -> [ f.Name ; scd1.Name ; scd0.Name ]\n                                | SCD2         (_, _        , Some scd0) -> [ f.Name             ; scd0.Name ]\n                                | SCD1         (_,            Some scd0) -> [ f.Name             ; scd0.Name ]\n                                | _                                      -> [ f.Name                         ]\n\nlet fieldSource     :  Field -> string list =\n                   fun f     -> match f with \n                                | SurrogateKey  _\n                                | SCD2BeginDate _\n                                | SCD2EndDate   _\n                                | ChangeReason  _\n                                | SCD2Current   _            -> []\n                                | _                          -> [ f.Name ]\n\nlet fieldTarget    :  Field -> string list =\n                   fun f     -> match f with \n                                | SurrogateKey  tfield\n                                | SCD2BeginDate tfield\n                                | SCD2EndDate   tfield\n                                | ChangeReason  tfield\n                                | SCD2Current   tfield                   -> [ tfield.Name            ]\n                                | SCD2         (_, Some scd1, Some scd0) -> [ scd1  .Name ; scd0.Name]\n                                | SCD2         (_, _        , Some scd0) -> [               scd0.Name]\n                                | SCD1         (_,            Some scd0) -> [               scd0.Name]\n                                | _                                      -> []\n\nlet fieldAlias      :  Field -> string =\n                   fun f     -> match f with \n                                | SurrogateKey  _ -> \"SurrogateKey_ \"\n                                | BusinessKey   _ -> \"BusinessKey_  \"\n                                | SourceDate    _ -> \"SourceDate_   \"\n                                | IntraDayOrder _ -> \"IntraDayOrder_\"\n                                | SCD2BeginDate _ -> \"SourceDate_   \"\n                                | ChangeReason  _\n                                | SCD2Current   _ \n                                | SCD2EndDate   _ -> \"\" \n                                | _               -> f.Name\nlet fieldAliasValue :  Field -> string -> string = \n                   fun f        v      -> sprintf \"%s = %s\" (pad4 (fieldAlias f)) v\n\nlet fieldSelectTable:  Field -> string list =\n                   fun f     -> match f with \n                                | SurrogateKey  _ -> [ fieldAliasValue f f.Name ]\n                                | BusinessKey   _ -> [ fieldAliasValue f f.Name ]\n                                | SCD2BeginDate _ -> [ fieldAliasValue f f.Name ]\n                                | SourceDate    _ \n                                | IntraDayOrder _\n                                | ChangeReason  _\n                                | SCD2Current   _ \n                                | SCD2EndDate   _ -> [] \n                                | _               -> [ f.Name ]\n\nlet fieldSelectSource: (string -> string) -> Field -> string list =\n                   fun transform             f     ->\n                                match f with \n                                | SurrogateKey  _ -> [ fieldAliasValue f \"NULL\"  ]\n                                | BusinessKey   _ -> [ fieldAliasValue f f.Name ]\n                                | SourceDate    _ -> [ fieldAliasValue f f.Name ]\n                                | IntraDayOrder _\n                                | SCD2BeginDate _\n                                | ChangeReason  _\n                                | SCD2Current   _ \n                                | SCD2EndDate   _ -> []\n                                | _               -> [ transform f.Name ]\n\nlet fieldSelectTogether1: (string -> string) -> Field -> string list =\n                   fun    transform             f     ->\n                                match f with \n                                | SurrogateKey  _ -> [ fieldAlias f |> transform ]\n                                | BusinessKey   _ -> [ fieldAlias f              ]\n                                | SourceDate    _ -> [ fieldAlias f              ]\n                                | IntraDayOrder _\n                                | SCD2BeginDate _ \n                                | ChangeReason  _\n                                | SCD2Current   _ \n                                | SCD2EndDate   _ -> []\n                                | _               -> [ transform f.Name ]\n\nlet fieldInsert     :  Field -> string list =\n                   fun f     -> match f with \n                                | SourceDate    _ \n                                | IntraDayOrder _\n                                | SurrogateKey  _ -> []\n                                | _               -> fieldNames f\n\nlet fieldValues     :  Field -> string list =\n                   fun f     -> match f with \n                                | SourceDate    _ \n                                | IntraDayOrder _\n                                | SurrogateKey  _ -> []\n                                | _               -> fieldNames f |> List.map (sprintf \"S.%s\")\n\nlet fieldUpdate     :  Field -> string list =\n                   fun f     -> match f with \n                                | SourceDate    _ \n                                | IntraDayOrder _\n                                | BusinessKey   _\n                                | SurrogateKey  _ -> []\n                                | _               -> fieldNames f |> List.map (fun n -> sprintf \"T.%s = S.%s\" (pad4 n) n)\n\nlet fieldSCD2Equal   : Field -> string list =\n                   fun f     -> match f with \n                                | SCD2 _ -> [ sprintf \"S.%s = P.%s\" ( pad4 f.Name) f.Name ]\n                                | _      -> []\n                                \nlet fieldSCD2        : Field -> string list =\n                   fun f     -> match f with \n                                | SCD2 _             -> [ sprintf \"S.%s\" f.Name ]\n                                | _                  -> []\n\nlet fieldSCD0        : Field -> string list =\n                   fun f     -> match f with \n                                | SCD1(_,    Some scd0) \n                                | SCD2(_, _, Some scd0) -> [ sprintf \"%s = FIRST_VALUE(S.%s) OVER (PARTITION BY S.BusinessKey_ ORDER BY S.NRec_)\" (pad4 scd0.Name) f.Name ]\n                                | SCD0 _                -> [ sprintf \"%s = FIRST_VALUE(S.%s) OVER (PARTITION BY S.BusinessKey_ ORDER BY S.NRec_)\" (pad4 f.Name   ) f.Name ]\n                                | _                     -> []\n\nlet fieldSCD1        : Field -> string list =\n                   fun f     -> match f with \n                                | SCD2(_, Some scd1, _) -> [ sprintf \"%s = LAST_VALUE(S.%s ) OVER (PARTITION BY S.BusinessKey_ ORDER BY S.NRec_ ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)\" (pad4 scd1.Name) f.Name ]\n                                | SCD1 _                -> [ sprintf \"%s = LAST_VALUE(S.%s ) OVER (PARTITION BY S.BusinessKey_ ORDER BY S.NRec_ ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)\" (pad4 f.Name   ) f.Name ]\n                                | _                     -> []\n\ntype SQLTableView = {\n    db       : string option\n    schema   : string option\n    sqlObject: string\n    where    : string option\n    parms    : string option\n}\nwith member this.Reference   : string =\n                               match this.db, this.schema with\n                               | None   , None    -> sprintf \"%s\"\n                               | Some db, None    -> sprintf \"%s..%s\"   (nameS db)\n                               | Some db, Some sc -> sprintf \"%s.%s.%s\" (nameS db) (nameS sc)\n                               | None   , Some sc -> sprintf \"%s.%s\"               (nameS sc)\n                               <| nameS this.sqlObject\n     member this.Call        : string =\n                               match this.parms with\n                               | None    -> sprintf \"%s\"\n                               | Some ps -> fun r -> sprintf \"%s(%s)\" r ps\n                               <| this.Reference\n     member this.FromWhere   : string =\n                               match this.where with\n                               | None    -> sprintf \"%s\"\n                               | Some wh -> fun c -> sprintf \"%s WHERE %s \" c wh\n                               <| this.Call\n\n     static member New: string -> string ->  string  -> string -> string -> SQLTableView =\n                    fun db        schema     sobject    where     parms  -> {\n                                                                                db        = strOption db\n                                                                                schema    = strOption schema\n                                                                                sqlObject = sobject.Trim()\n                                                                                where     = strOption where \n                                                                                parms     = strOption parms\n                                                                            }\n\nlet indent : string  -> string =\n         fun content -> content.Split[| '\\n' |] |> String.concat \"\\n    \"\n\nlet indent2: string  -> string =\n         fun content -> \"    \" + (indent content)\n\ntype SQLWith = { \n    name   : string \n    content: string \n}\nwith override this.ToString()  = sprintf \"%s as (\\n%s\\n)\" this.name this.content\n     static member New: string -> string  -> SQLWith =\n                    fun name      content -> { name = name.Trim() ; content = indent2 content }\n\nlet sqlSelectP: string -> string -> string seq -> string =\n    fun         select    from      fields     -> \n        fields \n        |> String.concat \"\\n     , \"\n        |> sprintf \"%s %s\\n  FROM %s\" select <| from\n\nlet sqlSelect : string -> string seq -> string = sqlSelectP \"SELECT\"\nlet sqlSelectD: string -> string seq -> string = sqlSelectP \"SELECT Distinct\"\n\nlet sqlProcedure: string -> string  -> string  -> string=\n              fun name      parms      content -> \n                  sqlDropCreate PROCEDURE name\n                  |> sprintf \"%s %s\\n as \\n %s \\nGO\" <| parms <| content\n\nlet bSurrogateKey  = function | SurrogateKey  _ -> true | _ -> false\nlet bBusinessKey   = function | BusinessKey   _ -> true | _ -> false\nlet bSourceDate    = function | SourceDate    _ -> true | _ -> false\nlet bIntraDayOrder = function | IntraDayOrder _ -> true | _ -> false\nlet bSCD2BeginDate = function | SCD2BeginDate _ -> true | _ -> false\nlet bSCD2EndDate   = function | SCD2EndDate   _ -> true | _ -> false\nlet bChangeReason  = function | ChangeReason  _ -> true | _ -> false\nlet bSCD2Current   = function | SCD2Current   _ -> true | _ -> false\nlet bSCD2          = function | SCD2          _ -> true | _ -> false\n\ntype Dimension ( tableBase : SQLTableView\n               , source    : SQLTableView\n               , fields    : Field  seq\n               , snowflakes: string seq\n               , extra     : Printf.StringFormat<_>) =              \n     let isSnowflaked   = snowflakes |> Seq.isEmpty |> not\n     let countF filter  = fields |> Seq.filter filter |> Seq.length\n     let cSurrogateKey  = countF bSurrogateKey \n     let cBusinessKey   = countF bBusinessKey  \n     let cSourceDate    = countF bSourceDate   \n     let cIntraDayOrder = countF bIntraDayOrder\n     let cSCD2BeginDate = countF bSCD2BeginDate\n     let cSCD2EndDate   = countF bSCD2EndDate  \n     let cChangeReason  = countF bChangeReason  \n     let cSCD2Current   = countF bSCD2Current  \n     let cSCD2          = countF bSCD2\n     let table          = if isSnowflaked then { tableBase with sqlObject = \"SV_\" + tableBase.sqlObject } else tableBase\n     let duplicates     = fields |> Seq.collect fieldNames |> Seq.countBy (fun n -> n.Trim().ToUpper()) |> Seq.choose (fun (n, i) -> if i > 1 then sprintf \"Field %s appears more than once\" n |> Some else None) |> Seq.toList\n     let errors         = [\n                             if              cSurrogateKey  = 0 then yield \"A SurrogateKey  must be specified\"\n                             if              cBusinessKey   = 0 then yield \"A BusinessKey   must be specified\"\n                             if cSCD2 > 0 && cSourceDate    = 0 then yield \"A SourceDate    must be specified\"\n                             if cSCD2 > 0 && cIntraDayOrder = 0 then yield \"A IntraDayOrder must be specified\"\n                             if cSCD2 > 0 && cSCD2BeginDate = 0 then yield \"A SCD2BeginDate must be specified\"\n                             if cSCD2 > 0 && cSCD2EndDate   = 0 then yield \"A SCD2EndDate   must be specified\"\n                             if              cSurrogateKey  > 1 then yield \"Only 1 SurrogateKey  can be specified\"\n                             if              cBusinessKey   > 1 then yield \"Only 1 BusinessKey   can be specified\"\n                             if              cSourceDate    > 1 then yield \"Only 1 SourceDate    can be specified\"\n                             if              cIntraDayOrder > 1 then yield \"Only 1 IntraDayOrder can be specified\"\n                             if              cSCD2BeginDate > 1 then yield \"Only 1 SCD2BeginDate can be specified\"\n                             if              cSCD2EndDate   > 1 then yield \"Only 1 SCD2EndDate   can be specified\"\n                             if              cSCD2Current   > 1 then yield \"Only 1 SCD2Current   can be specified\"\n                             if              cChangeReason  > 1 then yield \"Only 1 ChangeReason  can be specified\"\n                             if cSCD2 = 0 && cSourceDate    = 1 then yield \"No SCD2 fields, SourceDate    cannot be specified\"\n                             if cSCD2 = 0 && cIntraDayOrder = 1 then yield \"No SCD2 fields, IntraDayOrder cannot be specified\"\n                             if cSCD2 = 0 && cSCD2BeginDate = 1 then yield \"No SCD2 fields, SCD2BeginDate cannot be specified\"\n                             if cSCD2 = 0 && cSCD2EndDate   = 1 then yield \"No SCD2 fields, SCD2EndDate   cannot be specified\"\n                             if cSCD2 = 0 && cSCD2Current   = 1 then yield \"No SCD2 fields, SCD2Current   cannot be specified\"\n                          ] @ duplicates\n     do if not errors.IsEmpty then failwith (errors |> String.concat \"\\n\")\n     let find  : (Field -> bool) -> string =\n             fun  ft             -> fields |> Seq.find ft |> fun f -> f.Name\n     let surrogateKey   = find bSurrogateKey\n     let businessKey    = find bBusinessKey\n     let sourceDateO    = if cSourceDate    = 1 then find bSourceDate    |> Some else None\n     let intraDayOrderO = if cIntraDayOrder = 1 then find bIntraDayOrder |> Some else None\n     let sCD2BeginDateO = if cSCD2BeginDate = 1 then find bSCD2BeginDate |> Some else None\n     let sCD2EndDateO   = if cSCD2EndDate   = 1 then find bSCD2EndDate   |> Some else None\n     let sCD2CurrentO   = if cSCD2Current   = 1 then find bSCD2Current   |> Some else None\n     let changeReasonO  = if cChangeReason  = 1 then find bChangeReason  |> Some else None \n     let procedureName  = sprintf \"GENERIC.SP_LOAD_%s\" table.sqlObject\n     let lastOfDay    n = sprintf \"%s = LAST_VALUE(%s) OVER (PARTITION BY %s, %s ORDER BY %s ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)\" (pad4 n) n businessKey (sourceDateO |> Option.defaultValue \"\") (intraDayOrderO |> Option.defaultValue \"\")\n     let together1    n = sprintf \"%s = LAST_VALUE(%s) OVER (PARTITION BY BusinessKey_, SourceDate_ ORDER BY SurrogateKey_ ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)\" (pad4 n) n \nwith\n     new(table, source, fields            ) = Dimension(table, source, fields, []        , \"%s\")\n     new(table, source, fields, snowflakes) = Dimension(table, source, fields, snowflakes, \"%s\")\n     member this.TableReference     = table    .Reference\n     member this.TableBase          = tableBase\n     member this.Fields: (Field -> string list) -> string seq =\n                     fun chooser                  -> fields |> Seq.sort |> Seq.collect chooser\n     member this.AllFields          = this.Fields <| fieldNames\n     member this.FinTransViewFields = this.Fields <| fieldSource\n     member this.TargetFields       = this.Fields <| fieldTarget\n     member this.Existing           = this.Fields <| fieldSelectTable\n     member this.Source             = this.Fields <| fieldSelectSource    (if cSCD2 > 0 then lastOfDay else id)\n     member this.Together1          = this.Fields <| fieldSelectTogether1 (if cSCD2 > 0 then together1 else id)\n     member this.Together2          = [\n                                        sprintf \"NRec_  = ROW_NUMBER() OVER (PARTITION BY BusinessKey_ ORDER BY %s)\" <| if cSCD2 > 0 then \"SourceDate_, ISNULL(SurrogateKey_, 2147483647)\" else \"ISNULL(SurrogateKey_, 2147483647)\"\n                                        \"*\"\n                                      ]\n     member this.NewRec             = if cSCD2 > 0 then \n                                          this.Fields fieldSCD2Equal\n                                          |> String.concat \"\\n                 AND \"  \n                                          |> sprintf \"NewRec_ = IIF (%s, 0, 1)\"\n                                       else          \"NewRec_ = IIF (P.BusinessKey_ is NULL                  , 1, 0) \"\n     member this.Ordered            = [\n                                        yield                    \"S.SurrogateKey_ \"\n                                        yield                    \"S.BusinessKey_  \"\n                                        yield                    \"S.NRec_         \"\n                                        yield                    this.NewRec      \n                                        if cSCD2 > 0 then yield  \"S.SourceDate_   \"\n                                        yield!                   this.Fields fieldSCD2\n                                        yield!                   this.Fields fieldSCD1\n                                        yield!                   this.Fields fieldSCD0\n                                      ]\n     member this.SCD2Records        = [\n                                        \"SCD2Record_ = SUM(NewRec_    ) OVER (PARTITION BY BusinessKey_ ORDER BY NRec_ ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)\"\n                                        \"NextDate_   = MAX(SourceDate_) OVER (PARTITION BY BusinessKey_ ORDER BY NRec_ ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)\"\n                                        \"LastRec_    = MAX(NRec_      ) OVER (PARTITION BY BusinessKey_)\"\n                                        \"*\"\n                                      ]\n     member this.VersBeg            = [\n                                        sCD2BeginDateO.Value |> pad4 |> sprintf \"%s = MIN(SourceDate_) OVER (PARTITION BY BusinessKey_, SCD2Record_)\"\n                                        sCD2EndDateO  .Value |> pad4 |> sprintf \"%s = DATEADD(d, -1, MAX(IIF(NRec_ = LastRec_, '9999-12-31', NextDate_)) OVER (PARTITION BY BusinessKey_, SCD2Record_))\"\n                                        \"*\"\n                                      ]\n     member this.RKeys              = [\n                                        if sCD2CurrentO.IsSome then \n                                           yield sCD2CurrentO.Value  |> pad4 |> sprintf \"%s = IIF(%s = '9999-12-30', 'Y', 'N')\"                       <| sCD2EndDateO.Value\n                                        yield    surrogateKey        |> pad4 |> sprintf \"%s = MAX(SurrogateKey_) OVER (PARTITION BY BusinessKey_ %s)\" <| if sCD2BeginDateO.IsSome  then  \", \" + sCD2BeginDateO.Value else \"\"\n                                        yield    businessKey         |> pad4 |> sprintf \"%s = BusinessKey_\"\n                                        if changeReasonO.IsSome then\n                                           yield changeReasonO.Value |> pad4 |> sprintf \"%s = '---'\"\n                                        yield    \"*\"\n                                      ]\n     member this.fromTogether2      = \"    Together2 S\n LEFT JOIN Together2 P ON P.BusinessKey_ = S.BusinessKey_\n                      AND P.NRec_        = S.NRec_ - 1\"\n     member this.Withs              =\n         [\n             yield    SQLWith.New \"Existing     \" <| sqlSelect  table .FromWhere              this.Existing \n             yield    SQLWith.New \"Source       \" <| sqlSelectD source.FromWhere              this.Source   \n             yield    SQLWith.New \"Together0    \" <| \"SELECT *  FROM Existing UNION ALL SELECT * FROM Source\"\n             yield    SQLWith.New \"Together1    \" <| sqlSelectD \"Together0\"                   this.Together1\n             yield    SQLWith.New \"Together2    \" <| sqlSelect  \"Together1          \"         this.Together2\n             yield    SQLWith.New \"Ordered      \" <| sqlSelect  this.fromTogether2            this.Ordered     \n             if cSCD2 > 0 then                                  \n                yield SQLWith.New \"SCD2Records  \" <| sqlSelect  \"Ordered            \"         this.SCD2Records \n                yield SQLWith.New \"VersBeg      \" <| sqlSelect  \"SCD2Records        \"         this.VersBeg     \n                yield SQLWith.New \"RKeys        \" <| sqlSelect  \"VersBeg            \"         this.RKeys     \n             else                                               \n                yield SQLWith.New \"RKeys        \" <| sqlSelect  \"Ordered            \"         this.RKeys     \n         ]\n     member this.LastWith           = this.Withs |> Seq.last\n     member this.SelectIntoTemp     = if isSnowflaked then sprintf \"    , NewSurrogateKey_ = NEXT VALUE FOR Seq_%s\\n\" this.TableBase.sqlObject else \"\"\n                                      |> sprintf \"SELECT * \\n%s   INTO #TEMP\\n  FROM %s \\n WHERE NewRec_ = 1\" <| this.LastWith.name                                       \n     member this.Insert             = this.Fields fieldInsert\n                                      |> String.concat \"\\n, \"\n                                      |> sprintf \"   INSERT(%s %s)\" (if isSnowflaked then sprintf \"%s\\n,\" surrogateKey  else \"\")\n                                      |> indent  |> indent\n     member this.Values             = this.Fields fieldValues\n                                      |> String.concat \"\\n, \"\n                                      |> sprintf \"   VALUES(%s %s)\\n\" (if isSnowflaked then \"NewSurrogateKey_\\n,\" else \"\")\n                                      |> indent  |> indent\n     member this.Update             = this.Fields fieldUpdate\n                                      |> String.concat \"\\n, \"\n                                      |> indent |> indent\n     member this.WhenNotMatched     = sprintf \"WHEN NOT MATCHED BY TARGET THEN\\n%s\\n%s\" \n                                      <| this.Insert            <| this.Values\n     member this.WhenMatched        = (fun f -> if f <> \"\" then sprintf \"WHEN MATCHED THEN\\nUPDATE SET %s\" f else f)\n                                      <| this.Update\n     member this.Merge              = sprintf \"MERGE %s AS T\\nUSING #TEMP AS S\\nON (T.%s = S.%s)\\n%s\\n%s;\" \n                                      <| this.TableReference \n                                      <| surrogateKey        <| surrogateKey\n                                      <| this.WhenNotMatched\n                                      <| this.WhenMatched\n     member this.Query              = this.Withs\n                                      |> List.map (fun w -> w.ToString())\n                                      |> String.concat \", \"\n                                      |> sprintf \"WITH %s\"\n                                      |> sprintf \"%s \\n%s; \\n%s\" <| this.SelectIntoTemp <| this.Merge\n     member this.Procedure          = this.Query\n                                      |> sprintf \"BEGIN\\n  EXEC GENERIC.Log @SOURCE, '%s', 'Started Merge', '';\\n  %s\\n END\\n\" procedureName\n                                      |> sqlProcedure procedureName \"@SOURCE VARCHAR(30), @CURRENT_DTE DATE = NULL\" \n     member this.ProcedureName      = procedureName\n     member this.SurrogateKey       = surrogateKey\n     member this.BusinessKey        = businessKey\n     member this.SourceDateO        = sourceDateO\n     member this.SCD2BeginDateO     = sCD2BeginDateO\n     member this.SCD2EndDateO       = sCD2EndDateO  \n     member this.TableName          = table.sqlObject\n     member this.Verification       = sCD2BeginDateO \n                                      |> Option.map (fun b ->\n                                            let e = sCD2EndDateO.Value\n                                            sprintf \" AND (D.%s BETWEEN X.%s AND X.%s  OR D.%s BETWEEN X.%s AND X.%s ) \" b b e  e b e\n                                         )\n                                      |> defaultValue \"\"\n                                      |> sprintf \"SELECT * \\n  FROM %s D \\n WHERE EXISTS(SELECT * \\n         FROM %s X \\n      WHERE X.%s <> D.%s AND X.%s = D.%s %s) \\n ORDER BY %s %s\" \n                                            table.Reference table.Reference\n                                            surrogateKey    surrogateKey    \n                                            businessKey     businessKey\n                                      <| businessKey <| \"\"\n     member this.Snowflakes         = snowflakes\n                                      \n                                    \ntype FactField = \n    | Fact   of FinTransViewField\n    | OField of TargetField * value: string\n\nlet OField: TargetField -> string -> FactField = \n        fun fld            value  -> (fld, value.Trim()) |> OField\n\n[< NoComparison >]\ntype DimRef =\n    | DimRef of Dimension * SurrogateKey: TargetField option * BusinesKey: FinTransViewField option\nwith\n     member this.Dim                = match this with                                      DimRef (dim, _   , _) -> dim\n     member this.FactSurrogateKey   = match this with | DimRef (dim, Some key, _) -> key.Name | DimRef (dim, None, _) -> dim.SurrogateKey\n     member this.FactBusinessKey    = match this with | DimRef (dim, _, Some key) -> key.Name | DimRef (dim, _, None) -> dim.BusinessKey\n     member this.FinTransViewFields = match this with | DimRef (dim, sKO, bKO) -> seq [ yield! bKO |> Option.map (fun f -> f.Name) |> Option.toList ; yield! dim.FinTransViewFields ]\n     member this.TargetFields       = match this with | DimRef (dim, sKO, bKO) -> seq [ yield! sKO |> Option.map (fun f -> f.Name) |> Option.toList ; yield! dim.TargetFields       ]\n     static member New dim                             = DimRef(dim, None             , None            )\n     static member New(dim, surrogateKey             ) = DimRef(dim, Some surrogateKey, None            )\n     static member New(dim, surrogateKey, businessKey) = DimRef(dim, Some surrogateKey, Some businessKey)\nlet dimension: Dimension -> TargetField -> FinTransViewField -> DimRef = \n           fun dim          surroK         businK      -> DimRef (dim, tfldOption surroK, sfldOption businK)\n\ntype FactTable( table  : SQLTableView\n              , source : SQLTableView\n              , dims   : DimRef    seq\n              , fields : FactField seq\n              , extra  : Printf.StringFormat<_>) =\n     let procedureName  = sprintf \"GENERIC.SP_LOAD_%s\" table.sqlObject\nwith \n     member this.TableName      = table.sqlObject\n     member this.ProcedureName  = procedureName\n     member this.SourceFields   = fields \n                                  |> Seq.map (function \n                                              | Fact f       -> f.Name\n                                              | OField(_, f) -> f\n                                             )\n                                  |> Seq.append (dims |> Seq.collect (function dimR -> dimR.FinTransViewFields))\n                                  |> Seq.distinct\n     member this.TargetFields   = fields \n                                  |> Seq.collect (function \n                                                  | Fact f       -> []\n                                                  | OField(f, _) -> [ f.Name ]\n                                                 )\n                                  |> Seq.append (dims |> Seq.collect (function dimR -> dimR.TargetFields))\n                                  |> Seq.distinct\n     member this.Keys           = dims |> Seq.mapi(fun i dim -> sprintf \"D%d.%s\" i dim.Dim.SurrogateKey)\n     member this.Joins          = dims \n                                  |> Seq.mapi(fun i dim -> \n                                                    dim.Dim.SourceDateO\n                                                    |> Option.map (fun v -> sprintf \" AND S.%s BETWEEN D%d.%s AND D%d.%s\" v i dim.Dim.SCD2BeginDateO.Value i dim.Dim.SCD2EndDateO.Value)\n                                                    |> defaultValue \"\"\n                                                    |> sprintf \"%s D%d ON D%d.%s = S.%s %s\" (pad2 dim.Dim.TableBase.Reference) i i (pad2 dim.Dim.BusinessKey) (pad2 dim.FactBusinessKey)\n                                             )\n                                  |> Seq.toList                                                                 \n     member this.From           = sprintf \"%s S\" source.FromWhere\n                                  :: this.Joins\n                                  |> String.concat \"\\n LEFT JOIN \"\n     member this.Query          = fields \n                                  |> Seq.map (function \n                                              | Fact   f     -> sprintf \"S.%s\"    f.Name\n                                              | OField(f, v) -> sprintf \"%s = %s\" (pad2 f.Name) v\n                                             )\n                                  |> Seq.append this.Keys \n                                  |> sqlSelect this.From\n     member this.InsertFields   = fields \n                                  |> Seq.map (function \n                                              | Fact f       -> f.Name\n                                              | OField(f, _) -> f.Name\n                                             )\n                                  |> Seq.append (dims |> Seq.map (fun dim -> dim.FactSurrogateKey))\n                                  |> String.concat \"\\n     , \"\n     member this.Insert         = sprintf \"INSERT INTO %s\\n      (%s)\\n%s\" table.Reference this.InsertFields this.Query\n                                  |> sprintf extra\n     member this.Procedure      = sqlProcedure procedureName \"@SOURCE VARCHAR(30), @FROM DATE = NULL, @TO DATE = NULL\" this.Insert\n\nlet print: string -> unit =\n       fun txt    -> printf \"\\n\\n%s\\n\\n\" txt\n\nlet FinTransViewFields: FactTable -> Dimension seq -> string seq =\n    fun                 fTable       dims          -> \n        fTable.SourceFields \n        |> Seq.append     (dims |> Seq.collect (fun dim -> dim.FinTransViewFields))\n        |> Seq.filter     isIdentifier\n        |> Seq.distinctBy (fun f -> f.ToUpper())\n        |> Seq.sort\n\nlet targetFields: FactTable -> Dimension seq -> string seq =\n    fun           fTable       dims          -> \n        fTable.TargetFields \n        |> Seq.append     (dims |> Seq.collect (fun dim -> dim.TargetFields))\n        |> Seq.filter     isIdentifier\n        |> Seq.distinctBy (fun f -> f.ToUpper())\n        |> Seq.sort\n\n\nlet getDecl: string -> (string * bool) option =\n         fun fname  -> fieldDecl\n                       |> Seq.choose (fun (name, typeDecl, nullable) -> if name = fname.ToUpper() then (typeDecl, nullable = 1) |> Some else None)\n                       |> Seq.tryHead\n\nlet getDefault: string -> string option =\n            fun fname  -> fieldDefault\n                          |> Array.tryPick (fun (name, value) -> if name = fname.ToUpper() then Some value else None)\n\nlet convert fName v =\n    getDecl fName \n    |> Option.map (fun (fType, nullable) -> fType.Trim())\n    |> Option.map (fun typeName -> sprintf \"CONVERT(%s, %s)\"  typeName v) \n    |> Option.defaultValue v\n\nlet applyDefault fName v =\n    getDecl fName \n    |> Option.bind (fun (fType, nullable) ->\n           if nullable then None\n           else getDefault fName\n           |> Option.map (sprintf \"ISNULL(%s, %s)\" v)\n    )\n    |> Option.defaultValue v\n\nlet equalField fName v =\n    fName\n    |> nameS\n    |> pad4 \n    |> sprintf \"%s = %s\"  <| v\n\ntype FinTransViewField\nwith \n    \n    member this.Convert      v = convert      this.Name v\n    member this.applyDefault v = applyDefault this.Name v\n    member this.equal        v = equalField   this.Name v\n    member this.DefaultO       = getDefault   this.Name\n\nlet cast: FinTransViewField -> string -> string =\n      fun field                value  ->\n          value\n          |> field.Convert\n          |> field.applyDefault \n          |> field.equal\n\ntype QueryField(target: FinTransViewField, value: string) =\n    let name = target.Name\nwith\n    member this.Entry = cast target value\n    member this.Name  = name\n\nlet vwField: FinTransViewField -> string -> QueryField = \n         fun fld                  value  -> QueryField(fld, value.Trim())\n\n\nlet inline getUnionNames typ =\n    Microsoft.FSharp.Reflection.FSharpType.GetUnionCases typ\n    |> Seq.map (fun e -> e.Name |> aNumeral)\n    |> Seq.filter ((<>)\"Nil_\")\n    |> Seq.sort\n    |> Seq.toArray\n\nlet finTransViewFieldNames = getUnionNames typeof<FinTransViewField>\nlet targetFieldNames   = getUnionNames typeof<TargetField>\n\nlet missingFields: QueryField seq -> string[] =\n    fun            fields         -> \n        finTransViewFieldNames\n        |> Array.filter (fun e -> fields |> Seq.exists (fun f -> f.Name = e) |> not)\n\nlet allFields() = missingFields (seq[])\n                  |> Seq.sort\n                  |> String.concat \"\\n        , \"\n\nlet setDefault: string -> string =\n            fun field  -> getDefault    field \n                          |> Option.defaultValue \"(NULL)\" \n                          |> convert    field\n                          |> equalField field\n\ntype FactView(name: SQLTableView, source: SQLTableView, fields: QueryField seq) =\n    let fieldsCached = fields |> Seq.toArray\n    let getFieldValue fName =\n        fieldsCached \n        |> Array.tryFind      (fun q -> q.Name    = fName)\n        |> Option.map         (fun q -> q.Entry          )\n        |> Option.defaultWith (fun _ -> setDefault  fName)\nwith\n     member this.Name     = name.schema\n     member this.ViewName = name.Call\n     member this.Query    = \n         finTransViewFieldNames \n         |> Array.map  getFieldValue\n         |> String.concat \"\\n        , \"\n         |> sprintf \"SELECT %s\\n FROM %s;\\n\" <| source.FromWhere\n         |> sprintf \"%s\\n as %s; \\nGO\" (sqlDropCreate VIEW this.ViewName)\n\nlet missingDefaults() =\n    finTransViewFieldNames \n    |> Seq.map    (fun n -> n, getDecl n, getDefault n)\n    |> Seq.filter (fun (n, typeO, defO) -> \n         match typeO, defO with\n         | None               , _\n         | Some (_    , false), None -> true\n         | _                         -> false\n    )\n    |> Seq.map     (fun (n, typO, _) ->\n        (n, typO, \n            match typO with\n            | Some(\"int\"       , _) -> \"0\"\n            | Some(\"varchar(1)\", _)\n            | Some(\"varchar(2)\", _) -> \"'*'\"\n            | Some(\"date\"      , _) \n            | Some(\"datetime\"  , _) -> \"'1900-01-01'\"\n            | _                     -> \"'***'\"\n        )\n    )\n\nlet missingDecls () =\n    fieldDecl\n    |> Array.filter(fun (n, typ, nullable) -> Seq.exists ((=)n) finTransViewFieldNames |> not)\n    |> Array.filter(fun (n, typ, nullable) -> Seq.exists ((=)n) finTransViewFieldNames |> not)\n    \n\nlet inline str4 s = s |> sprintf \"%A\" |> pad4 \nlet inline str2 s = s |> sprintf \"%A\" |> pad2 \n\nlet mutable AllDimensions: Dimension  list = []\nlet mutable AllFactViews : FactView   list = []\nlet mutable AllFactTables: FactTable  list = []\n\ntype Dimension\nwith \n     static member New( tableBase : SQLTableView\n                      , source    : SQLTableView\n                      , fields    : Field  seq\n                      , snowflakes: string seq\n                      , extra     : Printf.StringFormat<_>) =\n          let dim = Dimension(tableBase, source, fields, snowflakes, extra)\n          AllDimensions <- List.append AllDimensions [ dim ]\n          dim\n     static member New(table, source, fields            ) = Dimension.New(table, source, fields, []        , \"%s\")\n     static member New(table, source, fields, snowflakes) = Dimension.New(table, source, fields, snowflakes, \"%s\")\n\ntype FactTable\nwith \n     static member New( table  : SQLTableView\n                      , source : SQLTableView\n                      , dims   : DimRef    seq\n                      , fields : FactField seq\n                      , extra  : Printf.StringFormat<_>) =\n          let ft = FactTable(table, source, dims, fields, extra)\n          AllFactTables <- List.append AllFactTables [ ft ]\n          ft\n\ntype FactView\nwith \n     static member New(name: SQLTableView, source: SQLTableView, fields: QueryField seq) =\n          let fv = FactView(name, source, fields)\n          AllFactViews <- List.append AllFactViews [ fv ]\n          fv\n\n(*          \n(*keep*)#load \"BetterFSI.fsx\"  // <<<==== Execute first in F# Interactive\nDo __SOURCE_FILE__ __LINE__ //\nDo __SOURCE_FILE__ __LINE__ //  missingDecls()    |> Seq.iter (printfn \"%A\")\nDo __SOURCE_FILE__ __LINE__ //  missingDefaults() |> Seq.iter (printfn \"%A\")\nDo __SOURCE_FILE__ __LINE__ //  missingDefaults() |> Seq.iter (fun (n, _, d) -> printfn \"(%s, %s)\" (str4 n) (str2 d))\nDo __SOURCE_FILE__ __LINE__ //  finTransViewFieldNames |> Seq.filter (fun a -> a.StartsWith \"A#\" ) |>\n*)\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[{"$":0,"Item":"62d0b48f-6f54-4fa2-a455-e1f288cfd0c8"},{"$":0,"Item":"133131ac-9ee5-47b2-8047-351746ee9e10"},{"$":0,"Item":"b67af98c-895c-4d9c-bee1-2c43359c6885"}],"id":{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"},"expanded":true,"level":0,"properties":{}},{"name":"-------- READ ME --------","content":"\n\nTo update and regenerate views and procedures:\n\n- Make the required changes to the Views and dimension definitions below \n  and/or the Fields, FieldDecls and Defaults above\n- When ready to send to SQL Server, \n  click on \"Copy Views and Procedures\" at the end of this group\n- WHILE \"Copy Views and Procedures\" IS HIGHLIGHTED, select the view(s) and/or dimensions(s) \n  that need to be updated by clicking on the small box to the right. \n- Click on the \"Evaluate FS\" button\n- After a while a menu will pop up\n- Click on the buttons to copy the new definition to the Clipboard\n- Paste into SSMS and execute\n\nSnowFlaked dimensions.\nTo also update the snowflaked dimensions superviews make sure to check the box for \"SQLFetchFields & SnowFlakeViews\"\nA connection to the SQL Server is required for this option to work.\nThe connection string can be found in line 6.\n\nIf more changes are necessary close the pop up menu and repeat the steps above.\n\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"id":{"$":0,"Item":"38aa569a-caf7-4c97-81c7-12ab6a9faec4"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"module Views =","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"id":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"expanded":true,"level":0,"properties":{}},{"name":"View EMS_MSB","content":"let EMS_MSBView =\n    FactView.New (\n        name   = SQLTableView.New \"\" \"EMS_MSB\" \"VW_FG_FIN_TRANS2        \" \"\" \"\"\n      , source = SQLTableView.New \"\" \"EMS_MSB\" \"VW_FG_FIN_TRANS_STEP0_V2\" \"\" \"\"\n      , fields = [\n                vwField SRC_SYS                             \"'EMS_MSB'                                                           \"\n                vwField SRC_SYS_ID                          \"'EMS_MSB-'+ CONVERT(VARCHAR, Account_No)                            \"\n\n                vwField INTRA_DAY_ORDER                     \"case Transaction_Type \n                                                              when 'Payment'          then 20              \n                                                              when 'Paid'             then 20             \n                                                              when 'Adjustment'       then 30         \n                                                              when 'Billed'           then 10                                                            \n                                                              when 'Turnback'         then 40                                                              \n                                                              when 'Turnover'         then 50                                                              \n                                                              end + IIF(TAG_STATUS='Closed', 2, 1)\"            \n\n                vwField BUS_AREA_ID                         \"'6400'                                                              \"\n// DIM_CARRIER                                                                                                                   \n                vwField CARRIER_SRC                         \"'EMS_MSB'                                                           \"\n// DIM_CARRIER PROCEDURE                                                                                                        \n                vwField CARRIER_PROCEDURE_SRC               \"'EMS_MSB'                                                           \"\n// DIM_COH_ORG                                                                                                                   \n                vwField DEPT_LONG_NAME                      \"'Houston Fire Department'                                           \"\n                vwField DIV_LONG_NAME                       \"'Emergency Medical Services'                                        \"\n// DIM_COLL_PERSON                                                                                                               \n                vwField COLL_PERSON_ID                      \"'EMS_MSB-111'                                                       \"\n                vwField COLL_PERSON_NAME                    \"'EMS_MSB Employee'                                                  \"\n                vwField DIGITECH_ID                         \"'EMS_MSB generic'                                                   \"\n// DIM_CONTR                                                                                                                     \n                vwField CONTR_ID                            \"'4600012363'                                                        \"\n// DIM_CUST                                                                                                                      \n                vwField CUST_ID                             \"'EMS_MSB-'+ CONVERT(VARCHAR, Account_No)                            \"\n                vwField CUST_NAME                           \"Name                                                                \"\n// DIM_CUST_PAR                                                                                                                  \n// DIM DTE                                                                                                                       \n                vwField DTE                                 \"Transaction_Date                                                    \"\n// DIM EMP                                                                                                                       \n                vwField EMP_TYPE                            \"'Employee'                                                          \"\n                vwField EMP_NAME                            \"'EMS_MSB '                                                          \"\n                vwField COH_EMP_NUM                         \"'EMS_MSB-111'                                                       \"\n// DIM_FIN_TRANS_TYPE                                                                                                            \n                vwField MSTR_TRANS_TYPE                     \"case Transaction_Type\t\n\t\t\t\t                                             when 'Payment'             then 'Paid' \n\t\t\t\t                                             when 'Adjustment'\t\t\tthen 'Adjustment'\n\t\t\t\t                                             when 'Turnback'\t\t\tthen 'Turnback'\n\t\t\t\t                                             when 'Turnover'\t\t\tthen 'Turnover'\n\t\t\t\t                                             else                            'Turnover'   end                      \"\n                vwField DET_TRANS_DESCR                     \"case Transaction_Type\t\n\t\t\t\t                                             when 'Payment'             then 'Base, City Portion Paid' \n\t\t\t\t                                             when 'Adjustment'\t\t\tthen 'Base Adjustment'\n\t\t\t\t                                             when 'Turnback'\t\t\tthen 'Base Amount Turnback'\n\t\t\t\t                                             when 'Turnover'\t\t\tthen 'Base Amount Turnover'\n\t\t\t\t                                             else                            'Base Amount Turnover'   end          \"\n                vwField DET_TRANS_CODE                      \"'EMS_MSB-' + Transaction_Type                                       \"\n// DIM INCDT                                                                                                                     \n                vwField INV_NUM                             \"Account_No                                                          \"\n                vwField INCDT_DESCR                         \"'Emergency Transport'                                               \"\n                vwField INCDT_TYPE                          \"'EMS Transport'                                                     \"\n                vwField INCDT_CAT                           \"'EMS Transport'                                                     \"\n                vwField INCDT_DTE                           \"Issue_Date                                                          \"\n// DIM INCDT EMS DET\n                vwField EMS_INCDT                           \"Account_No                                                          \"\n                vwField DISPATCH_NUM                        \"Account_No                                                          \"\n// DIM_ITEM                                                                                                                      \n                vwField ITEM_TYPE                           \"'EMS_MSB Patient'                                                   \"\n// DIM ITEM PT DET\n                vwField PT_GNDR                             \"PT_GNDR                                                             \"\n                vwField PT_AGE                              \"PT_AGE                                                              \"\n// DIM_RECEIVABLE\n                vwField RECEIVABLE_STAT                     \"Tag                                                                 \"      \n                vwField RECEIVABLE_EVER_TRANS_FLAG          \"'Y'                                                                 \"\n                vwField RECEIVABLE_VERS_DUE_DTE             \"IIF(DATEADD(year,1,Issue_Date) > Turnover_Date, Turnover_Date, DATEADD(year,1,Issue_Date))\"\n                vwField RECEIVABLE_VERS_ISSUE_DTE           \"Issue_Date                                                          \"\n                vwField RECEIVABLE_VERS_TO_DTE              \"Turnover_Date                                                       \"   \n                vwField RECEIVABLE_VERS_DELINQ_DTE          \"Turnover_Date                                                       \"   \n                vwField VERS_ASSIGNED_VEND                  \"'0000130521'                                                        \"   \n                vwField RECEIVABLE_MSTR_STAT                \"TAG_STATUS                                                          \"      \n                vwField ITEM_DESCR                          \"'EMS Patient'                                                       \"    \n                vwField ORIG_BILL_NAME                      \"Name                                                                \"     \n// FG_FIN_TRANS\n                vwField TRANS_AMT                           \"Transaction_Amount                                                  \"      \n                vwField POST_DTE                            \"Transaction_Date                                                    \"                               \n        ]\n)\n             \n(* \nopen SlowlyChangingDimensions\nprint EMS_MSBView.Query       \n*)\n\n","parent":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"d2205189-f6a8-4e24-81b2-5b485d18f424"},"expanded":true,"level":0,"properties":{}},{"name":"View HCTO","content":"let HCTOView =\n    FactView.New (\n        name   = SQLTableView.New \"\" \"HCTO\" \"VW_FG_FIN_TRANS2        \" \"\" \"\"\n      , source = SQLTableView.New \"\" \"HCTO\" \"VW_FG_FIN_TRANS_STEP0   \" \"\" \"\"\n      , fields = [\n                vwField SRC_SYS                             \"'HCTO'                                                          \"\n                vwField SRC_SYS_ID                          \"'HCTO-' + SRC_SYS_ID                                            \"\n                                                                                                                     \n                vwField BUS_AREA_ID                         \"'9000'                                                          \"\n// DIM_CARRIER                                                                                                                  \n                vwField CARRIER_SRC                         \"'HCTO'                                                          \"\n// DIM_CARRIER PROCEDURE                                                                                                       \n                vwField CARRIER_PROCEDURE_SRC               \"'HCTO'                                                          \"\n// DIM_COH_ORG                                                                                                                  \n                vwField DEPT_LONG_NAME                      \"'Legal Department'                                              \"\n                vwField DIV_LONG_NAME                       \"'Treasury'                                                      \"\n// DIM_COLL_PERSON                                                                                                              \n                vwField COLL_PERSON_ID                      \"'HCTO-111'                                                      \"\n                vwField COLL_PERSON_NAME                    \"'Harris County Employee'                                        \"\n                vwField DIGITECH_ID                         \"'HCTO generic'                                                  \"\n                vwField HCTO_AD_VAL_ID                      \"'Harris County Employee'                                        \"\n                vwField COLL_PERSON_TYPE                    \"'COH Contractor'                                                \"\n                \n// DIM_CONTR                                                                                                                     \n                vwField CONTR_ID                            \"'***-000001'                                                    \"\n// DIM_CUST                                                                                                                      \n                vwField CUST_ID                             \"'HCTO-'+ CAN                                                    \"\n                vwField CONFI_CUST_FLAG                     \"'N'                                                             \"\n                vwField CUST_NAME                           \"NAMELINE1                                                       \"\n                vwField CUST_IS_VEND_FLAG                   \"'N'                                                             \"\n                vwField JV_CUST_FLAG                        \"'N'                                                             \"\n                vwField CUST_ADDR_LINE_1                    \"NAMELINE2                                                       \"\n                vwField CUST_ADDR_LINE_2                    \"NAMELINE3                                                       \"\n                vwField CUST_ADDR_LINE_3                    \"NAMELINE4                                                       \"\n                vwField CUST_IN_CITY_FLAG                   \"IIF(CITY='HOUSTON','Y','N')                                     \"\n                vwField CUST_CITY                           \"CITY                                                            \"\n                vwField CUST_STATE                          \"STATE                                                           \"\n                vwField CUST_CTRY                           \"COUNTRY                                                         \"\n                vwField CUST_ZIP_CODE                       \"SUBSTRING(ZIPCODE,1,5)                                          \"\n                vwField CUST_ZIP_PLUS_4                     \"SUBSTRING(ZIPCODE,1,13)                                         \"\n// DIM_CUST_PAR                                                                                                                  \n// DIM DTE                                                                                                                       \n                vwField DTE                                 \"TRANS_DTE                                                       \"\n// DIM EMP                                                                                                                       \n                vwField EMP_TYPE                            \"'COH Contractor'                                                \"\n                vwField EMP_NAME                            \"'Harris County Employee'                                        \"\n                vwField COH_EMP_NUM                         \"'HCTO-111'                                                      \"\n// DIM_FIN_TRANS_TYPE                                                                                                            \n                vwField MSTR_TRANS_TYPE                     \"MSTR_TRANS_TYPE                                             \"\n                vwField DET_TRANS_DESCR                     \"DET_TRANS_DESCR                                                 \"\n                vwField DET_TRANS_CODE                      \"'HCTO-' + MSTR_TRANS_TYPE                                       \"\n// DIM INCDT                                                                                                                     \n                vwField INV_NUM                             \"SRC_SYS_ID                                                      \"\n                vwField INCDT_DESCR                         \"'Property ownership'                                            \"\n                vwField INCDT_TYPE                          \"'Property ownership'                                            \"\n                vwField INCDT_CAT                           \"'Property ownership'                                            \"\n                vwField INCDT_DTE                           \"CONVERT(DATETIME,'10/1/'+CONVERT(VARCHAR(4),YEAR))              \"\n                vwField INCDT_ADDR_LINE_1                   \"CONVERT(VARCHAR,PNUMBER)+' '+PSTRNAME                         \"\n                vwField INCDT_ST_NUM                        \"PNUMBER                                                         \"\n                vwField INCDT_ST_NAME                       \"PSTRNAME                                                        \"\n                vwField INCDT_IN_CITY_FLAG                  \"'Y'                                                             \"\n                vwField INCDT_STATE                         \"'Texas'                                                         \"\n                vwField INCDT_CTRY                          \"'USA'                                                           \"\n                vwField INCDT_ZIP_CODE                      \"SUBSTRING(PZIP,1,5)                                             \"\n// DIM_ITEM                                                                                                                      \n                vwField ITEM_TYPE                           \"'Ad Valorem Property'                                           \"\n                vwField ITEM_ADDR_LINE_1                    \"CONVERT(VARCHAR,PNUMBER)+' '+PSTRNAME                           \" \n                vwField ITEM_ST_NUM                         \"CONVERT(VARCHAR(13),PNUMBER)                                    \"\n                vwField ITEM_ST_NAME                        \"PSTRNAME                                                        \"\n                vwField ITEM_IN_CITY_FLAG                   \"'Y'                                                             \"\n                vwField ITEM_STATE                          \"'Texas'                                                         \"\n                vwField ITEM_DESCR                          \"'Property ownership'                                            \"\n                vwField ITEM_ZIP_CODE                       \"SUBSTRING(PZIP,1,5)                                             \"\n// DIM ITEM DET\n                vwField FLAG_DIM_ITEM_TAXABLE_PROP_DET      \"1                                                               \"\n                vwField TAXABLE_PROP_ROLL_TYPE              \"'Roll Type'                                          \"            \n                vwField NUM_OF_ACRES                        \"LEGACRES                                                        \"\n                vwField PROP_CLASS_CODE                     \"PROPCLASS                         \" \n                vwField CITY_RFPD_JURIS_CODE                \"'61'        \" \n                vwField CONFI_ACCT_FLAG                     \"'N' \" \n                vwField TAX_DEFERRAL_START_DTE              \"TAXDEFSTRT                                                      \"\n                vwField TAX_DEFERRAL_END_DTE                \"TAXDEFEND                                                     \" \n                vwField OWNERSHIP_EFF_DTE                   \"CONVERT(DATETIME,'1900-01-01 00:00:00.000') \" \n                vwField APPRAISAL_DISTR_ACCT_NUM            \"SUBSTRING(CAN,1,16) \" \n                vwField TAXABLE_PROP_LGL_DESCR_1            \"LEGAL1                                                          \"\n                vwField TAXABLE_PROP_LGL_DESCR_2            \"LEGAL2                                                          \"\n                vwField TAXABLE_PROP_LGL_DESCR_3            \"LEGAL3                                                          \"\n                vwField TAXABLE_PROP_LGL_DESCR_4            \"LEGAL4                                                          \"\n                vwField TAXABLE_PROP_LGL_DESCR_5            \"LEGAL5                                                          \"\n                vwField TAX_ROLL_CODE                       \"ROLL                                                            \"\n                vwField PROP_CLASS_DESCR                    \"Property_Description                                            \"\n                vwField CITY_RFPD_JURIS_DESCR               \"'HOUSTON, CITY OF'                                             \"\n                vwField TAX_ROLL_DESCR                      \"'Roll Type'                                         \"\n                vwField CAN                                 \"SUBSTRING(CAN,1,16) \"\n// DIM_RECEIVABLE\n                vwField RECEIVABLE_EVER_TRANS_FLAG      \"'N'                                                                 \"\n                vwField RECEIVABLE_VERS_DELINQ_DTE      \"DELINQ_DTE                                                          \"\n                vwField RECEIVABLE_VERS_DUE_DTE         \"DUEDATE                                                             \"\n                vwField RECEIVABLE_VERS_ISSUE_DTE       \"CONVERT(DATETIME,'10/1/'+CONVERT(VARCHAR(4), YEAR))                 \"\n                vwField RECEIVABLE_VERS_TO_DTE          \"CONVERT(DATETIME,'10/1/'+CONVERT(VARCHAR(4), YEAR))                 \"\n                vwField VERS_ASSIGNED_VEND              \"'0000113973'                                                        \"\n                vwField ORIG_BILL_NAME                  \"NAMELINE1                                                           \"\n                vwField UNK_CUST_AT_BILL_FLAG           \"'N'                                                                 \"\n// Dim_Receivable_Det DIM_RECEIVABLE_AD_VAL_RECEIVABLE_DET\n                vwField FLAG_DIM_RECEIVABLE_AD_VAL_RECEIVABLE_DET \"1\"\n                vwField AD_VAL_VET_FLAG                  \"VETERAN                                                            \"\n                vwField AD_VAL_DISABLED_FLAG             \"DISABLED                                                           \"\n                vwField AD_VAL_OVER_66_FLAG              \"OVER65                                                             \"\n                vwField AD_VAL_HOMESTEAD_FLAG            \"HOMESTEAD                                                          \"\n                vwField HCAD_ACCT_STAT                   \"CAN                                                                \"\n                vwField AD_VAL_TAX_DEFERRAL_START_DTE    \"TAXDEFSTRT                                                        \"\n                vwField AD_VAL_TAX_DEFERRAL_END_DTE      \"TAXDEFEND                                                         \"\n                vwField ``A#3348_ATTY_FEE_DTE``          \"DATE_3348                                                         \"\n                vwField ``A#3308_ATTY_FEE_DTE``          \"DATE_3308                                                         \"\n//              vwField ``A#3307_ATTY_FEE_DTE``          \"DATE_3307                                                         \"\n//Dim Business Area\n                vwField BUS_AREA_ID                   \"'9000'                                                               \"\n\n// Dim Functional Area\n                vwField FUNC_AREA_ID                    \"'GEGO-00-00000000'                                                   \"\n// Dim Fund ID\n                vwField FUND_ID                         \"'1000'                                                               \"\n// Dim Fund Cntr ID\n                vwField FUND_CNTR_ID                    \"'1000'                                                               \"\n// Dim GL Acct  \n                vwField GL_ACCT_ID                      \"'0000428020'                                                         \"\n\n// FG_FIN_TRANS\n                vwField TRANS_AMT                           \"TRANS_AMT\t                                                       \"      \n                vwField SRC_SYS_TRANS_ID                    \"'HCTO'                                                            \"      \n              \n                vwField POST_DTE                            \"TRANS_DTE                                                          \"                               \n        ]\n)\n\n(* \nopen SlowlyChangingDimensions\nprint HCTOView.Query \n*)","parent":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"79ff8549-d6f4-47cf-b0c0-efc9eaa6e813"},"expanded":true,"level":0,"properties":{}},{"name":"View HHD","content":"let HHDView =\n    FactView.New (\n        name   = SQLTableView.New \"\" \"HHD\" \"VW_FG_FIN_TRANS2        \" \"\" \"\"\n      , source = SQLTableView.New \"\" \"HHD\" \"VW_FG_FIN_TRANS_STEP0   \" \"\" \"\"\n      , fields = [\n                vwField SRC_SYS                             \"'HHD'                                                           \"\n                vwField SRC_SYS_ID                          \"'HHD-'+Document_Number                                          \"\n\n                vwField BUS_AREA_ID                         \"'3800'                                                          \"\n// DIM_CARRIER                                                                                                                   \n                vwField CARRIER_SRC                         \"'HHD'                                                           \"\n// DIM_CARRIER PROCEDURE                                                                                                        \n                vwField CARRIER_PROCEDURE_SRC               \"'HHD'                                                           \"\n// DIM_COH_ORG                                                                                                                   \n                vwField DEPT_LONG_NAME                      \"'Health & Human Services'                                       \"\n                vwField DIV_LONG_NAME                       \"'Health & Human Services'                                       \"\n// DIM_COLL_PERSON                                                                                                               \n                vwField COLL_PERSON_ID                      \"'HHD-111'                                                       \"\n                vwField COLL_PERSON_NAME                    \"'HHD Employee'                                                  \"\n                vwField DIGITECH_ID                         \"'HHD generic'                                                   \"\n// DIM_CONTR                                                                                                                     \n                vwField CONTR_ID                            \"'***'                                                           \"\n// DIM_CUST                                                                                                                      \n                vwField CUST_ID                             \"'HHD-'+ CONVERT(VARCHAR, CUSTOMER)                              \"\n                vwField CUST_NAME                           \"Name_1                                                          \"\n                vwField CUST_ADDR_LINE_1                    \"Street                                                          \"\n                vwField CUST_CITY                           \"City                                                            \"\n                vwField CUST_STATE                          \"Region                                                            \"\n                vwField CUST_ZIP_CODE                       \"IIF(LEN(Postal_Code) = 0, '***', isnull(LEFT(Postal_Code, 5) ,'***'))           \"\n                vwField CUST_PHN_NUM_1                      \"IIF(LEN(Telephone_1) = 0,'***',Telephone_1)                     \"\n                vwField CUST_FAX_NUM                        \"IIF(LEN(Fax_Number) = 0,'***',Fax_Number)                     \"\n         \n// DIM_CUST_PAR                                                                                                                  \n// DIM DTE                                                                                                                       \n                vwField DTE                                 \"Value_Date                                                      \"\n// DIM EMP                                                                                                                       \n                vwField EMP_TYPE                            \"'Employee'                                                      \"\n                vwField EMP_NAME                            \"'HHD '                                                          \"\n                vwField COH_EMP_NUM                         \"'HHD-111'                                                       \"\n// DIM_FIN_TRANS_TYPE                                                                                                            \n                vwField MSTR_TRANS_TYPE                     \"Transaction_Type\t                                             \"\n                vwField DET_TRANS_DESCR                     \"Transaction_Desc\t                                             \"\n                vwField DET_TRANS_CODE                      \"'HHD-' + Transaction_Type                                       \"\n// DIM INCDT                                                                                                                     \n                vwField INV_NUM                             \"'HHD-'+Document_Number                                          \"\n                vwField INCDT_DTE                           \"Value_Date                                                          \"\n// DIM_ITEM                                                                                                                      \n                vwField ITEM_TYPE                           \"'HHD Transaction'                                                   \"\n                vwField ITEM_DESCR                          \"'HHD Transaction'                                                   \"    \n// DIM_RECEIVABLE\n//                vwField RECEIVABLE_STAT                     \"BLNGSTAT                                                            \"      \n                vwField RECEIVABLE_EVER_TRANS_FLAG          \"'N'                                                                 \"\n                vwField RECEIVABLE_VERS_DUE_DTE             \"Due_date                                                            \"\n                vwField RECEIVABLE_VERS_ISSUE_DTE           \"Issue_date                                                          \"\n//                vwField RECEIVABLE_MSTR_STAT                \"ACCOUNTSTATUS                                                       \"      \n                vwField ORIG_BILL_NAME                      \"Name_1                                                            \"     \n// FG_FIN_TRANS\n                vwField TRANS_AMT                           \"Amount                                                            \"      \n                vwField POST_DTE                            \"Value_Date                                                        \"                               \n        ]\n)\n(* \nopen SlowlyChangingDimensions\nprint HHDView.Query \n*)\n","parent":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"a8351a4c-1fdb-4f57-8fca-8fed60008c36"},"expanded":true,"level":0,"properties":{}},{"name":"View HPL","content":"let HPLView =\n    FactView.New (\n        name   = SQLTableView.New \"\" \"HPL\" \"VW_FG_FIN_TRANS2        \" \"\" \"\"\n      , source = SQLTableView.New \"\" \"HPL\" \"VW_FG_FIN_TRANS_STEP0_v4\" \"\" \"\"\n      , fields = [\n                vwField SRC_SYS                             \"'HPL'                                                               \"\n                vwField SRC_SYS_ID                          \"INV_NUM                                                             \"\n                vwField INTRA_DAY_ORDER                     \"case Transaction_Type2 \n                                                              when 'Payment'          then 20              \n                                                              when 'Paid'             then 20             \n                                                              when 'Adjustment'       then 30         \n                                                              when 'Billed'           then 10                                                            \n                                                              when 'Turnback'         then 40                                                              \n                                                              when 'Turnover'         then 50                                                              \n                                                              end + IIF(PIF='Y', 2, 1)\"            \n\n                vwField BUS_AREA_ID                         \"'3400'                                                              \"\n// DIM_CARRIER                                                                                                                   \n                vwField CARRIER_SRC                         \"'HPL'                                                               \"\n// DIM_CARRIER PROCEDURE                                                                                                         \n                vwField CARRIER_PROCEDURE_SRC               \"'HPL'                                                               \"\n// DIM_COH_ORG                                                                                                                   \n                vwField DEPT_LONG_NAME                      \"'Houston Public Library'                                            \"\n                vwField DIV_LONG_NAME                       \"'Library Material Services'                                         \"\n// DIM_COLL_PERSON                                                                                                               \n                vwField COLL_PERSON_ID                      \"'HPL-111'                                                           \"\n                vwField COLL_PERSON_NAME                    \"'HPL Employee'                                                      \"\n                vwField DIGITECH_ID                         \"'HPL generic'                                                       \"\n// DIM_CONTR                                                                                                                     \n                vwField CONTR_ID                            \"IIF(CollectionState2 > 0, '4600014067' , '***')                     \"\n// DIM_CUST                                                                                                                      \n                vwField CUST_ID                             \"CUST_ID                                                             \"\n                vwField CUST_EMAIL_ADDR                     \"EMAIL                                                               \"\n                vwField CUST_PHN_NUM_1                      \"PHONE                                                               \"\n                vwField CUST_NAME                           \"Name                                                                \"\n                vwField CUST_TYPE                           \"PROFILE                                                             \"\n                vwField CUST_ADDR_LINE_1                    \"STREET                                                              \"\n                vwField CUST_ADDR_LINE_2                    \"APT_UNIT                                                            \"\n                vwField CUST_CITY                           \"CITY_STATE                                                          \"\n                vwField CUST_APT_LOT                        \"APT_UNIT                                                            \"\n                vwField CUST_ZIP_CODE                       \"LEFT(ZIP,5)                                                         \"\n                vwField CUST_ZIP_PLUS_4                     \"ZIP                                                                 \"\n// DIM_CUST_PAR                                                                                                                    \n                vwField CUST_PAR_ID                         \"IIF(LEN(CARE_OF) > 1, CUST_ID, '***')                               \"\n                vwField CUST_PAR_NAME                       \"IIF(LEN(CARE_OF) > 1, CARE_OF, '***')                               \"\n// DIM DTE                                                                                                                       \n                vwField DTE                                 \"Transaction_Date2                                                   \"\n// DIM EMP                                                                                                                       \n                vwField EMP_TYPE                            \"'Employee'                                                          \"\n                vwField EMP_NAME                            \"'HPL '                                                              \"\n                vwField COH_EMP_NUM                         \"'HPL-111'                                                           \"\n// DIM_FIN_TRANS_TYPE                                                                                                            \n                vwField MSTR_TRANS_TYPE                     \"Transaction_Type2                                                   \"\n                vwField DET_TRANS_DESCR                     \" case Transaction_Type2 \n                                                              when 'Payment'          then 'Base, City Portion Paid'              \n                                                              when 'Paid'             then 'Base, City Portion Paid'              \n                                                              when 'Adjustment'       then 'Base Adjustment'                 \n                                                              when 'Billed'           then 'Base Amount Billed'                                                                 \n                                                              when 'Turnback'         then 'Base Amount Turnback'                                                                 \n                                                              when 'Turnover'         then 'Base Amount Turnover'                                                                 \n                                                              end                                                                \"\n                vwField DET_TRANS_CODE                      \"'HPL-' + Transaction_Type2                                          \"\n// DIM INCDT                                                                                                                     \n                vwField INV_NUM                             \"INV_NUM                                                             \"\n                vwField INCDT_DESCR                         \"'HPL Billed'                                                        \"\n                vwField INCDT_TYPE                          \"'Houston Public Library'                                            \"\n                vwField INCDT_CAT                           \"'Houston Public Library'                                            \"\n                vwField INCDT_DTE                           \"Date_Billed                                                         \"\n// DIM_ITEM                                                                                                                      \n                vwField ITEM_TYPE                           \"ITEM_TYPE                                                           \"\n// DIM_RECEIVABLE\n                vwField RECEIVABLE_EVER_TRANS_FLAG          \"IIF(CollectionState2 > 0, 'Y','N')                                  \"\n                vwField RECEIVABLE_VERS_DELINQ_DTE          \"DATEADD(day,30,Date_Billed)                                         \"\n                vwField RECEIVABLE_VERS_DUE_DTE             \"DATEADD(day,30,Date_Billed)                                         \"\n                vwField RECEIVABLE_VERS_ISSUE_DTE           \"Date_Billed                                                         \"\n                vwField RECEIVABLE_VERS_TO_DTE              \"IIF(CollectionState2 > 0, TurnoverDate, '1900-01-01')               \"   \n                vwField VERS_ASSIGNED_VEND                  \"IIF(CollectionState2 > 0, '0000109958' , 'CoH')                     \"   \n                vwField RECEIVABLE_MSTR_STAT                \"IIF(PIF='Y','Close','Open')                                         \"      \n                vwField RECEIVABLE_MSTR_STAT_CHG_DTE        \"IIF(PIF='Y',Transaction_Date2, '1900-01-01')                        \"    \n                vwField ITEM_DESCR                          \"'HPL Transaction'                                                   \"    \n                vwField ORIG_BILL_NAME                      \"Name                                                                \"     \n                vwField RECEIVABLE_VERS_BILLING_TO_DTE      \"IIF(CollectionState2 > 0,TurnoverDate,'1900-01-01')                 \"   \n// FG_FIN_TRANS\n                vwField TRANS_AMT                           \"Transaction_Amount2                                                 \"      \n                vwField POST_DTE                            \"Transaction_Date2                                                   \"                               \n        ]\n    )\n(*          \nopen SlowlyChangingDimensions\nprint HPLView.Query \n*)\n","parent":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"04f28553-8359-4ba0-9281-bc45839b844f"},"expanded":true,"level":0,"properties":{}},{"name":"View MCD","content":"let MCDView =\n    FactView.New (\n        name   = SQLTableView.New \"\" \"MCD\" \"VW_FG_FIN_TRANS2       \" \"\" \"\"\n      , source = SQLTableView.New \"\" \"MCD\" \"VW_FG_FIN_TRANS_STEP0_v2  \" \"\" \"\"\n      , fields = [\n                vwField SRC_SYS                             \"'MCD'                                                               \"\n                vwField SRC_SYS_ID                          \"INV_NUM                                                             \"\n\n                vwField BUS_AREA_ID                         \"'1600'                                                              \"\n// DIM_CARRIER                                                                                                                   \n                vwField CARRIER_SRC                         \"'MCD'                                                               \"\n// DIM_CARRIER PROCEDURE                                                                                                         \n                vwField CARRIER_PROCEDURE_SRC               \"'MCD'                                                               \"\n// DIM_COH_ORG                                                                                                                   \n                vwField DEPT_LONG_NAME                      \"'Municipal Courts'                                                  \"\n                vwField DIV_LONG_NAME                       \"'Municipal Courts'                                                  \"\n// DIM_COLL_PERSON                                                                                                               \n                vwField COLL_PERSON_ID                      \"'MCD-111'                                                           \"\n                vwField COLL_PERSON_NAME                    \"'MCD Employee'                                                      \"\n                vwField DIGITECH_ID                         \"'MCD generic'                                                       \"\n// DIM_CONTR                                                                                                                     \n                vwField CONTR_ID                            \"IIF(Vendor_ID LIKE 'INCOLL', '***', '0000100103')\" // this is needed to point to Linebarger when they have it\n// DIM_CUST                                                                                                                      \n                vwField CUST_ID                             \"CUST_ID                                                             \"\n                vwField CUST_PHN_NUM_1                      \"ResPhone                                                            \"\n                vwField CUST_NAME                           \"DefLastName + ', ' + DefFirstName                                   \"\n                vwField DL_ISSUE_STATE                      \"DLState                                                             \"\n                vwField DL_NUM                              \"DLNbr                                                               \"\n                vwField CUST_ADDR_LINE_1                    \"BestAddLine1                                                        \"\n                vwField CUST_ADDR_LINE_2                    \"BestAddLine2                                                        \"\n                vwField CUST_CITY                           \"BestAddCity                                                         \"\n                vwField CUST_STATE                          \"BestAddState                                                        \"\n                vwField CUST_ZIP_CODE                       \"BestAddZip                                                          \"\n// DIM_CUST_PAR                                                                                                                  \n// DIM DTE                                                                                                                       \n                vwField DTE                                 \"Transaction_Date                                                    \"\n// DIM EMP                                                                                                                       \n                vwField EMP_TYPE                            \"'Employee'                                                          \"\n                vwField EMP_NAME                            \"'MCD '                                                              \"\n                vwField COH_EMP_NUM                         \"'MCD-111'                                                           \"\n// DIM_FIN_TRANS_TYPE                                                                                                            \n                vwField MSTR_TRANS_TYPE                     \"IIF(Transaction_Type = 'Non-Monetary','Adjustment',Transaction_Type) \"\n                vwField DET_TRANS_DESCR                     \"Transaction_Desc                                                    \"\n                vwField DET_TRANS_CODE                      \"'MCD-' + Transaction_Type                                           \"\n// DIM INCDT                                                                                                                     \n                vwField INV_NUM                             \"INV_NUM                                                             \"\n                vwField INCDT_DESCR                         \"ViolationDesc                                                       \"\n                vwField VIO_CODE                            \"ViolationCode                                                       \"\n                vwField ADJ_FLAG                            \"ADJUDICATED_STATUS                                                  \"\n                vwField INCDT_TYPE                          \"'Municipal Courts'                                                  \"\n                vwField INCDT_CAT                           \"'Municipal Courts'                                                  \"\n                vwField INCDT_DTE                           \"ViolationDate                                                       \"\n                vwField INCDT_TIME                          \"ViolationTime                                                       \"\n                vwField INCDT_ADDR_LINE_1                   \"VioStreetName                                                       \"\n                vwField BLK_NUM                             \"VioStreetBlck                                                       \"\n// DIM_ITEM                                                                                                                      \n// DIM_RECEIVABLE\n                vwField RECEIVABLE_STAT                     \"ViolationStatus                                                     \"      \n                vwField RECEIVABLE_EVER_TRANS_FLAG          \"IIF(Vendor_ID LIKE 'INCOLL', 'N','Y')                               \"\n       // too complex resolve in source  vwField RECEIVABLE_VERS_DELINQ_DTE          \"IIF(V.Vendor_ID LIKE 'INCOLL',NULL ,R.Turnover_DTE)                               \"\n                vwField RECEIVABLE_VERS_DUE_DTE             \"IIF(Turnover_DTE is null,DATEADD(day,60,Issue_DTE),Turnover_DTE) \"\n                vwField RECEIVABLE_VERS_ISSUE_DTE           \"Issue_DTE                                                           \"\n                vwField RECEIVABLE_VERS_TO_DTE              \"Turnover_DTE                                                        \"   \n                vwField VERS_ASSIGNED_VEND                  \"IIF(Vendor_ID LIKE 'INCOLL','CoH' , '0000106846')                   \"   \n                vwField RECEIVABLE_MSTR_STAT                \"IIF(ViolationStatus='CLOSED','Close','Open')                        \"      \n                vwField RECEIVABLE_MSTR_STAT_CHG_DTE        \"STATUS_DATE                                                         \"    \n                vwField ITEM_DESCR                          \"'MCD Transaction'                                                   \"    \n                vwField ORIG_BILL_NAME                      \"DefLastName + ', ' + DefFirstName                                   \"     \n// FG_FIN_TRANS\n                vwField TRANS_AMT                           \"Transaction_Amount                                                  \"      \n                vwField POST_DTE                            \"STATUS_DATE                                                         \"                               \n        ]\n)\n\n(* \nopen SlowlyChangingDimensions\nprint MCDView.Query\n*)\n","parent":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"28e52d96-1900-4150-a99d-6f5ed15bd1df"},"expanded":true,"level":0,"properties":{}},{"name":"View PWE","content":"let PWEView =\n    FactView.New (\n        name   = SQLTableView.New \"\" \"PWE\" \"VW_FG_FIN_TRANS2        \" \"\" \"\"\n      , source = SQLTableView.New \"\" \"PWE\" \"VW_FG_FIN_TRANS_STEP0   \" \"\" \"\"\n      , fields = [\n                vwField SRC_SYS                             \"'PWE'                                                           \"\n                vwField SRC_SYS_ID                          \"INV_NUM                                                         \"\n\n                vwField BUS_AREA_ID                         \"'2000'                                                          \"\n// DIM_CARRIER                                                                                                                   \n                vwField CARRIER_SRC                         \"'PWE'                                                           \"\n// DIM_CARRIER PROCEDURE                                                                                                        \n                vwField CARRIER_PROCEDURE_SRC               \"'PWE'                                                           \"\n// DIM_COH_ORG                                                                                                                   \n                vwField DEPT_LONG_NAME                      \"'Public Works & Engineering'                                    \"\n                vwField DIV_LONG_NAME                       \"'Public Works & Engineering'                                    \"\n// DIM_COLL_PERSON                                                                                                               \n                vwField COLL_PERSON_ID                      \"'PWE-111'                                                       \"\n                vwField COLL_PERSON_NAME                    \"'PWE Employee'                                                  \"\n                vwField DIGITECH_ID                         \"'PWE generic'                                                   \"\n// DIM_CONTR                                                                                                                     \n                vwField CONTR_ID                            \"'***'                                                           \"\n// DIM_CUST                                                                                                                      \n                vwField CUST_ID                             \"'PWE-'+ CONVERT(VARCHAR, ACCOUNTNUMBER)                         \"\n                vwField CUST_NAME                           \"CUSTDESC1                                                       \"\n                vwField CUST_ADDR_LINE_1                    \"CONVERT(VARCHAR(10), STNO) + ' ' + CONVERT(VARCHAR(max), STNAME)\"\n                vwField CUST_CITY                           \"City                                                            \"\n                vwField CUST_ZIP_CODE                       \"IIF(LEN(ZIP) = 0, '***', isnull(LEFT(ZIP, 5) ,'***'))           \"\n                vwField CUST_TYPE                           \"ACCTCLASSDESC                                                   \"\n\n// DIM_CUST_PAR                                                                                                                  \n// DIM DTE                                                                                                                       \n                vwField DTE                                 \"Transaction_Date                                                      \"\n// DIM EMP                                                                                                                       \n                vwField EMP_TYPE                            \"'Employee'                                                      \"\n                vwField EMP_NAME                            \"'PWE '                                                          \"\n                vwField COH_EMP_NUM                         \"'PWE-111'                                                       \"\n// DIM_FIN_TRANS_TYPE                                                                                                            \n                vwField MSTR_TRANS_TYPE                     \"Transaction_Type\t                                             \"\n                vwField DET_TRANS_DESCR                     \"case Transaction_Type\t\n\t\t\t\t                                             when 'Payment'             then 'Base, City Portion Paid' \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t when 'Paid'                then 'Base, City Portion Paid' \n\t\t\t\t                                             when 'Adjustment'\t\t\tthen 'Base Adjustment'\n\t\t\t\t                                             when 'Turnback'\t\t\tthen 'Base Amount Turnback'\n\t\t\t\t                                             when 'Turnover'\t\t\tthen 'Base Amount Turnover'\n\t\t\t\t                                             else                            'Base Amount Billed'   end          \"\n                vwField DET_TRANS_CODE                      \"'PWE-' + Transaction_Type                                       \"\n// DIM INCDT                                                                                                                     \n                vwField INV_NUM                             \"INV_NUM                                                         \"\n                vwField INCDT_DTE                           \"Issue_Date                                                          \"\n// DIM_ITEM                                                                                                                      \n                vwField ITEM_TYPE                           \"'PWE Transaction'                                                   \"\n                vwField ITEM_DESCR                          \"'PWE Transaction'                                                   \"    \n// DIM_RECEIVABLE\n                vwField RECEIVABLE_STAT                     \"BLNGSTAT                                                            \"      \n                vwField RECEIVABLE_EVER_TRANS_FLAG          \"'N'                                                                 \"\n                vwField RECEIVABLE_VERS_DUE_DTE             \"ISNULL(Due_Date, DATEADD(day, 21, CONVERT(DATETIME, Issue_Date)))   \"\n                vwField RECEIVABLE_VERS_ISSUE_DTE           \"Issue_Date                                                          \"\n                vwField RECEIVABLE_MSTR_STAT                \"ACCOUNTSTATUS                                                       \"      \n                vwField ORIG_BILL_NAME                      \"CUSTDESC                                                            \"     \n// FG_FIN_TRANS\n                vwField TRANS_AMT                           \"Transaction_Amount                                                  \"      \n                vwField POST_DTE                            \"Transaction_Date                                                          \"                               \n        ]\n)\n\n(* \nopen SlowlyChangingDimensions\nprint PWEView.Query\n*)\n","parent":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"3b47f651-d4ef-41db-90f3-ad67d1a4b6eb"},"expanded":true,"level":0,"properties":{}},{"name":"module Dimensions =","content":"module Dimensions =","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"id":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"expanded":true,"level":0,"properties":{}},{"name":"dimReceivable","content":"let dimReceivable = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_RECEIVABLE        \" \"SRC_SYS_ID LIKE @SOURCE + '%'\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , snowflakes =\n                 [\n                    \"DIM_RECEIVABLE_AD_VAL_RECEIVABLE_DET\"\n                    \"DIM_RECEIVABLE_BOOT_TOW_DET\"\n                    \"DIM_RECEIVABLE_EMS_RECEIVABLE_DET\"\n                    \"DIM_RECEIVABLE_FIRE_ALM_CIT_DET\"\n                    \"DIM_RECEIVABLE_PRKG_CONTRA_DET\"\n                 ]\n      , fields = [\n                    BusinessKey    SRC_SYS_ID                     \n                    SourceDate     DTE\n                    IntraDayOrder  INTRA_DAY_ORDER\n                    ChangeReason   ROW_CHG_RSN\n                    \n                    SurrogateKey   RECEIVABLE_KEY                    \n                    SCD2BeginDate  VERS_BEG_DTE                       \n                    SCD2EndDate    VERS_END_DTE                       \n                    SCD2Current    CURR_VERS_FLAG           \n\n////////////                       SCD2                              SCD1                             SCD0        \n////////////                       ---------                         -------                          ------\n                    SCD2           RECEIVABLE_STAT                   Nil                              Nil\n                    SCD2           RECEIVABLE_STAT_CHG_DTE           Nil                              Nil\n                    SCD2           RECEIVABLE_VERS_ISSUE_DTE         RECEIVABLE_CURR_ISSUE_DTE        RECEIVABLE_ORIG_ISSUE_DTE            \n                    SCD2           RECEIVABLE_VERS_DUE_DTE           RECEIVABLE_CURR_DUE_DTE          RECEIVABLE_ORIG_DUE_DTE              \n                    SCD2           RECEIVABLE_VERS_DELINQ_DTE        RECEIVABLE_CURR_DELINQ_DTE       RECEIVABLE_ORIG_DELINQ_DTE           \n                    SCD2           RECEIVABLE_VERS_TO_DTE            RECEIVABLE_CURR_TO_DTE           RECEIVABLE_ORIG_TO_DTE               \n                    SCD2           RECEIVABLE_VERS_BILLING_TO_DTE    RECEIVABLE_CURR_BILLING_TO_DTE   RECEIVABLE_ORIG_BILLING_TO_DTE       \n                    SCD2           VERS_ASSIGNED_VEND                CURR_ASSIGNED_VEND               ORIG_ASSIGNED_VEND              \n                    SCD2           RECEIVABLE_MSTR_STAT              Nil                              Nil\n                    SCD2           RECEIVABLE_MSTR_STAT_CHG_DTE      Nil                              Nil\n\n////////////                       SCD1                              SCD0                    \n////////////                       ---------                         -------                        \n                    SCD1           INV_NUM                           ORIG_INV_NUM                   \n                    SCD1           RECEIVABLE_EVER_TRANS_FLAG        Nil\n                    SCD1           RECEIVABLE_LITIGATION_DTE         Nil\n                    SCD1           RECEIVABLE_FNL_PAY_DTE            Nil\n                    SCD1           RECEIVABLE_1ST_PAY_DTE            Nil\n                    SCD1           RECEIVABLE_SETTLEMENT_DTE         Nil\n                    SCD1           FIRE_ALM_AGING_RST_FLAG           Nil\n                    SCD1           REINSTATEMENT_DTE                 Nil\n                    SCD1           FIRE_ORIG_ISSUE_DTE               Nil\n                    SCD1           ITEM_DESCR                        Nil\n                    SCD1           ORIG_BILL_NAME                    Nil\n                    SCD1           UNK_CUST_AT_BILL_FLAG             Nil\n\n////////////                       SCD0                    \n////////////                       --------- \n                    SCD0           LOAD_DTE                        \n                    SCD0           LOAD_TIME              \n                    \n                    SCD1           FLAG_DIM_RECEIVABLE_AD_VAL_RECEIVABLE_DET  Nil\n                    SCD1           ``A#3307_ATTY_FEE_DTE``                    Nil\n                    SCD1           ``A#3308_ATTY_FEE_DTE``                    Nil\n                    SCD1           ``A#3348_ATTY_FEE_DTE``                    Nil\n                    SCD1           AD_VAL_ACCT_LVL_ID                         Nil\n                    SCD1           AD_VAL_DISABLED_FLAG                       Nil\n                    SCD1           AD_VAL_EFF_DTE_OF_OWNERSHIP                Nil\n                    SCD1           AD_VAL_HOMESTEAD_FLAG                      Nil\n                    SCD1           AD_VAL_OVER_66_FLAG                        Nil\n                    SCD1           AD_VAL_TAX_DEFERRAL_END_DTE                Nil\n                    SCD1           AD_VAL_TAX_DEFERRAL_START_DTE              Nil\n                    SCD1           AD_VAL_VET_FLAG                            Nil\n                    SCD1           COLL_LAWSUIT_NUM                           Nil\n                    SCD1           COLL_LGL_COND                              Nil\n                    SCD1           HCAD_ACCT_STAT                             Nil\n                    SCD1           QTRLY_PAY_FLAG                             Nil\n                    SCD1           FLAG_DIM_RECEIVABLE_BOOT_TOW_DET           Nil\n                    SCD1           RECEIVABLE_HAS_LTR_FLAG                    Nil\n                    SCD1           RECEIVABLE_HAS_NOTE_FLAG                   Nil\n                    SCD1           RECEIVABLE_HAS_PEND_LTR_FLAG               Nil\n                    SCD1           RESOLVE_DESCR                              Nil\n                    SCD1           RESOLVE_DTE                                Nil\n                    SCD1           RESOLVE_RSN                                Nil\n                    SCD1           RESOLVED_BY                                Nil\n                    SCD1           FLAG_DIM_RECEIVABLE_EMS_RECEIVABLE_DET     Nil\n                    SCD1           ACTV_CARRIER                               Nil\n                    SCD1           ACTV_CARRIER_FIN_CLASS                     Nil\n                    SCD1           ACTV_CARRIER_FIN_GRP                       Nil\n                    SCD1           BILLING_HOLD_FLAG                          Nil\n                    SCD1           SIG_FLAG                                   Nil\n                    SCD1           FLAG_DIM_RECEIVABLE_FIRE_ALM_CIT_DET       Nil\n                    SCD1           VOID_CODE                                  Nil\n                    SCD1           VOID_DESCR                                 Nil\n                    SCD1           WORK_STAT                                  Nil\n                    SCD1           FLAG_DIM_RECEIVABLE_PRKG_CONTRA_DET        Nil\n                    SCD1           ESC_CAND_FLAG                              Nil\n                    SCD1           ON_ADMIN_HOLD_FLAG                         Nil\n                    SCD1           UNDER_APPEAL_FLAG                          Nil\n                    SCD1           VOID_FLAG                                  Nil\n                    SCD1           WRITE_OFF_FLAG                             Nil\n                 ]\n    )\n\n(*\nopen SlowlyChangingDimensions\nprint dimReceivable.Procedure\nprint dimReceivable.Verification\n*)","parent":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"96efc394-df97-4995-9643-b15f9475e16c"},"expanded":true,"level":0,"properties":{}},{"name":"dimItem","content":"let dimItem = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_ITEM              \" \"\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , snowflakes = \n                 [\n                    \"DIM_ITEM_BURG_ALM_PERMIT_DET\"\n                    \"DIM_ITEM_FIRE_ALM_PERMIT_DET\"\n                    \"DIM_ITEM_LICENSED_VEH_DET\"\n                    \"DIM_ITEM_PT_DET\"\n                    \"DIM_ITEM_TAXABLE_PROP_DET\"\n                    \"DIM_ITEM_WTR_ACCT_DET\"\n                 ]\n      , fields = [\n                    BusinessKey    ITEM_TYPE                     \n                    SourceDate     DTE                           \n                    IntraDayOrder  INTRA_DAY_ORDER\n                    ChangeReason   ROW_CHG_RSN\n\n                    SurrogateKey   ITEM_KEY                        \n                    SCD2BeginDate  VERS_BEG_DTE                     \n                    SCD2EndDate    VERS_END_DTE                     \n                    SCD2Current    CURR_VERS_FLAG                \n                    SCD2           ITEM_STAT                        Nil                             Nil\n                    SCD2           ITEM_STAT_CHG_DTE                Nil                             Nil\n                    SCD1           ITEM_EXMPT_FLAG                  Nil\n                    SCD1           ITEM_ADDR_LINE_1                 Nil\n                    SCD1           ITEM_ADDR_LINE_2                 Nil\n                    SCD1           ITEM_ADDR_LINE_3                 Nil\n                    SCD1           ITEM_ST_NUM                      Nil\n                    SCD1           ITEM_PREFIX                      Nil\n                    SCD1           ITEM_ST_PRETYPE                  Nil\n                    SCD1           ITEM_ST_NAME                     Nil\n                    SCD1           ITEM_ST_TYPE                     Nil\n                    SCD1           ITEM_SUFF                        Nil\n                    SCD1           ITEM_SERV_LVL                    Nil\n                    SCD1           ITEM_IN_CITY_FLAG                Nil\n                    SCD1           ITEM_CITY                        Nil\n                    SCD1           ITEM_STATE                       Nil\n                    SCD1           ITEM_CTRY                        Nil\n                    SCD1           ITEM_ST_DIR                      Nil\n                    SCD1           ITEM_ST                          Nil\n                    SCD1           ITEM_CNTY                        Nil\n                    SCD1           ITEM_APT_LOT                     Nil\n                    SCD1           ITEM_GIS_MATCH_SCORE             Nil\n                    SCD1           ITEM_GIS_ST_NUM                  Nil\n                    SCD1           ITEM_GIS_PREFIX                  Nil\n                    SCD1           ITEM_GIS_ST_PRETYPE              Nil\n                    SCD1           ITEM_GIS_ST_NAME                 Nil\n                    SCD1           ITEM_GIS_ST_TYPE                 Nil\n                    SCD1           ITEM_GIS_SUFF                    Nil\n                    SCD1           ITEM_GIS_CITY                    Nil\n                    SCD1           ITEM_GIS_ZIP                     Nil\n                    SCD1           ITEM_GIS_X                       Nil\n                    SCD1           ITEM_GIS_Y                       Nil\n                    SCD1           ITEM_ZIP_CODE                    Nil\n                    SCD1           ITEM_ZIP_PLUS_4                  Nil\n                    SCD1           ITEM_GIS_LOCATR_NAME             Nil\n                    SCD0           LOAD_DTE                        \n                    SCD0           LOAD_TIME         \n                    \n                    SCD1           FLAG_DIM_ITEM_BURG_ALM_PERMIT_DET  Nil\n                    SCD1           ALLOWABLE_NO_CHRG_INCDTS           Nil\n                    SCD1           ALM_MNT_CMPNY                      Nil\n                    SCD1           ALM_TYPE                           Nil\n                    SCD1           PERMIT_EXP_DTE                     Nil\n                    SCD1           PERMIT_ISSUE_DTE                   Nil\n                    SCD1           PERMIT_NAME                        Nil\n                    SCD1           PERMIT_NUM                         Nil\n                    SCD1           REG_HOLDER_FLAG                    Nil\n                    SCD1           SUSPD_PERMIT_DTE                   Nil\n                    SCD1           SUSPD_PERMIT_RSN                   Nil\n                    SCD1           TYPE_OF_ALM_SITE                   Nil\n                    SCD1           FLAG_DIM_ITEM_FIRE_ALM_PERMIT_DET  Nil\n                    SCD1           ALM_INSTL_CMPNY                    Nil\n                    SCD1           ALM_INSTL_DTE                      Nil\n                    SCD1           ALM_REG_KEY                        Nil\n                    SCD1           APPLICTN_RECV_DTE                  Nil\n                    SCD1           CURR_FIRE_ALM_PERMIT_FLAG          Nil\n                    SCD1           EXCL_TYPE                          Nil\n                    SCD1           FIRE_ALM_PERMIT_ACTV_FLAG          Nil\n                    SCD1           FIRE_ALM_PERMIT_NUM                Nil\n                    SCD1           FIRE_ALM_PURPOSE                   Nil\n                    SCD1           FLAG_DIM_ITEM_LICENSED_VEH_DET     Nil\n                    SCD1           LICENSE_PLATE_EXP_MTH              Nil\n                    SCD1           LICENSE_PLATE_EXP_YR               Nil\n                    SCD1           LICENSE_PLATE_NUM                  Nil\n                    SCD1           LICENSE_PLATE_TYPE                 Nil\n                    SCD1           OWNER_IS_CUST_FLAG                 Nil\n                    SCD1           SRC_SYS_VEH_ID                     Nil\n                    SCD1           VEH_COLOR                          Nil\n                    SCD1           VEH_ID_NUM                         Nil\n                    SCD1           VEH_MAKE                           Nil\n                    SCD1           VEH_MODEL                          Nil\n                    SCD1           VEH_MODEL_YR                       Nil\n                    SCD1           VEH_OWNER_ID                       Nil\n                    SCD1           VEH_OWNER_NAME                     Nil\n                    SCD1           VEH_TYPE                           Nil\n                    SCD1           FLAG_DIM_ITEM_PT_DET               Nil\n                    SCD1           PT_AGE                             Nil\n                    SCD1           PT_GNDR                            Nil\n                    SCD1           FLAG_DIM_ITEM_TAXABLE_PROP_DET     Nil\n                    SCD1           APPRAISAL_DISTR_ACCT_NUM           Nil\n                    SCD1           CAN                                Nil\n                    SCD1           CC_JURIS_CODE                      Nil\n                    SCD1           CC_JURIS_DESCR                     Nil\n                    SCD1           CITY_RFPD_JURIS_CODE               Nil\n                    SCD1           CITY_RFPD_JURIS_DESCR              Nil\n                    SCD1           CONFI_ACCT_FLAG                    Nil\n                    SCD1           MUNIC_UTIL_DISTR_CODE              Nil\n                    SCD1           MUNIC_UTIL_DISTR_DESCR             Nil\n                    SCD1           NUM_OF_ACRES                       Nil\n                    SCD1           OWNERSHIP_EFF_DTE                  Nil\n                    SCD1           PROP_CLASS_CODE                    Nil\n                    SCD1           PROP_CLASS_DESCR                   Nil\n                    SCD1           REND_PENALTY_JURIS_CODE            Nil\n                    SCD1           REND_PENALTY_JURIS_DESCR           Nil\n                    SCD1           SCHOOL_JURIS_CODE                  Nil\n                    SCD1           SCHOOL_JURIS_DESCR                 Nil\n                    SCD1           SUBSTANTIAL_ERR_PENALTY            Nil\n                    SCD1           TAX_DEFERRAL_END_DTE               Nil\n                    SCD1           TAX_DEFERRAL_START_DTE             Nil\n                    SCD1           TAX_ROLL_CODE                      Nil\n                    SCD1           TAX_ROLL_DESCR                     Nil\n                    SCD1           TAXABLE_PROP_LGL_DESCR_1           Nil\n                    SCD1           TAXABLE_PROP_LGL_DESCR_2           Nil\n                    SCD1           TAXABLE_PROP_LGL_DESCR_3           Nil\n                    SCD1           TAXABLE_PROP_LGL_DESCR_4           Nil\n                    SCD1           TAXABLE_PROP_LGL_DESCR_5           Nil\n                    SCD1           TAXABLE_PROP_ROLL_TYPE             Nil\n                    SCD1           FLAG_DIM_ITEM_WTR_ACCT_DET         Nil\n                    SCD1           CURR_WTR_ACCT_FLAG                 Nil\n                    SCD1           DELINQ_DTE                         Nil\n                    SCD1           LAST_CUST_CONN_DTE                 Nil\n                    SCD1           LAST_CUST_CUTOFF_DTE               Nil\n                    SCD1           LAST_CUST_DISCONN_DTE              Nil\n                    SCD1           LAST_METER_INSPECT_DTE             Nil\n                    SCD1           OWNER_RENTER                       Nil\n                    SCD1           SEN_CITIZEN_FLAG                   Nil\n                    SCD1           VAC_FLAG                           Nil\n                    SCD1           WTR_ACCT_NUM_OF_UNITS              Nil\n                    SCD1           WTR_ACCT_ORIG_USE_TYPE             Nil\n                    SCD1           WTR_ACCT_PROP_USE_TYPE             Nil\n                    SCD1           WTR_METER_NUM                      Nil\n                 ]\n    )\n    \n(*\nopen SlowlyChangingDimensions\nprint dimItem.Procedure\nprint dimItem.Verification\n*)    ","parent":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"72108083-b588-4246-9978-6fff21e46351"},"expanded":true,"level":0,"properties":{}},{"name":"dimIncdt","content":"let dimIncdt = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_INCDT             \" \"SRC_SYS_ID LIKE @SOURCE + '%'\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , snowflakes =\n                 [\n                    \"DIM_INCDT_EMS_DET\"\n                 ]\n      , fields = [\n                    BusinessKey    SRC_SYS_ID                          \n                    SourceDate     DTE                                 \n                    IntraDayOrder  INTRA_DAY_ORDER\n                    ChangeReason   ROW_CHG_RSN\n\n                    SurrogateKey   INCDT_KEY                              \n                    SCD2BeginDate  VERS_BEG_DTE                            \n                    SCD2EndDate    VERS_END_DTE                            \n                    SCD2Current    CURR_VERS_FLAG                      \n                    SCD2           ADJ_FLAG                              Nil Nil\n                    SCD1           BILLED_FLAG                           Nil\n                    SCD1           RSN_INCDT_NOT_BILLED                  Nil\n                    SCD1           INV_NUM                               Nil\n                    SCD1           PERMIT_IS_CURR_AT_TIME_OF_INCDT_FLAG  Nil\n                    SCD1           INCDT_DESCR                           Nil\n                    SCD1           VIO_CODE                              Nil\n                    SCD1           INCDT_TYPE                            Nil\n                    SCD1           INCDT_CAT                             Nil\n                    SCD1           TOWING_CMPNY                          Nil\n                    SCD1           BOOT_SERIAL_NUM                       Nil\n                    SCD1           PRKG_METER_VIO_FLAG                   Nil\n                    SCD1           PRKG_METER_NUM                        Nil\n                    SCD1           INCDT_SEQ_NUM                         Nil\n                    SCD1           INCDT_DTE                             Nil\n                    SCD1           INCDT_TIME                            Nil\n                    SCD1           INCDT_ADDR_LINE_1                     Nil\n                    SCD1           INCDT_ADDR_LINE_2                     Nil\n                    SCD1           INCDT_ADDR_LINE_3                     Nil\n                    SCD1           INCDT_ST_NUM                          Nil\n                    SCD1           INCDT_PREFIX                          Nil\n                    SCD1           INCDT_ST_PRETYPE                      Nil\n                    SCD1           INCDT_ST_NAME                         Nil\n                    SCD1           INCDT_ST_TYPE                         Nil\n                    SCD1           INCDT_SUFF                            Nil\n                    SCD1           INCDT_SERV_LVL                        Nil\n                    SCD1           INCDT_IN_CITY_FLAG                    Nil\n                    SCD1           INCDT_CITY                            Nil\n                    SCD1           INCDT_STATE                           Nil\n                    SCD1           INCDT_CTRY                            Nil\n                    SCD1           INCDT_ST_DIR                          Nil\n                    SCD1           INCDT_ST                              Nil\n                    SCD1           INCDT_CNTY                            Nil\n                    SCD1           INCDT_APT_LOT                         Nil\n                    SCD1           INCDT_GIS_MATCH_SCORE                 Nil\n                    SCD1           INCDT_GIS_ST_NUM                      Nil\n                    SCD1           INCDT_GIS_PREFIX                      Nil\n                    SCD1           INCDT_GIS_ST_PRETYPE                  Nil\n                    SCD1           INCDT_GIS_ST_NAME                     Nil\n                    SCD1           INCDT_GIS_ST_TYPE                     Nil\n                    SCD1           INCDT_GIS_SUFF                        Nil\n                    SCD1           INCDT_GIS_CITY                        Nil\n                    SCD1           INCDT_GIS_ZIP                         Nil\n                    SCD1           INCDT_GIS_X                           Nil\n                    SCD1           INCDT_GIS_Y                           Nil\n                    SCD1           INCDT_ZIP_CODE                        Nil\n                    SCD1           INCDT_ZIP_PLUS_4                      Nil\n                    SCD1           INCDT_GIS_LOCATR_NAME                 Nil\n                    SCD1           BLK_NUM                               Nil\n//                  SCD1           VEH                                   Nil\n//                  SCD1           EMS_INCDT                             Nil\n//                  SCD1           DISPATCH_NUM                          Nil\n//                  SCD1           EMS_INCDT_CAT                         Nil\n//                  SCD1           TXP_SERV_LVL                          Nil\n//                  SCD1           TXP_TYPE                              Nil\n//                  SCD1           ORIGIN_LOC                            Nil\n//                  SCD1           DEST_LOC                              Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n\n                    SCD1           FLAG_DIM_INCDT_EMS_DET                Nil\n                    SCD1           DEST_LOC                              Nil\n                    SCD1           DISPATCH_NUM                          Nil\n                    SCD1           EMS_INCDT                             Nil\n                    SCD1           EMS_INCDT_CAT                         Nil\n                    SCD1           ORIGIN_LOC                            Nil\n                    SCD1           TXP_SERV_LVL                          Nil\n                    SCD1           TXP_TYPE                              Nil\n                    SCD1           VEH                                   Nil\n                 ]\n    )\n    \n(*\nopen SlowlyChangingDimensions\nprint dimIncdt.Procedure\nprint dimIncdt.Verification\n*)    ","parent":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"80a1bb44-c482-4a00-bf8a-63832322bad9"},"expanded":true,"level":0,"properties":{}},{"name":"dimCust","content":"let dimCust = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_CUST              \" \"CUST_ID LIKE @SOURCE + '%'\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , fields = [\n                    BusinessKey    CUST_ID                                \n                    SourceDate     DTE                                       \n                    IntraDayOrder  INTRA_DAY_ORDER\n                    ChangeReason   ROW_CHG_RSN\n\n                    SurrogateKey   CUST_KEY                               \n                    SCD2BeginDate  VERS_BEG_DTE                            \n                    SCD2EndDate    VERS_END_DTE                            \n                    SCD2Current    CURR_VERS_FLAG                      \n                    SCD2           JV_CUST_FLAG                          Nil Nil\n                    SCD2           DEC_CUST_FLAG                         Nil Nil\n                    SCD1           CONFI_CUST_FLAG                       Nil\n                    SCD1           CUST_EMAIL_ADDR                       Nil\n                    SCD1           CUST_PHN_NUM_1                        Nil\n                    SCD1           CUST_FAX_NUM                          Nil\n                    SCD1           CUST_NAME                             Nil\n                    SCD1           FED_TAX_ID                            Nil\n                    SCD1           CUST_TYPE                             Nil\n                    SCD1           BUS_CONT_PERSON_NAME                  Nil\n                    SCD1           STATE_CORP_CHTR_ID                    Nil\n                    SCD1           STATE_SALES_TAX_ID                    Nil\n                    SCD1           CUST_IS_VEND_FLAG                     Nil\n                    SCD1           SAP_BUS_ID                            Nil\n                    SCD1           NAICS_DET_CODE                        Nil\n                    SCD1           NAICS_INDY_CODE                       Nil\n                    SCD1           NAICS_INDY_GRP_CODE                   Nil\n                    SCD1           NAICS_MAJ_GRP_CODE                    Nil\n                    SCD1           NAICS_DIV_CODE                        Nil\n                    SCD1           SIC_INDY_GRP_CODE                     Nil\n                    SCD1           SIC_MAJ_GRP_CODE                      Nil\n                    SCD1           SIC_DIV_CODE                          Nil\n                    SCD1           DL_ISSUE_STATE                        Nil\n                    SCD1           DL_NUM                                Nil\n                    SCD1           CUST_ADDR_LINE_1                      Nil\n                    SCD1           CUST_ADDR_LINE_2                      Nil\n                    SCD1           CUST_ADDR_LINE_3                      Nil\n                    SCD1           CUST_ST_NUM                           Nil\n                    SCD1           CUST_PREFIX                           Nil\n                    SCD1           CUST_ST_PRETYPE                       Nil\n                    SCD1           CUST_ST_NAME                          Nil\n                    SCD1           CUST_ST_TYPE                          Nil\n                    SCD1           CUST_SUFF                             Nil\n                    SCD1           CUST_SERV_LVL                         Nil\n                    SCD1           CUST_IN_CITY_FLAG                     Nil\n                    SCD1           CUST_CITY                             Nil\n                    SCD1           CUST_STATE                            Nil\n                    SCD1           CUST_CTRY                             Nil\n                    SCD1           CUST_ST_DIR                           Nil\n                    SCD1           CUST_ST                               Nil\n                    SCD1           CUST_CNTY                             Nil\n                    SCD1           CUST_APT_LOT                          Nil\n                    SCD1           CUST_GIS_MATCH_SCORE                  Nil\n                    SCD1           CUST_GIS_ST_NUM                       Nil\n                    SCD1           CUST_GIS_PREFIX                       Nil\n                    SCD1           CUST_GIS_ST_PRETYPE                   Nil\n                    SCD1           CUST_GIS_ST_NAME                      Nil\n                    SCD1           CUST_GIS_ST_TYPE                      Nil\n                    SCD1           CUST_GIS_SUFF                         Nil\n                    SCD1           CUST_GIS_CITY                         Nil\n                    SCD1           CUST_GIS_ZIP                          Nil\n                    SCD1           CUST_GIS_X                            Nil\n                    SCD1           CUST_GIS_Y                            Nil\n                    SCD1           CUST_ZIP_CODE                         Nil\n                    SCD1           CUST_ZIP_PLUS_4                       Nil\n                    SCD1           CUST_GIS_LOCATR_NAME                  Nil\n                    SCD1           CUST_PAR_KEY                          Nil\n                    SCD1           SIC_CODE                              Nil\n                    SCD1           NAICS_DET_NAME                        Nil\n                    SCD1           NAICS_INDY_NAME                       Nil\n                    SCD1           NAICS_INDY_GRP_NAME                   Nil\n                    SCD1           NAICS_MAJ_GRP_NAME                    Nil\n                    SCD1           NAICS_DIV_NAME                        Nil\n                    SCD1           SIC_NAME                              Nil\n                    SCD1           SIC_INDY_GRP_NAME                     Nil\n                    SCD1           SIC_MAJ_GRP_NAME                      Nil\n                    SCD1           SIC_DIV_NAME                          Nil\n                    SCD1           CUST_PHN_NUM_2                        Nil\n                    SCD1           CUST_PHN_NUM_3                        Nil\n                    SCD1           SRC_SYS_MOD_DTE                       Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n                 ]\n    )\n    \n(*\nopen SlowlyChangingDimensions\nprint dimCust.Procedure\nprint dimCust.Verification\n*)    ","parent":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"81c54ba2-389b-4333-8e02-42004320dde0"},"expanded":true,"level":0,"properties":{}},{"name":"dimFinTransType","content":"let dimFinTransType = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_FIN_TRANS_TYPE    \" \"DET_TRANS_CODE LIKE @SOURCE + '%'\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"                                 \" \"\"\n      , fields = [\n                    BusinessKey    DET_TRANS_CODE                               \n                    SurrogateKey   FIN_TRANS_TYPE_KEY                  \n                    SCD1           PAY_METH                              Nil\n                    SCD1           MAN_TRANS_FLAG                        Nil\n                    SCD1           DERIVED_TRANS_FLAG                    Nil\n                    SCD1           MSTR_TRANS_TYPE                       Nil\n                    SCD1           SRC_SYS                               Nil\n                    SCD1           ALLOC_TRANS_FLAG                      Nil\n                    SCD1           DET_TRANS_DESCR                       Nil\n                    SCD1           T2_TRANS_TYPE_CODE                    Nil\n                    SCD1           T2_TRANS_TYPE_DESCR                   Nil\n                    SCD1           T2_TRANS_RSN                          Nil\n                    SCD1           T2_TRANS_PARSED_DESCR                 Nil\n                    SCD1           T2_TRANS_MISC_ITEM_CODE               Nil\n                    SCD1           T2_TRANS_MISC_ITEM_DESCR              Nil\n                    SCD1           T2_TRANS_SCENARIO                     Nil\n                    SCD1           INTRA_FUND_TRANS_FLAG                 Nil\n                    SCD1           T2_TRANS_ORIG_OBJ_TYPE_ID             Nil\n                    SCD1           SMARTCM_OTHER_CRITERIA                Nil\n                    SCD1           SMARTCM_IS_FEE                        Nil\n                    SCD1           SMARTCM_IS_ADJMT                      Nil\n                    SCD1           SMARTCM_IS_PAY                        Nil\n                    SCD1           PMAM_ADJMT_TO                         Nil\n                    SCD1           PMAM_ADJMT_TYPE                       Nil\n                    SCD1           DIGITECH_TRANS_TYPE                   Nil\n                    SCD1           DIGITECH_TRANS_TYPE_DET               Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n                 ]\n    )\n\n(*\nopen SlowlyChangingDimensions\nprint dimFinTransType.Procedure\nprint dimFinTransType.Verification\n*)    ","parent":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"e193a2d8-54ab-4b99-a5cf-a6084db9fffb"},"expanded":true,"level":0,"properties":{}},{"name":"dims Carrier, Procedure, CollPerson, Emp, Dte,  CohOrg","content":"let dimCarrier = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_CARRIER           \" \"\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , fields = [\n                    BusinessKey    SRC_CARRIER_KEY                         \n                    SurrogateKey   CARRIER_KEY                            \n                    SCD1           MEDICARE_PAYER_CODE                   Nil\n                    SCD1           MEDICAID_PAYER_CODE                   Nil\n                    SCD1           CARRIER_FIN_GRP                       Nil\n                    SCD1           CARRIER_FIN_CLASS                     Nil\n                    SCD1           CARRIER_GRP                           Nil\n                    SCD1           CARRIER_NAME                          Nil\n                    SCD1           CARRIER_SRC                           Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n                 ]\n    )\n\nlet dimProcedure = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_CARRIER_PROCEDURE \" \"\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , fields = [\n                    BusinessKey    SRC_CARRIER_PROCEDURE_KEY                \n                    SurrogateKey   CARRIER_PROCEDURE_KEY                  \n                    SCD1           CARRIER_PROCEDURE_SRC                 Nil\n                    SCD1           CARRIER_PROCEDURE_CODE                Nil\n                    SCD1           CARRIER_PROCEDURE_DESCR               Nil\n                    SCD1           CARRIER_PROCEDURE_TYPE                Nil\n                    SCD1           CARRIER_PROCEDURE_BILL_CODE           Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n                 ]\n    )\n\nlet dimCollPerson = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_COLL_PERSON       \" \"COLL_PERSON_ID LIKE @SOURCE + '%'\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"                                 \" \"\"\n      , fields = [\n                    BusinessKey    COLL_PERSON_ID                           \n                    SurrogateKey   COLL_PERSON_KEY                        \n                    SCD1           T2_ID                                 Nil\n                    SCD1           PMAM_ID                               Nil\n                    SCD1           SMART_CM_ID                           Nil\n                    SCD1           HCTO_AD_VAL_ID                        Nil\n                    SCD1           COLL_PERSON_TYPE                      Nil\n                    SCD1           COLL_PERSON_NAME                      Nil\n                    SCD1           COH_EMP_NUM                           Nil\n                    SCD1           INT_EXT_EMP_FLAG                      Nil\n                    SCD1           DIGITECH_ID                           Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n                 ]\n    )\n\nlet dimEmp = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_EMP               \" \"COH_EMP_NUM LIKE @SOURCE + '%'\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"                              \" \"\"\n      , fields = [\n                    BusinessKey    COH_EMP_NUM                                  \n                    SurrogateKey   EMP_KEY                                \n                    SCD1           EMP_TYPE                              Nil\n                    SCD1           EMP_NAME                              Nil\n                    SCD1           RM_LOAD_DTE                           Nil\n                    SCD1           RM_LOAD_TIME                          Nil\n                    SCD1           RM_EMP_MSTR_KEY                       Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n                 ]\n    )\n\n\n\nlet dimDte = \n    Dimension(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_DTE               \" \"\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , fields = [\n                    BusinessKey    DTE                                         \n                    SurrogateKey   DTE_KEY                               \n                 ]\n    )\n\nlet dimCohOrg = \n    Dimension(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_COH_ORG           \" \"\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , fields = [\n                    BusinessKey    DEPT_LONG_NAME                       \n                    SurrogateKey   COH_ORG_KEY\n                 ]\n    )\n    \n(*\nopen SlowlyChangingDimensions\nprint dimCarrier   .Procedure\nprint dimProcedure .Procedure\nprint dimCollPerson.Procedure\nprint dimEmp       .Procedure\nprint dimCohOrg    .Procedure\n\nprint dimCarrier   .Verification\nprint dimProcedure .Verification\nprint dimCollPerson.Verification\nprint dimEmp       .Verification\n*)    ","parent":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"7e3c7382-100e-4212-b9be-02cd9f1cb2db"},"expanded":true,"level":0,"properties":{}},{"name":"FactTable finTrans","content":"open Dimensions\nlet finTrans =\n    FactTable.New(\n               table  = SQLTableView.New \"         \" \"       \" \"FG_FIN_TRANS_INTER    \" \"\" \"\"\n             , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n             , dims   = [ //        dimension       SurrogateKey    BusinessKey (if different)\n                          dimension dimCust         Nil              Nil_\n                          dimension dimReceivable   Nil              Nil_\n                          dimension dimItem         Nil              Nil_\n                          dimension dimIncdt        Nil              Nil_\n                        //dimension dimCarrier      Nil              Nil_\n                        //dimension dimProcedure    Nil              Nil_\n                          dimension dimCollPerson   Nil              Nil_\n                          dimension dimEmp          Nil              Nil_\n                          dimension dimFinTransType Nil              Nil_\n                          dimension dimCohOrg       Nil              Nil_\n                          dimension dimDte          TRANS_DTE_KEY    Nil_\n                          dimension dimDte          POST_DTE_KEY     POST_DTE\n                        ]\n             , fields = [\n                          OField  SYS_LOAD_KEY          \"(SELECT MAX(SYS_LOAD_KEY) FROM DIM_SYS_LOAD WHERE SRC_SYS = @SOURCE)\"\n                          OField  ORIG_CUST_KEY         \"D0.CUST_KEY     \"\n                          OField  COLL_VEND_CONTR_KEY   \"CON.CONTR_KEY   \"\n                          OField  GL_COMBO_KEY          \"1\"\n                          Fact    TRANS_CNT            \n                          Fact    TRANS_AMT            \n                          Fact    INTRA_FUND_TRANS_AMT \n                          Fact    LOAD_DTE             \n                          Fact    LOAD_TIME            \n                          Fact    SRC_SYS_TRANS_ID     \n                        ]\n             , extra  = \"\"\"\nBEGIN\n  EXEC GENERIC.Log @SOURCE, 'SP_LOAD_FG_FIN_TRANS', 'Started DELETE FG_FIN_TRANS_INTER', '';\n    DELETE S \n    FROM        FG_FIN_TRANS_INTER S \n    INNER JOIN  DIM_SYS_LOAD L ON L.SYS_LOAD_KEY = S.SYS_LOAD_KEY \n    INNER JOIN  DIM_DTE      D ON D.DTE_KEY      = S.TRANS_DTE_KEY\n    WHERE L.SRC_SYS = @SOURCE\n      AND D.DTE BETWEEN ISNULL(@FROM, '1000-01-01') AND ISNULL(@TO, '9999-12-31');\n    \n  EXEC GENERIC.Log @SOURCE, 'SP_LOAD_FG_FIN_TRANS', 'Started INSERT FG_FIN_TRANS_INTER', '';\n    %s\n LEFT JOIN  DIM_VEND             V ON V.VEND_ID               = S.VERS_ASSIGNED_VEND\n LEFT JOIN  DIM_CONTR          CON ON  CON.VEND_KEY           = V.VEND_KEY              AND S.DTE BETWEEN CON.VALID_FROM_DTE AND CON.VALID_TO_DTE\n                                  AND (CON.CONTR_REV_STREAM   = S.SRC_SYS                OR CON.CONTR_REV_STREAM   = '***'    ) \n\n  EXEC GENERIC.Log @SOURCE, 'SP_LOAD_FG_FIN_TRANS', 'FINISHED!!! INSERT FG_FIN_TRANS_INTER', '';\nEND\n             \"\"\"\n             )\n\n(*\nopen SlowlyChangingDimensions\nprint finTrans       .Procedure\n*)\n\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"},{"$":0,"Item":"96efc394-df97-4995-9643-b15f9475e16c"},{"$":0,"Item":"72108083-b588-4246-9978-6fff21e46351"},{"$":0,"Item":"80a1bb44-c482-4a00-bf8a-63832322bad9"},{"$":0,"Item":"81c54ba2-389b-4333-8e02-42004320dde0"},{"$":0,"Item":"e193a2d8-54ab-4b99-a5cf-a6084db9fffb"},{"$":0,"Item":"7e3c7382-100e-4212-b9be-02cd9f1cb2db"}],"id":{"$":0,"Item":"ca42551e-1781-4b7f-ba28-609caafa658c"},"expanded":true,"level":0,"properties":{}},{"name":"SQLFetchFields & SnowFlakeViews ","content":"#if SLOWLY_CHANGING_DIMENSIONS\n#define SQL_FETCH_FIELDS \nopen FSharp.Data\n\n[<Literal>]\nlet ConnectionString = @\"Data Source=ARStagingDB.HouTx.lcl;Initial Catalog=ARDatamart;UID=cipherbsc;PWD=123456\"\nlet columns = \n    lazy\n        use cmd = new SqlCommandProvider<\"\nWITH Columns as (\n    SELECT DISTINCT \n           ColumnName = ISNULL(UPPER(COLUMN_NAME), 'Nil')\n         , DataType   = ISNULL(DATA_TYPE + ISNULL('(' + CONVERT(VARCHAR(20), CHARACTER_MAXIMUM_LENGTH) + ')', ''), '')\n         , NULLABLE = IIF(ISNULL(IS_NULLABLE, '') = 'NO', 0, 1)\n         , NRec = ROW_NUMBER() OVER (PARTITION BY COLUMN_NAME ORDER BY TABLE_NAME)\n    FROM INFORMATION_SCHEMA.COLUMNS\n    WHERE TABLE_NAME  LIKE 'DIM_%'\n       OR TABLE_NAME = 'FG_FIN_TRANS'\n)\nSELECT ColumnName, DataType, NULLABLE  \nFROM Columns WHERE NRec = 1\n\" , ConnectionString, ResultType = ResultType.Tuples>(ConnectionString)\n        cmd.Execute()\n\nlet defaults =\n    lazy\n        use cmd = new SqlCommandProvider<\"SELECT TOP 1 * FROM ARStaging.EMS_MSB.VW_FG_FIN_TRANS\" , ConnectionString, ResultType = ResultType.DataReader>(ConnectionString)\n        use rdr = cmd.Execute()\n        if rdr.Read() |> not then [||] else\n        [|\n            for i = 0 to rdr.FieldCount - 1 do\n                if rdr.IsDBNull i |> not then\n                    yield rdr.GetName i, rdr.GetValue i \n                                         |> sprintf \"%A\" \n                                         |> fun s -> if s.StartsWith \"\\\"\" \n                                                     then s.[1..s.Length-2] |> sprintf \"'%s'\" \n                                                     else s\n        |]\n\n\nlet writeFieldDecl () =\n    columns.Value\n    |> Seq.map (sprintf \"%A\") \n    |> String.concat \"\\n    \" \n    |> sprintf \"let fieldDecl = [|\\n    %s \\n|]\"\n    |> fun txt -> System.IO.File.WriteAllText(\"FieldDecl.fsx\", txt)\n\nlet writeFieldDefault_Source () =\n    defaults.Value\n    |> Seq.sortBy snd\n    |> Seq.map (sprintf \"%A\") \n    |> String.concat \"\\n    \" \n    |> sprintf \"let fieldDefault = [|\\n    %s \\n|]\"\n    |> fun txt -> System.IO.File.WriteAllText(\"FieldDefault source.fsx\", txt)\n\n[<Literal>]\nlet columnsQuery = \"\nWITH Columns as (\n    SELECT DISTINCT \n\t\t   TableName  = ISNULL(UPPER(TABLE_NAME), 'Nil')\n         , ColumnName = ISNULL(UPPER(COLUMN_NAME), 'Nil')\n         , DataType   = ISNULL(DATA_TYPE + ISNULL('(' + CONVERT(VARCHAR(20), CHARACTER_MAXIMUM_LENGTH) + ')', ''), '')\n         , NULLABLE = IIF(ISNULL(IS_NULLABLE, '') = 'NO', 0, 1)\n         , NRec = ROW_NUMBER() OVER (PARTITION BY COLUMN_NAME ORDER BY TABLE_NAME)\n    FROM INFORMATION_SCHEMA.COLUMNS\n    WHERE TABLE_NAME  LIKE 'DIM_%'\n       OR TABLE_NAME = 'FG_FIN_TRANS'\n)\nSELECT DISTINCT \n       TableName\n     , ColumnName\n  FROM Columns\n WHERE CHARINDEX('|' + TableName + '|', @tables) > 0\nORDER BY 1, 2   \n   \"\n\ntype Dimension with\n    member this.allColumns() =\n        use cmd = new SqlCommandProvider<columnsQuery , ConnectionString, ResultType = ResultType.Tuples>(ConnectionString)\n        cmd.Execute(this.Snowflakes |> String.concat \"|\" |> sprintf \"|%s|%s|\" this.TableBase.sqlObject)\n    member this.superView() =\n        if this.Snowflakes |> Seq.isEmpty then \"\" else\n        let columns    = this.allColumns()\n        let first      = this.TableBase.sqlObject\n        let snowflakes = this.Snowflakes |> Seq.sort\n        let flags      = snowflakes |> Seq.map (sprintf \"        FLAG_%s = 0\")\n        let from  = \n            snowflakes\n            |> Seq.map (fun j -> sprintf \"LEFT JOIN %s ON %s.%s = %s.%s\" j j this.SurrogateKey first this.SurrogateKey)\n            |> String.concat \"\\n\"\n            |> sprintf \"  FROM %s \\n%s\" first\n        let fieldList f fields = fields |> Seq.map f |> String.concat \",\\n\"\n        let view =\n            columns\n            |> Seq.distinctBy (fun (tb, cl) -> cl)\n            |> fieldList (fun (tb, cl) -> sprintf \"        %s.%s\" (nameS tb) (nameS cl))\n            |> sprintf \"%s,\\n%s\" (flags |> String.concat \",\\n\")\n            |> sprintf \"SELECT \\n%s\\n%s\" <| from\n            |> sprintf \"%sAS\\n%s;\\nGO\" (sqlDropCreate VIEW (sprintf \"GENERIC.%s\" this.TableName))\n        let fields table = columns |> Seq.filter (fst >> ((=) table))\n        let snowflakeCond table = \n            if table = first then \"\" else \n            sprintf \"IF (SELECT TOP 1 FLAG_%s FROM INSERTED) = 1 \\n\" table\n        let createTrigger command codes =\n            codes\n            |> String.concat \";\\n\"\n            |> sprintf \"  ON GENERIC.SV_%s\\nINSTEAD OF %s AS\\nBEGIN\\n%s\\nEND;\\nGO\" first command\n            |> sprintf \"%s\\n%s\" (sqlDropCreate TRIGGER (sprintf \"GENERIC.TR_%s_%s\" command first))\n        let insertTable table =\n            fields table\n            |> fieldList (fun (tb, cl) -> sprintf \"        %s\" (nameS cl))\n            |> (fun flds -> \n                sprintf \"%s  INSERT INTO %s (%s)\\n  SELECT %s \\n  FROM inserted\"\n                  (snowflakeCond table) table flds flds      \n               )\n        let updateTable table =\n            fields table\n            |> fieldList (fun (tb, cl) -> sprintf \"    %s = inserted.%s\" (nameS cl) (nameS cl))\n            |> sprintf \"%s  UPDATE T SET\\n%s\\n  FROM %s T, inserted  \\n  WHERE T.%s = inserted.%s;\"\n                 (snowflakeCond table)\n                 <| table <| this.SurrogateKey <| this.SurrogateKey \n        let tables = Seq.append [first] snowflakes\n        let insert = tables |> Seq.map insertTable |> createTrigger \"INSERT\"\n        let update = tables |> Seq.map updateTable |> createTrigger \"UPDATE\"\n        view + insert + update\n\nlet snowflakeFields (dim: Dimension) =\n    if dim.Snowflakes |> Seq.isEmpty then \"\" else\n    use cmd = new SqlCommandProvider<columnsQuery , ConnectionString, ResultType = ResultType.Tuples>(ConnectionString)\n    let columns = \n        cmd.Execute(dim.Snowflakes |> Seq.sort |> String.concat \"|\" |> sprintf \"|%s|%s|\" dim.TableName)\n        |> Seq.distinctBy (fun (tb, cl) -> cl)\n\n    dim.Snowflakes\n    |> Seq.collect\n         (fun t ->\n            Seq.append\n                [ sprintf \"FLAG_%s\" t ]\n                (columns |> Seq.filter(fun (tb, fl) -> tb = t) |> Seq.map snd)\n         )\n    |> String.concat \"\\n\"\n\nlet snowflakeMissingFields (dim: Dimension) =\n    dim.allColumns()\n    |> Seq.filter(fun (tb, fn) -> \n        (finTransViewFieldNames |> Seq.contains fn |> not)\n     && (targetFieldNames       |> Seq.contains fn |> not)\n    )\n\nlet wrongFields (dim: Dimension) =\n    dim.AllFields\n    |> Seq.filter (fun n -> dim.allColumns() |> Seq.exists (fun (tb, cl) -> cl = n) |> not)\n\n#endif\n\n(*          \nopen SlowlyChangingDimensions\nprint <| dimItem      .superView()\nprint <| dimIncdt     .superView()\nprint <| dimReceivable.superView()\n\ndo writeFieldDecl()\ndo writeFieldDefault_Source()\n\nprint <| snowflakeFields dimIncdt      \nprint <| snowflakeFields dimItem       \nprint <| snowflakeFields dimReceivable \n\ndimReceivable.allColumns()            |> Seq.toList |> printfn \"%A\" \nsnowflakeMissingFields dimItem        |> Seq.iter     (printfn \"%A\")  \nsnowflakeMissingFields dimIncdt       |> Seq.iter     (printfn \"%A\")  \nsnowflakeMissingFields dimReceivable  |> Seq.iter     (printfn \"%A\")  \nwrongFields dimItem        |> Seq.iter     (printfn \"%A\")  \nwrongFields dimIncdt       |> Seq.iter     (printfn \"%A\")  \nwrongFields dimReceivable  |> Seq.iter     (printfn \"%A\")  \nwrongFields dimCust        |> Seq.iter     (printfn \"%A\")\nwrongFields dimCarrier     |> Seq.iter     (printfn \"%A\")\nwrongFields dimProcedure   |> Seq.iter     (printfn \"%A\")\nwrongFields dimCollPerson  |> Seq.iter     (printfn \"%A\")\nwrongFields dimEmp         |> Seq.iter     (printfn \"%A\")\nwrongFields dimCohOrg      |> Seq.iter     (printfn \"%A\")\nwrongFields dimFinTransType|> Seq.iter     (printfn \"%A\")\n*)\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"id":{"$":0,"Item":"db8ed4d6-4bee-407f-958e-250016275444"},"expanded":true,"level":0,"properties":{}},{"name":"Copy Views and Procedures","content":"#if SLOWLY_CHANGING_DIMENSIONS\n\nlet bAllViews = \"Copy ALL views\", fun _ -> AllFactViews  |> Seq.map (fun st -> st.Query    ) |> String.concat \"\\n\\n\"          |> Useful.sCopy  \nlet bAllDims  = \"Copy ALL dims\" , fun _ -> AllDimensions |> Seq.map (fun dm -> dm.Procedure) |> String.concat \"\\n\\n\"          |> Useful.sCopy  \nlet bViews    = AllFactViews  |> Seq.map    (fun st -> st.ViewName      |> sprintf \"Copy %s\", (fun _ -> st.Query       |> Useful.sCopy )) |> Seq.toList\nlet bDims     = AllDimensions |> Seq.map    (fun dm -> dm.ProcedureName |> sprintf \"Copy %s\", (fun _ -> dm.Procedure   |> Useful.sCopy )) |> Seq.toList\nlet bfact     = AllFactTables |> Seq.map    (fun ft -> ft.ProcedureName |> sprintf \"Copy %s\", (fun _ -> ft.Procedure   |> Useful.sCopy )) |> Seq.toList\n#if SQL_FETCH_FIELDS\nlet bSuperVw  = AllDimensions |> Seq.filter (fun dm -> dm.Snowflakes |> Seq.isEmpty |> not) \n                              |> Seq.map    (fun dm -> dm.TableName  |> sprintf \"Copy %s SuperView\", (fun _ -> dm.superView() |> Useful.sCopy )) |> Seq.toList\n#endif                              \n\n[\n  if not bViews.IsEmpty then\n      yield ( \"===== For ARStaging Database ======\", fun _ -> \"---------------------\"  )\n  if bViews.Length > 1 then yield bAllViews\n  yield! bViews\n  if not AllDimensions.IsEmpty then\n      yield ( \"===== For ARDatamart Database =====\", fun _ -> \"---------------------\"  )\n  if bDims.Length  > 1 then yield bAllDims\n  yield! bDims\n  if not AllFactTables.IsEmpty then \n      yield ( \"------ Fact Tables -------\"         , fun _ -> \"---------------------\"  )\n      yield! bfact\n#if SQL_FETCH_FIELDS\n  if not bSuperVw.IsEmpty then\n      yield ( \"------ Super Views -------\"         , fun _ -> \"---------------------\"  )\n  yield! bSuperVw\n#endif                              \n]\n#else\n[]\n#endif\n|> (fun l -> if l.IsEmpty then [ \"=== Select in F# some Views and/or Dimensions ===\", fun _ -> \"Nothing selected\" ]  else l)\n|> Useful.ActionBar\n\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[{"$":0,"Item":"a8351a4c-1fdb-4f57-8fca-8fed60008c36"},{"$":0,"Item":"04f28553-8359-4ba0-9281-bc45839b844f"},{"$":0,"Item":"28e52d96-1900-4150-a99d-6f5ed15bd1df"},{"$":0,"Item":"3b47f651-d4ef-41db-90f3-ad67d1a4b6eb"},{"$":0,"Item":"96efc394-df97-4995-9643-b15f9475e16c"},{"$":0,"Item":"72108083-b588-4246-9978-6fff21e46351"},{"$":0,"Item":"e193a2d8-54ab-4b99-a5cf-a6084db9fffb"},{"$":0,"Item":"7e3c7382-100e-4212-b9be-02cd9f1cb2db"},{"$":0,"Item":"ca42551e-1781-4b7f-ba28-609caafa658c"},{"$":0,"Item":"81c54ba2-389b-4333-8e02-42004320dde0"},{"$":0,"Item":"80a1bb44-c482-4a00-bf8a-63832322bad9"},{"$":0,"Item":"79ff8549-d6f4-47cf-b0c0-efc9eaa6e813"},{"$":0,"Item":"d2205189-f6a8-4e24-81b2-5b485d18f424"},{"$":0,"Item":"16f618b6-0483-44dc-9c54-550f4f5b725d"}],"id":{"$":0,"Item":"daa2fd06-2419-40bf-a9af-7f9863420fa5"},"expanded":true,"level":0,"properties":{}},{"name":"FSAutoCompleteIntermediary","content":"module FSAutoCompleteIntermediary =\n","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"b6577554-e62e-41ed-983e-d4dd12e3512f"},"expanded":false,"level":0,"properties":{}},{"name":"FSAutocompleteCall","content":"#r @\"..\\packages\\FSharp.Data\\lib\\net40\\FSharp.Data.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net40\\FSharp.Data.DesignTime.dll\"\n#r @\"..\\packages\\NewtonSoft.JSon\\lib\\net45\\NewtonSoft.JSon.dll\"\n\nopen System.Net\nopen System.Text\nopen System.IO\nopen FSharp.Data\nopen FSharp.Data.JsonExtensions\nopen Useful\nopen Useful.Result\nopen Newtonsoft.Json\n\nopen Utils\n\n#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule CommTypes =\n    type ResponseError =\n        {\n          Code: int\n          Message: string\n          //AdditionalData: 'T\n        }\n    type Location =\n      {\n        File: string\n        Line: int\n        Column: int\n      }\n    type CompletionResponse =\n      {\n        Name: string\n        ReplacementText: string\n        Glyph: string\n        GlyphChar: string\n      }\n    //type ProjectResponse =\n    //  {\n    //    Project: ProjectFilePath\n    //    Files: List<SourceFilePath>\n    //    Output: string\n    //    References: List<ProjectFilePath>\n    //    Logs: Map<string, string>\n    //  }\n    type OverloadDescription =\n      {\n        Signature: string\n        Comment: string\n      }\n    type OverloadParameter =\n      {\n        Name : string\n        CanonicalTypeTextForSorting : string\n        Display : string\n        Description : string\n      }\n    type Overload =\n      {\n        Tip : OverloadDescription list list\n        TypeText : string\n        Parameters : OverloadParameter list\n        IsStaticArguments : bool\n      }\n    type Parameter = {\n        Name : string\n        Type : string\n      }\n    type SignatureData = {\n        OutputType : string\n        Parameters : Parameter list list\n      }\n    type MethodResponse =\n      {\n        Name : string\n        CurrentParameter : int\n        Overloads : Overload list\n      }\n    type SymbolUseRange =\n      {\n        FileName: string\n        StartLine: int\n        StartColumn: int\n        EndLine: int\n        EndColumn: int\n        IsFromDefinition: bool\n        IsFromAttribute : bool\n        IsFromComputationExpression : bool\n        IsFromDispatchSlotImplementation : bool\n        IsFromPattern : bool\n        IsFromType : bool\n      }\n    type SymbolUseResponse =\n      {\n        Name: string\n        Uses: SymbolUseRange list\n      }\n    type HelpTextResponse =\n      {\n        Name: string\n        Overloads: OverloadDescription list list\n      }\n    type CompilerLocationResponse =\n      {\n        Fsc: string\n        Fsi: string\n        MSBuild: string\n      }\n    type FSharpErrorInfo =\n      {\n        FileName: string\n        StartLine:int\n        EndLine:int\n        StartColumn:int\n        EndColumn:int\n       // Severity:FSharpErrorSeverity\n        Message:string\n        Subcategory:string\n      }\n    type ErrorResponse =\n      {\n        File: string\n        Errors: FSharpErrorInfo []\n      }\n    type Colorization =\n      {\n    //    Range: Range\n        Kind: string\n      }\n    type Declaration =\n      {\n        UniqueName: string\n        Name: string\n        Glyph: string\n        GlyphChar: string\n        IsTopLevel: bool\n    //  Range     : Utils.Range\n    //    BodyRange : Utils.Range\n        File : string\n        EnclosingEntity: string\n        IsAbstract: bool\n      }\n    type DeclarationResponse = {\n        Declaration : Declaration;\n        Nested : Declaration []\n    }\n    type OpenNamespace = {\n      Namespace : string\n      Name : string\n      Type : string\n      Line : int\n      Column : int\n      MultipleNames : bool\n    }\n    type QualifySymbol = {\n      Name : string\n      Qualifier : string\n    }\n    type ResolveNamespaceResponse = {\n      Opens : OpenNamespace []\n      Qualifies: QualifySymbol []\n      Word : string\n    }\n    type UnionCaseResponse = {\n      Text : string\n    //  Position : Pos\n    }\n    type Kind = \n    | KInfo             of string\n    | KError            of ResponseError\n    | KHelpText         of HelpTextResponse\n    | KCompletion       of CompletionResponse  []\n    | KSymbolUse        of SymbolUseResponse\n    | KHelp             of string\n    | KMethod           of MethodResponse\n    | KErrors           of ErrorResponse\n    | KColorizations    of Colorization list\n    | KFindDecl         of Location\n    | KDeclarations     of DeclarationResponse []\n    | KToolTip          of OverloadDescription [][]\n    | KTypeSig          of string\n    | KSignatureData    of SignatureData\n    | KCompilerLocation of CompilerLocationResponse\n    | KNamespaces       of ResolveNamespaceResponse\n    | KUnionCase        of UnionCaseResponse\n    | KMultiple         of Kind                []\n    \n    type ACMessage =\n    | ACMIdentification\n    | ACMEcho             of string\n    | ACMToolTip          of string * int * int\n    | ACMToolTip2         of string * int * int *  string\n    | ACMSignature        of string * int * int\n    | ACMSignature2       of string * int * int *  string\n    | ACMFindDeclaration  of string * int * int\n    | ACMFindDeclaration2 of string * int * int *  string\n    | ACMComplete         of string * int * int *  string\n    | ACMComplete2        of string * int * int *  string *  string\n    | ACMParse            of string * string    * (string * (int * int * int)) []\n    | ACMMustParse        of string * string\n\nopen CommTypes\n\ntype ParseRequest         = { FileName  : string ; IsAsync    : bool   ; Lines : string[]           ; Version : int                                            }\ntype DeclarationsRequest  = { FileName  : string ;                       Lines : string[]           ; Version : int                                            }\ntype CompletionRequest    = { FileName  : string ; SourceLine : string ; Line  : int                ; Column  : int ; Filter : string; IncludeKeywords : bool  }\ntype PositionRequest      = { FileName  : string ;                       Line  : int                ; Column  : int ; Filter : string                          }\ntype ProjectRequest       = { FileName  : string                                                                                                               }\ntype LintRequest          = { FileName  : string                                                                                                               }\ntype HelptextRequest      = { Symbol    : string                                                                                                               }\ntype WorkspacePeekRequest = { Directory : string ; Deep       : int    ; ExcludedDirs : string []                                                              }\n\ntype FARequest =\n    | FarParse         of ParseRequest         \n    | FarDeclarations  of DeclarationsRequest  \n    | FarCompletion    of CompletionRequest    \n    | FarPosition      of PositionRequest      \n    | FarProject       of ProjectRequest       \n    | FarLint          of LintRequest          \n    | FarHelptext      of HelptextRequest      \n    | FarWorkspacePeek of WorkspacePeekRequest    \nwith\n  member this.Json =\n    match this with \n    | FarParse         data -> JsonConvert.SerializeObject data \n    | FarDeclarations  data -> JsonConvert.SerializeObject data \n    | FarCompletion    data -> JsonConvert.SerializeObject data \n    | FarPosition      data -> JsonConvert.SerializeObject data \n    | FarProject       data -> JsonConvert.SerializeObject data \n    | FarLint          data -> JsonConvert.SerializeObject data \n    | FarHelptext      data -> JsonConvert.SerializeObject data \n    | FarWorkspacePeek data -> JsonConvert.SerializeObject data    \n\nlet fromJson<'a> json = JsonConvert.DeserializeObject(json, typeof<'a>) :?> 'a\nlet jsonData2Obj item = item?Data.ToString() |> fromJson\n\nlet UrlAddress = \"http://localhost:9001/\"\n\nlet HttpRequestCall (url:string) (data:string) =\n    async {\n        //printfn \"RpcCall %s\" (extract 100 data)\n        let req = WebRequest.Create(url) :?> HttpWebRequest \n        req.Timeout         <- 300_000\n        req.ProtocolVersion <- HttpVersion.Version10\n        req.Method          <- \"POST\"\n        req.ContentType     <- \"application/json\"\n        let postBytes = Encoding.ASCII.GetBytes(data)\n        //printfn \"<---\\n%s\\n\" data\n        req.ContentLength <- int64 postBytes.Length\n        let reqStream = req.GetRequestStream() \n        reqStream.Write(postBytes, 0, postBytes.Length);\n        reqStream.Close()\n        \n        // Obtain response and download the resulting page \n        // (The sample contains the first & last name from POST data)\n        use resp   = req.GetResponse() \n        use stream = resp.GetResponseStream() \n        use reader = new StreamReader(stream)\n        let msg    = reader.ReadToEnd()\n        printfn \"\\n----> \\n%s\\n\" (extract 100 msg)\n        let jsonV  = JsonValue.Parse msg\n        return       jsonV\n    }\n\nlet KindError msg = KError { Code = 0 ; Message = msg }\n\nlet json2Kind (v:JsonValue) = \n    let item =JsonValue.Parse <| v.AsString()\n    match item?Kind.AsString() with\n    | \"info\"             -> jsonData2Obj item |> KInfo\n    | \"error\"            -> jsonData2Obj item |> KError\n    | \"errors\"           -> jsonData2Obj item |> KErrors\n    | \"tooltip\"          -> jsonData2Obj item |> KToolTip\n    | \"typesig\"          -> jsonData2Obj item |> KTypeSig\n    | \"completion\"       -> jsonData2Obj item |> KCompletion\n    | \"signatureData\"    -> jsonData2Obj item |> KSignatureData\n    | \"finddecl\"         -> jsonData2Obj item |> KFindDecl\n    | \"compilerlocation\" -> jsonData2Obj item |> KCompilerLocation\n    | _                  -> KindError <| v.ToString()\n\nlet FSAutocompleteCall cmd f (req: FARequest) =\n    Wrap.wrapper {\n        let  data         = req.Json\n        let! jsonV        = HttpRequestCall (UrlAddress + cmd) data\n        let  several      = jsonV.AsArray() |> Array.map json2Kind\n        let  good, others = several |> Array.partition f\n        let  msgs         = others  |> Seq.map (fun v -> (v.ToString(), match v with | KInfo _ -> true | _ -> false) |> ErrSimple :> ErrMsg) |> Seq.toList\n        let! result       = Result (Seq.tryHead good, msgs) \n        return result\n    } \n\nlet parseCode file code =\n    Wrap.wrapper {\n        let!  result = FSAutocompleteCall \"parse\" (function | KErrors _ -> true | _ -> false) <|\n                             FarParse\n                                 { FileName   = System.IO.Path.GetFullPath file\n                                   IsAsync    = false   \n                                   Lines      = code           \n                                   Version    = 0\n                                 }\n        return result\n    } \n\nlet toolTip file lin col filter =\n    Wrap.wrapper {\n        let!  result = FSAutocompleteCall \"tooltip\" (function | KToolTip _ -> true | _ -> false) <|\n                             FarPosition\n                                 { FileName   = System.IO.Path.GetFullPath file\n                                   Line       = lin         \n                                   Column     = col\n                                   Filter     = filter\n                                 }\n        return result\n    } \n\nlet signature file lin col filter =\n    Wrap.wrapper {\n        let!  result = FSAutocompleteCall \"signatureData\" (function | KSignatureData _ -> true | _ -> false) <|\n                             FarPosition\n                                 { FileName   = System.IO.Path.GetFullPath file\n                                   Line       = lin         \n                                   Column     = col\n                                   Filter     = filter\n                                 }\n        return result\n    } \n\nlet completion file lin col lineText filter =\n    Wrap.wrapper {\n        let!  result = FSAutocompleteCall \"completion\" (function | KCompletion _ -> true | _ -> false) <|\n                             FarCompletion\n                                 { FileName        = System.IO.Path.GetFullPath file\n                                   Line            = lin         \n                                   Column          = col\n                                   Filter          = filter\n                                   SourceLine      = lineText \n                                   IncludeKeywords = false                                     \n                                 }\n        return result\n    } \n\ntype FsAutoCompleteErr =\n    | ``Code has not been parsed, use Parse F#``\n    | ``This snippet has not been previosuly parsed, use Parse F#``\n    | ``Cached typecheck results not yet available``\n    | ``Error FileCheckerOptions`` of string\nwith interface ErrMsg with\n        member this.ErrMsg    = match this with | msg -> sprintf \"%A\" msg\n        member this.IsWarning = false    \n        \n/// this converts from Result to Rop.Result\nlet fromResult' f = \n    function \n    | Failure s  -> Result.fail <| f s\n    | Success v  -> Result.succeed v\n\ntype Responder2() =\n    //let commands = Commands()\n    let starts : Map<string, Map<string, int * int * int>> ref = ref Map.empty\n    \n    let getDelta fname snpIdO =\n        Wrap.wrapper {\n            do!  Result.tryProtection()\n            let  file = System.IO.Path.GetFullPath fname\n            match snpIdO with\n            | Some snpId -> let! fileMap          = (!starts) |> Map.tryFind file         |> Result.fromOption ``Code has not been parsed, use Parse F#``\n                            let! ind, first, last = fileMap   |> Map.tryFind snpIdO.Value |> Result.fromOption ``This snippet has not been previosuly parsed, use Parse F#``\n                            return file, first, ind\n            | None       -> return file, 0    , 0 \n        }\n    let getDeltaBack fname line =\n        Wrap.wrapper {\n            do!  Result.tryProtection()\n            let  file             = System.IO.Path.GetFullPath fname\n            let! fileMap          = (!starts) |> Map.tryFind file |> Result.fromOption ``Code has not been parsed, use Parse F#``\n            let! snp, first, ind  = fileMap \n                                    |> Seq.map     (fun kv -> kv.Key, kv.Value) \n                                    |> Seq.tryPick (fun (snp, (ind, first, last)) -> if line >= first && line < last then Some (snp, first, ind) else None) \n                                    |> Result.fromOption ``This snippet has not been previosuly parsed, use Parse F#``\n            return snp, first, ind                        \n        }\n    let mustParse fname snpId =\n        getDelta fname (Some snpId)\n        |> Wrap.map              (fun _ -> false)\n        |> Wrap.RunSynchronously \n        |> Result.withError      (fun _ -> true )\n\n    let findDeclaration file lin col filter =\n        Wrap.wrapper {\n            let!  result = FSAutocompleteCall \"finddeclaration\" (function | KFindDecl _ -> true | _ -> false) <|\n                                 FarPosition\n                                     { FileName   = System.IO.Path.GetFullPath file\n                                       Line       = lin         \n                                       Column     = col\n                                       Filter     = filter\n                                     }\n            match result with\n            | KFindDecl decl -> let! snp, dln, dcol = getDeltaBack decl.File decl.Line\n                                let resultAdj = \n                                 {  File    = snp\n                                    Line    = decl.Line   - dln\n                                    Column  = decl.Column - dcol\n                                 } |> KFindDecl\n                                return resultAdj\n            | _              -> return result\n        } \n\n    let getPosition (getKind: string -> int -> int -> string -> Wrap<Kind>) fname ln col (snpIdO:string option) =\n        Wrap.wrapper {\n            let! file, dln, dcol = getDelta fname snpIdO\n            let! res             = getKind fname (ln + dln) (col + dcol) \"\"\n            return res\n        } \n        |> Wrap.RunSynchronously\n        |> Result.withError (Result.getMessages >> KindError)\n\n    let getCompletion fname ln col lineText (snpIdO:string option) =\n        Wrap.wrapper {\n            let! file, dln, dcol = getDelta fname snpIdO\n            let! res             = completion fname (ln + dln) (col + dcol) ((String.replicate dcol \" \") + lineText) \"Contains\"\n            return res\n        } \n        |> Wrap.RunSynchronously\n        |> Result.withError (Result.getMessages >> KindError)\n        \n    member this.Respond (msg:ACMessage) =\n        match msg with\n        | ACMIdentification              -> KInfo \"FSAutoCompleteIntermedirary\"\n        | ACMEcho   txt                  -> KInfo txt \n        | ACMMustParse(fname, snpId    ) -> mustParse fname snpId |> sprintf \"%b\" |> KInfo\n        | ACMParse    (fname, code, sts) ->\n            async {\n                let  file = System.IO.Path.GetFullPath (fname)\n                do   starts := !starts |> Map.add file (Map sts)\n                //printfn \"\\n%A\\n\" sts\n                let! errors = parseCode file (code.Split '\\n') |> Wrap.getAsync\n                let  fixedErrors =\n                    match errors with\n                    | KErrors ers -> \n                          KErrors { ers with \n                                      Errors = ers.Errors \n                                        |> Array.map (fun err ->\n                                          sts \n                                          |> Array.tryFind (fun (snpNm, (ind, first, last)) -> err.StartLine >= first && err.StartLine < last)\n                                          |> Option.map    (fun (snpNm, (ind, first, last)) -> \n                                              { err with FileName    = snpNm\n                                                         StartLine   = err.StartLine   - first\n                                                         EndLine     = err.EndLine     - first\n                                                         StartColumn = err.StartColumn - ind\n                                                         EndColumn   = err.EndColumn   - ind   }) \n                                          |> Option.defaultValue err)\n                                  } \n                    | _ -> errors\n                return fixedErrors \n            }\n            |> Async.RunSynchronously\n        | ACMToolTip         (fname, ln, col)             -> getPosition   toolTip         fname ln col None\n        | ACMToolTip2        (fname, ln, col,      snpId) -> getPosition   toolTip         fname ln col (Some snpId)\n        | ACMSignature       (fname, ln, col)             -> getPosition   signature       fname ln col None\n        | ACMSignature2      (fname, ln, col,      snpId) -> getPosition   signature       fname ln col (Some snpId)\n        | ACMFindDeclaration (fname, ln, col)             -> getPosition   findDeclaration fname ln col None\n        | ACMFindDeclaration2(fname, ln, col,      snpId) -> getPosition   findDeclaration fname ln col (Some snpId)\n        | ACMComplete        (fname, ln, col, txt)        -> getCompletion                 fname ln col txt None\n        | ACMComplete2       (fname, ln, col, txt, snpId) -> getCompletion                 fname ln col txt (Some snpId)\n\n","parent":{"$":0,"Item":"b6577554-e62e-41ed-983e-d4dd12e3512f"},"predecessors":[{"$":0,"Item":"7a655466-e218-4121-a7b6-f9c70a922e07"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"319e0842-b83e-4036-9f57-602ca4a30ac5"},"expanded":true,"level":0,"properties":{}},{"name":"FSAutoCompleteIntermediaryClient","content":"open Useful\nopen FsStationShared\nopen WebSharper\nopen WebSharper.Remoting\n\n#if FSS_SERVER\n\nlet responder = Responder2()\n\n[< Rpc >]\nlet sendMessageRpc msg = async { return responder.Respond msg }\n\n[< JavaScript >]\nlet sendMessage  (msg:ACMessage) : Async<Kind> = \n    async {\n        let!   res = sendMessageRpc (msg |> box |> unbox)\n        return res                       |> box |> unbox\n    }\n#endif\n\n#if WEBSHARPER\n[< JavaScript >]\n#endif\ntype FSAutoCompleteIntermediaryClient(clientId, ?endPoint:string) =\n     #if FSS_SERVER\n     #else\n     let msgClient = MessagingClient(clientId, ?endPoint = endPoint)\n     let toId      = AddressId \"FSAutoComplete\"\n     let sendMessage (msg:ACMessage) =\n         Wrap.wrapper {\n             let! resp = msgClient.SendMessage toId (Json.Serialize msg)\n             let  acr  = resp |> Json.Deserialize<CommandResponse.Kind>\n             return acr\n         } |> Wrap.getAsyncWithDefault (Result.getMessages >> CommandResponse.KError)\n     #endif\n     let Async_map f aa = \n         async { \n             let! a = aa\n             return f a\n         }\n     let rec comp2Strings comp =\n         match comp with \n         | KCompletion cs -> cs |> Array.map (fun cs -> cs.Name, cs.ReplacementText, cs.Glyph, cs.GlyphChar)\n         | KHelpText   _  -> [||]\n         | KMultiple   ks -> ks |> Array.collect comp2Strings \n         | m              -> [| sprintf \"%A\" m, \"\", \"ErrorMsg\", \"E\" |] \n     let tip2String tip =\n         match tip with \n         | KToolTip ts -> ts |> Seq.collect id |> Seq.collect (fun t -> [ t.Signature ; t.Comment ] ) |> String.concat \"\\n\"\n         | m           -> sprintf \"%A\" m \n     let errors2String errs =\n         match errs with \n         | KErrors  es -> \n             es.Errors \n             |> Seq.map (fun er -> sprintf \"ErrFSharp \\\"F# %s.fsx (%d,%d) - (%d,%d) %s:%s\\\"\" \n                                      er.FileName er.StartLine er.StartColumn er.EndLine er.EndColumn er.Subcategory er.Message) \n             |> String.concat \"\\n\"\n         | m           -> sprintf \"%A\" m \n     let info2Bool inf =\n         match inf with\n         | KInfo \"true\" -> true\n         | _            -> false\n        \n   with\n     member this.MustParse(fname,                 sId) = sendMessage (ACMMustParse       (fname,                  sId)) |> Async_map info2Bool\n     member this.Parse    (fname, txt , sts          ) = sendMessage (ACMParse           (fname, txt , sts           )) |> Async_map errors2String\n     member this.Parse    (fname, txt                ) = sendMessage (ACMParse           (fname, txt , [||]          )) |> Async_map errors2String\n     member this.ToolTip  (fname, line, col          ) = sendMessage (ACMToolTip         (fname, line, col           )) |> Async_map tip2String\n     member this.ToolTip  (fname, line, col,      sId) = sendMessage (ACMToolTip2        (fname, line, col ,      sId)) |> Async_map tip2String\n     member this.Complete (fname, txt, line, col     ) = sendMessage (ACMComplete        (fname, line, col , txt     )) |> Async_map comp2Strings\n     member this.Complete (fname, txt, line, col, sId) = sendMessage (ACMComplete2       (fname, line, col , txt, sId)) |> Async_map comp2Strings\n     member this.FindDecl (fname, line, col          ) = sendMessage (ACMFindDeclaration (fname, line, col           )) |> Async_map id\n     member this.FindDecl (fname, line, col,      sId) = sendMessage (ACMFindDeclaration2(fname, line, col ,      sId)) |> Async_map id\n","parent":{"$":0,"Item":"b6577554-e62e-41ed-983e-d4dd12e3512f"},"predecessors":[{"$":0,"Item":"eb54ba64-3d11-4347-97c8-aeae9e3e3121"},{"$":0,"Item":"319e0842-b83e-4036-9f57-602ca4a30ac5"}],"id":{"$":0,"Item":"466e6783-0751-48d5-b79b-165aaa7d2173"},"expanded":true,"level":0,"properties":{}},{"name":"Snippets","content":"module Snippets =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"expanded":false,"level":0,"properties":{}},{"name":"","content":"let private displayHtml html = \n  let url = Server.instance.Value.AddPage(html)\n  System.Diagnostics.Process.Start(url) |> ignore\n\nfsi.AddPrinter(fun (chart:XPlot.GoogleCharts.GoogleChart) ->\n  let ch = chart |> XPlot.GoogleCharts.Chart.WithSize (800, 600)\n  ch.GetHtml() |> displayHtml\n  \"(Google Chart)\")\n\nfsi.AddPrinter(fun (chart:XPlot.Plotly.PlotlyChart) ->\n  \"\"\"<!DOCTYPE html>\n  <html>\n  <head>\n      <title>Plotly Chart</title>\n      <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script>\n  </head>\n  <body>\"\"\" + chart.GetInlineHtml() + \"</body></html>\" |> displayHtml","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"e620b2e0-e518-4992-86f3-bc9623015345"},"expanded":true,"level":0,"properties":{}},{"name":"Free Monad","content":"(**\nFree Monad - Interpreter pattern in F#\n================================\n\nAn analysis of the Free Monad - Interpreter pattern in F# from a definition\ncreated by erdeszt and based on: http://programmers.stackexchange.com/a/242803/145941\n\nThe DSL\n-------\n\nFirst we define a DSL for our actions. Each action points to the next action using the `'next` generic type, \nevery action has a `'next` that in turn could be a DSL, thus chaining them.\n*)\ntype DSL<'next> =\n    | Set of key: string * value: string *  'next\n    | Get of key: string *       (string -> 'next)\n(** \n* `Get` returns a string which is passed to a function. `id` function can be used to finish the chain.\n* `Set` doesn't return anything, so the `'next` portion is the next DSL element in the chain, or a constant like `()` to finish.\n\nNote that used this way `'next` can be anything. It does not have to be a DSL value, so there is no real implication of a chain of DSLs.\n\nThis is what 3 actions in the DSL may look like.\n*)\nlet ex1 = Set (\"name\", \"John\"\n             , Get (\"name\"\n                  , fun name -> Set (\"greeting\", sprintf \"Hello %s\" name, () )\n                   )\n              )\n(**\n`val ex1 : DSL<DSL<DSL<unit>>> =\n  Set (\"name\",\"John\",Get (\"name\",<fun:ex1@23-4>))`\n\nNotice how the resulting type `DSL<DSL<DSL<unit>>>` is nested and not generic. \nThis means a strongly type function cannot process all posible values.\n\nThe Free Monad\n--------------\n\nHere comes the Free Monad `ChainDSL` to the rescue.\n*)\n\ntype ChainDSL<'a> =\n    | Do     of DSL<ChainDSL<'a>>\n    | Return of 'a\n\n(**\nThe `Do` option creates a chain of `ChainDSL`s that ends with the `Return` option.\nThis chain ends up having a type equal to the last `DSL` in the chain.\nThis is almost like creating a `List` of `DSL`s (`List<DSL<'a>> or DSL<'a> list`), \nexcept that each `DSL` in the chain can be of a different type.\n\nLets look at the same value above with `ChainDSL`:\n*)\n\nlet exF1 = Do (Set (\"name\", \"John\"\n                  , Do (Get (\"name\"\n                           , fun name -> Do (Set (\"greeting\", sprintf \"Hello %s\" name, Return () )) \n                            )\n                       )\n                   )\n              )\n(**\n`val exF1 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:exF1@49-3>))))`\n\nCompare the resulting type with the prior case: `ChainDSL<unit>` vs `DSL<DSL<DSL<unit>>>`.\nNo matter how deep the chain is, the value will always be of type `ChainDSL<unit>` or `ChainDSL<string>`.\n\n\nBut creating the chain is much more complex than before.\nTo solve that, lets create two helper functions: get and set.\n*)\nlet get key       = Do (Get (key, fun value -> Return value))\nlet set key value = Do (Set (key,     value,   Return ()   ))    \n(**\n`val get : key:string -> ChainDSL<string>`\n\n`val set : key:string -> value:string -> ChainDSL<unit>`\n\nNotice `get` returns a `ChainDSL<string>` and `set` returns a `ChainDSL<unit>`.\nThey both return a `ChainDSL` chain with a single `DSL` action.\n\nWith these functions we can create Get & Set operations like this:\n*)\nlet setName     name = set \"name\"     name\nlet getName          = get \"name\"\nlet setGreeting name = set \"greeting\" (sprintf \"Hello %s\" name)\n(**\nbut they are not chained together like before.\n\nBinding it together\n-------------------\n\nTo chain them we will need to define a bind function for the ChainDSL.\nWe start with a map function for DSL, thus making DSL a functor:\n*)\nlet mapDSL: ('a -> 'b) -> DSL<'a> -> DSL<'b> = \n    fun     f             action  ->\n        match action with\n        | Get (key,        fNext) -> Get (key,        fNext >> f)\n        | Set (key, value,  next) -> Set (key, value,  next |> f)\n\n(**\nAll `mapDSL` does is apply the function `f` to the `'next` part of the `DSL`.\nIn other words go to the next node in the chain.\n\nNext we define the bind function for ChainDSL, finally making it a monad:\n*)\nlet bindChain: ('a -> ChainDSL<'b>) -> ChainDSL<'a> -> ChainDSL<'b> =\n    fun        fChain                  chainTo      ->\n        let rec appendTo chain =\n            match chain with\n            | Return a   -> fChain a\n            | Do     dsl -> Do (mapDSL appendTo dsl)\n        appendTo chainTo\n(** \n`bindChain` is similar and acts like the List.append function, it concatenates two chains of `ChainDSL`s. \nThe difference is that the chain to be appended `fChain` is passed within a function.\n`bindChain` navigates recursively down `chainTo` and replaces the last element with the result of `fChain`:\n\n* On the `Do` side `bindChain` calls `mapDSL` to apply the function to the next `ChainDSL` node.\n* On the `Return` side it replaces the 'Return a' for a call to the chain to be appended `fChain`.\n\nIn a sense `ChainDSL` is actually the opposite of a `List<DSL<'a>>`. In a List new elements are\ninserted at the head, here they are attached at the tail end.\n\nNow we can bind setName, getName & setResult from above like this: *)\n\nlet exF2 = setName \"John\" \n           |> bindChain (fun _    -> getName         )\n           |> bindChain (fun name -> setGreeting name)\n\n(** \n`val exF2 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nwhich is the same as this: *)\n\nlet exF3 = set \"name\" \"John\" \n           |> bindChain (fun _ -> get \"name\"                           )\n           |> bindChain (fun v -> set \"greeting\" (sprintf \"Hello %s\" v))\n(** \n`val exF3 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nand this: *)\nlet (>>=) v f = bindChain f v\n\nlet exF4 = set \"name\" \"John\" \n           >>= fun _    -> get \"name\" \n           >>= fun name -> set \"greeting\" (sprintf \"Hello %s\" name)\n(**\n`val exF4 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nUsing Computational Expressions\n-------------------------------\n\nNow lets try it with Computational Expressions.\nFirst we define a builder class.\n*)\n\ntype ChainDSLBuilder () =\n    member this.Return      v = Return v\n    member this.ReturnFrom mv = mv\n    member this.Zero       () = Return ()\n    member this.Bind   (v, f) = v >>= f\n\nlet chainDSL = ChainDSLBuilder ()\n\n(**\nAnd now we use the computational expression like this.\n*)\n\nlet exF5 = chainDSL {\n    do!         set \"name\"     \"John\"\n    let! name = get \"name\"\n    do!         set \"greeting\" (sprintf \"Hello %s\" name)\n}\n(**\n`val exF5 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nThe Interpreter(s)\n------------------\n  \nNow we are going to create an interpreter to execute the AST created.\n\nThis first version is very simple it does not store or retrieve any values, just prints out the commands.\n*)\n(*** define-output:interpreter1 ***)    \nlet rec interpreter1: ChainDSL<'a> -> 'a =\n    fun               chain        ->\n        match chain with\n        | Return v -> printfn \"return %A\" v\n                      v\n        | Do   dsl -> \n            match dsl with\n            | Get(key,        nextF) -> printfn \"Get %s\" key\n                                        nextF (sprintf \"<get.%s>\" key) \n            | Set(key, value, next ) -> printfn \"Set %s '%s'\" key value\n                                        next                           \n            |> interpreter1\n\ninterpreter1 exF5\n(*** include-output:interpreter1 ***)\n(**\nThis next version actually stores and retrieves the values in a `Map` object, and when finished prints its content. \n*)\n(*** define-output:interpreter2 ***)    \nlet interpreter2 chain = \n    let rec interpreter2r: Map<string, string> -> ChainDSL<'a> -> 'a =\n        fun                dataStore              chain        ->\n            match chain with\n            | Return v -> printfn \"return %A\\n%A\" v dataStore\n                          v\n            | Do   dsl -> \n                match dsl with\n                | Get(key,        nextF) -> dataStore \n                                            |> Map.find key \n                                            |> (fun v -> printfn \"Get %s -> '%s'\" key v ; v )\n                                            |> nextF\n                                            |> interpreter2r dataStore\n                | Set(key, value, next ) -> printfn \"Set %s '%s'\" key value\n                                            next\n                                            |> interpreter2r (dataStore |> Map.add key value)\n\n    interpreter2r (Map.ofList []) chain\n\ninterpreter2 exF5\n(*** include-output:interpreter2 ***)\n\n(**\nA slightly longer example:\n*)\n\n(*** define-output:interpreter2b ***)    \n\nchainDSL {\n    do!           set \"first-name\" \"John\"\n    do!           set \"last-name\"  \"Smith\"\n    let! first  = get \"first-name\"\n    let! last   = get \"last-name\"\n    do!           set \"full-name\" (first + \" \"  + last)\n    let! full   = get \"full-name\"\n    return        sprintf \"Hello %s\" full\n}\n|> interpreter2\n(** Output:*)\n(*** include-output:interpreter2b ***)\n(** Return value:*)\n(*** include-it:interpreter2b ***)\n(**\nTrying to replicate this last example without the computational expression \nrequires explicitly nesting some of the calls.\n\nIt would look like this:\n\n*)\n(*** define-output:interpreter2c ***)    \n\nset \"first-name\" \"John\" \n>>= fun _     -> set \"last-name\"  \"Smith\"            \n>>= fun _     -> get \"first-name\"                    \n>>= fun first -> get \"last-name\" \n                 >>= fun last -> set \"full-name\" (first + \" \"  + last)\n>>= fun _     -> get \"full-name\"\n>>= fun full  -> Return (sprintf \"Hello %s\" full)\n|> interpreter2\n(** Output:*)\n(*** include-output:interpreter2c ***)\n(** Return value:*)\n(*** include-it:interpreter2c ***)\n\n(**\nTwo in one\n----------\n\nSo, do we really need two types, the Free Monad and the DSL?\n\nI do not think it is necessary, the free monad helps in binding the elements of the DSL. \nThe same can be achieved just by adding the `Return` option to the DSL.\n\nHere is the same implementation with just the DSL type:\n*)\n\nmodule DSL2 =\n    type DSL<'a> =\n        | Set of key: string * value: string *  DSL<'a>\n        | Get of key: string *       (string -> DSL<'a>)\n        | Return of 'a\n    \n    let set key value = Set (key, value,          Return ())\n    let get key       = Get (key,        fun v -> Return v )\n    \n    let bind: ('a -> DSL<'b>) -> DSL<'a> -> DSL<'b> =\n        fun   fChain             chainTo ->\n           let rec appendTo chain =\n               match chain with\n               | Set (k, v,  next) -> Set (k, v,  next |> appendTo)\n               | Get (k,    fNext) -> Get (k,    fNext >> appendTo)\n               | Return  v         -> fChain v\n           appendTo chainTo\n\n    let (>>=) v f = bind f v\n\n    let interpreter2 dsl =\n        let rec interpreter2r: Map<string, string> -> DSL<'a> -> 'a =\n            fun                dataStore              dslR    ->\n                match dslR with\n                | Return v               -> printfn \"return %A\\n%A\" v dataStore\n                                            v\n                | Get(key,        nextF) -> dataStore \n                                            |> Map.find key \n                                            |> (fun v -> printfn \"Get %s -> '%s'\" key v ; v )\n                                            |> nextF\n                                            |> interpreter2r dataStore\n                | Set(key, value, next ) -> printfn \"Set %s '%s'\" key value\n                                            next\n                                            |> interpreter2r (dataStore |> Map.add key value)\n        interpreter2r (Map.ofList []) dsl\n\n(**\nThere you have it the DSL definition, helper functions, the bind function and the interpreter.\nHere is the last example again.\n*)\n(*** define-output:dsl2 ***)    \n\n    set \"first-name\" \"John\" \n    >>= fun _     -> set \"last-name\"  \"Smith\"            \n    >>= fun _     -> get \"first-name\"                    \n    >>= fun first -> get \"last-name\" \n                     >>= fun last -> set \"full-name\" (first + \" \"  + last)\n    >>= fun _     -> get \"full-name\"\n    >>= fun full  -> Return (sprintf \"Hello %s\" full)\n    |> interpreter2\n(** Output:*)\n(*** include-output:dsl2 ***)\n(** Return value:*)\n(*** include-it:dsl2 ***)    \n(*** hide ***)\ninterpreter2 exF1\ninterpreter2 exF2\ninterpreter2 exF3\ninterpreter2 exF4\ninterpreter2 exF5\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"8ee6b535-3615-4066-8917-9125cf8a1f20"},"expanded":true,"level":0,"properties":{}},{"name":"UNLOAD FSI","content":"#define UNLOAD_FSI\n\n#if WEBSHARPER\n#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Core.JavaScript.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.JavaScript.dll\"\nopen WebSharper\n[< JavaScript >]\n#endif\nlet a = 9 + 8\n\n7 * 3\n|> printfn \"%A\"\n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"1d18fdb5-2488-4ac9-813a-c96a66b9cd13"},"expanded":true,"level":0,"properties":{}},{"name":"Substring, Regex","content":"let extract n (s:string) = s.Substring(0, min n s.Length)\nlet s = \"1234567890123456789012345678901234567890\"\nprintfn \"%s\" <| extract 100 s\n\nopen System\nprintfn \"%s\" <| System.DateTime.UtcNow.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n\nopen UsefulDotNet\n//Example:\nlet phone = \"(555) 555-5555\"\nmatch phone with\n| Regex @\"\\(([0-9]{3})\\)[-. ]?([0-9]{3})[-. ]?([0-9]{4})\" [ area; prefix; suffix ] ->\n    printfn \"Area: %s, Prefix: %s, Suffix: %s\" area prefix suffix\n| _ -> printfn \"Not a phone number\"\n\nlet code = \"let a = \\\"123\\\" |> St\"\nmatch code with\n| Regex @\"([a-zA-Z_]\\w+)$\" [ txt ] -> printfn \"%s\" txt\n| _                                -> printfn \"<No match>\"\n\nlet line = \" hello how \\\"are you\\\" good \\\"and you\\\"\"\nmatch line with \n| Regexs \"(\\\".*?\\\"|\\S+)\" ms -> \n    ms \n    |> Seq.iter\n        (function | Regex \"(\\\"(.*?)\\\")\" [_ ; m] | m -> printfn \"%A\" m)\n//| Regex \"(\\\"([^\\\"]*)\\\"|\\S*)*\" r -> printfn \"%A\" r\n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"7646acbc-2c28-4159-98b1-2365d19fc97c"}],"id":{"$":0,"Item":"5df15cf1-361e-4d57-a565-683ab0b72082"},"expanded":true,"level":0,"properties":{}},{"name":"Stack Overflow","content":"let rec recursive i = 1 + recursive i\nrecursive 1","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"3d704638-8ba4-4bc8-b810-29e023a222fc"},"expanded":true,"level":0,"properties":{}},{"name":"Calculate primes","content":"open System\nopen System.ComponentModel\nopen System.Windows.Forms\n\ntype BackgroundWorker with\n        member this.AsyncRunWorker (computation, argument : 'T, progressChangedHandler) : Async<'U> =\n            let workerAsync =\n                Async.FromContinuations (fun (cont, econt, ccont) ->\n                            let handler = new RunWorkerCompletedEventHandler (fun sender args ->          \n                                if args.Cancelled then\n                                    ccont (new OperationCanceledException()) \n                                elif args.Error <> null then\n                                    econt args.Error\n                                else\n                                    cont (args.Result :?> 'U))\n                            this.WorkerSupportsCancellation <- true;\n                            this.WorkerReportsProgress <- true\n                            this.DoWork.AddHandler(new DoWorkEventHandler(fun sender args ->\n                                args.Result <- computation(argument, this, args)))\n                            this.ProgressChanged.AddHandler(progressChangedHandler)\n                            this.RunWorkerCompleted.AddHandler(handler)\n                            this.RunWorkerAsync(argument)\n                        )\n\n            async { \n                use! holder = Async.OnCancel(fun _ -> this.CancelAsync())\n                return! workerAsync\n             }\n\nlet factorial number =\n    let rec fact number =\n        match number with\n        | value when value < 0I ->\n            raise (InvalidOperationException(sprintf \"Cannot compute the factorial of a negative number: %s.\" (value.ToString())))\n        | value when value > 2000I ->\n            raise (InvalidOperationException(sprintf \"Input too large: %s\" (value.ToString())))\n        | value when value = 0I -> 1I\n        | value when value = 1I -> 1I\n        | number -> number * fact (number - 1I)\n    fact number\n\n// Recursive isprime function.\nlet isprime number =\n    let rec check count =\n        count > number/2 || (number % count <> 0 && check (count + 1))\n    check 2\n\nlet isprimeBigInt number =\n    let rec check count =\n        count > number/2I || (number % count <> 0I && check (count + 1I))\n    check 2I\n\nlet computeNthPrime (number, worker: BackgroundWorker, eventArgs: DoWorkEventArgs) =\n     if (number < 1) then\n         invalidOp <| sprintf \"Invalid input for nth prime: %s.\" (number.ToString())\n     let mutable count = 0\n     let mutable num = 1I\n     let isDone = false\n     while (count < number && not eventArgs.Cancel ) do\n         if (worker.CancellationPending) then\n             eventArgs.Cancel <- true\n         else\n             let percentComplete = int ((float count) / (float number) * 100.0)\n             worker.ReportProgress(percentComplete, num.ToString())\n         num <- num + 1I\n         if (num < bigint System.Int32.MaxValue) then\n             while (not (isprime (int num))) do\n                 num <- num + 1I\n         else\n             while (not (isprimeBigInt num)) do\n                 num <- num + 1I\n         count <- count + 1\n     num\n         \nlet async1 (progressBar:ProgressBar) (label:Label) value =\n     let worker = new BackgroundWorker()\n     label.Text <- \"Computing...\"\n     let computation value = worker.AsyncRunWorker(computeNthPrime, value,\n                                                   (fun sender (eventArgs:ProgressChangedEventArgs) ->\n                                                       label.Text <- \"Scanning ... \" + eventArgs.UserState.ToString()\n                                                       progressBar.Value <- eventArgs.ProgressPercentage ))\n     Async.StartWithContinuations(\n         computation value,\n         (fun result -> label.Text <- sprintf \"Result: %s\" (result.ToString())),\n         (fun exn -> label.Text <- \"Operation failed with error:\" + exn.Message),\n         (fun _ -> label.Text <- \"Operation canceled.\"))\n\n#if INTERACTIVE\nlet main =\n#else\n[< EntryPoint ; STAThread >]\nlet main args =\n#endif\n    Application.EnableVisualStyles()\n    let form = new Form(Text = \"Test Form\", Width = 400, Height = 400)\n    let panel1 = new Panel(Dock = DockStyle.Fill)\n    panel1.DockPadding.All <- 10\n    let spacing = 5\n    let button1 = new Button(Text = \"Start\")\n    let button2 = new Button(Text = \"Start Invalid\", Top = button1.Height + spacing)\n    let button3 = new Button(Text = \"Cancel\", Top = 2 * (button1.Height + spacing))\n    let updown1 = new System.Windows.Forms.NumericUpDown(Top = 3 * (button1.Height + spacing), \n                                                         Value = 20m,\n                                                         Minimum = 0m,\n                                                         Maximum = 1000000m)\n    let label1 = new Label (Text = \"\", Top = 4 * (button1.Height + spacing),\n                            Width = 300, Height = 2 * button1.Height)\n    let progressBar = new ProgressBar(Top = 6 * (button1.Height + spacing),\n                                      Width = 300)\n    panel1.Controls.AddRange [| button1; button2; button3; updown1; label1; progressBar; |]\n    form.Controls.Add(panel1)\n    button1.Click.Add(fun args -> async1 progressBar label1 (int updown1.Value))\n    button2.Click.Add(fun args -> async1 progressBar label1 (int (-updown1.Value)))\n    button3.Click.Add(fun args -> Async.CancelDefaultToken())\n    form.Activated.AddHandler(System.EventHandler (fun _ _ -> form.TopMost <- true(*; form.TopMost <- false*) ))\n#if INTERACTIVE\n    form.ShowDialog() |> ignore\n#else\n    form |> Application.Run\n#endif\n    0\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"bd716e89-0546-4d6b-8964-26473ddcd121"},"expanded":true,"level":0,"properties":{}},{"name":"Form test and Messaging","content":"open System\nopen System.ComponentModel\nopen System.Windows.Forms\n\nlet label1 = new Label (Text = \"\", Width = 300)\nlet newButton txt =\n    let btn = new Button(Text = txt)\n    btn.Click.Add (fun args -> label1.Text <- txt)\n    btn :> Control\n        \n\nlet spacing = 5\nlet button1 = newButton \"Start\"\nlet button2 = newButton \"Start Invalid\"\nlet button3 = newButton \"Cancel\"\n\nlet updown1 = new System.Windows.Forms.NumericUpDown(Value   = 20m     ,\n                                                     Minimum = 0m      ,\n                                                     Maximum = 1000000m)\n\nlet progressBar = new ProgressBar(Top = 6 * (button1.Height + spacing),\n                                  Width = 300)\nlet panel1 = new Panel(Dock = DockStyle.Fill)\n\n[| button1    \n   button2    \n   button3    \n   updown1     :> Control\n   label1      :> Control\n   progressBar :> Control\n|]\n|> Array.mapi (fun i cts -> cts.Top <- i * 25 ; cts)\n|> panel1.Controls.AddRange\npanel1.DockPadding.All <- 10\n//button1.Click.Add(fun args -> async1 progressBar label1 (int updown1.Value))\n//button2.Click.Add(fun args -> async1 progressBar label1 (int (-updown1.Value)))\n//button3.Click.Add(fun args -> Async.CancelDefaultToken())\nlet form = new Form(Text = \"Select Actions\", Width = 400, Height = 400)\nform.Controls.Add(panel1)\nform.Activated.AddHandler(System.EventHandler (fun _ _ -> form.TopMost <- true(*; form.TopMost <- false*) ))\nasync {\n  do Application.Run(form) \n} |> Async.Start\n\n//open CIPHERPrototype.Messaging\nopen Useful\nopen FsStationShared\n\n#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.Web.dll\"\n#nowarn \"1125\"\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Remoting\n\nlet fsClient = FsStationClient(\"ButtonTest\")\n\nbutton1.Click.Add (fun args ->                                                      \n    Wrap.wrapper {\n        let! response = fsClient.GenericMessage \"Hello\"\n        label1.Text <- response\n    } |> Wrap.Start\n)\n\n//let requestCode (snpName:string) = \n//    async {\n//        let! response = sendRequestRpc toId fromId (snpName.Split '/' |> GetSnippetCode |> Json.Serialize)\n//        let resp =\n//            match response |> Json.Deserialize<FSResponse> with\n//            | SnippetResponse(Some snp )    -> snp  |> Json.Serialize\n//            | StringResponse (Some code)    -> code\n//            | IdResponse     (AddressId id) -> id.ToString()\n//            | _                             -> sprintf \"<Incomplete response: %s>\" response\n//        return resp\n//    }    \n//\n//open Rop\n//Wrap.wrapper {\n//    let! code   = requestCode \"module FSharpStationMD   =/Evaluate F# Code/module Snippets =/Calculate primes\"\n//    let! result = processCode (compileCode \"TESTCODE\") code\n//    result |> Seq.map (sprintf \"%A\") |> String.concat \"\\n\" |> printfn \"%s\"\n//} |> Wrap.getAsyncR |> Async.Start\n\nlet respondMessage fromId (msg:string) : string =\n    label1.Text <- msg\n    match msg |> Json.Deserialize<FSMessage> with\n    | GenericMessage        txt  -> label1.Text <- txt\n                                    StringResponse <| (Some <| \"Message received: \" + txt)\n    | GetIdentification          -> IdResponse fromId \n    | _                          -> StringResponse <| (Some <| \"Message received: \" + msg)\n    |> Json.Serialize\n\nfsClient.MessagingClient.AwaitMessage respondMessage\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"}],"id":{"$":0,"Item":"dc44bbe1-876a-4910-a39a-5d74bc2304ee"},"expanded":true,"level":0,"properties":{}},{"name":"JSON Serializer","content":"#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Core.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Collections.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Main.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.JavaScript.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Web.dll\"\n#r @\"..\\packages\\Zafir.UI.Next\\lib\\net40\\WebSharper.UI.Next.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Sitelets.dll\"\n\n//open CIPHERPrototype.Messaging\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Remoting\n\n\ntype FSMessage =\n    | GetSnippetContentById of string //CodeSnippetId\n    | GetSnippetCodeById    of string //CodeSnippetId\n    | GetSnippetById        of string //CodeSnippetId\n    | GetSnippetContent     of string []\n    | GetSnippetCode        of string []\n    | GetSnippet            of string []\n    | GenericMessage        of string\n    | GetIdentification\n\ntype FSResponse =\n    | SnippetResponse   of string //CodeSnippet option\n    | StringResponse    of string option\n    | IdResponse        of CIPHERPrototype.Messaging.AddressId\n\nGenericMessage \"Hello\" \n|> Json.ServerSideProvider.GetEncoder().Encode\n|> Json.ServerSideProvider.Pack\n|> printfn \"%A\"\n\ntype Response = {\n    ``$TYPES`` : string[]\n    ``$DATA``  : string\n}\n\n\"\"\"{\"$TYPES\":[],\"$DATA\":\"{\\\"$\\\":1,\\\"Item\\\":\\\"Message received: Hello\\\"}\"}\"\"\"\n|> Json.Deserialize<Response>\n|> (fun r -> r.``$DATA``)\n|> Json.Deserialize<FSResponse>\n|> printfn \"%A\"\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"46450fbf-b073-4a66-ab42-587be0afc45f"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"System.IO.File.Delete(@\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\EPFileX\\CodeEditor.fsx.bak\")","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"b4a9f681-f5c2-443b-8f6e-146a6d6cd093"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"let rand = System.Random()\nlet randomNumbers = seq { while true do yield rand.Next(100) }\nlet firstTenRandomNumbers =\n randomNumbers\n |> Seq.truncate 10\n |> Seq.toList\n \nprintfn \"%+A\" firstTenRandomNumbers  \n//printfn \"%t\" (fun w -> w.WriteLine 6)  \n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"210f90c1-81fc-43bd-b838-6a5dc2a8e46b"},"expanded":true,"level":0,"properties":{}},{"name":"Failed to load argument type","content":"#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Collections.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.UI.Next.dll\"\n#r @\"WebSharper.JavaScript.dll\"\n#r @\"WebSharper.Web.dll\"\n#r @\"WebSharper.UI.Next.dll\"\n#r @\"WebSharper.Sitelets.dll\"\n\nopen WebSharper\n\n[< JavaScript >]\ntype AddressId = AddressId of string\n\n[< Rpc >]\nlet sendRequest  (toId:AddressId) =\n        async {\n            return \"HELLO\"\n        }\n\n[< JavaScript >]\nlet tried() =\n    let f = AddressId \"XXX\"\n    let v = sendRequest f\n    (f, v)\n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"f850ce38-14e5-47a4-81ed-df02d7979f8e"},"expanded":true,"level":0,"properties":{}},{"name":"Rules Alea","content":"let accounts =\n  [|\n    \"30\", \"Net Income After M. I. & Taxes \"\n    \"35\", \"Income (Loss) before Taxes \"\n    \"36\", \"Income (Loss) before taxes and M.I. \"\n    \"37\", \"Income from Continuing Operations \"\n    \"38\", \"Operating Income/(Loss) \"\n    \"39\", \"Actual Gross Income \"\n    \"300\", \"Total Net Revenue \"\n    \"301\", \"Orders Available to Ship \"\n    \"310\", \"Total Projected Sales Orders \"\n    \"320\", \"Plus:Orders In Backlog \"\n    \"350\", \"Less:Proj. Ending Backlog \"\n    \"360\", \"Non Interco Revenue \"\n    \"370\", \"Interco Revenue \"\n    \"400\", \"Cost of Goods Sold-Actual \"\n    \"401\", \"Memo Only:Inventory Receipts \"\n    \"402\", \"Memo Only:Interco inventory \"\n    \"410\", \"Cost of Goods Sold \"\n    \"430\", \"Standard COGS-Non Interco \"\n    \"440\", \"Standard COGS-Interco \"\n    \"500\", \"Total Mfg./Distr. Variances \"\n    \"510\", \"Purchase Price/Freight/Reclass \"\n    \"520\", \"Material Usage \"\n    \"530\", \"Inventory Adjustment \"\n    \"540\", \"Labor Performance/Rate \"\n    \"580\", \"Overhead Variance \"\n    \"5800\", \"Overhead Spending \"\n    \"5810\", \"Bonus Accrual for Overhead \"\n    \"5820\", \"Less:Overhead Absorption \"\n    \"40\", \"Actual Gross Margin %   \"\n    \"41\", \"Plan Gross Margin %  \"\n    \"60\", \"Total Expenses \"\n    \"610\", \"Engineering \"\n    \"620\", \"Sales \"\n    \"630\", \"General & Administrative \"\n    \"640\", \"ESOP/401K Contributions \"\n    \"650\", \"Bonus Accrual \"\n    \"660\", \"Warranty Expense-Total \"\n    \"700\", \"Total Non-Operating Income/(Expense) \"\n    \"710\", \"Other Income \"\n    \"720\", \"JV Profit Allocation \"\n    \"730\", \"Other (Expense) \"\n    \"740\", \"Management Fees \"\n    \"750\", \"Interest (Expense)/Income \"\n    \"810\", \"Inventory Disposal Program \"\n    \"910\", \"Minority Interest \"\n    \"920\", \"Federal State Other Income Tax \"\n    \"31\", \"P.A.T. % \"\n    \"32\", \"PLAN INCOME AFTER TAXES & M.I. \"\n    \"33\", \"$ VARIANCE TO PLAN \"\n    \"Cash Flow Statement\", \"Cash Flow Statement \"\n    \"C1\", \"Projected Ending Loan Balance \"\n    \"C10\", \"Beginning Loan Balance \"\n    \"C20\", \"NET PROJECTED CASH + (-) \"\n    \"C201\", \"Other Items- \"\n    \"C202\", \"Other Income \"\n    \"C203\", \"JV Profit Allocation \"\n    \"C204\", \"Other Expense \"\n    \"C205\", \"Management Fees \"\n    \"C206\", \"Capital Additions & Investments \"\n    \"C207\", \"Interest (Expense)/Income \"\n    \"C208\", \"Note principal payments \"\n    \"C209\", \"Other State & Fed Taxes \"\n    \"C210\", \"Tax Distributions to Holdings \"\n    \"C211\", \"Tax Dist. to Other Shareholders \"\n    \"C212\", \"Non-Tax Distributions to Holdings \"\n    \"C213\", \"Non-Tax Dist. to Other Shareholders \"\n    \"C30\", \"Net Cash Flow from Operations \"\n    \"C31\", \"= Gross Cash Inflow(Outflow) \"\n    \"C310\", \"= Net Collections \"\n    \"C311\", \"Gross Collections \"\n    \"C312\", \"Less Core Credits \"\n    \"C321\", \"Payments \"\n    \"C322\", \"Materials \"\n    \"C323\", \"Less Warranty Recovery \"\n    \"C324\", \"Freight Payments \"\n    \"C325\", \"Direct Labor \"\n    \"C326\", \"Overhead Spending \"\n    \"C33\", \"Total Expenses \"\n    \"C331\", \"Engineering \"\n    \"C332\", \"Sales \"\n    \"C333\", \"General & Administrative \"\n    \"C334\", \"ESOP/401K Contributions \"\n    \"C335\", \"Bonus Payments \"\n    \"C336\", \"Gross Warranty Payments \"\n    \"C39\", \"Add back: Depreciation \"\n    \"C2\", \"PLAN Loan Balance \"\n    \"C3\", \"$ VARIANCE TO PLAN (under) \"\n    \"Return On Assets\", \"Return On Assets \"\n    \"R10\", \"Opinion ROA (annualized) \"\n    \"R11\", \"Year End ROA Plan \"\n    \"R5\", \"Year End Net Income Plan \"\n    \"R100\", \"Net Income Calculations \"\n    \"R3\", \"YTD Comparison to Plan \"\n    \"R1\", \"Total Net Income (opinion & YTD) \"\n    \"R110\", \"Last Month Projected Net Income YTD \"\n    \"R120\", \"This Month Opinion Net Income \"\n    \"R2\", \"Net Income YTD Plan \"\n    \"R4\", \"Annualized Projected - Actual, Opinion & Plan \"\n    \"R8\", \"Assets Month to Plan (better) \"\n    \"R6\", \"Total This Month Ending Assets Opinion \"\n    \"R600\", \"Total Assets Calculation \"\n    \"R610\", \"Projected Last Month Ending Assets \"\n    \"R620\", \"Total Net Change in Assets \"\n    \"R630\", \"Total Net Change Inventory \"\n    \"R631\", \"Net Change in Inventory \"\n    \"R632\", \"Total Into Inventory \"\n    \"R633\", \"Material Receipts \"\n    \"R634\", \"Material Usage Variance \"\n    \"R635\", \"Labor \"\n    \"R636\", \"Labor Variance \"\n    \"R637\", \"Overhead Absorbed \"\n    \"R638\", \"Material Recovery from Warranty \"\n    \"R639\", \"COGS Out \"\n    \"R640\", \"Total Net Change Fixed Assets \"\n    \"R641\", \"Net Change in Fixed Assets \"\n    \"R642\", \"Capital and Investments \"\n    \"R643\", \"Depreciation \"\n    \"R650\", \"Total Net Change in A/R \"\n    \"R651\", \"Net Change in Accts Rec \"\n    \"R652\", \"Shipments \"\n    \"R653\", \"Gross Collections \"\n    \"R7\", \"Plan This Month Ending Assets \"\n    \"R9\", \"Year Ending Asset Plan \"\n    \"Earnings\", \"Earnings \"\n    \"E1\", \"EBITDA Dollar Calculations \"\n    \"E2\", \"EBITDA YTD Opinion to Plan (worse) \"\n    \"E20\", \"Annualized Projected  \"\n    \"E21\", \"Total EBITDA Dollars (opinion & YTD) \"\n    \"E22\", \"Projected Last Month EBITDA YTD \"\n    \"E23\", \"This Month Opinion EBITDA Dollars \"\n    \"E231\", \"This Month-- Profit Before Tax and M.I. \"\n    \"E232\", \"This Month-- Interest \"\n    \"E233\", \"This Month-- Depreciation/Amortization \"\n    \"E24\", \"EBITDA Plan Remaining Year \"\n    \"E25\", \"Annual EBITDA Dollars -- FROM PLAN \"\n    \"E3\", \"EBITDA Month Opinion to Plan (worse) \"\n    \"E30\", \"Plan EBITDA Dollars This Month \"\n    \"E31\", \"This Month Opinion EBITDA Dollars \"\n    \"E40\", \"Opinion EBITDA/Assets (annualized) \"\n    \"E41\", \"Annual EBITDA/Month Assets Plan \"\n    \"E42\", \"Annual EBITDA/Annual Assets Plan \"\n    \"R8\", \"Assets Month to Plan (better) \"\n    \"R6\", \"Total This Month Ending Assets Opinion \"\n    \"R600\", \"Total Assets Calculation \"\n    \"R610\", \"Projected Last Month Ending Assets \"\n    \"R620\", \"Total Net Change in Assets \"\n    \"R630\", \"Total Net Change Inventory \"\n    \"R631\", \"Net Change in Inventory \"\n    \"R632\", \"Total Into Inventory \"\n    \"R633\", \"Material Receipts \"\n    \"R634\", \"Material Usage Variance \"\n    \"R635\", \"Labor \"\n    \"R636\", \"Labor Variance \"\n    \"R637\", \"Overhead Absorbed \"\n    \"R638\", \"Material Recovery from Warranty \"\n    \"R639\", \"COGS Out \"\n    \"R640\", \"Total Net Change Fixed Assets \"\n    \"R641\", \"Net Change in Fixed Assets \"\n    \"R642\", \"Capital and Investments \"\n    \"R643\", \"Depreciation \"\n    \"R650\", \"Total Net Change in A/R \"\n    \"R651\", \"Net Change in Accts Rec \"\n    \"R652\", \"Shipments \"\n    \"R653\", \"Gross Collections \"\n    \"R7\", \"Plan This Month Ending Assets \"\n    \"R9\", \"Year Ending Asset Plan \"\n    \"Shipments\", \" \"\n    \"S1\", \"Current Shipments \"\n  |]\n  \nlet rules = \n  [| \n    \"[Version:'Projection'] =IF([Version:'Final Projection']<>0, [Version:'Final Projection'],IF([Version:'Week 5']<>0, [Version:'Week 5'],IF([Version:'Week 4']<>0, [Version:'Week 4'], IF([Version:'Week 3']<>0, [Version:'Week 3'],IF([Version:'Week 2']<>0, [Version:'Week 2'],IF([Version:'Week 1']<>0, [Version:'Week 1'],0))))));\", \"##[Projection] FROM [FP,W5,W4,W3,W2,W1] RULE: IF([Version:'Final Projection']<>0, [Version:'Final Projection'],IF([Version:'Week 5']<>0, [Version:'Week 5'],IF([Version:'Week 4']<>0, [Version:'Week 4'], IF([Version:'Week 3']<>0, [Version:'Week 3'],IF([Version:'Week 2']<>0, [Version:'Week 2'],IF([Version:'Week 1']<>0, [Version:'Week 1'],0))))))\"\n    \"[Version:'Actual\\Projection']=B:IF(NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),1,4))*100+NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),6,2))> NUMBR(!YEAR)*100+NUMBR(SUBST(!PERIOD, 2, 2)),['Actual'], ['Projection']);\", \"##[Actual\\Projection] FROM ['Actual'], ['Projection'] RULE: IF(NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),1,4))*100+NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),6,2))> NUMBR(!YEAR)*100+NUMBR(SUBST(!PERIOD, 2, 2)),['Actual'], ['Projection'])\"\n    \"[Currency:'USD'] =B:[Currency:'LC'] * DB('XRates',!YEAR, !PERIOD, !VERSION, GETATTR('ACCOUNT', !Account, 1, 'XRate'),GETATTR('UNIT', !Unit, 1, 'Currency'));\", \"##[Currency] FROM LC RULE: [Currency:'LC'] * DB('XRates',!YEAR, !PERIOD, !VERSION, GETATTR('ACCOUNT', !Account, 1, 'XRate'),GETATTR('UNIT', !Unit, 1, 'Currency'))\"\n    \"[Period:'YTD']=[Period:'YTD_12'];\", \"##[YTD] FROM [YTD_12] RULE: [Period:'YTD_12']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'310'] =B:-1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370'];\", \"##ELIM [Total Projected Sales Orders] FROM [Interco Revenue] RULE: -1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'370']=-1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370'];\", \"##ELIM [Interco Revenue]                     FROM [Interco Revenue]  RULE: -1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'401']=[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'370']\", \"##ELIM Memo [Only:Inventory Receipts] FROM [Interco Revenue] RULE: [Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'370']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'440'] =B:-1*[Level:'Net Reported', Unit:'Consolidated wo Elims', Account:'440'];\", \"##ELIM [Standard COGS-Interco] FROM [Standard COGS-Interco] RULE: -1*[Level:'Net Reported', Unit:'Consolidated wo Elims', Account:'440']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'430'] =B:-1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']+[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'440'];\", \"##ELIM [Standard COGS-Non Interco] FROM [Interco Revenue] AND [Standard COGS-Interco] RULE: -1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']+[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'440']\"\n    \"[Account:'910', Version:'Plan']=#NA;\", \"##[Minority Interest] RULE: #NA\"\n    \"[Level:'Adjustments', Account:'910']=B:-1*([Account:'36',Level:'Net Reported'])*DB('UNITSET',!YEAR, !PERIOD, !UNIT, 'Minority %');\", \"##[Minority Interest] FROM [Income (Loss) before taxes and M.I.] RULE: -1*([Account:'36',Level:'Net Reported'])*DB('UNITSET',!YEAR, !PERIOD, !UNIT, 'Minority %')\"\n    \"[Account:'40'] =[Account:'39']/[Account:'300'];\", \"##[Actual Gross Margin %] FROM [Actual Gross Income] / [Total Net Revenue] RULE: [Account:'39']/[Account:'300']\"\n    \"[Account:'41'] =[Account:'39',Version:'Plan']/[Account:'300',Version:'Plan'];\", \"##[Plan Gross Margin %] FROM [Actual Gross Income] / [Total Net Revenue] RULE: [Account:'39',Version:'Plan']/[Account:'300',Version:'Plan']\"\n    \"[Account:'31'] =[Account:'30']/[Account:'360'];\", \"##[P.A.T. %] FROM [Net Income After M. I. & Taxes] / [Income (Loss) before taxes and M.I.] RULE: [Account:'30']/[Account:'360']\"\n    \"[Account:'32'] =[Account:'30',Version:'Plan'];\", \"##[PLAN INCOME AFTER TAXES & M.I.] FROM [Net Income After M. I. & Taxes] RULE: [Account:'30',Version:'Plan']\"\n    \"[Account:'33'] =B:[Account:'30']-[Account:'32'];\", \"##[$ VARIANCE TO PLAN] FROM [Net Income After M. I. & Taxes] - [PLAN INCOME AFTER TAXES & M.I.] RULE: [Account:'30']-[Account:'32']\"\n    \"###[Account:'C326']=B:-1*([Account:'5800']-[Account:'5810'])\", \"##[Overhead Spending] FROM [Overhead Spending] - [Bonus Accrual for Overhead] RULE: -1*([Account:'5800']-[Account:'5810'])\"\n    \"[Account:'C331']=-1*([Account:'610']);\", \"##[Engineering] FROM [Engineering] RULE: -1*([Account:'610'])\"\n    \"[Account:'C332']=-1*([Account:'620']);\", \"##[Sales] FROM [Sales] RULE: -1*([Account:'620'])\"\n    \"[Account:'C333']=-1*([Account:'630']);\", \"##[General & Administrative] FROM [General & Administrative] RULE: -1*([Account:'630'])\"\n    \"[Account:'C334']=-1*[Account:'640'];\", \"##[ESOP/401K Contributions] FROM [ESOP/401K Contributions] RULE: -1*([Account:'640'])\"\n    \"[Account:'C205']=B:[Account:'740'];\", \"##[Management Fees] FROM [Management Fees] RULE: [Account:'740']\"\n    \"[Account:'C207']=[Account:'750'];\", \"##[Interest (Expense)/Income] FROM [Interest (Expense)/Income] RULE: [Account:'750']\"\n    \"[Account:'C3'] =[Account:'C1']-[Account:'C2'];\", \"##[$ VARIANCE TO PLAN (under)] FROM [Projected Ending Loan Balance] - [PLAN Loan Balance] RULE: [Account:'C1']-[Account:'C2']\"\n    \"[Account:'C2']=B:IF(!VERSION@='Plan',STET,[Version:'Plan', Account:'C2']);\", \"##[PLAN Loan Balance] FROM [PLAN Loan Balance] RULE: IF(!VERSION@='Plan',STET,[Version:'Plan', Account:'C2'])\"\n    \"[Account:'R110']=B:IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), !VERSION, !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE));\", \"##BC [Last Month Projected Net Income YTD] FROM [Income (Loss) before taxes and M.I.] RULE: IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), !VERSION, !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE))\"\n    \"[Account:'R110']=C:IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Account:'36'], STET);\", \"##CC [Last Month Projected Net Income YTD] FROM [Income (Loss) before taxes and M.I.] RULE: IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Account:'36'], STET)\"\n    \"[Account:'R120'] =[Account:'30'];\", \"##[This Month Opinion Net Income] FROM [Net Income After M. I. & Taxes] RULE: [Account:'30']\"\n    \"[Account:'R2']=B:DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##BC [Net Income YTD Plan] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'R2']=C:IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Version:'Plan', Account:'36'], STET);\", \"##CC [Net Income YTD Plan] FROM [Income (Loss) before taxes and M.I.] RULE: IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Version:'Plan', Account:'36'], STET)\"\n    \"[Account:'R610']=B:IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.SIBLING('Period',!PERIOD,-1), 'Projection', !CURRENCY, !LEVEL, !UNIT, 'R6', !MEASURE));\", \"##[Projected Last Month Ending Assets] FROM [Total This Month Ending Assets Opinion] RULE: IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.SIBLING('Period',!PERIOD,-1), 'Projection', !CURRENCY, !LEVEL, !UNIT, 'R6', !MEASURE))\"\n    \"[Account:'R7']=[Version:'Plan',Account:'R6'];\", \"##[Plan This Month Ending Assets] FROM [Total This Month Ending Assets Opinion] RULE: [Version:'Plan',Account:'R6']\"\n    \"[Account:'R9']=[Period:'Year', Version:'Plan', Account:'R6'];\", \"##[Year Ending Asset Plan] FROM [Total This Month Ending Assets Opinion] RULE: [Period:'Year', Version:'Plan', Account:'R6']\"\n    \"###[Account:'R3'] =[Account:'R1']-[Account:'R2']\", \"##[YTD Comparison to Plan] FROM [Total Net Income (opinion & YTD)] - [Net Income YTD Plan] RULE: [Account:'R1']-[Account:'R2']\"\n    \"[Account:R633] =[Account:401];\", \"##[Material Receipts] FROM [Memo Only:Inventory Receipts] RULE: [Account:401]\"\n    \"[Account:R634] =-1*[Account:520];\", \"##[Material Usage Variance] FROM [Material Usage] RULE: -1*[Account:520]\"\n    \"[Account:R635] =-1*[Account:C325];\", \"##[Labor] FROM [Direct Labor] RULE: -1*[Account:C325]\"\n    \"[Account:R637] =-1*[Account:5820];\", \"##[Overhead Absorbed] FROM [Less:Overhead Absorption] RULE: -1*[Account:5820]\"\n    \"[Account:R636] =-1*[Account:540];\", \"##[Labor Variance] FROM [Labor Performance/Rate] RULE: -1*[Account:540]\"\n    \"[Account:R638] =[Account:C323];\", \"##[Material Recovery from Warranty] FROM [Less Warranty Recovery] RULE: [Account:C323]\"\n    \"[Account:R639] =-1*[Account:'410'];\", \"##[COGS Out] FROM [Cost of Goods Sold] RULE: -1*[Account:'410']\"\n    \"[Account:R642] =-1*[Account:C206];\", \"##[Capital and Investments] FROM [Capital Additions & Investments] RULE: -1*[Account:C206]\"\n    \"[Account:R643] =-1*[Account:C39];\", \"##[Depreciation] FROM [Add back: Depreciation] RULE: -1*[Account:C39]\"\n    \"[Account:R652] =[Account:300];\", \"##[Shipments] FROM [Total Net Revenue] RULE: [Account:300]\"\n    \"[Account:R653] =[Account:C311];\", \"##[Gross Collections] FROM [Gross Collections] RULE: [Account:C311]\"\n    \"[Account:'R10']=[Account:'R4']/[Account:'R6'];\", \"##[Opinion ROA (annualized)] FROM [Annualized Projected - Actual, Opinion & Plan] / [Total This Month Ending Assets Opinion] RULE: [Account:'R4']/[Account:'R6']\"\n    \"[Account:'R11']=[Account:'R5']/[Account:'R9'];\", \"##[Year End ROA Plan] FROM [Year End Net Income Plan] / [Year Ending Asset Plan] RULE: [Account:'R5']/[Account:'R9']\"\n    \"[Account:'E22']=DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), 'Projection', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##[Projected Last Month EBITDA YTD] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), 'Projection', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'E24']=DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)-DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##[EBITDA Plan Remaining Year] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)-DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'E25']=DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##[Annual EBITDA Dollars -- FROM PLAN] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'E30']=[Version:'Plan',Account:'36'];\", \"##[Plan EBITDA Dollars This Month] FROM [Income (Loss) before taxes and M.I.] RULE: [Version:'Plan',Account:'36']\"\n    \"[Account:'E31']=[Account:'E23'];\", \"##[This Month Opinion EBITDA Dollars] FROM [This Month Opinion EBITDA Dollars] RULE: [Account:'E23']\"\n    \"[Account:'E231']=[Account:'36'];\", \"##[This Month-- Profit Before Tax and M.I.] FROM [Income (Loss) before taxes and M.I.] RULE: [Account:'36']\"\n    \"[Account:'E233']=[Account:'C39'];\", \"##[This Month-- Depreciation/Amortization] FROM [Add back: Depreciation] RULE: [Account:'C39']\"\n    \"[Account:'E232']=-1*[Account:'750'];\", \"##[This Month-- Interest] FROM [Interest (Expense)/Income] RULE: -1*[Account:'750']\"\n    \"[Account:'E40']=[Account:'E20']/[Account:'R6'];\", \"##[Opinion EBITDA/Assets (annualized)] FROM [Annualized Projected ] / [Total This Month Ending Assets Opinion] RULE: [Account:'E20']/[Account:'R6']\"\n    \"[Account:'E41']=[Account:'E25']/[Account:'R7'];\", \"##[Annual EBITDA/Month Assets Plan] FROM [Annual EBITDA Dollars -- FROM PLAN] / [Plan This Month Ending Assets] RULE: [Account:'E25']/[Account:'R7']\"\n    \"[Account:'E42']=[Account:'E25']/[Account:'R9'];\", \"##[Annual EBITDA/Annual Assets Plan] FROM [Annual EBITDA Dollars -- FROM PLAN] / [Year Ending Asset Plan] RULE: [Account:'E25']/[Account:'R9']\"\n  |]  \n  \n#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\nopen System.Text.RegularExpressions\n\nlet AccountP = @\"(\\[((.+?),)*\\s*Account\\s*:\\s*'?(.+?)'?(,(.+?))*\\])\"\nlet input    = @\"[Level:'Adjustments', Account:'910']=B:-1*([Account:'36',Level:'Net Reported'])*DB('UNITSET',!YEAR, !PERIOD, !UNIT, 'Minority %');\"\n\nlet splitRule r =\n    Regex.Match(r, @\"(.+?)=(.+)\")\n    |> (fun m -> m.Groups.[1].Value, m.Groups.[2].Value)\n\nlet replace input =\n    Regex.Matches(input, AccountP)\n    |> Seq.cast<Match>\n    |> Seq.map (fun m -> \n        let whole = m.Groups.[0]\n        let acct  = m.Groups.[4]\n        let pres  = m.Groups.[3].Captures |> Seq.cast<Capture>\n        let sufs  = m.Groups.[6].Captures |> Seq.cast<Capture>\n        accounts \n        |> Seq.tryFind (fst >> ((=) acct.Value)) \n        |> Option.map snd \n        |> Option.defaultValue (\"Not Found: \" + acct.Value) \n        |> (fun s -> \n            let txt  = \n                [ yield s.Trim()\n                  for pre in pres do yield pre.Value\n                  for suf in sufs do yield suf.Value \n                ] \n                |> String.concat \"~\" \n                |> sprintf \"{%s}\" \n            txt, whole.Index, whole.Length)\n       )\n    |> Seq.fold (fun (txt:string, i, out) (v, s, l) -> (txt.[s + l - i ..], s + l, out + txt.[0 .. s - i - 1] + v) ) (input, 0, \"\")\n    |> fun (res, _, out) -> out + res\n    \nrules\n|> Seq.iter (\n    fun (r, c) ->\n        let a, b = splitRule r\n        printfn \"%s\\t%s\\t%s\" (replace a) (replace b) c\n \n)","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"dfc80990-ada5-4f24-8192-85bfe3b115a5"},"expanded":true,"level":0,"properties":{}},{"name":"FSharpPlus","content":"#r \"..\\packages\\FSharpPlus\\lib\\net40\\FSharpPlus.dll\"\n\nopen FSharpPlus\n\nmap string [|2;3;4;5|]\n// val it : string [] = [|\"2\"; \"3\"; \"4\"; \"5\"|]\n|> printfn \"%A\"\n\nmap ((+) 9) (Some 3)\n// val it : int option = Some 12\n|> printfn \"%A\"\n\nmap string (NonEmptyList.create 2 [3;4;5])\n// val it : NonEmptyList<string> = {Head = \"2\"; Tail = [\"3\"; \"4\"; \"5\"];}\n|> printfn \"%A\"\n\n[\"hello\";\" \";\"world\"] >>= (fun x -> Seq.toList x)\n// val x : char list = ['h'; 'e'; 'l'; 'l'; 'o'; ' '; 'w'; 'o'; 'r'; 'l'; 'd']\n|> printfn \"%A\"\n\n\nlet tryParseInt : string -> int option = tryParse\nlet tryDivide x n = if n = 0 then None else Some (x / n)\n\nSome \"20\" >>= tryParseInt >>= tryDivide 100\n// val y : int option = Some 5\n|> printfn \"%A\"\n\nlet parseAndDivide100By = tryParseInt >=> tryDivide 100\n\nparseAndDivide100By \"20\"   // Some 5\n|> printfn \"%A\"\nparseAndDivide100By \"zero\" // None\n|> printfn \"%A\"\nparseAndDivide100By \"0\"    // None\n|> printfn \"%A\"\n\nlet parseElement n = List.tryItem n >=> tryParseInt\nparseElement 2 [\"0\"; \"1\";\"2\"]\n|> printfn \"%A\"\n\nlet tryParseInt' x : Choice<int, string> = \n    match tryParse x with \n    | Some x -> Choice1Of2 x\n    | None   -> Choice2Of2 (\"Failed to parse \" + x)\n        \n\nlet tryDivide' x n = \n    if n = 0 then Choice2Of2 \"Can't divide by zero\"\n    else Choice1Of2 (x / n)\n    \nlet parseAndDivide100By' = tryParseInt' >=> tryDivide' 100\n\nparseAndDivide100By' \"20\"   // Some 5\n|> printfn \"%A\"\nparseAndDivide100By' \"zero\" // None\n|> printfn \"%A\"\nparseAndDivide100By' \"0\"    // None\n|> printfn \"%A\"\n\nSome (+) <*> Some 2 <*> Some 10     // val sumAllOptions : int option = Some 12\n|> printfn \"%A\"\n\n[(+)] <*> [10; 100] <*> [1; 2; 3]   // int list = [11; 12; 13; 101; 102; 103]\n|> printfn \"%A\"\n\nopen FSharpPlus.Lens\n\n\n(\"hello\",\"world\")^. FSharpPlus.Lens._2\n// val it : string = \"world\"\n|> printfn \"%A\"\n\nset _2 42 (\"hello\",\"world\", 8)\n// val it : string * int = (\"hello\", 42)\n|> printfn \"%A\"\n\n(\"hello\",(\"world\",\"!!!\"))^.(_2 << _1)\n// val it : string = \"world\"\n|> printfn \"%A\"\n\nset (_2 << _1) 42 (\"hello\",(\"world\",\"!!!\"))             \n// val it : string * (int * string) = (\"hello\", (42, \"!!!\"))\n|> printfn \"%A\"\n\n\"hello\"^.to' length\n// val it : int = 5\n|> printfn \"%A\"\n\n(\"hello\",(\"world\",\"!!!\"))^. (_2 << _2 << to' length)\n// val it : int = 3\n|> printfn \"%A\"\n\n_1 .-> \"hello\" <| ((),\"world\")\n// val it : string * string = (\"hello\", \"world\")\n|> printfn \"%A\"\n\n((), \"world\") |> _1 .-> \"hello\"\n// val it : string * string = (\"hello\", \"world\")\n|> printfn \"%A\"\n\nview _2 (10,20)\n// val it : int = 20\n|> printfn \"%A\"\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"3def8b16-6c90-40f4-a78e-b2b293df699a"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"System.IO.Path.GetRandomFileName()\n|> printfn \"%s\"","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"c8d8aeb9-a872-45dc-b240-b7846e076d1a"},"expanded":true,"level":0,"properties":{}},{"name":"Check All F# Code 1","content":"#define JUSTCHECKING","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"c8d8aeb9-a872-45dc-b240-b7846e076d1a"},{"$":0,"Item":"dfc80990-ada5-4f24-8192-85bfe3b115a5"},{"$":0,"Item":"f850ce38-14e5-47a4-81ed-df02d7979f8e"},{"$":0,"Item":"210f90c1-81fc-43bd-b838-6a5dc2a8e46b"},{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},{"$":0,"Item":"b4a9f681-f5c2-443b-8f6e-146a6d6cd093"},{"$":0,"Item":"08e9600a-804b-4aba-a262-85f22e0cc8de"},{"$":0,"Item":"8efdcd5a-95c4-4212-9c75-1ebedce83dd8"},{"$":0,"Item":"c7e56d1e-aea8-483a-a99a-23b7e056de0d"},{"$":0,"Item":"16f618b6-0483-44dc-9c54-550f4f5b725d"},{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},{"$":0,"Item":"56e5bc09-e528-49cc-9d42-6359b32a0cc9"},{"$":0,"Item":"8ee6b535-3615-4066-8917-9125cf8a1f20"},{"$":0,"Item":"1d18fdb5-2488-4ac9-813a-c96a66b9cd13"},{"$":0,"Item":"5df15cf1-361e-4d57-a565-683ab0b72082"},{"$":0,"Item":"3d704638-8ba4-4bc8-b810-29e023a222fc"},{"$":0,"Item":"bd716e89-0546-4d6b-8964-26473ddcd121"},{"$":0,"Item":"dc44bbe1-876a-4910-a39a-5d74bc2304ee"},{"$":0,"Item":"46450fbf-b073-4a66-ab42-587be0afc45f"}],"id":{"$":0,"Item":"caa2898b-b46a-4e93-99ba-63cc8e5726d0"},"expanded":true,"level":0,"properties":{}},{"name":"Test FSharp.Compiler.Service","content":"let input = \"\"\"\n(**)#r @\"D:\\Abe\\CIPHERWorkspace\\Repos\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\nopen System\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n\n// Create an interactive checker instance \n#if HELLO\nlet checker = FSharpChecker.Create()\n#endif\n// Sample input as a multi-line string\nlet input = \"\"\n// Split the input & define file name\nlet inputLines = input.Split('\\n')\nlet file = \"/home/user/Test.fsx\"\n\nasync {\n    let! projOptions                   = checker.GetProjectOptionsFromScript(file, input)\n    let! parseResults, checkFileAnswer = checker.ParseAndCheckFileInProject(file, 0, input, projOptions) \n    let! tip                           =\n        match checkFileAnswer with\n        | FSharpCheckFileAnswer.Succeeded res -> async { let! tip = res.GetToolTipTextAlternate(4, 13, inputLines.[1], [\"foo\"], FSharpTokenTag.Identifier) \n                                                         return sprintf \"%A\" tip                              }\n        | res                                 -> async { return sprintf \"Parsing did not finish... (%A)\" res }      \n    printfn \"%s\" tip\n} |> Async.RunSynchronously\n\"\"\"              \n\n#define FSHARP40\n#r @\"D:\\Abe\\CIPHERWorkspace\\Repos\\packages\\ServiceStack.Text\\lib\\net45\\ServiceStack.Text.dll\"\n#if FHSARP40\n#r @\"D:\\Abe\\CIPHERWorkspace\\Repos\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n#else\n#r @\"FSharp.Compiler.Service.dll\"\n#endif\n\nopen System\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\nopen ServiceStack.Text\n\nlet checker = FSharpChecker.Create()\n\nlet file       = @\"Compiled\\Test.fsx\"\nlet inputLines = input.Split('\\n')\nlet line       = 2\nlet lineStr    = inputLines.[line - 1]\nasync {\n    #if FSHARP40 \n    let! projOptions0    = checker.GetProjectOptionsFromScript(file, input)\n    #else\n    let! projOptions02, errors           = checker.GetProjectOptionsFromScript(file, input)\n    printfn \"ERRORS: %A\" errors\n    #endif\n    let  projOptions     = { projOptions0 with OtherOptions = Array.append projOptions0.OtherOptions [| \"-d:HELLO\" |]}\n    let! parseResults, checkFileAnswer = checker.ParseAndCheckFileInProject(file, 0, \"////-d:HELLO\\nlet a = 1\", projOptions)\n    let! tip                           =\n        match checkFileAnswer with\n        | FSharpCheckFileAnswer.Succeeded res -> \n//                 sprintfn \"answer:%A\" res.GetAllUsesOfAllSymbolsInFile\n                 async { let! tip = res.GetToolTipTextAlternate(2, 5, \"let a = 1\", [\"a\"], FSharpTokenTag.IDENT) \n//                 async { //let tip = res.//GetAllUsesOfAllSymbolsInFile() \n                         //.Replace(\" \", \"_\")\n                               //|> Seq.map (fun u -> u.DisplayContext, u.FileName, u.RangeAlternate, u.Symbol)\n                               // |> Seq.map (sprintf \"%A\")\n                               // |> String.concat \"\\n\"\n                         return sprintf \"%A\" tip }\n        | res -> async { return sprintf \"Parsing did not finish... (%A)\" res }      \n    printfn \"%s\" tip\n    printfn \":%s\" lineStr\n    printfn \"PROJECT: %A\" projOptions\n    //parseResults.PrintDump()\n    let res = checker.TryGetRecentCheckResultsForFile(file, projOptions)\n    printfn \"RES: %A\" res\n    match res with\n    | None  -> ()\n    | Some  (_, res,_) ->\n        let! tip2 = res.GetToolTipTextAlternate(2, 5, \"let a = 1\", [\"a\"], FSharpTokenTag.IDENT) \n        printfn \"TIP2: %A\" tip2\n} |> Async.RunSynchronously","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"d54a55c5-1462-4983-a966-4feb4cfccb2a"},"expanded":true,"level":0,"properties":{}},{"name":"Check All F# Code 2","content":"// separate check for FSAutoComplete because it uses a different version of Compiler.Services.dll than Compile\n#define JUSTCHECKING","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"d54a55c5-1462-4983-a966-4feb4cfccb2a"},{"$":0,"Item":"971e9b81-6e5d-4f11-a604-f87504d7c950"}],"id":{"$":0,"Item":"11e21cf6-f497-4f73-a287-a2d5ff5b0445"},"expanded":true,"level":0,"properties":{}},{"name":"Calculation Editor","content":"module CalcEditor =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"002fe5c4-6032-4259-a8dc-9afa8f5f7742"},"expanded":false,"level":0,"properties":{}},{"name":"Calculations","content":"#r \"..\\packages\\FSharpPlus\\lib\\net40\\FSharpPlus.dll\"\nopen FSharpPlus\nopen Useful\nopen System\n\ntype DimType =\n    | DtDataType\n    | DtTime\n    | DtVersion\n    | DtTCalc\n    | DtCalc\n    | DtMeasure\n    | DtOther\n\ntype CubeType =\n    | CtOther\n    | CtCalc\n    | CtFreeze\n\ntype AttType =\n    | AtString\n    | AtNumber\n\ntype ElmType =\n    | EtString\n    | EtNumber\n\ntype ModId = ModId of Guid\ntype AttId = AttId of Guid\ntype ElmId = ElmId of Guid\ntype CubId = CubId of Guid\ntype DimId = DimId of Guid\ntype CalId = CalId of Guid\ntype ForId = ForId of Guid\ntype RulId = RulId of Guid\n\ntype Attribute = {\n    attId                  : AttId\n    mutable attName        : string\n    mutable attType        : AttType\n    mutable attTableNum    : int\n}\n\ntype Element = {\n    elmId                  : ElmId\n    elmDim                 : DimId\n    mutable elmType        : ElmType\n    mutable elmName        : string\n    mutable elmDescription : string\n    mutable elmAttributes  : Map<AttId, string> \n    mutable elmParents     : ElmId     []\n} \nwith\n    static member New name = \n      {\n        elmId          = ElmId <| Guid.NewGuid()\n        elmDim         = DimId <| Guid.NewGuid()\n        elmType        = EtString\n        elmName        = name\n        elmDescription = name\n        elmAttributes  = Map.empty\n        elmParents     = [||]\n      }\n\ntype Dimension = {\n    dimId                  : DimId\n    mutable dimName        : string\n    mutable dimPrefix      : string\n    mutable dimType        : DimType\n    mutable defaultElm     : ElmId     option\n    mutable dimElements    : Element   []\n    mutable dimAttributes  : Attribute []\n    isCalcDim              : bool\n} with\n    member this.GetElement       eId = this.dimElements |> Seq.find (fun e -> e.elmId = eId)\n\ntype Operator = \n    | OpAdd      \n    | OpSubtract \n    | OpMultiply \n    | OpDivide   \n    | OpEQ    \n    | OpNE\n    | OpGT       \n    | OpGE       \n    | OpLT       \n    | OpLE       \n    | OpAnd      \n    | OpOr           \n\ntype Function = Function\n\ntype ElmReference =\n    | ElemFixed   of DimId * ElmId\n    | ElemDynamic of DimId * ExpressionText\n  with\n    member this.DimId =\n        match this with\n        | ElemFixed  (id, _)\n        | ElemDynamic(id, _) -> id\n        \nand  ExpressionText =\n    | ExtNA\n    | ExtStet\n    | ExtSlice      of Slice\n    | ExtString     of string\n    | ExtDimElement of DimId\n    | ExtDimName    of DimId\n    | ExtFunction   of Function * ExpressionAny []\n    | ExtIf         of ExpressionNumber * ExpressionText   * ExpressionText\n    | ExtSubSt      of ExpressionText   * ExpressionNumber * ExpressionNumber\n\nand  ExpressionNumber =\n    | ExnNA\n    | ExnStet\n    | ExnSlice      of Slice\n    | ExnNumber     of float\n    | ExnOperationN of Operator * ExpressionNumber * ExpressionNumber\n    | ExnOperationT of Operator * ExpressionText   * ExpressionText\n    | ExnOperationI of Operator * ExpressionAny    * ExpressionAny\n    | ExnFunction   of Function * ExpressionAny []\n    | ExnIf         of ExpressionNumber * ExpressionNumber * ExpressionNumber\n    | ExnMax        of ExpressionNumber * ExpressionNumber\n    | ExnMin        of ExpressionNumber * ExpressionNumber\n    | ExnDeIsChild  of ExpressionText   * ExpressionText   * ExpressionText  \n    \nand ExpressionAny =    \n    | ExiNA\n    | ExiStet\n    | ExiSlice      of Slice\n    | ExNumeric     of ExpressionNumber\n    | ExText        of ExpressionText\n    | ExiIf         of ExpressionNumber * ExpressionAny * ExpressionAny\n    \nand  Slice = {\n    sliDims     : Map<DimId, ElmReference>   \n    calculation : CalId option\n    cube        : CubId option\n} with \n    static member New ds = {\n             sliDims       = ds |> Seq.map (fun (dr:ElmReference) -> dr.DimId, dr) |> Map \n             calculation   = None\n             cube          = None\n    }\n    static member ForAll = {\n             sliDims       = Map.empty\n             calculation   = None\n             cube          = None\n    }\n\n\ntype ForType = \n    | ForBase\n    | ForConsolidated\n    | ForAll\n\ntype Formula = {\n    forId                  : ForId\n    mutable forDestination : ElmReference list\n    mutable forDescription : string\n    mutable forExpression  : ExpressionAny\n    mutable forType        : ForType\n}\n\ntype Calculation = {\n    calId                  : CalId\n    mutable calName        : string\n    mutable calDescription : string\n    mutable format         : string\n    mutable isText         : bool\n    mutable isInput        : bool\n    mutable isBalance      : bool\n    mutable calDims        : Set<DimId>\n    mutable calFormulas    : Formula []\n    mutable cube           : CubId   option\n    properties             : System.Collections.Generic.Dictionary<string, string>\n} with\n    member this.Slice : Slice = \n         {\n             sliDims       = Map.empty\n             calculation   = Some this.calId\n             cube          = None\n         }\n    member this.Type = if this.isInput then \"INPUT\" else \"CALC\"\n\ntype RuleKey = \n    | RuleKey     of RulId\n    | CalcRuleKey of CalId\n    | FormulaKey  of ForId\n    | ForTextKey  of ForId\n    | ActualRuleKey \n    | InputRuleKey\n    | ConsolidatedRuleKey\n\ntype Cube = {\n    cubId                  : CubId\n    mutable cubName        : string\n    mutable cubRules       : Map<RuleKey, Rule option>\n    cubDims                : DimId []\n    measureDim             : DimId option\n    cubType                : CubeType\n} with\n    member this.Slice : Slice = \n         {\n             sliDims       = Map.empty\n             calculation   = None\n             cube          = Some this.cubId\n         }\n    member this.ContainsDim dimId = this.cubDims |> Seq.contains dimId\n    member this.IsCalcCube        = this.cubType = CtCalc\n\nand  Rule = {\n    rulId                  : RulId\n    rulSourceId            : IComparable\n    mutable rulDescription : string\n    mutable rulDestination : ElmReference list\n    mutable rulExpression  : ExpressionAny\n    mutable rulType        : ForType\n    mutable rulOrder       : string\n}\n\ntype Model = {\n    modId                   : ModId\n    mutable server          : string\n    mutable modDims         : Dimension   []\n    mutable modCubes        : Cube        []\n    mutable modCalculations : Calculation []\n} \nwith\n    member this.GetDim        dId   = this.modDims         |> Seq.find    (fun d   ->   d.dimId   =    dId)\n    member this.GetCalc       cId   = this.modCalculations |> Seq.find    (fun c   ->   c.calId   =    cId)\n    member this.GetCube     cubId   = this.modCubes        |> Seq.tryFind (fun cub -> cub.cubId   =  cubId)\n    member this.PickCube       ct   = this.modCubes        |> Seq.tryPick (fun c   ->   if c.cubType = ct then Some c else None)\n    member this.PickDim        dt   = this.modDims         |> Seq.tryPick (fun d   ->   if d.dimType = dt then Some d else None)\n    member this.PickCalc       cn   = this.modCalculations |> Seq.tryPick (fun c   ->   if c.calName = cn then Some c else None)\n    member this.FreezeCube          = this.PickCube CtFreeze\n    member this.TCalcDim            = this.PickDim  DtTCalc\n    member this.DataTypeDim         = this.PickDim  DtDataType\n    member this.TimeDim             = this.PickDim  DtTime    \n    member this.VersionDim          = this.PickDim  DtVersion \n    member this.IsActualCalc        = this.PickCalc \"IsActual\"\n    member this.GetCalcCube dims    = \n        this.modCubes \n        |> Seq.filter  (fun cub -> cub.IsCalcCube   ) \n        |> Seq.tryFind (fun cub -> \n            cub.cubDims \n            |> Seq.filter (fun d -> Some d <> cub.measureDim) \n            |> Set = dims )\n    member this.withDims f =\n        this.TCalcDim                         |> swap Option.bind <| fun tCalcDim    ->\n        this.DataTypeDim                      |> swap Option.bind <| fun dataTypeDim ->\n        f tCalcDim dataTypeDim\n\nlet model = \n  {\n    modId           = ModId <| Guid.NewGuid()\n    server          = @\"local\\Budget\"\n    modDims         = [||]\n    modCubes        = [||]\n    modCalculations = [||]\n  }\n\n#nowarn \"86\"\n\ntype HelperTypeN = HelperTypeN with\n    static member (&%>)  (HelperTypeN, a :     bool             ) : ExpressionNumber = ExnNumber <| if    a then 1.0 else 0.0\n    static member (&%>)  (HelperTypeN, a :     int              ) : ExpressionNumber = ExnNumber <| float a\n    static member (&%>)  (HelperTypeN, a :     float            ) : ExpressionNumber = ExnNumber          a\n    static member (&%>)  (HelperTypeN, a :     Slice            ) : ExpressionNumber = ExnSlice           a\n    static member (&%>)  (HelperTypeN, a :     Calculation      ) : ExpressionNumber = ExnSlice           a.Slice\n    static member (&%>)  (HelperTypeN, a :     ExpressionNumber ) : ExpressionNumber =                    a\n    \nlet inline toExpN v : ExpressionNumber = HelperTypeN &%>  v\n\ntype HelperTypeT = HelperTypeT with\n    static member (&&>)  (HelperTypeT, a :     string           ) : ExpressionText   = ExtString          a \n    static member (&&>)  (HelperTypeT, a :     Dimension        ) : ExpressionText   = ExtDimName         a.dimId \n    static member (&&>)  (HelperTypeT, a :     Slice            ) : ExpressionText   = ExtSlice           a\n    static member (&&>)  (HelperTypeT, a :     Calculation      ) : ExpressionText   = ExtSlice           a.Slice\n    static member (&&>)  (HelperTypeT, a :     ExpressionText   ) : ExpressionText   =                    a\n\nlet inline toExpT  v : ExpressionText = HelperTypeT &&>  v\n\ntype HelperTypeA = HelperTypeA with\n    static member (&>>)  (HelperTypeA, a :     ExpressionNumber) : ExpressionAny = ExNumeric          a \n    static member (&>>)  (HelperTypeA, a :     ExpressionText  ) : ExpressionAny = ExText             a\n    static member (&>>)  (HelperTypeA, a :     Slice           ) : ExpressionAny = ExiSlice           a\n    static member (&>>)  (HelperTypeA, a :     Calculation     ) : ExpressionAny = ExiSlice           a.Slice\n    static member (&>>)  (HelperTypeA, a :     bool            ) : ExpressionAny = toExpN             a |> ExNumeric\n    static member (&>>)  (HelperTypeA, a :     int             ) : ExpressionAny = toExpN             a |> ExNumeric\n    static member (&>>)  (HelperTypeA, a :     float           ) : ExpressionAny = toExpN             a |> ExNumeric\n    static member (&>>)  (HelperTypeA, a :     string          ) : ExpressionAny = toExpT             a |> ExText\n    static member (&>>)  (HelperTypeA, a :     ExpressionAny   ) : ExpressionAny =                    a\n\nlet inline toExpA  v : ExpressionAny = HelperTypeA &>>  v\n\ntype Formula with\n    static member inline New(dest, exp, typ) =\n          {\n              forId          = ForId <| Guid.NewGuid()\n              forDestination = dest\n              forDescription = \"\"\n              forExpression  = toExpA exp\n              forType        = typ\n          }\n    member this.Conso = { this with forType = ForConsolidated }\n   //static member inline Base(formula      ) = Formula.New([]  , formula, ForBase        )        \n   //static member inline Base(formula, dest) = Formula.New(dest, formula, ForBase        )        \n   //static member inline Cons(formula      ) = Formula.New([]  , formula, ForConsolidated)  \n   //static member inline Cons(formula, dest) = Formula.New(dest, formula, ForConsolidated)  \n   //static member inline All (formula      ) = Formula.New([]  , formula, ForAll         )    \n   //static member inline All (formula, dest) = Formula.New(dest, formula, ForAll         )    \n   \n\nlet Map_adds kvs map = Seq.append (map |> Map.toSeq) kvs |> Map\n\ntype Calculation with\n    static member Input (name: string) dims  =\n        let c =\n          {\n            calId          = CalId <| Guid.NewGuid()\n            calName        = name.Replace(\"_\", \" \").Trim()\n            calDescription = \"\"\n            format         = \"#,##0.00\"\n            isText         = false\n            isInput        = true\n            isBalance      = false\n            calDims        = dims |> Seq.map (fun d -> d.dimId) |> Set \n            calFormulas    = [||]\n            cube           = None\n            properties     = System.Collections.Generic.Dictionary<string, string>()\n          }\n        model.modCalculations <- Array.append model.modCalculations [| c |]\n        c\n    static member Calc name dims = \n        let c = Calculation.Input name dims\n        c.isInput <- false\n        c \n    member        this.Name name           = this.calName     <- name                                                                         ; this\n    member inline this.Add (formula      ) = this.calFormulas <- Array.append this.calFormulas [| formula                                  |] ; this \n    member inline this.Base(expr         ) = this.calFormulas <- Array.append this.calFormulas [| Formula.New([]  , expr, ForBase        ) |] ; this \n    member inline this.Base(expr   , dest) = this.calFormulas <- Array.append this.calFormulas [| Formula.New(dest, expr, ForBase        ) |] ; this \n    member inline this.Cons(expr         ) = this.calFormulas <- Array.append this.calFormulas [| Formula.New([]  , expr, ForConsolidated) |] ; this \n    member inline this.Cons(expr   , dest) = this.calFormulas <- Array.append this.calFormulas [| Formula.New(dest, expr, ForConsolidated) |] ; this \n    member inline this.All (expr         ) = this.calFormulas <- Array.append this.calFormulas [| Formula.New([]  , expr, ForAll         ) |] ; this \n    member inline this.All (expr   , dest) = this.calFormulas <- Array.append this.calFormulas [| Formula.New(dest, expr, ForAll         ) |] ; this \n    member inline this.For (es: ElmReference list) = { this.Slice with sliDims = Map_adds (List.map (fun (e:ElmReference) -> e.DimId, e) es) this.Slice.sliDims } \n    member        this.AddFormulas fs = Array.append this.calFormulas (fs |> Seq.toArray)\n    member        this.withCube (model: Model) f = this.cube |> Option.bind model.GetCube |> swap Option.bind <| f\n\ntype Dimension with \n    static member New(name, isCalcDim) =\n        let d =\n          {\n            dimId          = DimId <| Guid.NewGuid()\n            dimName        = name\n            dimPrefix      = \"\"\n            dimType        = DtOther\n            defaultElm     = None\n            dimElements    = [|  |]\n            dimAttributes  = [|  |]      \n            isCalcDim      = isCalcDim\n          }\n        model.modDims <- Array.append model.modDims [| d |]\n        d\n    static member New     name  = Dimension.New(name, false)\n    static member NewCalc name  = Dimension.New(name, true )\n    member inline this.Item (it) : ElmReference = \n        match toExpT it with \n        | ExtString s1 -> let s2 = s1.Replace(\"_\", \" \")\n                          let elm =\n                             this.dimElements\n                             \n                             |> Seq.tryFind (fun e -> e.elmName = s2)\n                             |> Option.defaultWith (fun () -> \n                                 let newE = Element.New s2\n                                 this.dimElements <- Array.append this.dimElements [| newE |]\n                                 newE\n                             )\n                          ElemFixed  (this.dimId, elm.elmId) \n        | exp          -> ElemDynamic(this.dimId, exp                         )  \n    //member inline this.__     it     = this.Item it\n    //member inline this.M      it     = this.Item it\n    //member inline this.E      it     = this.Item it\n    //member inline this.I      it     = this.Item it\n    member        this.Prefix pr     = this.dimPrefix <- pr   ; this\n    member        this.DType  dt     = this.dimType   <- dt   ; this\n    member        this.Name   name   = this.dimName   <- name ; this\n        \ntype Rule with\n    static member inline New(dest, exp, typ) =\n          {\n              rulId          = RulId <| Guid.NewGuid()\n              rulDestination = dest\n              rulDescription = \"\"\n              rulExpression  = toExpA exp\n              rulType        = typ\n              rulOrder       = \"A\"\n              rulSourceId    = None\n          }\n    static member inline New(dest, exp, typ) = Rule.New(dest.sliDims |> Map.toList |> List.map snd, exp, typ)\n    member this.Conso = { this with rulType = ForConsolidated }    \n\ntype Cube with\n    static member New(name, dims, mDimO, cType) = \n        let c =\n            {\n              cubId      = CubId <| Guid.NewGuid()\n              cubName    = name\n              cubDims    = dims\n              cubRules   = Map.empty\n              measureDim = mDimO\n              cubType    = cType\n            }\n        model.modCubes <- Array.append model.modCubes [| c |]\n        c\n    static member NewCalc(name, dims, mDimO) = Cube.New(name, dims                                             , mDimO, CtCalc )\n    static member New    (name, dims, mDimO) = Cube.New(name, dims |> Seq.map (fun d -> d.dimId) |> Seq.toArray, mDimO, CtOther) \n    member inline this.AddRule key rule      = this.cubRules <- Map.add key rule this.cubRules ; this \n    //member inline this.Calc ()    = { this with cubType = CtCalc } \n    member inline this.For (es: ElmReference list) = { this.Slice with sliDims = Map_adds (List.map (fun (e:ElmReference) -> e.DimId, e) es) this.Slice.sliDims } \n\n","parent":{"$":0,"Item":"002fe5c4-6032-4259-a8dc-9afa8f5f7742"},"predecessors":[{"$":0,"Item":"657c8f34-c917-4659-825d-c9ead206efcf"}],"id":{"$":0,"Item":"4c64379b-83c7-4785-874d-99271ccf1859"},"expanded":true,"level":0,"properties":{}},{"name":"RuleText","content":"type Operator with\n    member this.RuleText isText =\n        match isText, this with\n        | _    , OpAdd      -> \"+\"\n        | _    , OpSubtract -> \"-\"\n        | _    , OpMultiply -> \"*\"\n        | _    , OpDivide   -> \"/\"\n        | _    , OpAnd      -> \"and\"\n        | _    , OpOr       -> \"or\"   \n        | false, OpEQ       -> \"=\"\n        | false, OpNE       -> \"<>\"\n        | false, OpGT       -> \">\"\n        | false, OpGE       -> \">=\"\n        | false, OpLT       -> \"<\"\n        | false, OpLE       -> \"<=\"\n        | true , OpEQ       -> \"@=\"\n        | true , OpNE       -> \"@<>\"\n        | true , OpGT       -> \"@>\"\n        | true , OpGE       -> \"@>=\"\n        | true , OpLT       -> \"@<\"\n        | true , OpLE       -> \"@<=\"\n\ntype Element with\n    member this.RuleText = sprintf \"'%s'\" this.elmName       \n\ntype Model with\n    member this.ElementText dId eId = ((this.GetDim dId).GetElement eId).RuleText\n\ntype Dimension with\n    member this.DefaultElementText = \n        this.defaultElm \n        |>> this.GetElement \n        |> Option.defaultWith (fun () -> this.dimElements.[0])\n        |> fun elm -> elm.RuleText\n\nlet allFixedRefs sliDims =\n    sliDims \n    |> Seq.exists (fun (x:Collections.Generic.KeyValuePair<DimId,ElmReference>) -> \n        match x.Value with\n        | ElemFixed   _                \n        | ElemDynamic(_, ExtString(_)) -> false\n        | _                            -> true\n    )\n    |> not\n\ntype Cube with\n    member this.MeasureDim     (model: Model) = this.measureDim       |> Option.map model.GetDim\n    member this.MeasureDimName (model: Model) = this.MeasureDim model |> Option.map (fun d -> d.dimName) \n\ntype ElmReference with\n    member this.RuleText modcub =\n        match this with\n        | ElemFixed   (dId, eId) -> model.ElementText dId eId\n        | ElemDynamic (dId, exT) -> exT.RuleText modcub\n    member this.FixedText modcub = sprintf \"%s: %s\" (model.GetDim this.DimId).dimName <| this.RuleText modcub \n\nand  Calculation with\n    member this.MeasureDimName (model: Model) = this.cube |> Option.bind (fun cId -> (model.GetCube cId).Value.MeasureDimName model ) |> Option.defaultValue \"MXXX\" \n    member this.MeasureDimId   (model: Model) = this.cube |> Option.bind (fun cId -> (model.GetCube cId).Value.measureDim  )\n    member this.RuleTextRef model = sprintf \"%s: '%s'\" <| this.MeasureDimName model <| this.calName\n        \n\nand  Slice with        \n    member this.RuleText (model: Model, cubId: CubId) =\n        let cub, refs =\n            match this.cube, this.calculation with\n            | Some cub, _         -> cub                                   , this.sliDims\n            | _       , Some clId -> let calc = model.GetCalc clId\n                                     calc.cube |> Option.defaultValue cubId, calc.MeasureDimId model\n                                                                             |>> fun dId -> Map.add dId (ElemDynamic <| (dId, ExtString calc.calName))\n                                                                             |> Option.defaultValue id   \n                                                                             <| this.sliDims\n            | _       , _         -> cubId                                 , this.sliDims                \n        if cub = cubId && allFixedRefs this.sliDims then\n            refs\n            |> Seq.map (fun x -> x.Value.FixedText (model, cubId))\n            |> String.concat \", \"\n            |> sprintf \"[%s]\"\n        else\n            let cubeS       = (model.GetCube cub).Value\n            let contextDims = model.GetCube cubId |>> (fun cub -> cub.cubDims) |> Option.defaultValue [||]\n            cubeS.cubDims\n            |>> fun d ->\n                    refs \n                    |> Map.tryFind d\n                    |>>                    fun x -> x.RuleText (model, cubId)\n                    |> Option.defaultWith (fun () -> \n                        let dim = model.GetDim d\n                        if   Seq.exists ((=) d) contextDims\n                        then \"!\" + dim.dimName\n                        else dim.DefaultElementText\n                    )\n            |> String.concat \", \"\n            |> sprintf \"DB('%s', %s)\" cubeS.cubName\n\nand  ExpressionNumber with\n    member this.RuleText modcub =\n        match this with\n        | ExnNA                     -> \"#NA\"\n        | ExnStet                   -> \"STET\"\n        | ExnSlice      slc         -> slc.RuleText modcub\n        | ExnNumber     fn          -> sprintf \"%f\" fn\n        | ExnIf        (cn, th, el) -> sprintf \"IF(%s, %s, %s)\" <| cn.RuleText modcub <| th.RuleText modcub <| el.RuleText modcub\n        | ExnOperationN(op, n1, n2) -> sprintf \"(%s) %s (%s)\"   <| n1.RuleText modcub <| op.RuleText false <| n2.RuleText modcub\n        | ExnOperationT(op, n1, n2) -> sprintf \"(%s) %s (%s)\"   <| n1.RuleText modcub <| op.RuleText true  <| n2.RuleText modcub\n        | ExnOperationI(op, n1, n2) -> sprintf \"(%s) %s (%s)\"   <| n1.RuleText modcub <| op.RuleText false <| n2.RuleText modcub\n        | ExnFunction  (func, exs ) -> exs |> Seq.map (fun ex -> ex.RuleText modcub) |> String.concat \",\" |> sprintf \"Function(%s)\"\n        | ExnMax       (    n1, n2) -> sprintf \"MAX(%s, %s)\"    <| n1.RuleText modcub <| n2.RuleText modcub\n        | ExnMin       (    n1, n2) -> sprintf \"MIN(%s, %s)\"    <| n1.RuleText modcub <| n2.RuleText modcub\n        | ExnDeIsChild (dn, pn, cn) -> sprintf \"DE.IsChild(%s, %s, %s)\"<| dn.RuleText modcub <| pn.RuleText modcub <| cn.RuleText modcub\n\nand  ExpressionText with\n    member this.RuleText modcub =\n        match this with\n        | ExtNA                     -> \"#NA\"\n        | ExtStet                   -> \"STET\"\n        | ExtSlice      slc         -> slc.RuleText modcub\n        | ExtString     str         -> sprintf \"'%s'\" <| str.Replace(\"'\", \"''\") \n        | ExtDimElement dId         -> \"!\" + (model.GetDim dId).dimName\n        | ExtDimName    dId         -> sprintf \"'%s'\" <| (model.GetDim dId).dimName\n        | ExtIf        (cn, th, el) -> sprintf \"IF(%s, %s, %s)\" <| cn.RuleText modcub <| th.RuleText modcub <| el.RuleText modcub\n        | ExtFunction  (fn, exs)    -> exs |> Seq.map (fun ex -> ex.RuleText modcub) |> String.concat \",\" |> sprintf \"Function(%s)\"\n        | ExtSubSt     (tx, st, ln) -> sprintf \"SUBST(%s, %s, %s)\" <| tx.RuleText modcub <| st.RuleText modcub <| ln.RuleText modcub\n\nand  ExpressionAny with\n    member this.RuleText modcub =\n        match this with\n        | ExiNA                     -> \"#NA\"\n        | ExiStet                   -> \"STET\"\n        | ExiSlice      slc         -> slc.RuleText modcub\n        | ExNumeric     nmb         -> nmb.RuleText modcub\n        | ExText        txt         -> txt.RuleText modcub\n        | ExiIf        (cn, th, el) -> sprintf \"IF(%s, %s, %s)\" <| cn.RuleText modcub <| th.RuleText modcub <| el.RuleText modcub\n\ntype Rule with\n    member this.Destination (model: Model, cub: CubId)  =\n        this.rulDestination\n        |> Seq.map (function\n                    | ElemFixed   (dId, eId           ) -> sprintf \"%s: '%s'\" (model.GetDim dId).dimName <| model.ElementText dId eId\n                    | ElemDynamic (dId, ExtString(txt)) -> sprintf \"%s: '%s'\" (model.GetDim dId).dimName <| txt                      \n                    | ElemDynamic (dId, exp           ) -> exp.RuleText(model, cub)                      \n                    )\n        |> String.concat \", \"\n        |> sprintf \"[%s]\"\n    member this.AleaRule modcub =\n        sprintf \"%s %s: %s\"\n        <| this.Destination modcub\n        <| match this.rulType with\n           | ForBase         -> \"B\"\n           | ForConsolidated -> \"C\"\n           | ForAll          -> \"A\"\n        <| this.rulExpression.RuleText modcub\n\n","parent":{"$":0,"Item":"002fe5c4-6032-4259-a8dc-9afa8f5f7742"},"predecessors":[{"$":0,"Item":"4c64379b-83c7-4785-874d-99271ccf1859"}],"id":{"$":0,"Item":"8bb1ad32-3662-43ec-986b-887f6fa2a511"},"expanded":true,"level":0,"properties":{}},{"name":"Prepare Model","content":"\nopen Useful\n\ntype Model with\n    member this.DimCombinations() =\n        this.modCalculations\n        |>> fun c -> c.calDims\n        |>  Seq.distinct \n\n    member this.CubePrefix    = \"Z\"\n    member this.MeasurePrefix = \"M\"\n\n    member this.OrderedDims dimIds =\n            this.modDims \n            |>  Seq.filter (fun d -> dimIds |> Seq.exists ((=) d.dimId) ) \n\n    member this.AutoName dimIds =\n        let nameBase =\n            this.OrderedDims dimIds\n            |>> fun d -> d.dimPrefix \n            |>  String.concat \"\"\n        let similar =\n            this.modCubes\n            |> Seq.choose (fun c -> \n                match this.CubePrefix + nameBase with\n                | n when c.cubName          = n -> Some -1\n                | n when c.cubName.StartsWith n -> c.cubName.[nameBase.Length + 1..] |> parseInt\n                | _                             -> None\n            ) \n        nameBase\n      + if similar |> Seq.isEmpty then \"\" else similar |> Seq.max |> ((+) 1) |> sprintf \"%d\"\n\n    member this.DimIds = this.modDims |>> fun d -> d.dimId\n    member this.FixForDimensions() =\n        //this.modCubes        <- this.modCubes        |>> fun cub -> { cub with cubDims = cub.cubDims |> Array.filter (fun d -> Seq.exists ((=) d) this.DimIds) }\n        this.modCalculations <- this.modCalculations |>> fun cal -> { cal with calDims = cal.calDims |> Set.filter   (fun d -> Seq.exists ((=) d) this.DimIds) }\n\n    member this.NewCalcCube dimIds =\n        let name = this.AutoName dimIds\n        let mDim = Dimension.NewCalc(this.MeasurePrefix + name)\n        let orderedDimIds = \n            this.OrderedDims dimIds\n            |>  Seq.append <| [ mDim ]\n            |>> fun d -> d.dimId \n            |>  Seq.toArray\n        this.modDims  <- Array.append this.modDims  [| mDim                                                                 |]\n        this.modCubes <- Array.append this.modCubes [| Cube.NewCalc(this.CubePrefix + name, orderedDimIds, Some mDim.dimId) |]\n\n    member this.FixCalcsAndCubes() =\n        let calNoCube = this.modCalculations |> Array.filter (fun c -> c.cube >>= this.GetCube |> Option.isNone)\n        if not <| Seq.isEmpty calNoCube then\n            calNoCube\n            |>> fun c -> c.calDims\n            |>  Seq.distinct\n            |>  Seq.filter   (fun ds -> this.GetCalcCube ds |> Option.isNone)\n            |>  Seq.iter     this.NewCalcCube\n            this.modCalculations <- \n                this.modCalculations\n                |>> fun oldC ->\n                        calNoCube \n                        |> Seq.tryFind (fun newC -> newC.calId = oldC.calId)\n                        |>>             fun newC -> { newC with Calculation.cube = this.GetCalcCube newC.calDims |>> fun cub -> cub.cubId }  \n                        |> Option.defaultValue oldC\n                \n        //let dimCombinations = this.modCalculations |> Seq.map (fun cal -> cal.calDims) |> Seq.distinct |> Seq.toArray\n        //this.modCubes <- this.modCubes |> Array.filter (fun cub -> Array.exists ((=) cub.cubDims) dimCombinations)\n        \n    member this.PrepareModel() =\n        this.FixForDimensions()\n        this.FixCalcsAndCubes()\n    ","parent":{"$":0,"Item":"002fe5c4-6032-4259-a8dc-9afa8f5f7742"},"predecessors":[{"$":0,"Item":"af2b60c6-a99f-433d-b938-f59fefe66c01"},{"$":0,"Item":"4c64379b-83c7-4785-874d-99271ccf1859"}],"id":{"$":0,"Item":"39111a54-edb5-4bf3-9f94-479c2cac69de"},"expanded":true,"level":0,"properties":{}},{"name":"Alea Interfase","content":"#r @\"Compiled\\Alea\\Interop.MdsAut.dll\"\nopen Useful\n\ntype ErrAlea(errn, msg, warning) =\n    interface ErrMsg with\n        member this.ErrMsg   : string = msg\n        member this.IsWarning: bool   = warning\n    override this.ToString() = (this :> ErrMsg).ErrMsg\n\nmodule Alea =\n\n    let private g  = new MdsAut.GeneralClass()\n    let private s  = new MdsAut.ServersClass()\n    let private d  = new MdsAut.DimensionsClass()\n    let private c  = new MdsAut.TablesClass()\n    let private at = new MdsAut.AttributeTablesClass()\n    let private e  = new MdsAut.ElementsClass()\n    let private l  = new MdsAut.DataCellsClass()\n\n    let res = g.MdsInit(0)\n\n    let callR<'T> (v: obj) =\n        let err  = g.MdsGetLastError()\n        let errN = unbox<int> err\n        if  errN <> 0 && v = err\n        then Result.fail (ErrAlea(errN, g.MdsError errN |> unbox<string>, false))\n        else v |> unbox<'T> |> Result.succeed\n\n    let (|*>) result f = Result.bind f result\n\n    type ServerOlap(address: string) =\n        member this.Address     = address\n        member this.connectR    = s.ServerConnectEx (address, \"Admin\", \"\") |> callR<bool>\n        member this.disconnectR = s.ServerDisconnect(address             ) |> callR<bool>\n\n    type DimOlap(dimname: string, server: ServerOlap) = \n        member this.server                                  = server\n        member this.withR<'T>                f              = f this.server.Address dimname |> callR<'T>\n        member this.DimensionImport          df ef del desc = this.withR<bool  >    <| fun servAd dimN -> d.DimensionImport        (servAd, dimN, df, ef, del, desc)\n        member this.editBeginR               clear desc     = this.withR<bool  >    <| fun servAd dimN -> d.DimensionEditBegin     (servAd, dimN, clear, desc |> Option.defaultValue dimN)\n        member this.addElementR              eType elem parent weight = this.withR<bool  >    <| fun servAd dimN -> d.DimensionEditAddElement(servAd, dimN, eType, elem, parent, weight, \"\")\n        member this.editCommitR              commit         = this.withR<bool  >    <| fun servAd dimN -> d.DimensionEditCommit    (servAd, dimN, commit) \n        member this.elementsCountR                          = this.withR<int   >    <| fun servAd dimN -> e.ElementsCount          (servAd, dimN) \n        member this.elementsNameR            i              = this.withR<string>    <| fun servAd dimN -> e.ElementsName           (servAd, dimN, i) \n        member this.Name                                    = dimname\n     \n    type ElemOlap(elemname: string, dim: DimOlap) =\n        member this.dimension                                = dim\n        member this.withR<'T>                f               = this.dimension.withR<'T>    <| fun servAd dimN    -> f servAd dimN elemname\n        member this.childrenCountR                           = this.withR<int   >    <| fun servAd dimN elemN -> e.ElementChildrenCount   (servAd, dimN, elemN) \n        member this.childrenNameR      i                     = this.withR<string>    <| fun servAd dimN elemN -> e.ElementChildrenName    (servAd, dimN, elemN, i)\n        member this.childrenR                                =     Result.result {\n                                                                       let! n     = this.childrenCountR \n                                                                       let! elems = seq[ for i in 1..n do\n                                                                                            yield this.childrenNameR     i\n                                                                                    ] |> Result.seqCheck\n                                                                       return elems |> Seq.map (fun e -> ElemOlap(e, this.dimension)) |> Seq.toArray\n                                                                   }\n    type DimOlap with\n        member this.elementsR                                =     Result.result {\n                                                                       let! n     = this.elementsCountR\n                                                                       let! names = seq[ for i in 1..n do\n                                                                                            yield this.elementsNameR     i\n                                                                                    ] |> Result.seqCheck\n                                                                       let  elems = names |> Seq.map (fun e -> ElemOlap(e, this))\n                                                                       return elems |> Seq.toArray\n                                                                   }\n        member this.inputsR                                 =      Result.result {\n                                                                       let! n     = this.elementsCountR \n                                                                       let! elems = seq[ for i in 1..n do\n                                                                                            yield\n                                                                                                Result.result {\n                                                                                                    let! elemN  = this.elementsNameR     i\n                                                                                                    let  eOlap  = ElemOlap(elemN, this)\n                                                                                                    let! childN = eOlap.childrenCountR\n                                                                                                    return \n                                                                                                        if childN = 0 \n                                                                                                        then Some eOlap\n                                                                                                        else None\n                                                                                                }\n                                                                                    ]\n                                                                                    |> Result.seqCheck\n                                                                       return elems |> Seq.choose id |> Seq.toArray\n                                                                   }\n\n    type AttTableOlap(table: int16, dim: DimOlap) =\n        member this.dimension                               = dim\n        member this.nS                                      = table\n        member this.withR<'T>          f                    = this.dimension.withR<'T>    <| fun servAd dimN    -> f servAd dimN this.nS\n        member this.deleteR                                 = this.withR<bool>            <| fun servAd dimN nS -> at.ATableDelete     (servAd, dimN, nS |> int)\n        member this.createBeginR    ()                      = this.withR<int >            <| fun servAd dimN nS -> at.ATableCreateBegin(servAd, dimN, nS - 1s  )\n        member this.fieldAddR       handle name desc nType len dec = at.ATableFieldAdd(int16 handle, name, desc, nType, len, dec) |> callR<bool>\n        member this.createCommitR   handle                  = at.ATableCreateCommit(int16 handle) |> callR<bool>\n\n    type AttFieldOlap(name: string, table: AttTableOlap) =\n        member this.attTable                                = table\n        member this.name                                    = name\n        member this.withR<'T>          f                    = this.attTable.withR<'T>     <| fun servAd dimN nS       -> f servAd dimN nS this.name\n        member this.getInfoDescR                            = this.withR<string>          <| fun servAd dimN nS field -> at.ATableFieldGetInfo(servAd, dimN, nS, field, 2)\n        member this.getInfoAtypR                            = this.withR<int16 >          <| fun servAd dimN nS field -> at.ATableFieldGetInfo(servAd, dimN, nS, field, 3)\n        member this.getInfoLengthR                          = this.withR<int16 >          <| fun servAd dimN nS field -> at.ATableFieldGetInfo(servAd, dimN, nS, field, 4)\n        member this.getInfoDecimalR                         = this.withR<int16 >          <| fun servAd dimN nS field -> at.ATableFieldGetInfo(servAd, dimN, nS, field, 5)\n        member this.putValueR          v elem               = this.withR<bool  >          <| fun servAd dimN nS field -> at.ATableFieldPutValue(v, servAd, dimN, nS |> int, elem, field)\n\n    type CubeOlap(cube: string, server: ServerOlap) =\n        member this.server                                   = server\n        member this.withR<'T>              f                 = f this.server.Address cube |> callR<'T>\n        static member bulkTransferBeginR  lType              = l.BulkTransferBegin(lType)             |> callR<bool>\n        static member bulkTransferCommitR lType stop log     = l.BulkTransferCommit(lType, stop, log) |> callR<bool>\n        member this.create                (dims: string[])   = this.withR<int       >        <| fun servAd cubeN -> c.TablesAdd(servAd, cubeN, cubeN, dims.[0], dims.[1]\n                                                                                                                       , Array.tryItem  2 dims, Array.tryItem  3 dims, Array.tryItem  4 dims, Array.tryItem  5 dims\n                                                                                                                       , Array.tryItem  6 dims, Array.tryItem  7 dims, Array.tryItem  8 dims, Array.tryItem  9 dims\n                                                                                                                       , Array.tryItem 10 dims, Array.tryItem 11 dims, Array.tryItem 12 dims, Array.tryItem 13 dims\n                                                                                                                       , Array.tryItem 14 dims, Array.tryItem 15 dims, Array.tryItem 16 dims, Array.tryItem 17 dims\n                                                                                                                       , Array.tryItem 18 dims, Array.tryItem 19 dims)\n        member this.delete                 ()                = this.withR<int       >        <| fun servAd cubeN -> c.TableKill(servAd, cubeN)\n        member this.setMeasure             dim               = this.withR<int       >        <| fun servAd cubeN -> c.TableSetMeasureDimension(servAd, cubeN, dim)\n        member this.dimensionsCountR                         = this.withR<int       >        <| fun servAd cubeN -> c.TableDimensionsCount(servAd, cubeN)\n        member this.exists                                   = this.dimensionsCountR |> Result.map ((>) 0) |> Result.ifError false  \n        member this.dimensionsNameR        i                 = this.withR<string    >        <| fun servAd cubeN -> c.TableDimensionsName (servAd, cubeN, i)\n        member this.putValueExR            v elems           = this.withR<bool      >        <| fun servAd cubeN -> l.DataPutValueEx (servAd, cubeN, v, elems)\n        member this.dimensionsR                              =     Result.result {\n                                                                        let! n    = this.dimensionsCountR\n                                                                        let! dims = seq [\n                                                                                         for i in 1..n do \n                                                                                             yield (this.dimensionsNameR    i)\n                                                                                    ]\n                                                                                    |> Result.seqCheck\n                                                                        return dims |> Seq.map (fun dimN -> DimOlap(dimN, this.server)) |> Seq.toArray\n                                                                   } \n","parent":{"$":0,"Item":"002fe5c4-6032-4259-a8dc-9afa8f5f7742"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"65a5556d-d78e-4afb-8736-cb9f71aaf19f"},"expanded":true,"level":0,"properties":{}},{"name":"Update Model","content":"#r \"..\\packages\\FSharpPlus\\lib\\net40\\FSharpPlus.dll\"\nopen FSharpPlus.Lens\n\ntype Model with\n    member this.ServerOlap         = Alea.ServerOlap this.server\n    member this.GetDimension dimId = this.modDims |> Seq.tryFind (fun d -> d.dimId = dimId)\n\ntype Cube with\n    member this.Dims (model:Model)  = \n        model.modDims\n        |> Array.filter(fun d -> this.cubDims |> Set.exists ((=) d.dimId) )\n    member this.CreateAttTable dim =\n        Result.result {\n            let  att    = Alea.AttTableOlap(1s, dim)\n            let! handle = att.createBeginR()\n            let! res    = att.fieldAddR handle \"Type\"          \"Type\"   0s  10s 0s  \n            let! res    = att.fieldAddR handle \"Format_String\" \"Format\" 0s 254s 0s\n            let! res    = att.createCommitR handle \n            ()\n        }\n    member this.CreateMeasureDimension(model: Model) =\n        Result.result {\n            do!  Result.tryProtection()\n            use  temp1 = new UsefulDotNet.TempFileName()\n            model.modCalculations\n            |> Seq.filter (fun c -> c.cube = Some this.cubId)\n            |> Seq.map    (fun c -> sprintf \"%s    %s\" (if c.isText then \"S\" else \"N\" ) c.calName)\n            |> String.concat \"\\n\"\n            |> fun txt -> System.IO.File.WriteAllText(temp1.Name, txt)\n            use  temp2  = new UsefulDotNet.TempFileName()\n            let  dim    = Alea.DimOlap((this.MeasureDimName model).Value, model.ServerOlap)\n            let! res    = dim.DimensionImport temp1.Name  temp2.Name  '\\t'  (\"Measure for \" + this.cubName)\n            let  att    = Alea.AttTableOlap(int16 1, dim)\n            let  res    = this.CreateAttTable dim\n            let  fldTyp = Alea.AttFieldOlap(\"Type\"         , att)\n            let  fldFmt = Alea.AttFieldOlap(\"Format_String\", att)\n            model.modCalculations\n            |> Seq.iter (fun c ->\n                fldTyp.putValueR c.Type   c.calName |> ignore\n                fldFmt.putValueR c.format c.calName |> ignore\n            )\n        }\n    member this.CreateCube (model: Model) =\n        Result.result {\n            do!  this.CreateMeasureDimension model\n            let  cube      = Alea.CubeOlap(this.cubName, model.ServerOlap)\n            let  dims      = this.Dims model\n            let  dimNames  = dims |> Array.map (fun d -> d.dimName.ToUpper())\n            let  dimsOlapR = cube.dimensionsR \n            let  exists = \n                dimsOlapR \n                |> Result.map (fun dimsOlap ->\n                    dimNames = (dimsOlap |> Array.map (fun dimOlap -> dimOlap.Name.ToUpper()))\n                )\n                |> Result.ifError false\n            if not exists then\n                cube.delete |> ignore\n                let! res = cube.create dimNames\n                let! res = cube.setMeasure <| (this.MeasureDimName model).Value\n                ()\n            ()\n        }\n    \n\ntype Model with\n    member this.DimCombinations() =\n        this.modCalculations\n        |> Seq.map (fun c -> c.calDims)\n        |> Seq.distinct \n\n    member this.CubePrefix    = \"Z\"\n    member this.MeasurePrefix = \"M\"\n\n    member this.AutoName dims =\n        let nameBase =\n            this.modDims\n            |> Seq.filter (fun d -> dims |> Seq.exists ((=) d.dimId) ) \n            |> Seq.map    (fun d -> d.dimPrefix )\n            |> String.concat \"\"\n        let similar =\n            this.modCubes\n            |> Seq.choose (fun c -> \n                match this.CubePrefix + nameBase with\n                | n when c.cubName          = n -> Some -1\n                | n when c.cubName.StartsWith n -> c.cubName.[nameBase.Length + 1..] |> parseInt\n                | _                             -> None\n            ) \n        nameBase\n      + if similar |> Seq.isEmpty then \"\" else similar |> Seq.max |> ((+) 1) |> sprintf \"%d\"\n\n    member this.FixForDimensions() =\n        let dimIds = this.modDims |> Array.map (fun d -> d.dimId)\n        this.modCubes <-\n            this.modCubes\n            |> Array.map (fun cub ->\n                { cub with cubDims = cub.cubDims |> Set.filter (fun d -> Seq.exists ((=) d) dimIds) }\n            )\n        this.modCalculations <-\n            this.modCalculations\n            |> Array.map (fun cal ->\n                { cal with calDims = cal.calDims |> Set.filter (fun d -> Seq.exists ((=) d) dimIds) }\n            )\n    member this.NewCube ds = \n        let name = this.AutoName ds\n        let mDim = Dimension.New <| this.MeasurePrefix + name\n        this.modDims  <- Array.append this.modDims  [| mDim                                      |]\n        this.modCubes <- Array.append this.modCubes [| Cube.New(this.CubePrefix + name, ds, Some mDim.dimId) |]\n\n    member this.FixCalcsAndCubes() =\n        let calNoCube, calCube = this.modCalculations |> Array.partition (fun c -> c.cube |> Option.bind this.GetCube |> Option.isNone)\n        if not <| Seq.isEmpty calNoCube then\n            calNoCube\n            |> Seq.map    (fun c -> c.calDims)\n            |> Seq.distinct\n            |> Seq.filter (fun ds -> this.GetCube ds |> Option.isNone)\n            |> Seq.iter   this.NewCube\n            let calNews = \n                calNoCube \n                |> Seq.map (fun c -> { c with cube = this.GetCube c.calDims |> Option.map (fun cub -> cub.cubId) } ) \n                |> Seq.toArray\n                |> Array.append calCube\n            this.modCalculations <- calNews\n        let dimCombinations = this.modCalculations |> Seq.map (fun cal -> cal.calDims) |> Seq.distinct |> Seq.toArray\n        this.modCubes <- this.modCubes |> Array.filter (fun cub -> Array.exists ((=) cub.cubDims) dimCombinations)\n        \n    member this.UpdateModel() =\n        this.FixForDimensions()\n        this.FixCalcsAndCubes()\n        this.modCubes |> Seq.iter (fun cub -> cub.CreateCube this |> Result.mapMsgs Result.countMessages |> snd |> printfn \"%s\")\n    ","parent":{"$":0,"Item":"002fe5c4-6032-4259-a8dc-9afa8f5f7742"},"predecessors":[{"$":0,"Item":"af2b60c6-a99f-433d-b938-f59fefe66c01"},{"$":0,"Item":"4137cad8-fd64-426e-98de-16a92a56388d"},{"$":0,"Item":"65a5556d-d78e-4afb-8736-cb9f71aaf19f"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"4c64379b-83c7-4785-874d-99271ccf1859"}],"id":{"$":0,"Item":"ffce841e-404b-42d5-945c-cb2e9f9a67e3"},"expanded":true,"level":0,"properties":{}},{"name":"Syntax","content":"module Syntax =   \n    let And = (&&)\n\n    type HelperAdd      = HelperAdd      with static member inline (?<-) (x            , HelperAdd     , y) = ExnOperationN (OpAdd     , toExpN    x      , toExpN    y)\n    type HelperSubtract = HelperSubtract with static member inline (?<-) (x            , HelperSubtract, y) = ExnOperationN (OpSubtract, toExpN    x      , toExpN    y)\n    type HelperMultiply = HelperMultiply with static member inline (?<-) (x            , HelperMultiply, y) = ExnOperationN (OpMultiply, toExpN    x      , toExpN    y)\n    type HelperDivide   = HelperDivide   with static member inline (?<-) (x            , HelperDivide  , y) = ExnOperationN (OpDivide  , toExpN    x      , toExpN    y)\n    type HelperEQ       = HelperEQ       with static member inline (?<-) (x            , HelperEQ      , y) = ExnOperationN (OpEQ      , toExpN    x      , toExpN    y)\n    type HelperNE       = HelperNE       with static member inline (?<-) (x            , HelperNE      , y) = ExnOperationN (OpNE      , toExpN    x      , toExpN    y)\n    type HelperGT       = HelperGT       with static member inline (?<-) (x            , HelperGT      , y) = ExnOperationN (OpGT      , toExpN    x      , toExpN    y)\n    type HelperGE       = HelperGE       with static member inline (?<-) (x            , HelperGE      , y) = ExnOperationN (OpGE      , toExpN    x      , toExpN    y)\n    type HelperLT       = HelperLT       with static member inline (?<-) (x            , HelperLT      , y) = ExnOperationN (OpLT      , toExpN    x      , toExpN    y)\n    type HelperLE       = HelperLE       with static member inline (?<-) (x            , HelperLE      , y) = ExnOperationN (OpLE      , toExpN    x      , toExpN    y)\n    type HelperEQx      = HelperEQx      with static member inline (?<-) (x            , HelperEQx     , y) = ExnOperationT (OpEQ      , toExpT    x      , toExpT    y)\n    type HelperNEx      = HelperNEx      with static member inline (?<-) (x            , HelperNEx     , y) = ExnOperationT (OpNE      , toExpT    x      , toExpT    y)\n    type HelperGTx      = HelperGTx      with static member inline (?<-) (x            , HelperGTx     , y) = ExnOperationT (OpGT      , toExpT    x      , toExpT    y)\n    type HelperGEx      = HelperGEx      with static member inline (?<-) (x            , HelperGEx     , y) = ExnOperationT (OpGE      , toExpT    x      , toExpT    y)\n    type HelperLTx      = HelperLTx      with static member inline (?<-) (x            , HelperLTx     , y) = ExnOperationT (OpLT      , toExpT    x      , toExpT    y)\n    type HelperLEx      = HelperLEx      with static member inline (?<-) (x            , HelperLEx     , y) = ExnOperationT (OpLE      , toExpT    x      , toExpT    y)\n    type HelperAnd      = HelperAnd      with static member inline (?<-) (x            , HelperAnd     , y) = ExnOperationN (OpAnd     , toExpN    x      , toExpN    y)\n    type HelperOr       = HelperOr       with static member inline (?<-) (x            , HelperOr      , y) = ExnOperationN (OpOr      , toExpN    x      , toExpN    y)\n    \n    let inline ( +   )  x y = x ? (HelperAdd     ) <- y\n    let inline ( -   )  x y = x ? (HelperSubtract) <- y\n    let inline ( *   )  x y = x ? (HelperMultiply) <- y\n    let inline ( /   )  x y = x ? (HelperDivide  ) <- y\n    let inline ( =   )  x y = x ? (HelperEQ      ) <- y\n    let inline ( <>  )  x y = x ? (HelperNE      ) <- y\n    let inline ( >   )  x y = x ? (HelperGT      ) <- y\n    let inline ( >=  )  x y = x ? (HelperGE      ) <- y\n    let inline ( <   )  x y = x ? (HelperLT      ) <- y\n    let inline ( <=  )  x y = x ? (HelperLE      ) <- y\n    let inline ( &&  )  x y = x ? (HelperAnd     ) <- y\n    let inline ( ||  )  x y = x ? (HelperOr      ) <- y\n     \n    let inline ( &=  ) x y = x ? (HelperEQx     ) <- y\n    let inline ( &<> ) x y = x ? (HelperNEx     ) <- y\n    let inline ( &>  ) x y = x ? (HelperGTx     ) <- y\n    let inline ( &>= ) x y = x ? (HelperGEx     ) <- y\n    let inline ( &<  ) x y = x ? (HelperLTx     ) <- y\n    let inline ( &<= ) x y = x ? (HelperLEx     ) <- y\n     \n    let inline ( ?   ) (d:Dimension) e = d.[ toExpT e ]\n    let inline ( !   ) (d:Dimension)   = ExtDimElement d.dimId\n    \n    \n    let inline IF          (cond, thenR , elseR) = ExnIf       (toExpN cond, toExpN thenR , toExpN elseR)\n    let inline MAX         (v1  , v2           ) = ExnMax      (toExpN v1  , toExpN v2                  )\n    let inline MIN         (v1  , v2           ) = ExnMin      (toExpN v1  , toExpN v2                  )\n    let inline DE_ISCHILD  (dim , parent, child) = ExnDeIsChild(toExpT dim , toExpT parent, toExpT child)\n    \n    let inline IFt  (cond, thenR, elseR) = ExtIf   (toExpN cond, toExpT thenR, toExpT elseR)\n    let inline IFa  (cond, thenR, elseR) = ExiIf   (toExpN cond, toExpA thenR, toExpA elseR)\n    let inline SUBST(txt , from , len  ) = ExtSubSt(toExpT txt , toExpN from , toExpN len  )\n    \n    let ForAll = {\n                 sliDims       = Map.empty\n                 calculation   = None\n                 cube          = None\n    }\n    \n    let inline toForm0 e = Formula.New([], toExpA e, ForBase)\n    let inline addFormula  (c:Calculation) f dest forT = c.Add({ f with forDestination = dest ; forType = forT })\n    let inline addFormulaE (c:Calculation) e           = addFormula c (toForm0 e)\n    let inline toRule0 e = Rule.New([], toExpA e, ForBase)\n    let inline addRule     (c:Cube       ) r dest rulT = c.AddRule (RuleKey r.rulId) (Some { r with rulDestination = dest ; rulType = rulT })\n    let inline addRuleE    (c:Cube       ) e           = addRule c (toRule0 e)\n    \n(*    let elmRef2ElmId r =\n        match r with\n        | ElemFixed  (d, eId) -> d, eId\n        | ElemDynamic(d, exp) -> failwith <| sprintf \"dynamic references not allowed: %O\" (d, exp)\n        \n    let elmRefs2ElmIds rs = rs |> List.map elmRef2ElmId\n*)    \n    type HelperForm = HelperForm with\n        static member (?<-) (c:Cube       , HelperForm, l : ElmReference list) = fun dest rulT f -> addRule    c f l rulT\n        static member (?<-) (c:Calculation, HelperForm, f : Formula          ) = addFormula  c f \n        static member (?<-) (c:Calculation, HelperForm, e : ExpressionNumber ) = addFormulaE c e \n        static member (?<-) (c:Calculation, HelperForm, e : ExpressionText   ) = addFormulaE c e\n        static member (?<-) (c:Calculation, HelperForm, e : Slice            ) = addFormulaE c e\n        static member (?<-) (c:Calculation, HelperForm, e : Calculation      ) = addFormulaE c e\n        static member (?<-) (c:Calculation, HelperForm, e : bool             ) = addFormulaE c e\n        static member (?<-) (c:Calculation, HelperForm, e : int              ) = addFormulaE c e\n        static member (?<-) (c:Calculation, HelperForm, e : float            ) = addFormulaE c e\n        static member (?<-) (c:Calculation, HelperForm, e : string           ) = addFormulaE c e\n        static member (?<-) (c:Calculation, HelperForm, e : ExpressionAny    ) = addFormulaE c e \n        static member (?<-) (c:Calculation, HelperForm, l : ElmReference list) = fun dest forT f -> addFormula c f l forT\n    \n    let inline (<<|  )  c e = (c?(HelperForm)<-e) [] ForBase\n    let inline (<<|* )  c e = (c?(HelperForm)<-e) [] ForConsolidated\n    \n    type HelperForm2 = HelperForm2 with\n        static member (?<-) (add :Rule    -> Cube       , HelperForm2, r : Rule             ) = add(r        )\n        static member (?<-) (add :Rule    -> Cube       , HelperForm2, f : ExpressionNumber ) = add(toRule0 f) \n        static member (?<-) (add :Rule    -> Cube       , HelperForm2, f : ExpressionText   ) = add(toRule0 f)\n        static member (?<-) (add :Rule    -> Cube       , HelperForm2, f : Slice            ) = add(toRule0 f)\n        static member (?<-) (add :Rule    -> Cube       , HelperForm2, f : Calculation      ) = add(toRule0 f)\n        static member (?<-) (add :Rule    -> Cube       , HelperForm2, f : bool             ) = add(toRule0 f)\n        static member (?<-) (add :Rule    -> Cube       , HelperForm2, f : int              ) = add(toRule0 f)\n        static member (?<-) (add :Rule    -> Cube       , HelperForm2, f : float            ) = add(toRule0 f)\n        static member (?<-) (add :Rule    -> Cube       , HelperForm2, f : string           ) = add(toRule0 f)\n        static member (?<-) (add :Rule    -> Cube       , HelperForm2, f : ExpressionAny    ) = add(toRule0 f) \n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : Formula          ) = add(f        )\n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : ExpressionNumber ) = add(toForm0 f) \n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : ExpressionText   ) = add(toForm0 f)\n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : Slice            ) = add(toForm0 f)\n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : Calculation      ) = add(toForm0 f)\n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : bool             ) = add(toForm0 f)\n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : int              ) = add(toForm0 f)\n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : float            ) = add(toForm0 f)\n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : string           ) = add(toForm0 f)\n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : ExpressionAny    ) = add(toForm0 f) \n    \n    let inline (<<<)  p e = p?(HelperForm2)<-e\n    \n    let Calc  = Calculation.Calc\n    let Input = Calculation.Input\n    let NA    = ExnNA\n    \n    ","parent":{"$":0,"Item":"002fe5c4-6032-4259-a8dc-9afa8f5f7742"},"predecessors":[{"$":0,"Item":"4c64379b-83c7-4785-874d-99271ccf1859"}],"id":{"$":0,"Item":"547d9db7-67cb-4879-9568-e16a617b81b9"},"expanded":true,"level":0,"properties":{}},{"name":"Formula & Calculation Rules","content":"open Useful\n\nmodule CalcRules =\n    let eq = (=)\n    open Syntax\n    \n    type Formula with\n        member this.FormulaRule (model: Model) (calc: Calculation) (cube:Cube) =\n            model.withDims      <| fun tCalcDim dataTypeDim ->\n            let dest = if cube.ContainsDim dataTypeDim.dimId then\n                           let dataTypeDest = this.forDestination \n                                              |> swap Seq.tryPick \n                                              <| fun er -> if eq er.DimId dataTypeDim.dimId then Some er else None\n                           if   dataTypeDest.IsNone \n                           then dataTypeDim?Calculated_Value :: this.forDestination\n                           else this.forDestination\n                       else     this.forDestination\n            Rule.New(dest, this.forExpression, this.forType)\n            |> Some\n        member this.FormulaTextRule (model: Model) (calc: Calculation) (cube:Cube) =\n            model.withDims      <| fun tCalcDim dataTypeDim ->\n            calc.withCube model <| fun cube                 -> \n            if not <| cube.ContainsDim dataTypeDim.dimId then None else\n            let dataTypeDest = this.forDestination \n                               |> swap Seq.tryPick \n                               <| fun er -> if eq er.DimId dataTypeDim.dimId then Some er else None\n            if  dataTypeDest.IsSome then None else \n            Rule.New(dataTypeDim?Formula :: this.forDestination, ExtString <| sprintf \"%O\" this.forExpression, this.forType)\n            |> Some\n        member this.CreateFormulaRules (model: Model) (calc: Calculation) =\n            calc.withCube model <| fun cube        -> \n                let key1, rule1 = FormulaKey this.forId, this.FormulaRule     model calc cube\n                let key2, rule2 = ForTextKey this.forId, this.FormulaTextRule model calc cube\n                cube.AddRule key1 rule1 |> ignore\n                cube.AddRule key2 rule2 |> ignore\n                None\n            |> ignore\n            \n    type Calculation with\n        member this.CalculationRule (model: Model) (cube:Cube) =\n            model.withDims <| fun tCalcDim dataTypeDim ->\n            if not <| cube.ContainsDim dataTypeDim.dimId then None else\n            let versionDim       = model.VersionDim\n            let timeDim          = model.TimeDim\n            let freezeCube       = model.FreezeCube\n            let isActualCalc     = model.IsActualCalc\n            let calculatedValue  = cube.For [ dataTypeDim?Calculated_Value                ]\n            let manualAdjustment = cube.For [ dataTypeDim?Manual_Adjustment               ]\n            let frozenValue      = cube.For [ dataTypeDim?Frozen_Value                    ]\n            let valueCalc        = cube.For [ dataTypeDim?Value ; tCalcDim?(this.calName) ]\n            let useActual        = seq { \n                                     yield                  isActualCalc.IsSome\n                                     yield                  versionDim  .IsSome\n                                     yield cube.ContainsDim versionDim  .Value.dimId\n                                     yield                  timeDim     .IsSome\n                                     yield cube.ContainsDim timeDim     .Value.dimId\n                                   } |> Seq.contains false |> not\n            let body1            = if this.isInput then \n                                       ExiStet  \n                                   else\n                                       if this.isText then\n                                           IFa(manualAdjustment &= ExtNA, calculatedValue, manualAdjustment) \n                                       else\n                                           calculatedValue + manualAdjustment |> ExNumeric\n            let body2            = if freezeCube.IsSome\n                                   then IFa(freezeCube.Value.For[tCalcDim?(this.calName)] = 1, frozenValue, body1)\n                                   else body1\n            let body3            = if   useActual \n                                   then IFa(isActualCalc.Value = 1, cube.For [ versionDim.Value?ActualElem ], body2)\n                                   else body2\n            if eq body3 ExiStet then None else                      \n            Rule.New(valueCalc.sliDims |> Map.toList |> List.map snd, body3, ForBase)\n            |> Some\n        member this.CreateCalcRules (model: Model) =\n            this.withCube model <| fun cube        -> \n                let key1, rule1 = CalcRuleKey this.calId, this.CalculationRule model cube\n                cube.AddRule key1 rule1 |> ignore\n                this.calFormulas |> swap Seq.iter <| fun fr -> fr.CreateFormulaRules model this\n                None\n            |> ignore\n            \n    type Cube with            \n        member this.FormulaInputRule (model: Model) =\n            model.withDims      <| fun tCalcDim dataTypeDim ->\n            Rule.New([ dataTypeDim?Formula ], ExtString \"<Input>\", ForBase)\n            |> Some\n        member this.FormulaConsolidationRule (model: Model) =\n            model.withDims      <| fun tCalcDim dataTypeDim ->\n            Rule.New([ dataTypeDim?Formula ], ExtString \"<Consolidation>\", ForConsolidated)\n            |> Some\n        member this.CreateActualRule (model: Model) =\n            model.VersionDim\n            |> swap Option.map <| fun versionDim -> \n                Rule.New([ versionDim?Actual ], ExtStet, ForBase)\n        member this.CreateCalcRules (model: Model) =\n            let key1, rule1 = ActualRuleKey      , this.CreateActualRule model\n            let key2, rule2 = InputRuleKey       , this.FormulaInputRule model\n            let key3, rule3 = ConsolidatedRuleKey, this.FormulaConsolidationRule model\n            this.AddRule key1 rule1 |> ignore\n            this.AddRule key2 rule2 |> ignore\n            this.AddRule key3 rule3 |> ignore\n    \n    type Model with\n        member this.CreateCalcRules () =\n            this.modCubes\n            |> Seq.filter (fun cub -> cub.IsCalcCube          )\n            |> Seq.iter   (fun cub -> cub.CreateCalcRules this)\n            this.modCalculations\n            |> swap Seq.iter <| fun calc -> calc.CreateCalcRules this\n                        \n","parent":{"$":0,"Item":"547d9db7-67cb-4879-9568-e16a617b81b9"},"predecessors":[{"$":0,"Item":"657c8f34-c917-4659-825d-c9ead206efcf"},{"$":0,"Item":"547d9db7-67cb-4879-9568-e16a617b81b9"},{"$":0,"Item":"8bb1ad32-3662-43ec-986b-887f6fa2a511"}],"id":{"$":0,"Item":"167700ab-a298-4a44-aece-dfd6f071a8e4"},"expanded":true,"level":0,"properties":{}},{"name":"Alea Calculations","content":"open Syntax\n\nlet TCalc                = Dimension    .New( \"TCalc\"      ).DType DtTCalc\nlet DataType             = Dimension    .New( \"DataType\"   ).DType DtDataType\nlet Version              = Dimension    .New( \"Version\"    ).DType DtVersion\nlet Year                 = Dimension    .New( \"Year\"       ).DType DtTime\nlet Value                = DataType.[\"Value\"]\n \nlet Price                = Dimension    .New( \"Price\"      ).Prefix \"PR\"\nlet Brand                = Dimension    .New( \"Brand\"      ).Prefix \"BR\"\nlet Product              = Dimension    .New( \"Product\"    ).Prefix \"PD\"\nlet Season               = Dimension    .New( \"Season\"     ).Prefix \"SE\"\nlet CostCenter           = Dimension    .New( \"CostCenter\" ).Prefix \"CC\"\nlet Account              = Dimension    .New( \"Account\"    ).Prefix \"AC\"\n\nlet comb1 = [ Version; DataType; Price; Brand; Product; Season; CostCenter; Account ]\n \n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nlet Sales_by_Brand                           = Input(\"Sales_by_Brand                           \") comb1\nlet FP_vs_MD_Perc                            = Input(\"FP_vs_MD_Perc                            \") comb1\nlet Sales_by_Brand_Price                     =  Calc(\"Sales_by_Brand_Price                     \") comb1\nlet Gross_Perc                               = Input(\"Gross_Perc                               \") comb1\nlet Gross_Sales_by_Brand_Price               =  Calc(\"Gross_Sales_by_Brand_Price               \") comb1\nlet Seasonal_Allocation                      = Input(\"Seasonal_Allocation                      \") comb1\nlet Seasonal_Allocation_2                    =  Calc(\"Seasonal_Allocation_2                    \") comb1\nlet Seasonal_Allocation_Outlet               = Input(\"Seasonal_Allocation_Outlet               \") comb1\nlet Discount                                 = Input(\"Discount                                 \") comb1\nlet Sales_by_Season                          =  Calc(\"Sales_by_Season                          \") comb1\nlet Net_Sales_by_Season                      =  Calc(\"Net_Sales_by_Season                      \") comb1\nlet Markup                                   =  Calc(\"Markup                                   \") comb1\nlet Seasonal_Cost_Factor                     = Input(\"Seasonal_Cost_Factor                     \") comb1\nlet COGS                                     =  Calc(\"COGS                                     \") comb1\nlet Inventory_Beginning                      =  Calc(\"Inventory_Beginning                      \") comb1\nlet Average_Price                            = Input(\"Average_Price                            \") comb1\nlet Inventory_Beginning_Quantity             =  Calc(\"Inventory_Beginning_Quantity             \") comb1\nlet Inventory_Transfer_IN                    =  Calc(\"Inventory_Transfer_IN                    \") comb1\nlet Purchases                                =  Calc(\"Purchases                                \") comb1\nlet Inventory_Transfer_OUT                   =  Calc(\"Inventory_Transfer_OUT                   \") comb1\nlet Sell_Through                             = Input(\"Sell_Through                             \") comb1\nlet Purchases_Timing_Perc                    = Input(\"Purchases_Timing_Perc                    \") comb1\nlet Total_Stock                              =  Calc(\"Total_Stock                              \") comb1\nlet Inventory_Ending                         =  Calc(\"Inventory_Ending                         \") comb1\nlet VAT_Rate_Sales_Tax                       = Input(\"VAT_Rate_Sales_Tax                       \") comb1\nlet Selling_Squared_meters                   = Input(\"Selling_Squared_meters                   \") comb1\nlet Net_Squared_meters                       = Input(\"Net_Squared_meters                       \") comb1\nlet Gross_Squared_Meters                     = Input(\"Gross_Squared_Meters                     \") comb1\nlet CAPEX                                    = Input(\"CAPEX                                    \") comb1\nlet CASHOUT                                  = Input(\"CASHOUT                                  \") comb1\nlet Landed_Factor_Custom_Duties              = Input(\"Landed_Factor_Custom_Duties              \") comb1\nlet Landed_Factor_Insurance                  = Input(\"Landed_Factor_Insurance                  \") comb1\nlet Landed_Factor_Freight                    = Input(\"Landed_Factor_Freight                    \") comb1\nlet Net_Sales_Stockist                       = Input(\"Net_Sales_Stockist                       \") comb1\nlet Net_Sales_Inter_Company                  = Input(\"Net_Sales_Inter_Company                  \") comb1\nlet PercNet_Sales_Full_Price                 =  Calc(\"PercNet_Sales_Full_Price                 \") comb1\nlet PercNet_Sales_Markdown                   =  Calc(\"PercNet_Sales_Markdown                   \") comb1\nlet PercNet_Sales_Stockist                   =  Calc(\"PercNet_Sales_Stockist                   \") comb1\nlet PercNet_Sales_InterCompany               =  Calc(\"PercNet_Sales_InterCompany               \") comb1\nlet Average_Sales_Price_Full_Price           = Input(\"Average_Sales_Price_Full_Price           \") comb1\nlet Average_Sales_Price_Markdown             = Input(\"Average_Sales_Price_Markdown             \") comb1\nlet Average_Sales_Price_Stockist             = Input(\"Average_Sales_Price_Stockist             \") comb1\nlet Average_Sales_Price_Intercompany         = Input(\"Average_Sales_Price_Intercompany         \") comb1\nlet Mark_Up_Boutique                         =  Calc(\"Mark_Up_Boutique                         \") comb1\nlet Mark_Up_Outlet                           =  Calc(\"Mark_Up_Outlet                           \") comb1\nlet Custom_Duties_Beginning_Inventory        = Input(\"Custom_Duties_Beginning_Inventory        \") comb1\nlet Freight_Beginning_Inventory              = Input(\"Freight_Beginning_Inventory              \") comb1\nlet Insurance_Beginning_Inventory            = Input(\"Insurance_Beginning_Inventory            \") comb1\nlet Index_Perc                               = Input(\"Index_Perc                               \") comb1\nlet Depreciation_IC_Initial_Provision        = Input(\"Depreciation_IC_Initial_Provision        \") comb1\nlet Depreciation_IC_Final_Provision          = Input(\"Depreciation_IC_Final_Provision          \") comb1\nlet Depreciation_TP_Initial_Provision        = Input(\"Depreciation_TP_Initial_Provision        \") comb1\nlet Depreciation_TP_Final_Provision          = Input(\"Depreciation_TP_Final_Provision          \") comb1\nlet Depreciation_IC_Initial_Provision_Factor =  Calc(\"Depreciation_IC_Initial_Provision_Factor \") comb1\nlet Depreciation_IC_Final_Provision_Factor   =  Calc(\"Depreciation_IC_Final_Provision_Factor   \") comb1\nlet Depreciation_TP_Initial_Provision_Factor =  Calc(\"Depreciation_TP_Initial_Provision_Factor \") comb1\nlet Depreciation_TP_Final_Provision_Factor   =  Calc(\"Depreciation_TP_Final_Provision_Factor   \") comb1\nlet Depreciation_Beginning                   =  Calc(\"Depreciation_Beginning                   \") comb1\nlet Depreciation_Ending                      =  Calc(\"Depreciation_Ending                      \") comb1\nlet Depreciation_Change                      =  Calc(\"Depreciation_Change                      \") comb1\nlet AMOUNT                                   =  Calc(\"AMOUNT                                   \") comb1\n\n(*\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nlet For_NoSeasonal           = [ Season?(\"21\")     ; Value ]\nlet For_FallWinterM1         = [ Season?(\"07\")     ; Value ]\nlet For_SeasonCarryOver      = [ Season?(\"19\")     ; Value ]\nlet For_NoSeasonalThirdParty = For_NoSeasonal @ [ Brand?(\"06\") ]\n\nlet isOutlet                  = SUBST(!CostCenter, 2, 1) &= \"O\"\nlet isThirdParty              = DE_ISCHILD(Product, \"TP\", !Product)\nlet isFallWinterM1            = !Season &= \"07\"\nlet isSeasonCarryOver         = !Season &= \"19\"\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nSales_by_Brand_Price                    <-- Sales_by_Brand * FP_vs_MD_Perc                                                                                              \n\nFP_vs_MD_Perc                           //<-- ([ Price?Mark_Down ; Value ] := (1 - FP_vs_MD_Perc.For[ Price?Full_Price ] ))                                   \n                                        <== Sales_by_Brand_Price / Sales_by_Brand                                                                                       \n\nGross_Sales_by_Brand_Price              <-- Sales_by_Brand_Price / (1 - Gross_Perc)                                                                                     \n\nSeasonal_Allocation                     <-- (For_NoSeasonalThirdParty := 1)                                                                                                         \n                                        <-- 1 - Seasonal_Allocation.For[ Season?Seasons ]                                , For_SeasonCarryOver                          )\n\nSeasonal_Allocation_2                   <-- 1                                                                            , For_NoSeasonalThirdParty                     )\n                                        <-- 0.5                                                                          , For_FallWinterM1                             )\n                                        <-- 0.5                                                                          , For_SeasonCarryOver                          )\n                                        <-- 0                                                                                                                           )\n                                        <-- IF(isFallWinterM1 || isSeasonCarryOver, 0.5, 0)                                                                             )\n\nSeasonal_Allocation_Outlet              <-- 1 - Seasonal_Allocation_Outlet.For[ Season?Seasons2 ]                        , For_NoSeasonal                               )\n\nSales_by_Season                         <-- Sales_by_Brand_Price                                          \n                                               * IF( isOutlet                                           \n                                                   , Seasonal_Allocation_Outlet                                           \n                                                   , IF(!CostCenter &= \"RBUS19\"                                           \n                                                     || !CostCenter &= \"RBUS20\"                                           \n                                                     || !CostCenter &= \"RBUS42\"                                           \n                                                     || !CostCenter &= \"RBUS41\"                                          \n                                                       , Seasonal_Allocation_2                                          \n                                                       , Seasonal_Allocation                                          \n                                                   )                                           \n                                                )                                                                                                                          )\n\nDiscount                                <== 1 - Sales_by_Season / Net_Sales_by_Season                                                                                   )\n\nNet_Sales_by_Season                     <-- Sales_by_Season / (1 - Discount)                                                                                            )\n\nMarkup                                  <-- IF (isOutlet, 1.25, 2.5)                                                     , [ Value                                    ] )\n                                        <== Net_Sales_by_Season / COGS   * Seasonal_Cost_Factor                                                                         )\n\nCOGS                                    <-- Net_Sales_by_Season / Markup * Seasonal_Cost_Factor                                                                         )\n                                             \nInventory_Beginning                     <-- IF( isOutlet                                           \n                                                 , NA                                          \n                                                 , COGS \n                                                   * (Inventory_Transfer_IN.For[ CostCenter?Outlets ]                                          \n                                                      /  COGS.For[ CostCenter?Boutiques ]                                          \n                                                      +  COGS.For[ CostCenter?Boutiques ] ) )                               ,   For_FallWinterM1                           )\n                                                                                                   \n                                        <-- IF (isOutlet, COGS, COGS / 0.47 * 0.55)                                                                                     )\n                                                                                        \nInventory_Beginning_Quantity            <-- Inventory_Beginning / (Average_Price * Seasonal_Cost_Factor)                                                                )\nInventory_Transfer_IN                   <-- COGS                                                                         , [ CostCenter?ROUS08                        ] )\n                                        <-- IF( isOutlet, COGS / 0.35, NA)                                               ,   For_FallWinterM1                           )\n                                        <-- IF( isOutlet                                           \n                                                 , Inventory_Transfer_OUT.For[ CostCenter?Boutiques ]               \n                                                   * Sales_by_Brand / Sales_by_Brand.For[ CostCenter?Outlets ]               \n                                                 , NA)                                                                                                                     )\nPurchases                               <-- COGS * Purchases_Timing_Perc / Sell_Through                                                                                 )\nInventory_Transfer_OUT                  <-- IF( isOutlet, NA, Inventory_Beginning + Purchases - COGS)                                                                   )\nTotal_Stock                             <-- Inventory_Beginning + Inventory_Transfer_IN - Inventory_Transfer_OUT + Purchases                                            )\nInventory_Ending                        <-- Total_Stock - COGS                                                                                                          )\n\nMark_Up_Boutique                        <-- IF(isOutlet, NA    , Markup)                                                                                                )\nMark_Up_Outlet                          <-- IF(isOutlet, Markup, NA    )                                                                                                )\n\nDepreciation_IC_Initial_Provision_Factor<-- IF(Depreciation_IC_Initial_Provision <= 0, 0, MAX(0, 1 - (1 - Depreciation_IC_Initial_Provision) / Index_Perc) )            )\nDepreciation_IC_Final_Provision_Factor  <-- IF(Depreciation_IC_Final_Provision   <= 0, 0, MAX(0, 1 - (1 - Depreciation_IC_Final_Provision  ) / Index_Perc) )            )\nDepreciation_TP_Initial_Provision_Factor<-- IF(Depreciation_TP_Initial_Provision <= 0, 0, MAX(0, 1 - (1 - Depreciation_TP_Initial_Provision) / Index_Perc) )            )\nDepreciation_TP_Final_Provision_Factor  <-- IF(Depreciation_TP_Final_Provision   <= 0, 0, MAX(0, 1 - (1 - Depreciation_TP_Final_Provision  ) / Index_Perc) )            )\nDepreciation_Beginning                  <-- IF(isOutlet,              \n                                                   IF( isThirdParty              \n                                                     , Depreciation_TP_Initial_Provision_Factor              \n                                                     , Depreciation_IC_Initial_Provision_Factor)              \n                                                   * Inventory_Beginning              \n                                               , 0)                                                                                                                        )\nDepreciation_Ending                     <-- IF(isOutlet,              \n                                                   IF( isThirdParty              \n                                                     , Depreciation_TP_Final_Provision_Factor              \n                                                     , Depreciation_IC_Final_Provision_Factor)              \n                                                   * Inventory_Ending              \n                                               , 0)                                                                                                                        )\nDepreciation_Change                     <-- Depreciation_Beginning - Depreciation_Ending                                                                                )\n\nAMOUNT                                  <-- Net_Sales_by_Season.For[ Price?Full_Price ; Product?All_Products ]          , [ Account?(\"BDG.002.02.FPR\"); Product   ?ND ] )\n                                        <-- Net_Sales_by_Season.For[ Price?Mark_Down  ; Product?All_Products ]          , [ Account?(\"BDG.002.02.MKD\"); Product   ?ND ] )\n                                        <-- Purchases_Timing_Perc                                                       , [ Account?(\"BDG.005.04\"    ); Product   ?ND ] )\n                                        <-- Markup                                                                      , [ Account?(\"BDG.011.EC\"    ); CostCenter?ND ] )\n                                        <-- IF( isOutlet, NA,  Markup)                                                  , [ Account?(\"BDG.011.W\"     ); CostCenter?ND ] )\n  \nprintfn \"%A\" model\n*)","parent":{"$":0,"Item":"002fe5c4-6032-4259-a8dc-9afa8f5f7742"},"predecessors":[{"$":0,"Item":"547d9db7-67cb-4879-9568-e16a617b81b9"}],"id":{"$":0,"Item":"9b967b5a-a186-416e-b2f0-c5dfdf581917"},"expanded":true,"level":0,"properties":{}},{"name":"Alea Formulas","content":"let For_NoSeasonal           = [ Season?(\"21\")     ; Value ]\nlet For_FallWinterM1         = [ Season?(\"07\")     ; Value ]\nlet For_SeasonCarryOver      = [ Season?(\"19\")     ; Value ]\nlet For_NoSeasonalThirdParty =   Brand?(\"06\") :: For_NoSeasonal\n\nlet isOutlet                  = SUBST(!CostCenter, 2, 1) &= \"O\"\nlet isThirdParty              = DE_ISCHILD(Product, \"TP\", !Product)\nlet isFallWinterM1            = !Season &= \"07\"\nlet isSeasonCarryOver         = !Season &= \"19\"\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nSales_by_Brand_Price                    <<|                                    Sales_by_Brand * FP_vs_MD_Perc                  \n\nFP_vs_MD_Perc                           <<| [ Price?Mark_Down ; Value ]    <<< 1 - FP_vs_MD_Perc.For[ Price?Full_Price ]                                 \n                                        <<|                                    Sales_by_Brand_Price / Sales_by_Brand                                                                           \n                  \n\nGross_Sales_by_Brand_Price              <<|                                    Sales_by_Brand_Price / (1 - Gross_Perc)                                                                                                       \n\nSeasonal_Allocation                     <<| For_NoSeasonalThirdParty       <<< 1                                                                                                         \n                                        <<| For_SeasonCarryOver            <<< 1 - Seasonal_Allocation.For[ Season?Seasons ]                                           \n\nSeasonal_Allocation_2                   <<| For_NoSeasonalThirdParty       <<< 1         \n                                        <<| For_FallWinterM1               <<< 0.5                              \n                                        <<| For_SeasonCarryOver            <<< 0.5                          \n                                        <<|                                    0                                                                                                                           \n                                        <<|                                    IF(isFallWinterM1 || isSeasonCarryOver, 0.5, 0)                                                                                               \n\nSeasonal_Allocation_Outlet              <<| For_NoSeasonal                 <<< 1 - Seasonal_Allocation_Outlet.For[ Season?Seasons2 ]                                                 \n\nSales_by_Season                         <<|                                    Sales_by_Brand_Price                                          \n                                                                                  * IF( isOutlet                                           \n                                                                                      , Seasonal_Allocation_Outlet                                           \n                                                                                      , IF(!CostCenter &= \"RBUS19\"                                           \n                                                                                        || !CostCenter &= \"RBUS20\"                                           \n                                                                                        || !CostCenter &= \"RBUS42\"                                           \n                                                                                        || !CostCenter &= \"RBUS41\"                                          \n                                                                                          , Seasonal_Allocation_2                                          \n                                                                                          , Seasonal_Allocation                                          \n                                                                                      )                                           \n                                                                                   )                                                                                                                          \n                                                  \nDiscount                                <<|*                                   1 - Sales_by_Season / Net_Sales_by_Season                                                                                   \n                                                  \nNet_Sales_by_Season                     <<|                                    Sales_by_Season / (1 - Discount)                                                                                            \n                                                  \nMarkup                                  <<| [ Value ]                      <<< IF (isOutlet, 1.25, 2.5)                                                     \n                                        <<|*                                   Net_Sales_by_Season / COGS   * Seasonal_Cost_Factor                                                                         \n                                                  \nCOGS                                    <<|                                    Net_Sales_by_Season / Markup * Seasonal_Cost_Factor                                                                         \n                                                                                \nInventory_Beginning                     <<| For_FallWinterM1               <<< IF( isOutlet                                           \n                                                                                                    , NA                                          \n                                                                                                    , COGS \n                                                                                                      * (Inventory_Transfer_IN.For[ CostCenter?Outlets ]                                          \n                                                                                                         /  COGS.For[ CostCenter?Boutiques ]                                          \n                                                                                                         +  COGS.For[ CostCenter?Boutiques ] ) )                                                                                                                                                                             \n                                        <<|                                    IF (isOutlet, COGS, COGS / 0.47 * 0.55)                                                                                     \n                                                                                                                           \nInventory_Beginning_Quantity            <<|                                    Inventory_Beginning / (Average_Price * Seasonal_Cost_Factor)                                                                \nInventory_Transfer_IN                   <<| [ CostCenter?ROUS08 ]          <<< COGS \n                                        <<| For_FallWinterM1               <<< IF( isOutlet, COGS / 0.35, NA)                           \n                                        <<|                                    IF( isOutlet                                           \n                                                                                    , Inventory_Transfer_OUT.For[ CostCenter?Boutiques ]               \n                                                                                      * Sales_by_Brand / Sales_by_Brand.For[ CostCenter?Outlets ]               \n                                                                                    , NA)     \n                                                                                    \nPurchases                               <<|                                    COGS * Purchases_Timing_Perc / Sell_Through                                                                                 \nInventory_Transfer_OUT                  <<|                                    IF( isOutlet, NA, Inventory_Beginning + Purchases - COGS)                                                                   \nTotal_Stock                             <<|                                    Inventory_Beginning + Inventory_Transfer_IN - Inventory_Transfer_OUT + Purchases                                            \nInventory_Ending                        <<|                                    Total_Stock - COGS                                                                                                          \n                                                  \nMark_Up_Boutique                        <<|                                    IF(isOutlet, NA    , Markup)                                                                                                \nMark_Up_Outlet                          <<|                                    IF(isOutlet, Markup, NA    )                                                                                                \n                                                  \nDepreciation_IC_Initial_Provision_Factor<<|                                    IF(Depreciation_IC_Initial_Provision <= 0, 0, MAX(0, 1 - (1 - Depreciation_IC_Initial_Provision) / Index_Perc) )            \nDepreciation_IC_Final_Provision_Factor  <<|                                    IF(Depreciation_IC_Final_Provision   <= 0, 0, MAX(0, 1 - (1 - Depreciation_IC_Final_Provision  ) / Index_Perc) )            \nDepreciation_TP_Initial_Provision_Factor<<|                                    IF(Depreciation_TP_Initial_Provision <= 0, 0, MAX(0, 1 - (1 - Depreciation_TP_Initial_Provision) / Index_Perc) )            \nDepreciation_TP_Final_Provision_Factor  <<|                                    IF(Depreciation_TP_Final_Provision   <= 0, 0, MAX(0, 1 - (1 - Depreciation_TP_Final_Provision  ) / Index_Perc) )            \nDepreciation_Beginning                  <<|                                    IF(isOutlet,              \n                                                                                      IF( isThirdParty              \n                                                                                        , Depreciation_TP_Initial_Provision_Factor              \n                                                                                        , Depreciation_IC_Initial_Provision_Factor)              \n                                                                                      * Inventory_Beginning              \n                                                                                  , 0)                                                                                                                     \nDepreciation_Ending                     <<|                                    IF(isOutlet,              \n                                                                                      IF( isThirdParty              \n                                                                                        , Depreciation_TP_Final_Provision_Factor              \n                                                                                        , Depreciation_IC_Final_Provision_Factor)              \n                                                                                      * Inventory_Ending              \n                                                                                  , 0)                                                                                                                     \nDepreciation_Change                     <<|                                    Depreciation_Beginning - Depreciation_Ending                                                                                \n\nAMOUNT                                  <<| [ Account?(\"BDG.002.02.FPR\") \n                                              Product   ?ND              ] <<< Net_Sales_by_Season.For[ Price?Full_Price ; Product?All_Products ] \n                                        <<| [ Account?(\"BDG.002.02.MKD\")\n                                              Product   ?ND              ] <<< Net_Sales_by_Season.For[ Price?Mark_Down  ; Product?All_Products ] \n                                        <<| [ Account?(\"BDG.005.04\"    )\n                                              Product   ?ND              ] <<< Purchases_Timing_Perc                                              \n                                        <<| [ Account?(\"BDG.011.EC\"    )\n                                              CostCenter?ND              ] <<< Markup                                                             \n                                        <<| [ Account?(\"BDG.011.W\"     )\n                                              CostCenter?ND              ] <<< IF( isOutlet, NA,  Markup)                                         \n  \n","parent":{"$":0,"Item":"002fe5c4-6032-4259-a8dc-9afa8f5f7742"},"predecessors":[{"$":0,"Item":"9b967b5a-a186-416e-b2f0-c5dfdf581917"}],"id":{"$":0,"Item":"9904a292-3cee-45b2-9909-5f3894447112"},"expanded":true,"level":0,"properties":{}},{"name":"Rules","content":"open CalcRules\n\nmodel.PrepareModel()\nmodel.CreateCalcRules()\n\n\nlet ReportCube = Cube.New(\"Model\"\n                   , [ DataType  \n                       Price     \n                       Brand     \n                       Product   \n                       Season    \n                       CostCenter\n                       Account   \n                     ]\n                   , None)\n\nprintfn \"->%s<-\" <| model.AutoName [| Brand.dimId |]\n\nReportCube  <<| [ Price?Mark_Down ; Value ] <<< 1 - FP_vs_MD_Perc.For[ Price?Full_Price ]                                 \n\nFP_vs_MD_Perc.calFormulas.[0].forExpression.RuleText (model, model.modCubes.[0].cubId) \n|> printfn \"%s\"\n\nprintfn \"%A\" model","parent":{"$":0,"Item":"002fe5c4-6032-4259-a8dc-9afa8f5f7742"},"predecessors":[{"$":0,"Item":"167700ab-a298-4a44-aece-dfd6f071a8e4"},{"$":0,"Item":"8bb1ad32-3662-43ec-986b-887f6fa2a511"},{"$":0,"Item":"39111a54-edb5-4bf3-9f94-479c2cac69de"},{"$":0,"Item":"9904a292-3cee-45b2-9909-5f3894447112"},{"$":0,"Item":"9b967b5a-a186-416e-b2f0-c5dfdf581917"},{"$":0,"Item":"547d9db7-67cb-4879-9568-e16a617b81b9"}],"id":{"$":0,"Item":"2230b8dc-8c96-4f1d-b7c0-d9058ee9a7bc"},"expanded":true,"level":0,"properties":{}},{"name":"WebSharper Code","content":"#define WEBSHARPER\n(*\n Code to be Compiled to Javascript and run in the browser\n using `Compile WebSharper` or `Run WebSharper`\n*)\n","parent":{"$":0,"Item":"bf864f3c-1370-42f2-ac8a-565a604892e8"},"predecessors":[{"$":0,"Item":"66ab3e22-f5ed-4e75-966d-28394d24f3d7"}],"id":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"expanded":false,"level":0,"properties":{}},{"name":"HtmlNode","content":"\n[<JavaScript>]\nmodule HtmlNode      =\n","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"expanded":false,"level":0,"properties":{}},{"name":"Val","content":"[<NoComparison>]\ntype Val<'a> =\n    | Constant  of 'a\n    | DynamicV  of IRef<'a>\n    | Dynamic   of View<'a>\n  with member this.FooBar = 0\n\nmodule Val =\n    \n    let mapV : ('a -> 'b) -> Val<'a> -> Val<'b> =\n        fun    f             va      ->\n            match va with\n            | Constant  a -> f a                   |> Constant\n            | Dynamic  wa -> wa      |> View.Map f |> Dynamic \n            | DynamicV va -> va.View |> View.Map f |> Dynamic \n\n    let iterV : ('a -> unit) -> Val<'a> -> unit = //f v = toView v |> View.Get f\n        fun     f               va      ->\n            match va with\n            | Constant  a ->          f  a                  \n            | Dynamic  wa -> View.Get f wa \n            | DynamicV va ->          f va.Value \n\n    let toView v =\n        match v with\n        | Constant  a -> View.Const a\n        | Dynamic  wa -> wa\n        | DynamicV va -> va.View\n\n    let bindV : ('a -> Val<'b>) -> Val<'a> -> Val<'b> =\n        fun     f                  v       -> \n            match v with\n            | Constant  a -> f a\n            | Dynamic  wa -> wa      |> View.Bind (f >> toView) |> Dynamic \n            | DynamicV va -> va.View |> View.Bind (f >> toView) |> Dynamic \n\n    let inline map2V f = // : ('a -> 'b -> 'c) -> Val<'a> -> Val<'b> -> Val<'c> =\n        //fun     f                ->\n        let inline swap f a b = f b a\n        let inline fv vb = bindV (swap (f >> mapV) vb)\n        swap fv\n\n    let inline map3V f3 v1 v2 v3    = map2V f3 v1 v2    |> map2V (|>) v3\n    let inline map4V f3 v1 v2 v3 v4 = map3V f3 v1 v2 v3 |> map2V (|>) v4\n    \n    let tagDoc: ('a -> Doc) -> Val<'a> -> Doc =\n        fun     tag            va      ->\n            match va with\n            | Constant  a -> tag   a\n            | Dynamic  wa -> wa      |> View.Map tag |> Doc.EmbedView\n            | DynamicV va -> va.View |> View.Map tag |> Doc.EmbedView\n\n    let tagElt: ('a -> Elt) -> Val<'a> -> Doc =\n        fun     tag            va     ->\n            match va with\n            | Constant  a -> tag   a :> Doc\n            | Dynamic  wa -> wa     |> View.Map tag |> Doc.EmbedView\n            | DynamicV va -> va.View |> View.Map tag |> Doc.EmbedView\n\n    let attrVO att       vao     =\n            match vao with\n            | Constant (Some a)-> Attr.Create      att   a\n            | Constant  None   -> Attr.DynamicPred att  (View.Const false              ) (View.Const                      \"\"         )\n            | Dynamic       wa -> Attr.DynamicPred att  (View.Map Option.isSome wa     ) (View.Map   (Option.defaultValue \"\") wa     )\n            | DynamicV      va -> Attr.DynamicPred att  (View.Map Option.isSome va.View) (View.Map   (Option.defaultValue \"\") va.View)\n\n    let attrV att       va      =\n            match va with\n            | Constant  a -> Attr.Create  att   a\n            | Dynamic  wa -> Attr.Dynamic att  wa\n            | DynamicV va -> Attr.Dynamic att  va.View\n\n\n    type HelperType = HelperType with\n        static member (&>) (HelperType, a :     string option   ) = Constant  a\n        static member (&>) (HelperType, a :     string          ) = Constant  a\n        static member (&>) (HelperType, a :     bool            ) = Constant  a\n        static member (&>) (HelperType, a :     int             ) = Constant  a\n        static member (&>) (HelperType, a :     float           ) = Constant  a\n        static member (&>) (HelperType, a :     Doc             ) = Constant  a\n        static member (&>) (HelperType, va: Val<string option>  ) =          va\n        static member (&>) (HelperType, va: Val<string       >  ) =          va\n        static member (&>) (HelperType, va: Val<bool         >  ) =          va\n        static member (&>) (HelperType, va: Val<int          >  ) =          va\n        static member (&>) (HelperType, va: Val<float        >  ) =          va\n        static member (&>) (HelperType, va: Val<Doc          >  ) =          va\n        static member (&>) (HelperType, va: Val<_            >  ) =          va\n        static member (&>) (HelperType, vr: IRef<_           >  ) = DynamicV vr\n        static member (&>) (HelperType, vw: View<_           >  ) = Dynamic  vw\n\n(*    [< Inline @\"(\n            typeof($v) == 'function' ? {$:2, $0:$v} // View\n            :   typeof($v) == 'object'\n                      ? typeof($v.$) != 'undefined' // Val\n                            ? $v \n                            : typeof($v.Id) == 'number' || typeof($v.i) == 'number' || typeof($v.RView == 'function')// Var\n                                 ? {$:1, $0:$v}\n                                 : typeof($v.docNode) != 'undefined'\n                                     ? {$:0, $0:$v} // Doc\n                                     : {$:2, $0:$v} // View?\n                      : {$:0, $0:$v}) // other\n                                     \" >]\n    let fixit0 v = Constant v\n    let fixit2 v = let result = fixit0 v\n                   result\n                   \n    [< Direct \"FSSGlobal.HtmlNode.Val.fixit2($v)\" >]\n    //[< Inline >]\n    let inline fixit v = HelperType &> v\n*)\n    let toVal (o: obj) =\n        match o with\n        | :?      string   as t   -> Val.Constant t \n        | :?      int      as t   -> Val.Constant t |> As<Val<string>> \n        | :?      bool     as t   -> Val.Constant t |> As<Val<string>>  \n        | :?      Doc      as t   -> Val.Constant t |> As<Val<string>>  \n        | :? Val< string>  as v   ->              v        \n        | :? Var< string>  as v   -> Val.DynamicV v        \n        | v when JS.In \"RSet\" v   -> Val.DynamicV (As<IRef<string>> v)\n        | :? Function      as vw  -> Val.Dynamic  (As<View<string>> vw)        \n        | _                       -> failwith <| sprintf \"Could not convert %A\" o\n\n    [< Direct \"$f($v)\" >]\n    let inline fixitF f v = HelperType &> v\n    let inline fixit    v = fixitF toVal v\n\n    let [<Inline>] inline bindIRef0 (f: 'a->IRef<'b>) (view: View<'a>) = \n        let contentVar = Var.Create Unchecked.defaultof<'b>\n        let changingIRefO : IRef<'b> option ref = ref None\n        let contentVarChanged = ref 0L\n        let refVarChanged     = ref 0L\n    \n        contentVar.View \n        |> View.Sink (fun _ -> \n            !changingIRefO \n            |> Option.iter (fun r -> \n                if  !contentVarChanged  > !refVarChanged   then refVarChanged := !contentVarChanged\n                elif r.Value           <> contentVar.Value then refVarChanged := !refVarChanged       + 1L ; r.Value         <-  contentVar.Value\n               )\n           )\n    \n        view |> View.Bind (fun cur ->\n            let r = f cur\n            changingIRefO    := Some r\n            refVarChanged    := !contentVarChanged + 100L\n            contentVar.Value <- r.Value\n            r.View\n        ) |> View.Sink (fun _ -> \n            !changingIRefO \n            |> Option.iter (fun r -> \n                if  !refVarChanged  > !contentVarChanged then contentVarChanged := !refVarChanged\n                elif r.Value       <> contentVar.Value   then contentVarChanged := !contentVarChanged + 10L; contentVar.Value  <-  r.Value\n               )\n            )\n        contentVar\n    \n    let inline toDoc       v           = toView      (fixit v ) |> Doc.EmbedView\n    let [<Inline>] inline bindIRef f  v           = bindIRef0 f (fixit v   |> toView)\n    let inline iter     f  v           = iterV     f (fixit v )\n    let inline bind     f  v           = bindV     f (fixit v )\n    let inline map      f  v           = mapV      f (fixit v )\n    let inline map2     f  v1 v2       = map2V     f (fixit v1) (fixit v2)\n    let inline map3     f  v1 v2 v3    = map3V     f (fixit v1) (fixit v2) (fixit v3)\n    let inline map4     f  v1 v2 v3 v4 = map4V     f (fixit v1) (fixit v2) (fixit v3) (fixit v4)\n    let inline sink     f  v           = fixit v |> toView |> View.Sink f\n\n    let inline iter2    f  v1 v2       = map2      f v1 v2       |> iterV id\n    let inline iter3    f  v1 v2 v3    = map3      f v1 v2 v3    |> iterV id\n    let inline iter4    f  v1 v2 v3 v4 = map4      f v1 v2 v3 v4 |> iterV id\n\n    let inline mapAsync f  v           = View.MapAsync f (fixit v |> toView) \n\n","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"0f5719f0-e95e-498d-ab88-f89ff1440e32"},"expanded":true,"level":0,"properties":{}},{"name":"HtmlNode","content":"[<NoComparison ; NoEquality>]\ntype HtmlNode =\n    | HtmlElement    of name: string * children: HtmlNode seq\n    | HtmlAttribute  of name: string * value:    Val<string>\n    | HtmlAttributeO of name: string * value:    Val<string option>\n    | HtmlText       of Val<string>\n    | HtmlEmpty\n    | HtmlElementV   of Val<HtmlNode>\n    | SomeDoc        of Doc\n    | SomeAttr       of Attr\n    \nlet addClassX    (classes:string) (add:string) = classes.Split ' ' |> Set.ofSeq |> Set.union  (Set.ofSeq <| add.Split ' ') |> String.concat \" \"\n//let removeClass (classes:string) (rem:string) = classes.Split ' ' |> Set.ofSeq |> Set.remove               rem            |> String.concat \" \"\n\n//let callAddClassX = addClassX \"a\" \"b\" // so that WebSharper.Collections.js is included\n\nlet inline chooseAttr node = \n    match node with\n    | HtmlAttribute (name, value   ) when name <> \"class\" && name <> \"style\" \n                                     -> Some <| Val.attrV    name value\n    | HtmlAttributeO(name, valueO  ) when name <> \"class\" && name <> \"style\" \n                                     -> Some <| Val.attrVO   name valueO\n    | SomeAttr             attr      -> Some <| attr\n    | _                              -> None\n\nlet chooseThisAttr this node =\n    match node with\n    | HtmlAttribute (att, value) when att = this -> Some value\n    | _                                          -> None\n\nlet concat s a b = a + s + b\nlet groupAttr name sep children = \n    children \n    |> Seq.choose (chooseThisAttr name)\n    |> (fun ss -> if ss |> Seq.isEmpty \n                  then None \n                  else ss |> Seq.reduce (Val.map2 <| concat sep ) |> Val.attrV name |> Some)\n\nlet inline getAttrsFromSeq children =\n    children \n    |> Seq.choose chooseAttr\n    |> Seq.append (List.choose id [ children |> groupAttr \"class\" \" \" ; children |> groupAttr \"style\" \"; \" ])\n\nlet rec chooseNode node =\n    match node with\n    | HtmlElement (name, children) -> Some <| (Doc.Element name (getAttrsFromSeq children) (children |> Seq.choose chooseNode) :> Doc)\n    | HtmlText     vtext           -> Some <| Val.tagDoc WebSharper.UI.Next.Html.text vtext\n    | SomeDoc      doc             -> Some <| doc\n    | HtmlElementV vnode           -> Some <| (vnode |> Val.toView |> Doc.BindView (chooseNode >> Option.defaultValue Doc.Empty))\n    | _                            -> None\n\nlet getAttrChildren attr =\n    Seq.tryPick (function \n                | HtmlAttribute(a, v) when a = attr -> Some v \n                | _                                 -> None)\n    >> Option.defaultValue (Constant \"\")\n\nlet rec mapHtmlElement (f:string -> seq<HtmlNode> -> string * HtmlNode seq) (element:HtmlNode) :HtmlNode =\n    match element with\n    | HtmlElement (name, children) -> f name  children                    |> HtmlElement\n    | HtmlElementV vnode           -> vnode |> Val.map (mapHtmlElement f) |> HtmlElementV\n    | _                            -> element\n\n//let getAttr attr element =\n//    match element with\n//    | HtmlElement(_, children) -> children\n//    | _                        -> seq []\n//    |> getAttrChildren attr\n//\n//let getClass = getAttr \"class\"\n//let getStyle = getAttr \"style\"\n\n//let replaceAttribute att (children: HtmlNode seq) newVal =\n//    HtmlAttribute(att, newVal)\n//    :: (children\n//        |> Seq.filter (function HtmlAttribute(old, _) when old = att -> false | _ -> true)\n//        |> Seq.toList\n//       )\n//\n//let replaceAtt att node newVal = mapHtmlElement (fun n ch -> n, replaceAttribute att ch newVal |> Seq.ofList) node\n\nlet inline htmlElement    name ch = HtmlElement   (name, ch           )\nlet inline htmlAttribute  name v  = HtmlAttribute (name, Val.fixit v  )\nlet inline htmlAttributeO name v  = HtmlAttributeO(name, Val.fixit v  )\nlet inline htmlText       txt     = HtmlText      (      Val.fixit txt)\nlet inline someElt        elt     = SomeDoc       (elt :> Doc         )    \n  \nlet inline addChildren    add (h:HtmlNode) = h |> mapHtmlElement (fun n ch -> n, Seq.append ch   add)\nlet inline insertChildren add (h:HtmlNode) = h |> mapHtmlElement (fun n ch -> n, Seq.append add  ch )\nlet inline addClass       c    h           = h |> addChildren [ htmlAttribute  \"class\" c ] \nlet inline addClassIf     c v              = addClass <| Val.map (fun b -> if b then c else \"\") (Val.fixit v)\n\ntype HtmlNode with\n    member inline this.toDoc = \n        match this with\n        | HtmlAttribute _\n        | HtmlEmpty       -> Doc.Empty\n        | _               -> chooseNode this |> Option.defaultValue Doc.Empty\n    // member inline   this.Class          clas = Val.fixit clas |> replaceAtt \"class\" this\n    member          this.AddChildren    add  = this |> addChildren    add\n    member          this.InsertChildren add  = this |> insertChildren add\n    member inline   this.AddClass       c    = this |> addClass       c\n\nlet renderDoc = chooseNode >> Option.defaultValue Doc.Empty\n    ","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"0f5719f0-e95e-498d-ab88-f89ff1440e32"}],"id":{"$":0,"Item":"d9124644-0af6-4a7f-a711-ef76ca77f0de"},"expanded":true,"level":0,"properties":{}},{"name":"HTML Elements & Attributes","content":"let inline atr att v = Val.attrV  att (Val.fixit v)\nlet inline tag tag v = Val.tagDoc tag (Val.fixit v)\n\nlet inline _class       v = atr \"class\"       v\nlet inline _type        v = atr \"type\"        v\nlet inline _style       v = atr \"style\"       v\nlet inline _placeholder v = atr \"placeholder\" v\nlet inline textV        v = tag  Html.text    v\n\nlet inline a           ch = htmlElement   \"a\"           ch\nlet inline ul          ch = htmlElement   \"ul\"          ch\nlet inline li          ch = htmlElement   \"li\"          ch\nlet inline br          ch = htmlElement   \"br\"          ch\nlet inline hr          ch = htmlElement   \"hr\"          ch\nlet inline h1          ch = htmlElement   \"h1\"          ch\nlet inline h2          ch = htmlElement   \"h2\"          ch\nlet inline h3          ch = htmlElement   \"h3\"          ch\nlet inline h4          ch = htmlElement   \"h4\"          ch\nlet inline h5          ch = htmlElement   \"h5\"          ch\nlet inline h6          ch = htmlElement   \"h6\"          ch\nlet inline div         ch = htmlElement   \"div\"         ch\nlet inline img         ch = htmlElement   \"img\"         ch\nlet inline span        ch = htmlElement   \"span\"        ch\nlet inline form        ch = htmlElement   \"form\"        ch\nlet inline table       ch = htmlElement   \"table\"       ch\nlet inline thead       ch = htmlElement   \"thead\"       ch\nlet inline th          ch = htmlElement   \"th\"          ch\nlet inline tr          ch = htmlElement   \"tr\"          ch\nlet inline td          ch = htmlElement   \"td\"          ch\nlet inline tbody       ch = htmlElement   \"tbody\"       ch\nlet inline label       ch = htmlElement   \"label\"       ch\nlet inline button      ch = htmlElement   \"button\"      ch\nlet inline script      sc = htmlElement   \"script\"      sc\nlet inline styleH      st = htmlElement   \"style\"       st\nlet inline fieldset    ch = htmlElement   \"fieldset\"    ch\nlet inline link        sc = htmlElement   \"link\"        sc\nlet inline iframe      at = htmlElement   \"iframe\"      at\nlet inline body        ch = htmlElement   \"body\"        ch\n\n\nlet inline href        v  = htmlAttribute  \"href\"        v\nlet inline hrefO       vO = htmlAttributeO \"href\"        vO\nlet inline rel         v  = htmlAttribute  \"rel\"         v\nlet inline charset     v  = htmlAttribute  \"charset\"     v\nlet inline src         v  = htmlAttribute  \"src\"         v\nlet inline ``class``   v  = htmlAttribute  \"class\"       v\nlet inline ``type``    v  = htmlAttribute  \"type\"        v\nlet inline width       v  = htmlAttribute  \"width\"       v\nlet inline title       v  = htmlAttribute  \"title\"       v\nlet inline Id          v  = htmlAttribute  \"id\"          v\nlet inline frameborder v  = htmlAttribute  \"frameborder\" v\nlet inline spellcheck  v  = htmlAttribute  \"spellcheck\"  v\nlet inline draggable   v  = htmlAttribute  \"draggable\"   v\nlet inline style       v  = htmlAttribute  \"style\"       v\n\nlet inline style1    n v  = style <| Val.map ((+) (n + \":\")) v\n\ntype HtmlNode with\n    member inline   this.Style          sty  = this.AddChildren([ style sty ])\n\nlet inline css         v  = styleH [ htmlText v ] \n\nlet inline classIf cls v = ``class`` <| Val.map (fun b -> if b then cls else \"\") (Val.fixit v)\n\nlet inline ``xclass`` v  = \n    match Val.fixit v with\n    | Constant c  -> Attr.Class        c       \n    | Dynamic  cw -> Attr.DynamicClass \"class_for_view_not_implemented\" cw      ((<>)\"\")\n    | DynamicV cv -> Attr.DynamicClass cv.Value                         cv.View ((<>)\"\")\n    |> SomeAttr\n\nlet style2pairs (ss:string) : (string * string) [] =\n    ss.Split(';') \n    |> Array.map   (fun s -> s.Split(':') ) \n    |> Array.filter(fun d -> d.Length = 2 )\n    |> Array.map   (fun d -> d.[0].Trim(), d.[1].Trim() )\n\nlet string2Styles = style2pairs >> Array.map (fun (n, v) -> Attr.Style n v |> SomeAttr)\n\n//let composeDoc elt dtl dtlVal = dtlVal |> Val.toView |> Doc.BindView (Seq.append dtl >> elt >> renderDoc) |> SomeDoc\n\nlet inline bindHElem hElemF v  = Val.map hElemF  (Val.fixit v) |> HtmlElementV\n\nlet createIFrame f =\n    let cover = Var.Create true\n    div [ style           \"position: relative; overflow: hidden; height: 100%; width: 100%;\" \n          iframe \n            [ style       \"position: absolute; width:100%; height:100%;\"\n              frameborder \"0\"\n              SomeAttr <| on.afterRender f\n              SomeAttr <| on.mouseLeave (fun _ _ -> cover.Value <- true)\n            ]\n          div \n            [ style       \"position: absolute;\"\n              classIf     \"iframe-cover\" (Val.map id cover)               \n              SomeAttr <| on.mouseEnter (fun _ _ -> Input.Mouse.MousePressed \n                                                    |> View.Get (fun pressed -> if not pressed then cover.Value <- false))\n            ]          \n          styleH [ htmlText \".iframe-cover { top:0; left:0; right:0; bottom:0; background: blue; opacity: 0.04; z-index: 2; }\" ]\n        ]\n\n[< Inline \"\"\"(!$v)\"\"\">]\nlet isUndefined v = true\n\nlet  findRootElement (e:Dom.Element) =\n    let root = e.GetRootNode()\n    if isUndefined root?body \n    then root.FirstChild :?> Dom.Element\n    else root?body  |> unbox<Dom.Element>\n","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"d9124644-0af6-4a7f-a711-ef76ca77f0de"}],"id":{"$":0,"Item":"c3755c07-1385-495d-bad7-a5b0fa54ac9b"},"expanded":true,"level":0,"properties":{}},{"name":"storeVar","content":"[< Inline >]\nlet inline storeVar<'T> storeName (var:IRef<_>) =\n    JS.Window.LocalStorage.GetItem storeName |> fun v -> if v <> null then           var.Value <- Json.Deserialize<'T> v\n    Val.sink (fun v -> JS.Window.LocalStorage.SetItem (storeName, Json.Serialize v)) var\n\n","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"0f5719f0-e95e-498d-ab88-f89ff1440e32"}],"id":{"$":0,"Item":"336d6f19-0c57-4af9-8716-1b3fbf6b112c"},"expanded":true,"level":0,"properties":{}},{"name":"LoadFiles","content":"[< Inline \"CIPHERSpaceLoadFiles($files, $cb)\" >]\nlet LoadFiles (files: string []) (cb: unit -> unit) : unit = X<_>","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"02d3bc50-4aa0-41ce-a37e-5b90a943481f"}],"id":{"$":0,"Item":"1f1aa135-fd74-42cc-b9a5-87f380c113a9"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"open HtmlNode","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"c3755c07-1385-495d-bad7-a5b0fa54ac9b"}],"id":{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},"expanded":true,"level":0,"properties":{}},{"name":"Template","content":"[<JavaScript>]\nmodule Template      =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"11ecbe45-3d0c-4121-a8fd-7c126b96f4a3"}],"id":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"expanded":false,"level":0,"properties":{}},{"name":"","content":"let container content = div <| [ ``class`` \"container\" ] @ content","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"8fb54777-3046-4aae-9282-33401a45c280"},"expanded":true,"level":0,"properties":{}},{"name":"Bootstrap","content":"type Bootstrap() =\n    member this.Render =\n        div [\n          script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js' type='text/javascript\"    ; ``type`` \"text/javascript\" ; charset \"UTF-8\"      ]\n          script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"   ; ``type`` \"text/javascript\" ; charset \"UTF-8\"      ]\n          link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" ; ``type`` \"text/css\"        ; rel     \"stylesheet\" ]\n          link   [ href \"/EPFileX/css/main.css\"                                                ; ``type`` \"text/css\"        ; rel     \"stylesheet\" ]\n         ]\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"40614ad6-3f81-468b-a4ff-034124b82ae1"},"expanded":true,"level":0,"properties":{}},{"name":"Button","content":"[<NoComparison ; NoEquality>]\ntype Button = {\n    _class  : Val<string>\n    _type   : Val<string>\n    style   : Val<string>\n    text    : Val<string>\n    onClick : Dom.Element -> Dom.MouseEvent -> unit\n    disabled: Val<bool>\n    id      : string\n} with\n  static member inline New txt = \n      { _class   = Val.fixit \"btn\" \n        _type    = Val.fixit \"button\" \n        style    = Val.fixit \"\"\n        text     = Val.fixit txt\n        onClick  = fun _ _ -> ()\n        disabled = Val.fixit false\n        id       = \"\"\n      }\n  member        this.Render     =         \n    button [ ``type``  <| this._type\n             ``class`` <| this._class\n             Id        <| this.id  \n             style     <| this.style\n             SomeAttr  <| attr.disabledDynPred (View.Const \"\") (this.disabled |> Val.toView)\n             SomeAttr  <| on.click <@ this.onClick @>\n             HtmlText  <| this.text \n           ]\n  member inline this.Id          id   = { this with id       = id             }\n  member inline this.Class       clas = { this with _class   = Val.fixit clas }\n  member inline this.Type        typ  = { this with _type    = Val.fixit typ  }\n  member inline this.Style       sty  = { this with style    = Val.fixit sty  }\n  member inline this.Text        txt  = { this with text     = Val.fixit txt  }\n  member inline this.Disabled    dis  = { this with disabled = Val.fixit dis  }\n  member inline this.OnClick     f    = { this with onClick  = f              }","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},"expanded":true,"level":0,"properties":{}},{"name":"Input","content":"[<NoComparison ; NoEquality>]\ntype Input = {\n    _type       : Val<string>\n    _class      : Val<string>\n    style       : Val<string>\n    placeholder : Val<string>\n    id          : string\n    var         : IRef<string>\n    prefix      : HtmlNode\n    suffix      : HtmlNode\n    content     : Attr seq\n    prefixAdded : bool\n    suffixAdded : bool\n} with\n  static member  New(var) = { _class      = Val.fixit \"form-control\" \n                              _type       = Val.fixit \"text\" \n                              style       = Val.fixit \"\" \n                              placeholder = Val.fixit \"Enter text:\"\n                              id          = \"\"\n                              content     = []\n                              prefix      = HtmlEmpty\n                              prefixAdded = false\n                              suffix      = HtmlEmpty\n                              suffixAdded = false\n                              var         = var   \n                            }\n  static member  New(v)   = Input.New(Var.Create v)\n  member        this.Render    =         \n    let groupClass det = match det with HtmlText _  -> \"input-group-addon\" | _ -> \"input-group-btn\"\n    div [\n        if this.prefixAdded || this.suffixAdded then\n            yield ``class`` \"input-group\"\n        if this.prefixAdded then\n            yield  span     [ ``class`` <| groupClass this.prefix \n                              this.prefix       ]\n        yield Doc.Input ([_type            this._type\n                          _class           this._class\n                          _style           this.style\n                          attr.id          this.id  \n                          _placeholder     this.placeholder ] |> Seq.append this.content)\n                          this.var\n              :> Doc |> SomeDoc\n        if this.suffixAdded then\n            yield  span     [ ``class`` <| groupClass this.suffix \n                              this.suffix       ]\n      ]\n  member inline this.Class       clas = { this with _class      = Val.fixit clas                  }\n  member inline this.Type        typ  = { this with _type       = Val.fixit typ                   }\n  member inline this.Style       sty  = { this with style       = Val.fixit sty                   }\n  member inline this.Placeholder plc  = { this with placeholder = Val.fixit plc                   }\n  member inline this.Id          id   = { this with id          =       id                        }\n  member inline this.Content     c    = { this with content     =       c                         }\n  member inline this.Prefix      p    = { this with prefix      =       p    ; prefixAdded = true }\n  member inline this.Suffix      s    = { this with suffix      =       s    ; suffixAdded = true }\n  member inline this.SetVar      v    = { this with var         = v                               }\n  member inline this.Var              = this.var","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},"expanded":true,"level":0,"properties":{}},{"name":"Hoverable","content":"[<NoComparison ; NoEquality>]\ntype Hoverable = {\n    hover      : IRef<bool>\n} with\n  static member  New   = \n    let hover      = Var.Create false\n    { \n        hover      = hover     \n    }\n  member inline this.Content    (c: HtmlNode seq) = \n    [ classIf \"hovering\" this.hover\n      SomeAttr <| on.mouseEnter (fun _ _ -> this.hover.Value <- true )\n      SomeAttr <| on.mouseLeave (fun _ _ -> this.hover.Value <- false)\n    ] \n    |> Seq.append  c\n    |> div\n  member inline this.Content    (c:HtmlNode) = \n      c.AddChildren \n          [ classIf \"hovering\" this.hover\n            SomeAttr <| on.mouseEnter (fun _ _ -> this.hover.Value <- true )\n            SomeAttr <| on.mouseLeave (fun _ _ -> this.hover.Value <- false)\n          ] \n  static member  Demo  = Hoverable.New.Content(div [ style \"flex-flow: column;\" ])\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"},"expanded":true,"level":0,"properties":{}},{"name":"Panel","content":"[<NoComparison ; NoEquality>]\ntype Panel = {\n    _class   : Val<string>\n    _style   : Val<string>\n    title    : Val<string>\n    header   : HtmlNode seq\n    content  : HtmlNode seq\n    disabled : Val<bool>\n} with\n  static member  New   = { _class   = Val.fixit <| \"panel panel-default shadow\"\n                           _style   = Val.fixit <| \"text-align:center\" \n                           title    = Val.fixit <| \"Panel\"        \n                           header   =          [ htmlText \"Some text\"    ] \n                           content  =          [ htmlText \"Some Content\" ] \n                           disabled = Val.fixit <| Var.Create false\n                         }\n  member        this.Render          =  \n    fieldset [ SomeAttr <| attr.disabledDynPred (View.Const \"\")  (this.disabled |> Val.toView)\n               div [ ``class`` this._class\n                     div (Seq.append\n                              [ ``class`` \"panel-heading\"\n                                label [ ``class``  \"panel-title text-center\" ; htmlText this.title ]\n                              ]\n                              this.header)\n\n                     div (Seq.append\n                              [ ``class`` \"panel-body\"\n                                style     this._style \n                              ]\n                              this.content)\n                   ] \n             ]\n  member inline this.Class       clas = { this with _class   = Val.fixit clas                                        }\n  member inline this.Style       sty  = { this with _style   = Val.fixit sty                                         }\n  member inline this.Title       txt  = { this with title    = Val.fixit txt                                         }\n  member inline this.Header      h    = { this with header   =       h                                           }\n  member inline this.Content     c    = { this with content  =       c                                           }\n  member inline this.Disabled    dis  = { this with disabled =       dis                                         }\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"}],"id":{"$":0,"Item":"0a11766b-f227-4b38-88a3-919d964387bf"},"expanded":true,"level":0,"properties":{}},{"name":"TextArea","content":"[<NoComparison ; NoEquality>]\ntype TextArea = {\n    _class      : Val<string>\n    placeholder : Val<string>\n    title       : Val<string>\n    spellcheck  : Val<bool>\n    id          : string\n    var         : IRef<string>\n} with\n  static member  New(var) = { _class      = Val.fixit \"form-control\"\n                              placeholder = Val.fixit \"Enter text:\"\n                              title       = Val.fixit \"\"\n                              spellcheck  = Val.fixit false\n                              id          = \"\"\n                              var         = var \n                            }\n  static member  New(v)   = TextArea.New(Var.Create v)\n  member        this.RenderWith  more  =    \n    Doc.InputArea\n        ([ \n          _class              this._class\n          attr.id             this.id  \n          atr \"spellcheck\" <| Val.map (fun spl -> if spl then \"true\" else \"false\") this.spellcheck\n          atr \"title\"         this.title\n          atr \"style\"        \"height: 100%;  width: 100%; box-sizing: border-box; \"\n          _placeholder        this.placeholder \n        ] @ more)\n        this.var\n    |> someElt \n    |> Seq.singleton \n    //|> Seq.append [ style \"height: 100%;  width: 100%; box-sizing: border-box; \" ] \n    |> div\n  member        this.Render           = this.RenderWith []    \n  member inline this.Class       clas = { this with _class      = Val.fixit clas }\n  member inline this.Placeholder plc  = { this with placeholder = Val.fixit plc  }\n  member inline this.Title       ttl  = { this with title       = Val.fixit ttl  }\n  member inline this.Spellcheck  spl  = { this with spellcheck  = spl            }\n  member inline this.Id          id   = { this with id          = id             }\n  member inline this.SetVar      v    = { this with var         = v              }\n  member inline this.Var              = this.var\n  ","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},"expanded":true,"level":0,"properties":{}},{"name":"codeMirrorIncludes","content":"let codeMirrorIncludes =\n   [| \"/EPFileX/codemirror/scripts/codemirror/codemirror.js\"             \n      \"/EPFileX/codemirror/scripts/intellisense.js\"                      \n      \"/EPFileX/codemirror/scripts/codemirror/codemirror-intellisense.js\"\n      \"/EPFileX/codemirror/scripts/codemirror/codemirror-compiler.js\"    \n      \"/EPFileX/codemirror/scripts/codemirror/mode/fsharp.js\"            \n      \"/EPFileX/codemirror/scripts/addon/search/searchcursor.js\"          \n      \"/EPFileX/codemirror/scripts/addon/search/search.js\"          \n      \"/EPFileX/codemirror/scripts/addon/search/jump-to-line.js\"          \n      \"/EPFileX/codemirror/scripts/addon/dialog/dialog.js\"          \n      \"/EPFileX/codemirror/scripts/addon/edit/matchbrackets.js\"          \n      \"/EPFileX/codemirror/scripts/addon/selection/active-line.js\"       \n      \"/EPFileX/codemirror/scripts/addon/display/fullscreen.js\"          \n      \"/EPFileX/codemirror/scripts/addon/hint/show-hint.js\"          \n      \"/EPFileX/codemirror/scripts/addon/lint/lint.js\"          \n//      \"/EPFileX/codemirror/scripts/codemirror/mode/markdown.js\"                 \n   |]","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"4180353c-9dc5-438d-862d-851539b02075"},"expanded":true,"level":0,"properties":{}},{"name":"CodeMirror","content":"type CodeMirrorPos = { line: int ; ch  : int }\nlet inline cmPos(l, c) = { line = l ; ch  = c }\n\ntype CodeMirrorEditor() =\n    let a = 1\n  with\n    [< Inline \"CodeMirror($elt, {\n\t    theme        : 'rubyblue'\n\t  , lineNumbers  : true\n\t  , matchBrackets: true\n      , gutters      : ['CodeMirror-lint-markers']\n      , extraKeys    : {\n\t\t    Tab  : function (cm) { cm.replaceSelection('    ', 'end'); }\n\t\t  , 'F11': function (cm) { cm.setOption('fullScreen', !cm.getOption('fullScreen')); }\n        }\n})\"    >]\n//    [< Inline \"setupEditor($elt)\" >]\n    static member SetupEditor elt                                     : CodeMirrorEditor = X<_>\n    [< Inline \"$this.getValue()\"              >]      \n    member this.GetValue()                                            : string           = X<_>\n    [< Inline \"$this.setValue($v)\"            >]      \n    member this.SetValue(v:string)                                    : unit             = X<_>\n    [< Inline \"$this.setOption($o, $v)\"       >]      \n    member this.SetOption(o:string, v:obj)                            : unit             = X<_>\n    [< Inline \"$this.getCursor()\"             >]      \n    member this.GetCursor()                                           : CodeMirrorPos    = X<_>\n    [< Inline \"$this.setCursor($line, $col)\"  >]      \n    member this.SetCursor(line:int, col:int)                          : unit             = X<_>\n    [< Inline \"$this.focus()\"                 >]      \n    member this.Focus()                                               : unit             = X<_>\n    [< Inline \"$this.getLine($l)\"             >]      \n    member this.GetLine(l:int)                                        : string           = X<_>\n    [< Inline \"$this.getDoc().markText({line:$fl, ch:$fc}, {line:$tl, ch:$tc}, {className: $className, title: $title})\" >]\n    member this.MarkText (fl:int, fc:int) (tl:int, tc:int) (className: string) (title: string): unit       = X<_>\n    [< Inline \"while($this.getAllMarks().length > 0) { $this.getAllMarks()[0].clear() }\" >]\n    member this.RemoveMarks() : unit       = X<_>\n    [< Inline \"$this.getDoc().clearHistory()\" >]\n    member this.ClearHistory()                                        : unit             = X<_>\n    [< Inline \"$this.on($event, $f)\"          >]\n    member this.On(event: string, f:(CodeMirrorEditor * obj) -> unit) : unit             = X<_>\n    [< Inline \"$this.addKeyMap($keyMap)\"      >]\n    member this.AddKeyMap(keyMap: obj)                                : unit              = X<_>\n    [< Inline \"$this.getWrapperElement()\"     >]\n    member this.GetWrapperElement()                                   : Dom.Element       = X<_>\n\n[<NoComparison ; NoEquality>]\ntype CodeMirror = {\n    _class          : Val<string>\n    style           : Val<string>\n    id              : string\n    var             : IRef<string>\n    onChange        : (unit             -> unit)\n    onRender        : (CodeMirrorEditor -> unit) option\n    mutable editorO : CodeMirrorEditor option\n} with\n\n  static member  New(var) = \n      { _class   = Val.fixit \"\" \n        style    = Val.fixit \"\" \n        id       = \"\"\n        var      = var \n        onChange = ignore\n        onRender = None\n        editorO  = None\n      }\n  static member  New(v)   = CodeMirror.New(Var.Create v)\n  member        this.Render    =\n    div [ \n          ``class``            this._class\n          SomeAttr <| attr.id  this.id \n          style \"position: relative; height: 300px\"\n          style                this.style\n          div [\n                style \"height: 100%; width: 100%; position: absolute;\"\n                SomeAttr <| on.afterRender (fun el ->\n                  LoadFiles codeMirrorIncludes\n                    (fun () ->                       \n                       let editor = CodeMirrorEditor.SetupEditor el\n                       this.editorO <- Some editor\n                       this.onRender |> Option.iter (fun onrender -> onrender editor)\n                       let editorChanged = ref 0L\n                       let varChanged    = ref 0L\n                       editor.On(\"changes\", fun (cm, change) ->\n                           let v = editor.GetValue() \n                           if this.var.Value <> v then editorChanged := !editorChanged + 1L; this.var.Value <- v; this.onChange() \n                       )\n                       this.var.View |> View.Sink (fun _ ->\n                           if  !editorChanged      > !varChanged    then varChanged := !editorChanged\n                           elif editor.GetValue() <> this.var.Value then editor.SetValue this.var.Value ; editor.ClearHistory()\n                       )\n                    )\n                )    \n              ]\n          link [ href \"/EPFileX/codemirror/content/editor.css\"                   ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/content/codemirror.css\"               ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/content/theme/rubyblue.css\"           ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/display/fullscreen.css\" ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/dialog/dialog.css\"      ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/hint/show-hint.css\"     ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/lint/lint.css\"          ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          css  \".CodeMirror { height: 100% }\"\n     ]\n  member inline this.Class    clas = { this with _class    = Val.fixit clas }\n  member inline this.Id       id   = { this with id        =       id       }\n  member inline this.SetVar   v    = { this with var       = v              }\n  member inline this.Style    sty  = { this with style     = Val.fixit sty  }\n  member inline this.OnChange f    = { this with onChange  = f              }\n  member inline this.OnRender f    = { this with onRender  = Some f         }\n  member inline this.Var           = this.var\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"1f1aa135-fd74-42cc-b9a5-87f380c113a9"},{"$":0,"Item":"4180353c-9dc5-438d-862d-851539b02075"}],"id":{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},"expanded":true,"level":0,"properties":{}},{"name":"CodeMirror Hints","content":"\ntype Hint = {\n    text        : string\n    displayText : string\n    className   : string\n}\n\ntype HintResponse  = {\n    list           : Hint []\n    from           : CodeMirrorPos   \n    ``to``         : CodeMirrorPos   \n}\n\ntype HintFunc      = FuncWithArgs<CodeMirrorEditor * (HintResponse -> unit) * obj,  unit>\n\ntype HintOptions   = {\n    hint           : HintFunc\n    completeSingle : bool   \n    container      : Dom.Element\n}\n\n[< Inline \"($v.hint.async = 1, $ed.showHint($v))\"          >]\nlet showHint_ (ed:CodeMirrorEditor) v   : unit       = X<_>\nlet showHints (ed:CodeMirrorEditor) getHints completeSingle _ =\n    showHint_ ed\n        {  completeSingle = completeSingle\n           hint           = HintFunc getHints\n           container      = ed.GetWrapperElement() |> findRootElement\n        }\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"id":{"$":0,"Item":"a05dd36e-a15e-4394-8013-128e21e69574"},"expanded":true,"level":0,"properties":{}},{"name":"CodeMirror Lint","content":"type LintResponse  = {\n    message        : string\n    severity       : string\n    from           : CodeMirrorPos   \n    ``to``         : CodeMirrorPos   \n}\n\ntype LintFunc      = FuncWithArgs<string * (LintResponse[] -> unit) * obj * CodeMirrorEditor,  unit>\n\n[< Inline \"($ed.setOption('lint', { async: 1, getAnnotations: $f, container: $elm }))\"          >]\nlet setLint_(ed:CodeMirrorEditor) (f:LintFunc) (elm:Dom.Element)  : unit = X<_>\nlet setLint (ed:CodeMirrorEditor) getAnnotations       = \n    setLint_ ed (LintFunc getAnnotations) (ed.GetWrapperElement() |> findRootElement)\n\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"id":{"$":0,"Item":"18d8153d-422c-42f6-8266-9a9d854bd6a1"},"expanded":true,"level":0,"properties":{}},{"name":"SplitterBar","content":"[<NoComparison ; NoEquality>]\ntype HtmlMeasure =\n| Percentage of Val<float>\n| Pixel      of Val<float>\n\n[<NoComparison ; NoEquality>]\ntype SplitterBar = {\n    value            : IRef<float>\n    min              : Val<float>\n    max              : Val<float>\n    vertical         : Val<bool>\n    node             : HtmlNode\n    children         : HtmlNode seq\n    after            : bool\n    mutable dragging : bool\n    mutable startVer : bool \n    mutable startP   : float \n    mutable start    : float \n    mutable size     : float \n    mutable domElem  : Dom.Element option\n}\nwith\n    static member New(var) = \n        {\n            value    = var\n            min      = Val.fixit   5.0\n            max      = Val.fixit  95.0\n            vertical = Val.fixit  true  \n            node     = div [ ``class`` \"Splitter\" ]\n            children = []\n            after    = true\n            dragging = false\n            startVer = true\n            startP   = 0.0\n            start    = 0.0\n            size     = 0.0\n            domElem  = None\n        }\n    static member New(value)    = SplitterBar.New(Var.Create value)\n    member        this.Var      = this.value\n    member        this.GetValue = this.value |> Val.map2 max this.min |> Val.map2 min this.max\n    member        this.Render   =\n        let mouseCoord (ev: Dom.MouseEvent) = if this.startVer then float ev.ClientX else float ev.ClientY\n        let size () : float =\n            match this.domElem with\n            | None    -> 100.0\n            | Some el -> \n             el.ParentElement.GetBoundingClientRect() \n             |> fun r -> \n                 match this.startVer, this.after with\n                 | true , true  ->  r.Width  \n                 | true , false -> -r.Width \n                 | false, true  ->  r.Height\n                 | false, false -> -r.Height\n        let drag (ev: Dom.Event) =\n            ev :?> Dom.MouseEvent\n            |> mouseCoord\n            |> fun m   -> (m - this.start) * 100.0 / this.size + this.startP\n            |> fun v   -> this.value.Value <- v // ; JS.Inline(\"console.log($0)\", this)\n           \n        let rec finishDragging (_: Dom.Event) =\n            if this.dragging then\n                this.dragging <- false\n                JS.Window.RemoveEventListener(\"mousemove\", drag          , false) \n                JS.Window.RemoveEventListener(\"mouseup\"  , finishDragging, false) \n                //printfn \"mouseup\"\n        let startDragging _ (ev: Dom.MouseEvent) =\n            if not this.dragging then\n                Val.map2 (fun startP dirV ->\n                    this.dragging <- true\n                    this.startVer <- dirV\n                    this.startP   <- startP\n                    this.start    <- mouseCoord ev\n                    this.size     <- size()\n                    JS.Window.AddEventListener(\"mousemove\", drag          , false) \n                    JS.Window.AddEventListener(\"mouseup\"  , finishDragging, false) \n                    ev.PreventDefault()\n                ) this.GetValue this.vertical\n                |> Val.iter id\n        this.node\n          .AddChildren(\n          [\n            ``class`` <| Val.map (fun ver -> if ver then \"Vertical\" else \"Horizontal\") this.vertical \n            SomeAttr  <| on.mouseDown startDragging\n            SomeAttr  <| on.afterRender (fun el -> this.domElem <- Some el)\n            css \"\n                .Splitter.Vertical   { cursor: col-resize; background-color: #eef ; width : 5px ; margin-left:-7px; }\n                .Splitter.Horizontal { cursor: row-resize; background-color: #eef ; height: 5px ; margin-top :-7px; }\n            \"\n          ])\n          .AddChildren this.children\n    member inline this.Value       v =   this.value.Value <- v  ; this\n    member inline this.Node     node = { this with node         = node                        }\n    member inline this.Min         v = { this with min          = Val.fixit v                 }\n    member inline this.Max         v = { this with max          = Val.fixit v                 }\n    member inline this.Vertical    v = { this with vertical     = Val.fixit v                 }\n    member inline this.Horizontal  v = { this with vertical     = Val.fixit v |> Val.map not  }\n    member inline this.Vertical   () = { this with vertical     = Val.fixit true              }\n    member inline this.Horizontal () = { this with vertical     = Val.fixit false             }\n    member inline this.Before        = { this with after        =           false             }\n    member inline this.After         = { this with after        =           true              }\n    member inline this.Children   ch = { this with children     = ch                          }\n    ","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"},"expanded":true,"level":0,"properties":{}},{"name":"ResizeObserver","content":"[< Inline \"new ResizeObserver($f)\" >]\nlet newResizeObserver (f: unit->unit) = X<_> \n\n[< Inline \"$ro.observe($el)\" >]\nlet RObserve ro (el:Dom.Element) = X<_> \n\nlet mutable observers : obj list = []\n\nlet addResizeObserver f el =\n    let ro =  newResizeObserver f\n    observers <- ro::observers\n    RObserve ro el","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"5878287a-a18f-4c71-b086-bd6e146270a1"},"expanded":true,"level":0,"properties":{}},{"name":"Grid","content":"[<NoComparison ; NoEquality>]\ntype Area =\n| Auto     of SplitterBar\n| Fixed    of HtmlMeasure\n| Splitter of SplitterBar\n\n[<NoComparison ; NoEquality>]\ntype Grid = {\n    padding       : float\n    gap           : float\n    content       : (string option * HtmlNode) []\n    cols          : Area []\n    rows          : Area []\n    width         : IRef<float>\n    height        : IRef<float>\n    lastSplitter  : (int * bool) option\n}\nwith\n    static member New = {\n       padding       = 9.0\n       gap           = 9.0\n       cols          = [| |]\n       rows          = [| |]\n       content       = [| |]\n       width         = Var.Create 1000.0\n       height        = Var.Create  100.0\n       lastSplitter  = None\n    }\n    member this.NewSplitter  (f: float)  col =\n        let spl = SplitterBar.New(f)\n        if col then\n            { this with lastSplitter = Some (this.cols.Length, col) ; cols = Array.append this.cols  [| spl              |> Splitter |] }\n        else \n            { this with lastSplitter = Some (this.rows.Length, col) ; rows = Array.append this.rows  [| spl.Horizontal() |> Splitter |] }\n    member inline this.ColFixedPx   f              = { this with cols    = Array.append this.cols    [| Pixel     (Val.fixit f)              |> Fixed    |] }\n    member inline this.ColFixed     f              = { this with cols    = Array.append this.cols    [| Percentage(Val.fixit f)              |> Fixed    |] }\n    member inline this.ColVariable (s:SplitterBar) = { this with cols    = Array.append this.cols    [| s                                    |> Splitter |] }\n    member inline this.ColVariable (f:float)       = this.NewSplitter f true\n    member inline this.ColAuto     (f:float)       = { this with cols    = Array.append this.cols    [| SplitterBar.New(     f)              |> Auto     |] }\n    member inline this.RowFixedPx   f              = { this with rows    = Array.append this.rows    [| Pixel     (Val.fixit f)              |> Fixed    |] }\n    member inline this.RowFixed     f              = { this with rows    = Array.append this.rows    [| Percentage(Val.fixit f)              |> Fixed    |] }\n    member inline this.RowVariable (s:SplitterBar) = { this with rows    = Array.append this.rows    [| s                                    |> Splitter |] }\n    member inline this.RowVariable (f:float)       = this.NewSplitter f false\n    member inline this.RowAuto     (f:float)       = { this with rows    = Array.append this.rows    [| SplitterBar.New(     f).Horizontal() |> Auto     |] }\n    member        this.Content (area, html)        = { this with content = Array.append this.content [| Some area, html                                  |] }\n    member        this.Content        html         = { this with content = Array.append this.content [| None     , html                                  |] }\n    member inline this.Padding      f              = { this with padding = f                                                                                }\n    member inline this.Gap          f              = { this with gap     = f                                                                                }\n    member this.changeSplitter f =\n        this.lastSplitter\n        |> Option.iter (fun (pos, col) ->\n            if col then\n                match this.cols.[pos] with\n                | Splitter spl -> this.cols.[pos] <- Splitter <| f spl \n                | _            -> ()\n            else \n                match this.rows.[pos] with\n                | Splitter spl -> this.rows.[pos] <- Splitter <| f spl \n                | _            -> ()\n        )\n        this\n    member        this.Before                = this.changeSplitter (fun spl -> spl.Before     )\n    member inline this.Max                 v = this.changeSplitter (fun spl -> spl.Max       v)\n    member inline this.Min                 v = this.changeSplitter (fun spl -> spl.Min       v)\n    member inline this.Children           ch = this.changeSplitter (fun spl -> spl.Children ch)\n    member this.style    (areas:Area[]) size =\n        if areas.Length = 0 then Val.Constant \"100%\" else\n        let pcs, pxs = \n            areas \n            |> Seq.fold (fun (pcs, pxs) a ->\n                match a with\n                | Auto              spl -> (                          pcs,                pxs)          \n                | Splitter          spl -> (Val.map2 (+) spl.GetValue pcs,                pxs) \n                | Fixed (Percentage v)  -> (Val.map2 (+) v            pcs,                pxs)\n                | Fixed (Pixel      v)  -> (                          pcs, Val.map2 (+) v pxs)\n            ) (Val.Constant 0.0, Val.Constant 0.0)\n        let finalPerc = Val.map2 (fun v size -> (size - this.padding * 2. - this.gap * ((float areas.Length) - 1.) - v) / (size - this.padding * 2.)) pxs size\n        let autoPct   = Val.map  ((-) 100.0)  pcs \n        let perc   pc = Val.map2 (fun finalPerc pc -> finalPerc * pc |> max 0.0 |> sprintf \"%f%%\") finalPerc pc\n        let pixel  px = Val.map  (fun           px ->             px |> max 0.0 |> sprintf \"%fpx\")           px\n        areas\n        |> Seq.foldBack (fun a state ->\n            match a with\n            |  Auto              spl -> perc  autoPct          \n            |  Splitter          spl -> perc  spl.GetValue\n            |  Fixed (Percentage v)  -> perc  v\n            |  Fixed (Pixel      v)  -> pixel v\n            |> Val.map2(fun state v -> v::state) state\n           )  <| (Val.Constant [])\n        |> Val.map (String.concat \" \")\n    member this.styles() =\n        [ style1 \"grid-template-columns\" <| this.style this.cols this.width\n          style1 \"grid-template-rows\"    <| this.style this.rows this.height\n        ]\n    member this.GridTemplate() =\n        [ \n            yield!\n                this.content\n                |> Seq.map (fun (area, html) ->\n                    match area with\n                    | None   -> html\n                    | Some a -> html.AddChildren([ style <| sprintf \"grid-area: %s\" a ])\n                   )\n            yield!\n                this.cols\n                |> Seq.indexed\n                |> Seq.choose (function\n                    | i, Auto     spl -> None           \n                    | i, Splitter spl -> Some <| spl.Render.InsertChildren( \n                                            [ style1 \"grid-column\" (string (i + if spl.after then 2 else 1))\n                                              style1 \"grid-row\"    (sprintf \"1 / %d\" (this.rows.Length + 1)) ] ) \n                    | i, Fixed    _   -> None\n               )\n            yield!\n                this.rows\n                |> Seq.indexed\n                |> Seq.choose (function\n                    | i, Auto     spl -> None           \n                    | i, Splitter spl -> Some <| spl.Render.InsertChildren( \n                                            [ style1 \"grid-row\"    (string (i + if spl.after then 2 else 1))\n                                              style1 \"grid-column\" (sprintf \"1 / %d\" (this.cols.Length + 1)) ] ) \n                    | i, Fixed    _   -> None\n               )\n            yield! this.styles() \n            yield style    <| sprintf \"display: grid; grid-gap: %fpx; padding: %fpx; box-sizing: border-box\" this.gap this.padding \n            yield SomeAttr <| on.afterRender(fun el   -> \n                let setVar (vr:IRef<_>) vl = if vr.Value <> vl then vr.Value <- vl \n                let setDimensions () =\n                    el.GetBoundingClientRect()\n                    |> fun r ->  \n                        setVar this.width  r.Width\n                        setVar this.height r.Height\n                JS.SetTimeout  setDimensions 60 |> ignore\n                addResizeObserver setDimensions el\n              ) \n        ]\n    member this.Render =\n        div <| this.GridTemplate()","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"5878287a-a18f-4c71-b086-bd6e146270a1"},{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"id":{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},"expanded":true,"level":0,"properties":{}},{"name":"TabStrip","content":"let reorderList (ts:'a list) drag drop =\n    if drop < drag then\n       ts.[0       ..drop - 1     ]\n     @    [      ts.[drag]        ]\n     @ ts.[drop    ..drag - 1     ]\n     @ ts.[drag + 1..ts.Length - 1]\n    else\n       ts.[0..drag - 1            ]\n     @ ts.[drag + 1..drop         ]\n     @    [      ts.[drag]        ]\n     @ ts.[drop + 1..ts.Length - 1]\n\nlet reorderArray (ts:'a []) drag drop =\n   (if drop < drag then\n      [|\n       ts.[0       ..drop - 1     ]\n       [|        ts.[drag]       |]\n       ts.[drop    ..drag - 1     ]\n       ts.[drag + 1..ts.Length - 1]\n      |]\n    else\n      [|\n       ts.[0..drag - 1            ]\n       ts.[drag + 1..drop         ]\n       [|        ts.[drag]       |]\n       ts.[drop + 1..ts.Length - 1]\n      |]\n   )|> Array.collect id \n\n\n[< NoComparison >]\ntype TabStrip =\n    { selected  : IRef<int>\n      tabs      : IRef<(System.Guid * (string * HtmlNode)) []>\n      top       : bool\n      horizontal: bool\n      id        : System.Guid\n    } \n\nlet draggedTab: (TabStrip * int) option ref = ref None\n\nlet uid2s (uid: System.Guid) = \"X\" + uid.ToString().Replace(\"-\", \"\")\n\nlet selectedPanels: Var<Map<System.Guid, System.Guid>> = Var.Create Map.empty \n\nlet setSelectedPanel group panelO = \n    selectedPanels.Value <- \n        match panelO with\n        | Some panel -> selectedPanels.Value.Add    (group, panel)\n        | None       -> selectedPanels.Value.Remove  group\n\nlet mutable TabMoved : ((TabStrip * TabStrip) -> unit) option = None\nlet RaiseTabMoved fromS toS = TabMoved |> Option.iter (fun f -> f (fromS, toS))\n\ntype TabStrip with\n    member this.moveTab from drag drop =\n        let ts = this.tabs.Value\n        let ft = from.tabs.Value\n        let newTabsT =\n            [|\n             ts.[0       ..drop - 1     ]\n             [|        ft.[drag]       |]\n             ts.[drop    ..ts.Length - 1]\n            |]\n            |> Array.collect id\n        let newTabsF =\n            [|\n             ft.[0       ..drag - 1     ]\n             ft.[drag + 1..ft.Length - 1]\n            |]\n            |> Array.collect id\n        from.tabs.Value     <- newTabsF\n        this.tabs.Value     <- newTabsT\n        this.selected.Value <- drop\n        if from.selected.Value >= newTabsF.Length then from.selected.Value <- 0\n        RaiseTabMoved from this\n\n    member this.reorder drop =\n        match !draggedTab with\n        | None                                     -> ()\n        | Some(from, drag) when from.id <> this.id -> this.moveTab from drag drop\n        | Some(from, drag)                         ->\n        this.tabs.Value     <- reorderArray this.tabs.Value drag drop\n        let sel = this.selected.Value\n        this.selected.Value <- if    sel = drag                then drop\n                               elif (sel < drag && sel < drop)\n                                 || (sel > drag && sel > drop) then sel \n                               elif  sel < drag                then sel + 1\n                               else                                 sel - 1\n                               \n    static member New(tabs)    =\n        { selected   = Var.Create 0\n          tabs       = tabs \n          top        = false \n          horizontal = true\n          id         = System.Guid.NewGuid() \n        } \n    static member New(tabs) = TabStrip.New(tabs |> Seq.map (fun def -> System.Guid.NewGuid(), def) |> Seq.toArray |> Var.Create)\n    member this.Top         = { this with top        = true  }\n    member this.Bottom      = { this with top        = false }\n    member this.Horizontal  = { this with horizontal = true  }\n    member this.Vertical    = { this with horizontal = false }\n    member this.Selected    = Val.map2 (fun tabs sel -> tabs |> Seq.tryItem sel |> Option.map fst) this.tabs this.selected\n    member this.Select    n = this.selected.Value <- n\n    member this.Select   nm = this.tabs.Value |> Seq.indexed |> Seq.tryPick (fun (i, (_ , (tn, _))) -> if tn = nm then this.selected.Value <- i ; Some true else None) |> Option.defaultValue false\n    member this.Select   gi = this.tabs.Value |> Seq.indexed |> Seq.tryPick (fun (i, (ti, (_ , _))) -> if ti = gi then this.selected.Value <- i ; Some true else None) |> Option.defaultValue false\n    member this.Render      =\n        let strip =\n            this.tabs\n            |> bindHElem (\n                fun tabs ->\n                    div [ yield ``class`` <| sprintf \"tab-strip %s %s\"\n                                                (if this.top        then \"top\"        else \"bottom\"  ) \n                                                (if this.horizontal then \"horizontal\" else \"vertical\")\n                          \n                          for i, (uid, (txt, _)) in  tabs |> Seq.indexed  do\n                              yield Hoverable.New.Content(\n                                    div [ htmlText txt\n                                          ``class`` <| Val.map (fun sel -> \"tab\" + (if sel = i then \" selected\" else \"\")) this.selected\n                                          draggable \"true\"\n                                          SomeAttr <| on.dragOver(fun _ ev -> ev.PreventDefault()                            )\n                                          SomeAttr <| on.drag    (fun _ _  ->                     draggedTab := Some(this, i))\n                                          SomeAttr <| on.drop    (fun e ev -> ev.PreventDefault(); ev.StopPropagation() ; this.reorder i )\n                                          SomeAttr <| on.click   (fun _ _  ->                       this.selected.Value <- i ) \n                                        ])\n                        ]\n            )\n        Val.sink (setSelectedPanel this.id) this.Selected  \n        let content = \n            this.tabs\n            |> bindHElem (fun tabs ->\n                div [\n                  yield  ``class`` \"tab-children\"\n                  yield  Id <| uid2s this.id\n                  yield!\n                      tabs\n                      |> Seq.map (fun (uid, (txt, sub)) -> \n                          sub.AddChildren(\n                            [ style <| Val.map (fun sels -> if sels |> Map.toSeq |> Seq.map snd |> Seq.contains uid then \"\" else \"display : none\") selectedPanels\n                              Id    <| uid2s uid\n                            ]))\n                ] \n             )\n        div [ ``class`` \"tab-panel\"\n              (if     this.top then strip else HtmlEmpty)\n              div [ content ; ``class`` \"tab-content\" ]\n              (if not this.top then strip else HtmlEmpty)\n              SomeAttr <| on.dragOver(fun _ ev -> ev.PreventDefault()                                      )\n              SomeAttr <| on.drop    (fun e ev -> ev.PreventDefault() ; this.reorder this.tabs.Value.Length)\n              css @\"\n\n.tab-panel {\n overflow : hidden ;\n display  : flex   ;\n flex-flow: column ;\n background: pink    ;\n}\n.tab-content {\n flex      : 1 1     ;\n overflow  : auto    ;\n position  : relative;\n}\n.tab-children {\n height    : 100%    ;\n width     : 100%    ;\n position  : absolute;\n display   : grid    ;\n}\n.tab-strip {\n padding   : 0pt     ;\n flex      : 0 0     ;\n}\n.tab {\n border     : 0.2pt solid transparent;\n padding    : 0pt 4pt;\n display    : inline-block;\n font-family: sans-serif;\n font-weight: 200;\n font-size  : small;\n color      : #666;\n cursor     : pointer;\n}\n.top>.tab {\n border-radius: 2pt 2pt 0pt 0pt;\n border-bottom-width: 0pt;\n vertical-align: bottom;\n}\n.bottom>.tab {\n border-top-width: 0pt;\n border-radius: 0pt 0pt 2pt 2pt;\n vertical-align: top;\n}\n.horizontal>.tab:not(:first-child) {\n border-left-width: 0pt;\n}\n.tab.hovering {\n background: red;\n}\n.tab.selected {\n background: white;\n border-left-width: 0.2pt;\n color: black;\n font-weight: 500;\n border-color: black;\n}\n.horizontal>.tab.selected {\n border-left-width: 0.2pt;\n}\n\"]","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"}],"id":{"$":0,"Item":"cddabd38-7ecb-4692-99bd-13ca70e4232f"},"expanded":true,"level":0,"properties":{}},{"name":"SplitterNode","content":"#nowarn \"1178\"\ntype SplitterNode = | SplitterNode of Var<SplitterStructure>\nand  SplitterStructure =\n    | SHtmlNode of HtmlNode\n    | STabStrip of TabStrip\n    | Split     of SplitterNode * SplitterNode * (SplitterNode -> SplitterNode -> HtmlNode)\n\nlet rec renderSplitterNode      sn = match sn with SplitterNode chV -> bindHElem (fun ch -> renderSplitterStructure ch) chV \nand     renderSplitterStructure ss =\n        match ss with\n        | SHtmlNode node        -> node\n        | STabStrip strip       -> strip.Render  \n        | Split   (ch1, ch2, f) -> f ch1 ch2\n\nlet renderSplitter (per:float) ver ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", renderSplitterNode ch1)\n                       .Content(\"two\", renderSplitterNode ch2).Padding(0.0)\n    if ver then grid.ColVariable(per).ColAuto(50.0).Content( style \"grid-template-areas: 'one   two' \" ).Render\n           else grid.RowVariable(per).RowAuto(50.0).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\ntype SplitterStructure with    \n    static member New(vertical : bool, child1, child2, per) = Split(SplitterNode (Var.Create              child1), SplitterNode (Var.Create              child2), renderSplitter per  vertical)\n    static member New(vertical : bool, child1, child2     ) = Split(SplitterNode (Var.Create              child1), SplitterNode (Var.Create              child2), renderSplitter 50.0 vertical)\n    static member New(vertical : bool, child1, child2, per) = Split(SplitterNode (Var.Create <| SHtmlNode child1), SplitterNode (Var.Create <| SHtmlNode child2), renderSplitter per  vertical)\n    static member New(vertical : bool, child1, child2, per) = Split(SplitterNode (Var.Create <| STabStrip child1), SplitterNode (Var.Create <| STabStrip child2), renderSplitter per  vertical)\n    static member New(ss1, ss2, f                    ) = Split(SplitterNode (Var.Create ss1                ), SplitterNode (Var.Create ss2                ), f                      )\n    static member New(strip                          ) = STabStrip strip\n    static member New(node                           ) = SHtmlNode node\n\ntype SplitterNode with\n    static member New        ss           = SplitterNode <| Var.Create ss\n    static member New       (ss:HtmlNode) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    static member New       (ss:TabStrip) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    member this.Render                    = renderSplitterNode this\n    member this.Var                       = match this with SplitterNode chV -> chV\n    member this.Value                     = this.Var.Value\n    member this.SplitMe(first, ver, node) =\n        this.Var.Value <- if first then SplitterStructure.New(ver, node      , this.Value) \n                                   else SplitterStructure.New(ver, this.Value, node      )\n    member this.SplitMe(first, ver, node:TabStrip) = this.SplitMe(first, ver, STabStrip node      )\n    member this.SplitMe(first, ver, node:HtmlNode) = this.SplitMe(first, ver, SHtmlNode node      )\n    member this.SplitMe(first, ver               ) = this.SplitMe(first, ver, TabStrip.New([||])  )\n    member this.Navigate recFun                    =\n        match this.Value with\n        | SHtmlNode _           \n        | STabStrip _           -> recFun this.Value\n        | Split   (ch1, ch2, f) -> ch1.Navigate recFun || ch2.Navigate recFun\n    member this.SelectTab  (nm: string)            = this.Navigate (function | STabStrip strip -> strip.Select nm | _ -> false) \n    member this.IsEmpty                            =\n        match this.Value with\n        | SHtmlNode HtmlEmpty   -> true\n        | SHtmlNode _           -> false\n        | STabStrip strip       -> strip.tabs.Value.Length = 0\n        | Split   (ch1, ch2, f) -> ch1.IsEmpty && ch2.IsEmpty\n    member this.UnSplitEmpties()                   =\n        if                                    this.IsEmpty then this.Var.Value <- SplitterStructure.New(TabStrip.New([||])) else\n        match this.Value with\n        | Split   (ch1, ch2, f) -> if   ch1.IsEmpty then ch2.UnSplitEmpties() ; this.Var.Value <- ch2.Value \n                                   elif ch2.IsEmpty then ch1.UnSplitEmpties() ; this.Var.Value <- ch1.Value \n                                                    else ch1.UnSplitEmpties()\n                                                         ch2.UnSplitEmpties()\n        | _                     -> ()  \n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"cddabd38-7ecb-4692-99bd-13ca70e4232f"}],"id":{"$":0,"Item":"a48d72fc-5220-4dac-b3b3-98bad48b0561"},"expanded":true,"level":0,"properties":{}},{"name":"MenuBar","content":"let inline menuEntry content   = li [ content ]\nlet inline private ref       content r = a  [ content ; hrefO r ] \nlet inline refText   txt     r = bindHElem (fun t -> if t = \"\" then HtmlEmpty else ref (htmlText t) r) txt\nlet inline entryTxt  txt     r = menuEntry (refText  txt  r)\n  \nlet inline entries    ch cl    =  ul ch |> addClass cl\nlet inline nav        ch       =  entries ch \"nav navbar-nav\"\nlet inline dropdown   ch       =  entries ch \"dropdown-menu\"\nlet navbar brand center right  =\n    div [ ``class``                     \"navbar navbar-default\"\n          div [ ``class``               \"container-fluid\"\n                div [ ``class``         \"navbar-header\"\n                      div [ ``class``   \"navbar-brand\"\n                            brand\n                          ]\n                    ]\n                div [ ``class``         \"navbar-collapse collapse\"\n                      center\n                      right |> addClass \"navbar-right\"\n                    ]\n              ]\n    ]\n    \n#nowarn \"1178\"    \n\ntype MenuEntry = {\n    text       : Val<string>\n    ref        : Val<string option>\n    active     : Val<bool>\n    disabled   : Val<bool>\n    subMenu    : Menu option\n    toolTip    : string option\n    divider    : bool\n    onClick    : (Dom.Element -> Dom.MouseEvent -> unit) option\n} with\n    static member inline New txt = { \n        text      = Val.fixit  txt\n        active    = Val.fixit  false \n        ref       = Val.Constant None\n        toolTip   = None\n        subMenu   = None\n        onClick   = None\n        divider   = false\n        disabled  = Val.fixit false\n    } \n    static member inline New(txt, ref) = { MenuEntry.New(txt) with ref      = Val.map Some ref }\n    member this.Render           = \n        entryTxt this.text this.ref |> addClassIf \"active\" this.active |> addClassIf \"disabled\" this.disabled\n        |> match this.subMenu with | None  -> id | Some m -> addChildren [ ``class`` \"dropdown\" ; m.Render ]\n        |> match this.onClick with | None  -> id | Some f -> addChildren [ SomeAttr  <| on.click <@ f @>   ; style \"cursor : pointer\" ]\n        |> match this.divider with | false -> id | true   -> addClass    \"divider\"\n    member inline this.Divider      = { this with divider  = true                           }\n    member inline this.OnClick  f   = { this with onClick  = Some f                         }\n    member inline this.Disabled dis = { this with disabled = Val.fixit dis                  }\n    member inline this.SubMenu  es  = { this with subMenu  = Some <| Menu.New( es).DropDown } \n    member inline this.SubMenu  es  = { this with subMenu  = Some <| Menu.New2(es).DropDown } \n    member        this.MenuNode     = MenuEntry this\nand MenuNode =\n    | MenuHtml  of HtmlNode\n    | MenuEntry of MenuEntry \n  with\n    member this.Render = match this with | MenuHtml h -> h | MenuEntry e -> e.Render\nand Menu = {\n    entries  : MenuNode seq\n    dropdown : bool\n} with\n    static member New es : Menu = { \n        entries = es\n        dropdown = false\n    }    \n    static member New2 es : Menu = Menu.New(es |> Seq.map MenuEntry) \n    member this.DropDown        = { this      with dropdown = true  }\n    member this.Render          =\n        (if this.dropdown then dropdown else nav) <|\n            seq [\n                for entry in this.entries -> \n                    entry.Render\n            ]","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"f3c86328-e5b6-4ef1-a3d9-d82098f4ffe2"},"expanded":true,"level":0,"properties":{}},{"name":"Action","content":"type Action = {\n    text       : Val<string>\n    highlight  : Val<bool>\n    disabled   : Val<bool>\n    toolTip    : string option\n    onClick    : (Dom.Element -> Dom.MouseEvent -> unit) option\n} with\n    static member inline New txt = { \n        text      = Val.fixit  txt\n        highlight = Val.fixit  false \n        disabled  = Val.fixit  false\n        toolTip   = None\n        onClick   = None\n    } \n    member inline this.OnClick   f   = { this with onClick   = Some f        }\n    member inline this.OnClick2  f   = { this with onClick   = Some (f this) }\n    member inline this.Disabled  dis = { this with disabled  = Val.fixit dis }\n    member inline this.Highlight h   = { this with highlight = Val.fixit h   }\n    member        this.MenuEntry     = {\n        MenuEntry.text      = this.text\n        MenuEntry.active    = this.highlight \n        MenuEntry.disabled  = this.disabled\n        MenuEntry.toolTip   = this.toolTip\n        MenuEntry.onClick   = this.onClick\n        MenuEntry.ref       = Val.Constant None\n        MenuEntry.divider   = false\n        MenuEntry.subMenu   = None\n    }\n    member        this.Button       = {\n        Button.text      = this.text\n        Button.disabled  = this.disabled\n        Button.onClick   = this.onClick |> Option.defaultValue (fun _ _ -> ())\n//        Button.toolTip   = this.toolTip\n        Button._class    = Val.map (fun h -> if h then \"btn btn-primary\" else \"btn\") this.highlight \n        Button._type     = Val.fixit \"button\" \n        Button.style     = Val.fixit \"\"\n        Button.id        = \"\"\n      }\n\nlet Do  f p = (fun     _ _ -> f     p)\nlet Do2 f p = (fun act _ _ -> f act p)","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"f3c86328-e5b6-4ef1-a3d9-d82098f4ffe2"}],"id":{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"},"expanded":true,"level":0,"properties":{}},{"name":"RunCode","content":"[<JavaScript>]\nmodule RunCode       =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"1095ae38-19fc-4195-840c-c368a3a486c4"}],"id":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"expanded":false,"level":0,"properties":{}},{"name":"completeJS","content":"let completeJS js = \n  \"\"\"\n    CIPHERSpaceLoadFileGlobalFileRef = null;\n    CIPHERSpaceLoadFile = function (filename, callback) {\n        if (filename.slice(-3) == \".js\" || filename.slice(-4) == \".fsx\" || filename.slice(-3) == \".fs\") { //if filename is a external JavaScript file\n            var fileRef = null;\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement('script')\n                fileRef.setAttribute(\"type\", \"text/javascript\")\n                fileRef.setAttribute(\"src\", filename)\n            }\n            else callback();\n        }\n        else if (filename.slice(-4) == \".css\") { //if filename is an external CSS file\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement(\"link\")\n                fileRef.setAttribute(\"rel\", \"stylesheet\")\n                fileRef.setAttribute(\"type\", \"text/css\")\n                fileRef.setAttribute(\"href\", filename)\n            }\n            else callback();\n        }\n        else if (filename.slice(-5) == \".html\") { //if filename is an external HTML file\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement(\"link\")\n                fileRef.setAttribute(\"rel\", \"import\")\n                fileRef.setAttribute(\"type\", \"text/html\")\n                fileRef.setAttribute(\"href\", filename)\n            }\n            else callback();\n        }\n        if (!!fileRef) {\n            CIPHERSpaceLoadFileGlobalFileRef = fileRef;\n\t\t\tfileRef.onload = function () { fileRef.onload = null;  callback(); }\n            document.getElementsByTagName(\"head\")[0].appendChild(fileRef);\n        }\n    }\n    CIPHERSpaceLoadFiles = function (files, callback) {\n        var newCallback = callback\n        if (!!CIPHERSpaceLoadFileGlobalFileRef && !!(CIPHERSpaceLoadFileGlobalFileRef.onload)) {\n            var oldCallback = CIPHERSpaceLoadFileGlobalFileRef.onload;\n            CIPHERSpaceLoadFileGlobalFileRef.onload = null;\n            newCallback = function () {\n                callback();\n                oldCallback();\n            }\n        }\n        var i = 0;\n        loadNext = function () {\n            if (i < files.length) {\n                var file = files[i];\n                i++;\n                CIPHERSpaceLoadFile(file, loadNext);\n            }\n            else newCallback();\n        };\n        loadNext();\n\t}\n    CIPHERSpaceLoadFiles(['https://code.jquery.com/jquery-3.1.1.min.js'], function() {}); \n\tCIPHERSpaceLoadFilesDoAfter = function (callback) {\n\t\tvar newCallback = callback\n\t\tif (!!CIPHERSpaceLoadFileGlobalFileRef) {\n\t\t\tif (!!(CIPHERSpaceLoadFileGlobalFileRef.onload)) {\n\t\t\t\tvar oldCallback = CIPHERSpaceLoadFileGlobalFileRef.onload;\n\t\t\t\tCIPHERSpaceLoadFileGlobalFileRef.onload = null;\n\t\t\t\tnewCallback = function () {\n\t\t\t\t\toldCallback();\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse CIPHERSpaceLoadFileGlobalFileRef = {};\n\t\tCIPHERSpaceLoadFileGlobalFileRef.onload = newCallback;\n\t}\n\nCIPHERSpaceLoadFilesDoAfter(function() { \n  if (typeof IntelliFactory !=='undefined')\n    IntelliFactory.Runtime.Start();\n  for (key in window) { \n    if (key.startsWith(\"StartupCode$\")) \n      try { window[key].$cctor(); } catch (e) {} \n  } \n})\n                 \"\"\" + js","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[],"id":{"$":0,"Item":"afaac2af-143d-4745-9447-7e8d3044950f"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"type RunNode(nodeName, ?clearNode: bool) =\n  let bClearNode    = defaultArg clearNode true\n  let createNode() =\n      let e = JS.Document.CreateElement \"div\"\n      e?style <- \"height: 100%; width: 100%;\"\n      e\n  let createBaseNode () =\n      let el = JS.Document.CreateElement \"div\"\n      el.SetAttribute(\"id\", nodeName)\n      JS.Document.Body.AppendChild el |> ignore\n      el\n  let baseNode = \n      match JS.Document.GetElementById nodeName with\n      | null -> createBaseNode()\n      | node -> node\n  let runNode =\n      match baseNode.ShadowRoot with\n      | null -> let p = createNode()\n                baseNode.AttachShadow(Dom.ShadowRootInit(Dom.ShadowRootMode.Open)).AppendChild p |> ignore\n                let e = createNode()\n                p.AppendChild e |> ignore\n                e\n      | root -> root.FirstChild :?> Dom.Element\n  do if bClearNode then runNode.InnerHTML <- \"\"\nwith\n  new(?clearNode: bool) = RunNode(\"TestNode\", ?clearNode = clearNode)\n  member this.RunNode   = runNode","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[],"id":{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"},"expanded":true,"level":0,"properties":{}},{"name":"AddBootstrap","content":"  member this.AddBootstrap =\n    JS.Document.CreateElement \"div\"\n    |> fun el -> \n        el.InnerHTML <- \n          @\"<script src='http://code.jquery.com/jquery-3.1.1.min.js' type='text/javascript' charset='UTF-8'></script>\n            <script src='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js' type='text/javascript' charset='UTF-8'></script>\n            <link type='text/css' rel='stylesheet' href='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css'>\n            <link type='text/css' rel='stylesheet' href='/EPFileX/css/main.css'>\n           \"\n        runNode.ParentElement.AppendChild el |> ignore\n    this","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"}],"id":{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},"expanded":true,"level":0,"properties":{}},{"name":"RunDoc","content":"  member inline this.RunDoc doc = doc :> Doc |> Doc.Run this.RunNode","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"},{"$":0,"Item":"aba6c516-0ac9-4abe-95a2-7257d077e338"}],"id":{"$":0,"Item":"c110a9c9-bc3b-4be7-8e5d-f43cc75f93ed"},"expanded":true,"level":0,"properties":{}},{"name":"RunHtml","content":"  member inline this.RunHtml node = node |> renderDoc |> this.RunDoc","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"c110a9c9-bc3b-4be7-8e5d-f43cc75f93ed"}],"id":{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"},"expanded":true,"level":0,"properties":{}},{"name":"RunHtmlPlusFree","content":"  member        this.RunHtmlPlusFree node =\n    let freeHtml    = Var.Create \"\"\n    let freeCSS     = Var.Create \"\"\n    let freeFS      = Var.Create \"\"\n    let freeJS      = Var.Create \"\"\n    let freeMsgs    = Var.Create \"\"\n    let sendMsg msg = \n        freeMsgs.Value  <- \n            match freeMsgs.Value, msg with\n            | null, m \n            | \"\"  , m\n            | m   , null\n            | m   , \"\"   -> m\n            | m1  , m2   -> m1 + \"\\n\" + m2\n    let runJS () =\n        sendMsg \"Running JavaScript...\"\n        try JS.Eval(freeJS.Value) |> (fun v -> sendMsg \"Done!\"; v.ToString())\n        with e -> sendMsg \"Failed!\"; e.ToString()\n        |> sendMsg\n    let runFS () =\n        Useful.Wrap.wrapper {\n            freeMsgs.Value <- \"Compiling to JavaScript...\"\n            freeJS.Value   <- \"\"\n            let    code      = freeFS.Value\n            let!   jsR       = FsTranslator.translateAR code false\n            let!   js        = jsR\n            let    jsc       = completeJS js\n            freeJS.Value    <- jsc\n            sendMsg            \"Compiled!\"\n            runJS()\n        } |> Useful.Wrap.start sendMsg\n    div [ style \"height: 100%\"\n          node\n          Template.Button.New(\"Eval F#\").Style(\"vertical-align:top\").OnClick(fun _ _ -> runFS()                        ).Render  \n          someElt <| Doc.InputArea [ attr.placeholder \"F#:\"         ; attr.title \"Add F# code and invoke with Eval F#\" ] freeFS\n          someElt <| Doc.InputArea [ attr.placeholder \"HTML:\"       ; attr.title \"Enter HTML tags and text\"            ] freeHtml \n          someElt <| Doc.InputArea [ attr.placeholder \"CSS:\"        ; attr.title \"Test your CSS styles dynamically\"    ] freeCSS \n          someElt <| Doc.InputArea [ attr.placeholder \"JavaScript:\" ; attr.title \"Add JS code and invoke with Eval JS\" ] freeJS\n          Template.Button.New(\"Eval JS\").Style(\"vertical-align:top\").OnClick(fun _ _ -> freeMsgs.Value <- \"\" ; runJS() ).Render  \n          someElt <| Doc.InputArea [ attr.placeholder \"Output:\"     ; attr.title \"Messages\"                            ] freeMsgs\n          SomeDoc <| tag Doc.Verbatim (Val.map2 (sprintf \"%s<style>%s</style>\") freeHtml freeCSS)\n    ]\n    |> this.RunHtml","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"afaac2af-143d-4745-9447-7e8d3044950f"},{"$":0,"Item":"95a237c8-a9ff-40d1-bd72-bd298b20af8c"},{"$":0,"Item":"79f8f6c6-d1f5-4593-9775-60ba2863e94d"},{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"}],"id":{"$":0,"Item":"456562f7-0757-4431-9aeb-d58b050cecf7"},"expanded":true,"level":0,"properties":{}},{"name":"ShowHtmlResult","content":"  member inline this.ShowHtmlResult res =\n    this.AddBootstrap |> ignore\n    div [ ``class`` \"container\"\n          Template.Panel.New\n            .Title(\"Result:\")\n            .Header([])\n            .Content([ h3 res ; style \"font-family:monospace;\" ])\n            .Render\n     ] |> this.RunHtml\n  member inline this.ShowHtmlResult res = this.ShowHtmlResult [res]\n","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"0a11766b-f227-4b38-88a3-919d964387bf"},{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"}],"id":{"$":0,"Item":"bf400a85-8264-4540-9381-f3be0c968c94"},"expanded":true,"level":0,"properties":{}},{"name":"ShowResult","content":"  member inline this.ShowResult res = htmlText (sprintf \"%A\" res) |> this.ShowHtmlResult\n","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"bf400a85-8264-4540-9381-f3be0c968c94"}],"id":{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"},"expanded":true,"level":0,"properties":{}},{"name":"FSharpStation Code","content":"module FSharpStation =\n","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[],"id":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"expanded":false,"level":0,"properties":{}},{"name":"CodeSnippet Extensions, Position","content":"open Template\nopen FsStationShared\nopen System.Collections.Generic\nopen Useful\n\n#if FSS_SERVER\nopen FsTranslator\nopen FsEvaluator\n#endif\n\n[< JavaScript >]\nmodule FsGlobal =\n    [< Inline >]\n    let inline storeVarCodeEditor name = storeVar <| \"CodeEditor.\" + name\n    \n    //let codeSnippetsStorage = WebSharper.UI.Next.Storage.LocalStorage \"CodeSnippets\" Serializer.Typed<CodeSnippet>\n    //let codeSnippets        = ListModel.CreateWithStorage<CodeSnippetId, CodeSnippet> (fun s -> s.id) codeSnippetsStorage\n    let codeSnippets        = ListModel.Create<CodeSnippetId, CodeSnippet> (fun s -> s.id) []\n    let fsIds  = \"FSharpStation\" //+ (System.Guid.NewGuid() |> string)\n    \n    let tryPickI f s = s |> Seq.indexed |> Seq.filter f |> Seq.tryHead\n    \n    type CodeSnippet \n        with\n        static member PickIO       id   = codeSnippets.Value    |> tryPickI (fun (_, snp) -> snp.id = id)\n        static member FetchO       id   = codeSnippets.TryFindByKey id\n        static member FetchL       id   = CodeSnippet.FetchO id |> Option.toList\n        static member New(            pred    , cnt) = CodeSnippet.New(\"\", None   , pred, [], cnt)\n        static member New(        pa, pred    , cnt) = CodeSnippet.New(\"\", Some pa, pred, [], cnt)\n        static member New(        pa,           cnt) = CodeSnippet.New(\"\", Some pa, []  , [], cnt)\n        static member New(                      cnt) = CodeSnippet.New(\"\", None   , []  , [], cnt)\n        static member New(    nm, pa, pred, co, cnt) = CodeSnippet.New(codeSnippets.Length, nm, pa, pred, co, cnt)\n        static member New(od, nm, pa, pred, co, cnt) =\n            let newS =\n                {\n                    name         = nm\n                    content      = cnt\n                    parent       = pa\n                    predecessors = pred\n                    id           = CodeSnippetId.New\n                    expanded     = true\n                    level        = 0\n                    properties   = Map.empty\n                }\n            match od, codeSnippets.Length with\n            | _, 0            -> codeSnippets.Append newS\n            | 0, _            -> codeSnippets.Set <| Seq.append [| newS |] codeSnippets.Value\n            | i, n when i < n -> codeSnippets.Value \n                                    |> Seq.toArray\n                                    |> Array.splitAt od\n                                    |> fun (fst, snd) -> Array.append fst <| Array.append [| newS |] snd\n                                    |> codeSnippets.Set \n            | _, _            -> codeSnippets.Append newS\n            newS\n        member this.Level =\n            let rec level out snp = \n                snp.parent\n                |> Option.bind CodeSnippet.FetchO\n                |> Option.map (level <| out + 1) \n                |> Option.defaultValue out\n            level 0 this\n        member this.PrepareSnippet   = { this with level   = this.Level\n                                                   content = this.content\n                                                                  .Replace(\"##\" + \"FSHARPSTATION_ID\" + \"##\"      , fsIds                  )\n                                                                  .Replace(\"##\" + \"FSHARPSTATION_ENDPOINT\" + \"##\", JS.Window.Location.Href) }\n        member this.Predecessors     () =\n            let preds = this.UniquePredecessors CodeSnippet.FetchO |> Seq.toArray\n            codeSnippets.Value\n            |> Seq.filter (fun snp -> preds |> Array.contains snp.id)\n            |> Seq.map    (fun snp -> snp.PrepareSnippet)\n            |> Seq.toArray\n        member this.GetCodeAndStarts addLinePrepos = this.Predecessors() |> CodeSnippet.CodeAndStarts addLinePrepos\n        member this.GetCodeFsx       addLinePrepos = this.GetCodeAndStarts addLinePrepos |> fst\n        member this.IsDescendantOf antId =\n            let rec isDescendantOf snp =\n                match snp.parent with\n                | None       -> false\n                | Some parId ->\n                if parId = antId then true else\n                CodeSnippet.FetchO parId\n                |> Option.map isDescendantOf\n                |> Option.defaultValue false\n            isDescendantOf this\n        static member FetchByPathO names      = \n            let tryFindByName      snps name  = snps |> Seq.filter (fun (snp:CodeSnippet) -> snp.Name = name) |> Seq.tryHead\n            let rec tryFindByPath  snps names = \n                let first = names |> Seq.tryHead |> Option.bind (tryFindByName snps)\n                if names |> Seq.length <= 1 then first else\n                first\n                |> Option.bind (fun f ->\n                    names \n                    |> Seq.tail\n                    |> tryFindByPath  (codeSnippets.Value |> Seq.filter (fun snp -> snp.parent = Some f.id))\n                )\n            names \n            |> tryFindByPath (codeSnippets.Value |> Seq.filter (fun snp -> snp.parent.IsNone))  \n    \n    type Position =\n        | Below\n        | Right\n        | Tab\n        | NewBrowser\n        \n    \n    type ErrCompiler =\n        | JsCompilerMsg  of string * bool\n        | ``Snippet Missing``\n        | ``Could not open new browser, Popup blocker may be active``\n        interface ErrMsg with\n            member this.ErrMsg   : string = \n                match this with \n                | JsCompilerMsg(msg, err) -> sprintf \"%s\" msg\n                | _                       -> sprintf \"%A\" this\n            member this.IsWarning: bool   = \n                match this with \n                | JsCompilerMsg(msg, err) -> not err\n                | _                       -> false\n                \n    [< Inline \"saveAs(new Blob([$txt], {type: 'text/plain;charset=utf-8'}), $name)\" >]\n    let saveAs (txt:string) (name:string) = ()\n    \n    type KeyMapAutoComplete = { \n        F2              : Template.CodeMirrorEditor -> unit \n        LeftDoubleClick : Template.CodeMirrorEditor -> unit\n        ``Ctrl-Space``  : Template.CodeMirrorEditor -> unit\n    }\n    \nopen FsGlobal                ","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"},{"$":0,"Item":"95a237c8-a9ff-40d1-bd72-bd298b20af8c"},{"$":0,"Item":"336d6f19-0c57-4af9-8716-1b3fbf6b112c"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"}],"id":{"$":0,"Item":"1787d1fe-db11-4716-b3f6-164048e8991b"},"expanded":true,"level":0,"properties":{}},{"name":"CIPHERPrototype Module","content":"#r @\"ZafirTranspiler.dll\"\n    \n[< JavaScript >]\ntype CIPHERPrototypeMsg(msg: string, warning: bool) =\n    interface ErrMsg with\n        member this.ErrMsg    = msg\n        member this.IsWarning = warning\n\n[< JavaScript >]\nlet translateAR fsCode minified = \n    Wrap.wrapper {\n        let! vO, msgs = CIPHERPrototype.Editor.translate fsCode minified\n        let!   js     = Result (vO, [ CIPHERPrototypeMsg(msgs, vO.IsNone) :> ErrMsg ])\n        return js\n    } |> Wrap.getAsyncR\n\n[< JavaScript >]\nlet evaluateAR  fsCode = \n    Wrap.wrapper {\n        let! vO, msgs = CIPHERPrototype.Editor.evaluate fsCode\n        let!   txt    = Result (vO, [ CIPHERPrototypeMsg(msgs, vO.IsNone) :> ErrMsg ])\n        return txt\n    } |> Wrap.getAsyncR\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"8fbd59ac-9417-4309-8d01-3ccd5d62452c"},"expanded":true,"level":0,"properties":{}},{"name":"FSharpStationClient","content":"[< JavaScript >]\nlet FSharpStationClient () =\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"336d6f19-0c57-4af9-8716-1b3fbf6b112c"},{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"expanded":true,"level":0,"properties":{}},{"name":"currentCodeSnippetId","content":"\nlet missingVar  = Var.Create \"\"\nlet missing find lens k =\n    match find k with\n    | Some _ -> lens k\n    | None   -> missingVar.Lens (fun _ -> \"\") (fun _ _ -> \"\")\n    \nlet currentCodeSnippetId  = Var.Create <| CodeSnippetId.New\n\nstoreVarCodeEditor \"currentCodeSnippetId\" currentCodeSnippetId\n\nlet refresh       = Var.Create()\nlet refreshView b = refresh.Value <- b\n\nlet currentCodeSnippetO = Val.map2 (fun k () -> codeSnippets.TryFindByKey k) currentCodeSnippetId refresh\n\nlet curSnippetNameOf k = missing codeSnippets.TryFindByKey <| codeSnippets.LensInto (fun s -> s.Name   ) (fun s n -> { s with name    = n }) <| k\nlet curSnippetCodeOf k = missing codeSnippets.TryFindByKey <| codeSnippets.LensInto (fun s -> s.content) (fun s n -> { s with content = n }) <| k\n    \nlet positionTxt v =\n    match v with\n    | Below      -> \"Below\"\n    | Right      -> \"Right\"\n    | Tab        -> \"In Tab\"\n    | NewBrowser -> \"New Browser\"\n    \nlet position = Var.Create Below\nstoreVarCodeEditor \"position\" position\n\nlet directionVertical    = \n    Val.map (fun pos -> \n        match pos with\n        | Right -> true\n        | _     -> false\n    ) position\n    \n    ","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"1787d1fe-db11-4716-b3f6-164048e8991b"},{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"}],"id":{"$":0,"Item":"987560b0-1fe6-4835-ad99-aed93db7da1a"},"expanded":true,"level":0,"properties":{}},{"name":"CodeEditorMain","content":"\n\nlet noSelection cur = CodeSnippet.FetchO cur = None\nlet noSelectionVal  = Val.map noSelection currentCodeSnippetId\n\nlet mutable lastCodeAndStarts : (CodeSnippetId * bool * ((string * int * int) [] * string [] * string [] * string [] * string [] * string [])) option = None\n\nlet getPredecessors curO =\n    curO\n    |> Option.map (fun (snp:CodeSnippet) -> snp.UniquePredecessors CodeSnippet.FetchO |> HashSet)\n    |> Option.defaultValue (System.Collections.Generic.HashSet())\n\nlet getPredecessorsM = Useful.ResetableMemoize(getPredecessors)\n\nlet codeFS         = Var.Create \"\"\nlet codeJS         = Var.Create \"\"\nlet parserMsgs     = Var.Create \"\"\nlet outputMsgs     = Var.Create \"\"\nlet mutable parsed = false\nlet dirty          = Var.Create false \nlet setDirtyPart() = parsed            <- false\n                     dirty.Value       <- true       \nlet setDirty()     = lastCodeAndStarts <- None\n                     setDirtyPart               ()\nlet setDirtyPred() = setDirty                   ()\n                     getPredecessorsM.ClearCache()\n                     refreshView                ()\nlet setClean()     = getPredecessorsM.ClearCache()\n                     dirty.Value       <- false\n                     lastCodeAndStarts <- None\n                     \n\n//storeVarCodeEditor \"dirty\" dirty\nlet appendMsg (var:IRef<string>) msg =\n    if isUndefined msg then () else\n    let newM =\n        match var.Value, msg.ToString() with\n        | null, m \n        | \"\"  , m\n        | m   , null\n        | m   , \"\"   -> m\n        | m1  , m2   -> m1 + \"\\n\" + m2\n    if newM <> var.Value then\n        var.Value  <- newM\n\nlet addOutMsg msg = appendMsg outputMsgs msg\nlet addPrsMsg msg = appendMsg parserMsgs msg\n\nlet getFSCode () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value \n    |> Option.iter (fun snp -> codeFS.Value <- snp.GetCodeFsx true )\n\ndo Val.sink (fun m -> \n    JS.Window.Onbeforeunload <- \n        if m then System.Action<Dom.Event>(fun (e:Dom.Event) -> e?returnValue  <- \"Changes you made may not be saved.\")\n        else null\n    ) dirty \n\n//let evalIFrameJS success failure js =\n//    createIFrame (fun frame ->\n//        try\n//             let window   = frame?contentWindow\n//             let eval   s = JS.Apply window \"eval\" [| s |]\n//             eval js           |> success\n//        with e -> e.ToString() |> failure\n//    )\n//    |> RunCode.RunNode().RunHtml\n//\n//let evalWindowUrlJS (url:string) success failure js =\n//    let window       = JS.Apply JS.Window \"open\" [| url |]\n//    match window with\n//    | null -> failure \"could not open new browser. Popup blocker may be active.\"\n//    | _    ->\n//    800 \n//    |> JS.SetTimeout (fun () -> \n//        try\n//             let eval   s = JS.Apply window   \"eval\" [| s |]\n//             //printfn \"Evaluating...\"\n//             JS.Apply window   \"focus\" [|  |]\n//             eval js           |> success\n//        with e -> e.ToString() |> failure)\n//    |> ignore\n//\n//let runUrlJS url pos msgs js =\n//    sendMsg \"Running JavaScript...\"\n//    match pos with\n//    | NewBrowser -> evalWindowUrlJS url\n//    | _          -> evalIFrameJS\n//    <| (fun res  -> sendMsg \"Done!\"   ; sendMsg res ; sendMsg msgs) \n//    <| (fun res  -> sendMsg \"Failed!\" ; sendMsg res ; sendMsg msgs)\n//    <| js\n//\n//let processSnippet getCode msg processCode =\n//    CodeSnippet.FetchO currentCodeSnippetId.Value \n//    |> Option.iter (fun snp -> \n//        codeMsgs.Value <- msg\n//        codeJS.Value   <- \"\"\n//        let code = getCode snp\n//        codeFS.Value   <- code\n//        processCode       code\n//    )\n//\n//let compileSnippet fThen fFail = \n//    processSnippet (fun snp -> snp.GetCodeFsx true) \"Compiling to JavaScript...\" (RunCode.compile (fun msgs js -> codeJS.Value <- js ; fThen msgs js) fFail)\n//\n//let compileRunP pos = compileSnippet (runJS pos)                                         sendMsg\n//let compileRun  ()  = compileRunP           position.Value\n//let justCompile ()  = compileSnippet (fun msgs _ -> sendMsg \"Compiled!\" ; sendMsg msgs)  sendMsg\n\nlet reorderSnippet toId fromId =\n    let trySnippet id = tryPickI (fun (_, snp) -> snp.id = id) \n    let moving, others = codeSnippets.Value |> Seq.toArray |> Array.partition (fun snp -> snp.id = fromId || snp.IsDescendantOf fromId)\n    match trySnippet fromId moving, trySnippet toId others with\n    | Some(_, snp), Some(ti, tsn) ->\n        [| others.[0..ti - 1] ; moving ; others.[ti..] |]\n        |> Array.collect id\n        |> codeSnippets.Set\n        codeSnippets.UpdateBy (fun c -> Some { c with parent = tsn.parent }) snp.id\n    | _ -> ()\n    setDirtyPred()\n\nlet indentCodeIn () =\n    CodeSnippet.PickIO currentCodeSnippetId.Value\n    |> Option.iter (fun (j, snp) ->\n        let rec doPriorUntil f i =\n            if i < 0 then () else\n            if codeSnippets.Value |> Seq.item i |> f then () else\n            doPriorUntil f (i - 1)\n        j - 1 |> doPriorUntil (fun pri ->\n            if pri.parent = snp.parent \n            then codeSnippets.UpdateBy (fun c -> Some { c with parent = Some pri.id }) snp.id\n                 true\n            else false\n        )\n        setDirtyPred()\n    )\n\nlet indentCodeOut () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value\n    |> Option.iter (fun snp ->\n        let newP = snp.parent\n                   |> Option.bind CodeSnippet.FetchO\n                   |> Option.bind (fun p -> p.parent)\n        codeSnippets.UpdateBy (fun c -> Some { c with parent = newP }) snp.id\n        setDirtyPred()\n    )\n\nlet mutable draggedId   = CodeSnippetId.New\n\n()","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"8efdcd5a-95c4-4212-9c75-1ebedce83dd8"},{"$":0,"Item":"a28fe808-236e-4b7e-9509-51ebe21e35fc"},{"$":0,"Item":"987560b0-1fe6-4835-ad99-aed93db7da1a"}],"id":{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"},"expanded":true,"level":0,"properties":{}},{"name":"Compile","content":"let compileSnippetW (snpO: CodeSnippet option) =\n    Wrap.wrapper {\n        let!   snp         = snpO |> Result.fromOption ``Snippet Missing``\n        outputMsgs.Value  <- \"Compiling to JavaScript...\"\n        codeJS.Value      <- \"\"\n        let    code        = snp.GetCodeFsx true\n        codeFS.Value      <- code\n        let!   jsR         = translateAR code false\n        let!   js          = jsR\n        let    jsc         = RunCode.completeJS js\n        codeJS.Value      <- jsc\n        addOutMsg            \"Compiled!\"\n        return jsc\n    }\n    \nlet newWindow url = \n    JS.Apply JS.Window \"open\"  [| url |]\n    |> function\n       | null   -> Result.fail    ``Could not open new browser, Popup blocker may be active``\n       | window -> Result.succeed window\n    \nlet eval  window js = JS.Apply window \"eval\"  [| js  |]\nlet focus window    = JS.Apply window \"focus\" [|     |] |> ignore\n\nlet evalWindowUrlJSW (url:string) js =\n    Wrap.wrapper {\n        do!    Result.tryProtection()\n        let!   window       = newWindow url\n        do     focus window\n        do!    Async.Sleep 800 \n        let    res : string = eval window js\n        return res\n    }\n\nlet createIFrameA () =\n    Async.FromContinuations\n        (fun (cb, errF: exn -> unit, canF: System.OperationCanceledException -> unit) ->\n            try\n                createIFrame cb |> RunCode.RunNode().RunHtml     \n            with e -> errF e\n        )\n\nlet evalIFrameJSW js =\n    Wrap.wrapper {\n        do!    Result.tryProtection()\n        let!   frame        = createIFrameA () \n        let    window       = frame?contentWindow\n        let    res : string = eval window js\n        return res\n    }\n\nlet compileRunUrlW url pos snpO =\n    Wrap.wrapper {\n        let! js  = compileSnippetW snpO\n        outputMsgs.Value <-  \"Running JavaScript...\"\n        let! res = match pos with\n                   | NewBrowser -> evalWindowUrlJSW url js\n                   | _          -> evalIFrameJSW        js\n        addOutMsg res\n        addOutMsg \"Done!\"\n        return  pos, res\n    }\n\nlet getSnpO () = CodeSnippet.FetchO currentCodeSnippetId.Value\n\nlet evaluateSnippetW (snpO: CodeSnippet option) =\n    Wrap.wrapper {\n        let!   snp        = snpO |> Result.fromOption ``Snippet Missing``\n        outputMsgs.Value <- \"Evaluating F# code...\"\n        let    code       = snp.GetCodeFsx true\n        codeFS.Value     <- code\n        let! resR         = evaluateAR code\n        let! res          = resR\n        addOutMsg res\n        addOutMsg \"Done!\"\n        return  res\n    }\n\nlet compileRunW = compileRunUrlW (JS.Window.Location.Origin + \"/Main.html\") \n\nlet compileRunP pos = getSnpO() |> compileRunW pos  //|> Wrap.map ignore |> Wrap.start addOutMsg\nlet justCompile     = getSnpO   >> compileSnippetW  //>> Wrap.map ignore >> Wrap.start addOutMsg\nlet evaluateFS      = getSnpO   >> evaluateSnippetW //>> Wrap.map ignore >> Wrap.start addOutMsg\nlet compileRun  ()  = compileRunP position.Value\n\n()","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"},{"$":0,"Item":"afaac2af-143d-4745-9447-7e8d3044950f"},{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"3f2ec5e2-8ab6-4e5b-bb89-1943ed3a4964"},"expanded":true,"level":0,"properties":{}},{"name":"Messaging","content":"#if NOMESSAGING\n#else\n\nlet fsStationClient = FsStationClient(fsIds, fsIds, endPoint = JS.Window.Location.Href)\n\nlet transMsgs (msgs: ErrMsg list)  =  msgs |> Seq.map (fun e -> e.ErrMsg, if e.IsWarning then FSWarning else FSError) |> Seq.toArray\n\nlet result2response res = \n    match res with \n    | Result (a, b) -> StringResponseR (a |> Option.map snd, b |> Seq.map (fun err -> err.ErrMsg, if err.IsWarning then FSWarning else FSError) |> Seq.toArray ) \n\nlet respond fromId (msg:FSMessage) : Async<FSResponse> =\n    async {\n        match msg with\n        | GetWholeFile                     -> return  codeSnippets.Value            |> Seq.toArray |> Json.Serialize |> Some                                   |> StringResponse       \n        | GetSnippetContentById sId        -> return  CodeSnippet.FetchO       sId  |> Option.map (fun snp -> snp.content        )                             |> StringResponse       \n        | GetSnippetCodeById    sId        -> return  CodeSnippet.FetchO       sId  |> Option.map (fun snp -> snp.GetCodeFsx true)                             |> StringResponse \n        | GetSnippetPredsById   sId        -> return  CodeSnippet.FetchO       sId  |> Option.map (fun snp -> snp.Predecessors ()) |> Option.defaultValue [||] |> SnippetsResponse\n        | GetSnippetById        sId        -> return  CodeSnippet.FetchO       sId                                                                             |> SnippetResponse \n        | GetSnippetContent     path       -> return  CodeSnippet.FetchByPathO path |> Option.map (fun snp -> snp.content        )                             |> StringResponse\n        | GetSnippetCode        path       -> return  CodeSnippet.FetchByPathO path |> Option.map (fun snp -> snp.GetCodeFsx true)                             |> StringResponse\n        | GetSnippetJSCode      path       -> match   CodeSnippet.FetchByPathO path with\n                                              | Some snp -> let!    jsR = translateAR (snp.GetCodeFsx true) false\n                                                            return (jsR |> Result.map RunCode.completeJS |> Result.getOption, jsR |> Result.getMsgs |> transMsgs)      |> StringResponseR\n                                              | None     -> return (None, [| \"Snippet not found\" , FSError |] )                                                |> StringResponseR\n        | GetSnippetPreds       path       -> return  CodeSnippet.FetchByPathO path |> Option.map (fun snp -> snp.Predecessors ()) |> Option.defaultValue [||] |> SnippetsResponse\n        | GetSnippet            path       -> return  CodeSnippet.FetchByPathO path                                                                            |> SnippetResponse \n        | GenericMessage        txt        -> return  (Some <| \"Message received: \" + txt)                                                                     |> StringResponse\n        | GetIdentification                -> return  fromId                                                                                                   |> IdResponse  \n        | RunSnippetUrlJSById  (sId , url) -> return! CodeSnippet.FetchO       sId  |> compileRunUrlW url NewBrowser |> Wrap.getAsyncR |> Async.map result2response\n        | RunSnippetUrlJS      (path, url) -> return! CodeSnippet.FetchByPathO path |> compileRunUrlW url NewBrowser |> Wrap.getAsyncR |> Async.map result2response\n    }     \n     \nlet respondMessage fromId txt =\n    async {\n        let  msg = Json.Deserialize txt \n        let! res = respond fromId msg\n        return Json.Serialize res\n    }\n\n1000 |> JS.SetTimeout (fun () -> fsStationClient.MessagingClient.AwaitMessage respondMessage) |> ignore\n\n#endif","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"3f2ec5e2-8ab6-4e5b-bb89-1943ed3a4964"},{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"}],"id":{"$":0,"Item":"95ca1e9f-4029-4fc1-8b1c-ab12db71c90b"},"expanded":true,"level":0,"properties":{}},{"name":"List Code","content":"let isDirectPredecessor pre curO =\n    curO\n    |> Option.map (fun snp -> snp.predecessors |> List.contains pre)\n    |> Option.defaultValue false\n\n\nlet curPredecessors = Val.map getPredecessorsM.Call currentCodeSnippetO\n\nlet isIndirectPredecessor pre (predecessors: HashSet<CodeSnippetId>) = predecessors.Contains pre //predecessors |> Set.contains pre\n\n//let isIndirectPredecessorT (preId, curId) = getPredecessors curId |> Set.contains preId            // horrible performance\n//let isIndirectPredecessorM  preId  curId  = (Useful.memoize isIndirectPredecessorT) (preId, curId) // horrible performance\n\nlet togglePredecessorForCur (pre:CodeSnippet) curO =\n    curO |> Option.iter (fun cur ->\n        if cur = pre || isIndirectPredecessor cur.id (pre.UniquePredecessors CodeSnippet.FetchO |> HashSet) then () else\n        let preds = \n            if cur.predecessors |> List.contains pre.id\n            then List.filter ((<>) pre.id)\n            else fun l -> pre.id :: l\n            <| cur.predecessors\n        codeSnippets.UpdateBy  (fun c -> Some { c with predecessors = preds }) cur.id\n        setDirtyPred()\n    )\n\nlet toggleExpanded snp =\n    codeSnippets.UpdateBy  (fun c -> Some { c with expanded = not c.expanded }) snp.id\n    refreshView()\n\nlet listEntry isParent isExpanded code =\n    Template.Hoverable.New\n        .Content( [ ``class`` \"code-editor-list-tile\"\n                    classIf   \"selected\"              <| Val.map ((=)                    code.id) currentCodeSnippetId\n                    classIf   \"direct-predecessor\"    <| Val.map (isDirectPredecessor    code.id) currentCodeSnippetO\n                    classIf   \"indirect-predecessor\"  <| Val.map (isIndirectPredecessor  code.id) curPredecessors\n                    draggable \"true\"\n                    SomeAttr <| on.dragOver(fun _ ev -> ev.PreventDefault()                                              )\n                    SomeAttr <| on.drag    (fun _ _  ->                                              draggedId <- code.id)\n                    SomeAttr <| on.drop    (fun _ ev -> ev.PreventDefault() ; reorderSnippet code.id draggedId           )\n                    span    [ ``class`` \"node\"\n                              classIf   \"parent\"   isParent\n                              classIf   \"expanded\" isExpanded\n                              SomeAttr <| on.click(fun _ _ -> if isParent then toggleExpanded code)\n                              title    <| if isParent then (if isExpanded then \"collapse\" else \"expand\") else \"\"\n                              htmlText <| if isParent then (if isExpanded then \"-\"        else \"+\"     ) else \"\"\n                            ]\n                    div     [ ``class`` \"code-editor-list-text\"\n                              style1 \"text-indent\" (sprintf \"%dem\" <| code.Level)\n                              style  \"white-space: pre\"\n                              htmlText <| Val.map2 snippetName (curSnippetNameOf code.id) (curSnippetCodeOf code.id)\n                              SomeAttr <| on.click (fun _ _ -> currentCodeSnippetId.Value <- code.id)\n                            ]\n                    span    [ ``class``   \"predecessor\"\n                              title       \"toggle predecessor\"\n                              SomeAttr <| on.click(fun _ _ -> Val.iter (togglePredecessorForCur code) currentCodeSnippetO)\n                              htmlText    \"X\"\n                            ]\n                    ])\n\nlet mutable topScrollList = 0.0\n\nlet listEntries snps =\n    let list =\n      div [ \n        yield style \"overflow: auto\"\n        yield! \n            snps\n            |> Seq.indexed\n            |> Seq.mapFold (fun expanded (i, snp) ->\n                if snp.parent |> Option.map (fun p -> Set.contains p expanded) |> Option.defaultValue true then \n                    let isParent    = codeSnippets |> Seq.tryItem (i + 1) |> Option.map (fun nxt -> nxt.parent = Some snp.id) |> Option.defaultValue false\n                    let isExpanded  = isParent && snp.expanded\n                    (listEntry isParent isExpanded snp |> Some, if isExpanded then Set.add snp.id expanded else expanded)\n                else  (None, expanded)\n            )  (Set [])\n            |> fst\n            |> Seq.choose id\n        yield SomeAttr <| on.scroll      (fun e _ -> topScrollList <- e.ScrollTop   )\n        yield SomeAttr <| on.afterRender (fun e   -> e.ScrollTop   <- topScrollList )\n      ]\n    list\n\n()    ","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"},{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}],"id":{"$":0,"Item":"93f32df7-da8b-472f-8bad-e82cc58ec52b"},"expanded":true,"level":0,"properties":{}},{"name":"Deserialize","content":"let inline ifUndef def v = if isUndefined v then def else v\nlet obj2CodeSnippetId o = \n    if isUndefined o then\n        System.Guid(\"00000000-0000-0000-0000-000000000000\")\n    else\n        o?Item\n    |> CodeSnippetId \n\nlet obj2CodeSnippetIdO o = // the json representation of an option is different from the internal representation\n    if isUndefined o then\n        None\n    else\n        Some <| obj2CodeSnippetId o\n\nlet obj2Map o =\n    if isUndefined o then\n        Map.empty\n    else\n        JS.GetFields o |> Array.map (fun (f, v) -> f, v :?> string ) |> Map.ofSeq\n\nlet deserializeCodeSnipets v = \n    try\n        let objs= WebSharper.Json.Parse v |> unbox<obj[]>\n        printfn \"%A\" <| Array.length objs\n        let snps =\n            objs\n            |> Array.choose (fun o ->\n                 if isUndefined o then None else\n                 {\n                    name         = o?name         |> ifUndef \"\"\n                    content      = o?content      |> ifUndef \"\"\n                    parent       = o?parent       |> obj2CodeSnippetIdO\n                    predecessors = o?predecessors |> ifUndef [||] |> Array.map  obj2CodeSnippetId |> Seq.toList\n                    id           = o?id           |> obj2CodeSnippetId\n                    expanded     = o?expanded     |> ifUndef false\n                    level        = o?level        |> ifUndef 0\n                    properties   = o?properties   |> obj2Map\n                  } |> Some)\n        snps\n    with _ -> [||]","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}],"id":{"$":0,"Item":"54304360-819a-498c-a091-e6ece880a35a"},"expanded":true,"level":0,"properties":{}},{"name":"Add,Delete,Load,Save","content":"let addCode   ()   =\n    CodeSnippet.PickIO currentCodeSnippetId.Value\n    |> Option.map (fun (i, snp) -> CodeSnippet.New(i + 1, \"\", snp.parent, [], [], \"\"))\n    |> Option.defaultWith (fun _ -> CodeSnippet.New \"\")\n    |> fun n -> currentCodeSnippetId.Value <- n.id\n    setDirty()\n    refreshView()\n\n\nlet deleteCode () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value\n    |> Option.iter (fun snp -> \n        if JS.Confirm (sprintf \"Do you want to delete %s?\" snp.Name) then\n            currentCodeSnippetId.Value <- CodeSnippetId.New\n            codeSnippets.Remove snp\n            setDirty()\n            refreshView()\n    )\n    \nlet justFileName (f:string) = f.Split [| '/' ; '\\\\' |] |> Seq.last\n\nlet fileName  = Var.Create \"\"\nlet emptyFile = Val.map (fun v -> v = \"\") fileName\n\nlet loadTextFile element (f: string -> unit) =\n    let files = element |> FileList.OfElement \n    if files.Length > 0 then\n        let  reader  = TextFileReader()\n        reader.Onload <- (fun e -> f e.Target?result)\n        reader.ReadAsText files.[0] \n\nlet fileInputElementId = \"CodeEditorFileSel\"\nlet loadFile (e: Dom.Element) =\n    if (not dirty.Value) || JS.Confirm \"Changes have not been saved, do you really want to load?\" then\n      let root = findRootElement e\n      loadTextFile (root.QuerySelector(\"#\" + fileInputElementId))\n        (fun txt ->\n            try\n                txt\n                |> deserializeCodeSnipets\n                |> codeSnippets.Set\n                setClean()\n                refreshView()\n            with e -> JS.Alert <| e.ToString()\n        )\n\nlet downloadFile() =\n    codeSnippets.Value\n        |> Seq.toArray\n        |> Json.Serialize\n        |> saveAs <| match justFileName fileName.Value with | \"\" -> \"snippets.fsjson\" | fname -> fname\n    setClean()\n\nlet loadFileElement =\n    Template.Input.New(fileName.Lens justFileName (fun prev n -> prev) )\n        .Prefix( label [ ``class`` \"btn btn-primary\" ; htmlText \"Load File...\" \n                         Template.Input.New(fileName)\n                                 .Type(\"file\")\n                                 .Style(\"display: none\")\n                                 .Content([ on.change (fun el _ -> loadFile el   )\n                                            on.click  (fun el _ -> el?value <- \"\")\n                                          ])\n                                 .Id(fileInputElementId)\n                                 .Render \n                        ]\n                )\n                \nlet do_LoadFile (e:Dom.Element) _ =          \n    let root = findRootElement e\n    (root.QuerySelector(\"#\" + fileInputElementId))?click()\n\n()","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"54304360-819a-498c-a091-e6ece880a35a"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}],"id":{"$":0,"Item":"60191ea0-da20-4fbf-96b8-3871338a66d8"},"expanded":true,"level":0,"properties":{}},{"name":"codeMirror","content":"let autoCompleteClient = FSAutoCompleteIntermediary.FSAutoCompleteIntermediaryClient(\"FSharpStation\", endPoint = JS.Window.Location.Href)\n\n#if FSS_SERVER\nlet parseFile = @\"ParseFSharp.fsx\"\n#else\nlet parseFile = @\"..\\ParseFSharp.fsx\"\n#endif\n\nlet setDirtyCond() =\n    match lastCodeAndStarts with\n    | Some (pId, _, red) when pId = currentCodeSnippetId.Value -> setDirtyPart()\n    | _                                                        -> setDirty    ()\n\nlet getCodeAndStartsFast msgF (snp:CodeSnippet) addLinePrepos =\n    let red0, cur = \n        match lastCodeAndStarts with\n        | Some (pId, alp, red) when pId = snp.id && alp = addLinePrepos -> msgF \"Reparsing...\"; red, snp.PrepareSnippet\n        | _ -> \n        msgF \"Parsing...\"\n        let preds = snp.Predecessors()\n        let red = CodeSnippet.ReducedCode addLinePrepos preds.[0..preds.Length - 2]\n        let cur = preds.[preds.Length - 1]\n        lastCodeAndStarts <- Some(cur.id, addLinePrepos, red)\n        red, cur\n    let red1 = CodeSnippet.ReducedCode addLinePrepos [| cur |]\n    CodeSnippet.AddSeps red0 red1\n    |> CodeSnippet.FinishCode addLinePrepos\n\nlet mutable parseRun = 1\n\nlet parseFSA silent =\n    async {\n        let msgF = if silent then ignore else fun txt -> parserMsgs.Value <- txt\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        let runN           = parseRun + 1\n        parseRun          <- runN\n        let  code, starts  = getCodeAndStartsFast msgF cur false\n        parsed            <- true\n        let! res           = autoCompleteClient.Parse(parseFile, code, starts)\n        if not silent && runN = parseRun && parsed then\n            addPrsMsg res\n            addPrsMsg \"Parsed!\"\n    }\n\nlet parseFS() = \n    Wrap.wrapper {\n        lastCodeAndStarts <- None\n        do! parseFSA false\n    }\n\n\nlet mustParse (cur:CodeSnippet) =\n    async {\n        if not parsed then return true \n        else\n            let! must = autoCompleteClient.MustParse(parseFile, cur.NameSanitized)\n            return must\n    }\n\nlet parseIfMustThen silent =\n    async {\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        let! must = mustParse cur\n        if must then \n            do! parseFSA silent\n    }\n\nlet getStartWord (line:string) ch =\n    match line.Substring(0, ch) with\n    | REGEX @\"([a-zA-Z_]\\w*)$\" \"g\" [| txt |] -> txt\n    | _                                      -> \"\"          \n\nlet getEndWord (line:string) ch =\n    match line.Substring(ch) with\n    | REGEX @\"^([a-zA-Z_]\\w*)\" \"g\" [| txt |] -> txt\n    | _                                      -> \"\"          \n\nlet showToolTip (ed:Template.CodeMirrorEditor) =\n    async {\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        do!  parseIfMustThen false\n        let  pos   = ed.GetCursor()\n        let  l     = ed.GetLine pos.line\n        let  sub   = (getStartWord l pos.ch |> String.length)   \n        let  add0  = (getEndWord   l pos.ch |> String.length)    \n        let  add   = if sub = 0 && add0 = 0 then 2 else add0 \n        let! tip   = autoCompleteClient.ToolTip  (parseFile, pos.line + 1, pos.ch + 1, cur.NameSanitized)\n        addPrsMsg <| sprintf \"InfoFSharp \\\"%s %A - %A %s \\\"\" cur.NameSanitized (pos.line + 1, pos.ch - sub + 1) (pos.line + 1, pos.ch + add + 1) (tip.Replace(\"\\\"\",\"''\"))\n    } |> Async.Start\n\nlet getHints (ed:Template.CodeMirrorEditor, cb, _) =\n    async {\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        do!  parseIfMustThen true\n        let  pos    = ed.GetCursor()\n        let  l      = ed.GetLine pos.line\n        let  word   = getStartWord l pos.ch     \n        let! com    = autoCompleteClient.Complete(parseFile, l, pos.line + 1, pos.ch + 1, cur.NameSanitized)\n        cb { Template.list   = com \n                               |> Array.map (fun (dis, rep, cls, chr) -> \n                                    { text        = rep\n                                      displayText = chr + \"| \" + dis\n                                      className   = cls                              \n                                    })\n             Template.from   = { pos with ch = pos.ch - word.Length }\n             Template.``to`` = pos \n           }\n    } |> Async.Start\n    \nlet rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\"\"\"\nlet rex2 = \"\"\"(Err|Warning|Info)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) ?)?F?#? ?(.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\nlet rex = rex1 + \"|\" + rex2\n\nlet getAnnotations (txt, cb, _, ed:Template.CodeMirrorEditor) =\n    async {\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        do!  parseIfMustThen false\n        match parserMsgs.Value with\n        | REGEX rex \"g\" m -> m\n        | _               -> [||]\n        |> Array.choose (fun v ->\n            match v with\n            | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, indent, int fl, int fc    , int tl, int tc, sev, from , msg)\n            | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, indent, int fl, int fc - 1, int fl, int fc, sev, \"fsi\", msg)\n            | _ -> None\n        )\n        |> Array.choose (fun (file, indent, fl, fc, tl, tc, sev, from, msg) ->\n            if file.StartsWith cur.id.Text || file = sanitize cur.name then\n                let ind = if int indent > 0 then int indent else 0\n                { Template.LintResponse.message  = msg\n                  Template.LintResponse.severity = (if sev.ToUpper().StartsWith(\"ERR\") then \"error\" elif sev.ToUpper().StartsWith(\"INFO\") then \"info\" else \"warning\")\n                  Template.LintResponse.from     = Template.cmPos(fl - 1, fc - 1 - ind) \n                  Template.LintResponse.``to``   = Template.cmPos(tl - 1, tc - 1 - ind)\n                } |> Some\n            else     None\n          )\n        |> cb\n    } |> Async.Start\n\nlet codeMirror = \n    Template.CodeMirror.New(Val.bindIRef curSnippetCodeOf currentCodeSnippetId)\n        .OnChange(setDirtyCond)\n        .OnRender(fun ed ->\n          ed.AddKeyMap({  F2              = showToolTip            \n                          LeftDoubleClick = showToolTip\n                          ``Ctrl-Space``  = Template.showHints ed getHints false\n                       })\n          Template.setLint ed getAnnotations \n        )\n        .Style(\"height: 100%\")\n\nlet rec expandParents snp = \n    snp.parent\n    |> Option.bind CodeSnippet.FetchO\n    |> Option.iter (fun me -> \n        expandParents me\n        if not me.expanded then toggleExpanded me)\n\nlet goto codeId line col =\n    async {\n        currentCodeSnippetId.Value <- codeId\n        CodeSnippet.FetchO codeId |> Option.iter expandParents\n        do! Async.Sleep 200\n        codeMirror.editorO \n        |> Option.iter (fun ed -> \n            ed.SetCursor(line - 1, col - 1) \n            ed.Focus()\n        )\n    } |> Async.Start\n\nlet rexGuid = \"\"\"([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}).+?\\((\\d+)\\,\\s*(\\d+)\\)\"\"\"\n\nlet jumpToLine (line:string) = \n    match line with\n    | REGEX rexGuid \"\" [| _ ; guid ; line ; col |] -> goto <| CodeSnippetId (System.Guid guid) <| int line <| int col\n    | _                                            -> ()\n\nlet gotoDefinition () =\n    async {\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        match codeMirror.editorO  with\n        | None     -> () \n        | Some ed  ->\n        let  pos   = ed.GetCursor()\n        let  l     = ed.GetLine pos.line\n        let! kind  = autoCompleteClient.FindDecl(parseFile, pos.line + 1, pos.ch + 1, cur.NameSanitized)\n        match kind with\n        | FSAutoCompleteIntermediary.CommTypes.KFindDecl decl -> jumpToLine <| sprintf \"%s (%d, %d) - (%d, %d)\" decl.File decl.Line decl.Column decl.Line decl.Column\n        | FSAutoCompleteIntermediary.CommTypes.KError    err  -> JS.Alert   <| sprintf \"%A\" err\n        | _                                                   -> JS.Alert   <| sprintf \"%A\" kind\n    } |> Async.Start\n\nlet codeMirrorRender = \n    codeMirror.Render.AddChildren [ \n        SomeAttr <| on.dblClick (fun _ _ -> showToolTip codeMirror.editorO.Value)  \n        htmlElement \"menu\" [  // does not work anymore. support for this was dropped by Chrome\n            ``type`` \"context\"\n            Id       \"right-menu\"\n            htmlElement \"menuitem\" [ \n                htmlAttribute \"label\" \"Goto Definition\"\n                SomeAttr <| on.click (fun _ _ -> gotoDefinition() )  \n            ] \n        ]\n        htmlAttribute \"contextmenu\" \"right-menu\"\n    ]\n\nparserMsgs\n|> Val.sink (fun msgs ->\n    async {\n        if not parsed then () else\n        match codeMirror.editorO  with\n        | None    -> () \n        | Some ed ->\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        let! must = autoCompleteClient.MustParse(parseFile, cur.NameSanitized)\n        if must       then () else\n        ed?performLint() |> ignore\n    } |> Async.Start      \n)\n//let mutable prior = \"\", \"\"\n//Val.map2 (fun msgs curO -> msgs, curO) codeMsgs currentCodeSnippetO\n//|> Val.sink (fun (msgs, curO) ->\n//    async {\n//        match codeMirror.editorO  with\n//        | None        -> () \n//        | Some editor ->\n//            match curO with \n//            | None -> () \n//            | Some cur ->\n//            curSnippetNameOf cur.id\n//            |> Val.iter (fun name ->\n//                printfn \"RemoveMarks: %s\" name\n//                if prior = (msgs, name) then () else\n//                prior   <- (msgs, name)\n//                editor.RemoveMarks()\n//                match msgs with\n//                | REGEX rex \"g\" m -> m\n//                | _               -> [||]\n//                |> Array.choose (fun v ->\n//                    match v with\n//                    | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, int fl, int fc - int indent    , int tl, int tc - int indent, sev, from , msg)\n//                    | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, int fl, int fc - int indent - 1, int fl, int fc - int indent, sev, \"fsi\", msg)\n//                    | _ -> None\n//                )\n//                |> Array.iter (fun (file, fl, fc, tl, tc, sev, from, msg) ->\n//                    printfn \"inside -%s-%s-\" file (sanitize name)\n//                    if file.StartsWith cur.id.Text || file = sanitize name then\n//                        100\n//                        |> JS.SetTimeout (fun () ->\n//                            editor.MarkText (fl - 1, fc - 1) (tl - 1, tc - 1) (if sev.ToUpper().StartsWith(\"ERR\") then \"Error\" else \"Warning\")  msg)\n//                        |> ignore\n//    \n//                )\n//            )\n//    } |> Async.Start\n//)\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"93f32df7-da8b-472f-8bad-e82cc58ec52b"},{"$":0,"Item":"466e6783-0751-48d5-b79b-165aaa7d2173"},{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"},{"$":0,"Item":"18d8153d-422c-42f6-8266-9a9d854bd6a1"},{"$":0,"Item":"a05dd36e-a15e-4394-8013-128e21e69574"},{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"id":{"$":0,"Item":"47f7c0ba-35b0-466e-a759-4e4d9963e524"},"expanded":true,"level":0,"properties":{}},{"name":"style","content":"let styleEditor    =\n     \"\"\"\ndiv textarea {\nfont-family: monospace;\n}\n.code-editor-list-tile {\nwhite-space: nowrap; \nborder-style: solid none none;\nborder-color: white;\nborder-width: 1px;\nbackground-color: #D8D8D8;\ndisplay: flex;\n}\n.code-editor-list-text{\npadding: 1px 10px 1px 5px;\noverflow:hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;\nflex: 1;\n}\n\n.code-editor-list-tile.direct-predecessor {\nfont-weight: bold;\n}\n.code-editor-list-tile.indirect-predecessor {\ncolor: blue;\n}\n.code-editor-list-tile.selected {\nbackground-color: #77F;\ncolor: white;\n}\n.code-editor-list-tile.hovering {\nbackground: lightgray;\n}\n.code-editor-list-tile.hovering.selected {\nbackground:  blue;\n}\n.code-editor-list-tile>.predecessor {\nfont-weight: bold;\nborder-style: inset;\nborder-width: 1px;\ntext-align: center;\ncolor: transparent;\n}\n.code-editor-list-tile.direct-predecessor>.predecessor {\ncolor: blue;\n}\n\n.CodeMirror { height: 100%; }\n\n.node {\n    background-color:white; \n    width: 2ch; \n    color: #A03; \n    font-weight:bold; \n    text-align: center;\n    font-family: arial;\n}\n.Warning { text-decoration: underline lightblue } \n.Error   { text-decoration: underline red       } \n.body    { margin         : 0px                 }\n    \"\"\"","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"id":{"$":0,"Item":"fa5b4506-b26d-4387-8e04-ac7a5a90861a"},"expanded":true,"level":0,"properties":{}},{"name":"Actions","content":"let triggerWSResult = Var.Create ()\n\nlet DoW f p _ _ = f p |> Wrap.map ignore |> Wrap.start addOutMsg\nlet DoP f p _ _ = f p |> Wrap.startV (function\n                                      | Some (Below, _), msgs -> msgs |> addOutMsg ;  triggerWSResult.Value <- ()\n                                      | Some _         , msgs -> msgs |> addOutMsg \n                                      | None           , msgs -> \"Failed!\\n\" + msgs |> addOutMsg)\n\nlet actLoadFile       = Template.Action.New(\"Load...\"                    ).OnClick(do_LoadFile                 )  \nlet actSaveFile       = Template.Action.New(\"Save as...\"                 ).OnClick(Do  downloadFile   ()        ).Highlight(dirty)\nlet actAddSnippet     = Template.Action.New(\"Add Snippet\"                ).OnClick(Do  addCode        ()        )\nlet actDeleteSnippet  = Template.Action.New(\"Delete Snippet\"             ).OnClick(Do  deleteCode     ()        ).Disabled(noSelectionVal)\nlet actIndentSnippet  = Template.Action.New(\"Indent In  >>\"              ).OnClick(Do  indentCodeIn   ()        ).Disabled(noSelectionVal)\nlet actOutdentSnippet = Template.Action.New(\"Indent Out <<\"              ).OnClick(Do  indentCodeOut  ()        ).Disabled(noSelectionVal)\nlet actGetFsCode      = Template.Action.New(\"Get F# Code\"                ).OnClick(Do  getFSCode      ()        ).Disabled(noSelectionVal)\nlet actEvalCode       = Template.Action.New(\"Evaluate F#\"                ).OnClick(DoW evaluateFS     ()        ).Disabled(noSelectionVal)\nlet actRunWSNewTab    = Template.Action.New(\"Run WebSharper in new tab\"  ).OnClick(DoW compileRunP    NewBrowser).Disabled(noSelectionVal)\nlet actRunWSHere      = Template.Action.New(\"Run WebSharper in WS Result\").OnClick(DoP compileRunP    Below     ).Disabled(noSelectionVal)\nlet actRunWSIn        = Template.Action.New(\"Run WebSharper in ...\"      ).OnClick(DoP compileRun     ()        ).Disabled(noSelectionVal)\nlet actParseCode      = Template.Action.New(\"Parse F#\"                   ).OnClick(DoW parseFS        ()        ).Disabled(noSelectionVal)\nlet actCompileWS      = Template.Action.New(\"Compile WebSharper\"         ).OnClick(DoW justCompile    ()        ).Disabled(noSelectionVal)\nlet actFindDefinition = Template.Action.New(\"Find Definition\"            ).OnClick(Do  gotoDefinition ()        ).Disabled(noSelectionVal)\n\nlet buttonsH =\n    div [ \n          actAddSnippet    .Button.Render\n          actOutdentSnippet.Button.Render\n          actIndentSnippet .Button.Render\n          loadFileElement.Render.AddChildren([ style \"grid-column: 4/6\" ])\n          actParseCode     .Button.Render\n          actEvalCode      .Button.Render\n          actGetFsCode     .Button.Render\n       \n          actDeleteSnippet .Button.Render\n          actFindDefinition.Button.Render\n          span []       \n          actSaveFile      .Button.Render\n          span []\n          actCompileWS     .Button.Render\n          actRunWSIn       .Button.Render\n          Doc.Select [ attr.id \"Position\" ] positionTxt [ NewBrowser ; Below ] position |> someElt\n          style \"\"\"\n              overflow: hidden;\n              display: grid;\n              grid-template-columns: repeat(8, 12.1%);\n              bxackground-color: #eee;\n              padding : 5px;\n              grid-gap: 5px;\n          \"\"\"\n        ]\n\nlet menuLeft =\n    Menu.New2\n      [\n        MenuEntry.New(\"File\")\n            .SubMenu(\n                    [\n                        actLoadFile.MenuEntry\n                        actSaveFile.MenuEntry\n                    ]           \n            )            \n        MenuEntry.New(\"Code\")           \n            .SubMenu(           \n                    [           \n                        actAddSnippet    .MenuEntry\n                        actDeleteSnippet .MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actIndentSnippet .MenuEntry\n                        actOutdentSnippet.MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actFindDefinition.MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actGetFsCode     .MenuEntry\n                    ]     \n            )      \n        MenuEntry.New(\"Run\")     \n            .SubMenu(     \n                    [     \n                        actEvalCode      .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actRunWSNewTab   .MenuEntry\n                        actRunWSHere     .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actParseCode     .MenuEntry\n                        actCompileWS     .MenuEntry\n                    ]\n            ) \n      ]\n\nlet menuRight =\n    Menu.New2\n      [\n        MenuEntry.New(\"About\")\n      ]      \n\nlet menuBar =\n    navbar <| h1 [ htmlText \"F# Station\" ; style \"font-size: 48px; margin-top: -17px\" ]\n           <| menuLeft .Render \n           <| menuRight.Render\n           \n()           ","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"3f2ec5e2-8ab6-4e5b-bb89-1943ed3a4964"},{"$":0,"Item":"60191ea0-da20-4fbf-96b8-3871338a66d8"},{"$":0,"Item":"47f7c0ba-35b0-466e-a759-4e4d9963e524"},{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"}],"id":{"$":0,"Item":"70bc3916-4714-4ee1-a2d0-d3917eeadf9d"},"expanded":true,"level":0,"properties":{}},{"name":"CodeEditorGrid","content":"let spl1         = Template.SplitterBar.New(20.0).Children([ style \"grid-row: 2 / 4\" ])\nstoreVarCodeEditor \"splitterV1\" spl1.Var\n//storeVarCodeEditor \"splitterV2\" splitterV2.Var\n//storeVarCodeEditor \"splitterH3\" splitterH3.Var\n\nlet jumpToRef (e:obj) _ = \n    let v : string = e?value |> unbox\n    let s : int    = e?selectionStart |> unbox\n    let lines = v.Split '\\n'\n    lines \n    |> Seq.mapFold (fun total line -> (line, total, total + line.Length + 1), total + line.Length + 1) 0 \n    |> fst\n    |> Seq.pick (fun (line, from, to_) -> if s >= from && s < to_ then Some line else None)\n    |> jumpToLine\n\nlet Messages =\n    [\n     \"Output\"    , Template.TextArea.New(outputMsgs).Placeholder(\"Output:\"         ).Title(\"Output\"                   ).RenderWith [ on.dblClick jumpToRef ]\n     \"Parser\"    , Template.TextArea.New(parserMsgs).Placeholder(\"Parser messages:\").Title(\"Parser\"                   ).RenderWith [ on.dblClick jumpToRef ]\n     \"JavaScript\", Template.TextArea.New(codeJS    ).Placeholder(\"Javascript:\"     ).Title(\"JavaScript code generated\").Render\n     \"F# code\"   , Template.TextArea.New(codeFS    ).Placeholder(\"F# code:\"        ).Title(\"F# code assembled\"        ).Render\n     \"WS Result\" , div [ div [ Id \"TestNode\" ; style \"background: white; height: 100%; width: 100%; \"] ]\n    ]\n    \n(*\nlet CodeEditor() =\n  Template.Grid.New\n     .ColVariable(spl1)\n     .ColAuto(     0.0)\n     .ColVariable( 0.0).Min(0.0).Max(Val.map ((-) 92.0) spl1.GetValue).Before.Children([ style \"grid-row   : 1 / 5\" ])\n     .RowFixedPx( 34.0) \n     .RowAuto(     0.0)\n     .RowVariable(17.0)                                               .Before.Children([ style \"grid-column: 2 / 3\" ])\n     .RowFixedPx( 80.0)\n     .Padding(1.0)\n     .Content(\"sidebar\", \n         codeSnippets.View\n         |> View.SnapshotOn codeSnippets.Value refresh.View\n         |> bindHElem listEntries\n      )\n     .Content(\"header\"  , Template.Input     .New(Val.bindIRef curSnippetNameOf currentCodeSnippetId).Prefix(htmlText \"name:\")         .Render)\n     .Content(\"content1\", codeMirror                                                                                                   .Render)\n     .Content(\"content2\", Template.TabStrip  .New(Messages).Top                                                                        .Render)\n     .Content(\"footer\"  ,       \n        div [ \n              actAddSnippet    .Button.Render\n              actOutdentSnippet.Button.Render\n              actIndentSnippet .Button.Render\n              loadFileElement.Render.AddChildren([ style \"grid-column: 4/6\" ])\n              actParseCode     .Button.Render\n              actEvalCode      .Button.Render\n              actGetFsCode     .Button.Render\n       \n              actDeleteSnippet .Button.Render\n              span []       \n              span []       \n              actSaveFile      .Button.Render\n              span []\n              actCompileWS     .Button.Render\n              actRunWSIn       .Button.Render\n              Doc.Select [ attr.id \"Position\" ] positionTxt [ Below ; Right ; NewBrowser ] position |> someElt\n              style \"\"\"\n                  overflow: hidden;\n                  display: grid;\n                  grid-template-columns: repeat(8, 12.1%);\n                  bxackground-color: #eee;\n                  padding : 5px;\n                  grid-gap: 5px;\n              \"\"\"\n            ]\n        )\n     .Content( script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                                     ; ``type`` \"text/javascript\"             ] )\n     .Content( script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ] )\n     .Content( script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ] )\n     .Content( link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ] )\n     .Content( link   [ href \"/EPFileX/css/main.css\"                                               ; ``type`` \"text/css\" ; rel \"stylesheet\" ] )\n     .Content( css styleEditor                                                                                                                )\n     .Render\n     .Style(\"\"\" \n            grid-template-areas:\n                'header0 header   sidebar2'\n                'sidebar content1 sidebar2'\n                'sidebar content2 sidebar2'\n                'footer  footer   sidebar2';\n            color      : #333;\n            height     : 100%;\n            font-size  : small;\n            font-family: monospace;\n            line-height: 1.2;\n                \"\"\")\n\n*)\n()","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"e702bf50-ad01-45eb-8b7b-813cc9046bef"},{"$":0,"Item":"70bc3916-4714-4ee1-a2d0-d3917eeadf9d"},{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"},{"$":0,"Item":"cddabd38-7ecb-4692-99bd-13ca70e4232f"},{"$":0,"Item":"47f7c0ba-35b0-466e-a759-4e4d9963e524"},{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"93f32df7-da8b-472f-8bad-e82cc58ec52b"},{"$":0,"Item":"60191ea0-da20-4fbf-96b8-3871338a66d8"},{"$":0,"Item":"b417f7b1-5e53-4c51-a23f-6f2c8c5a77b7"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},{"$":0,"Item":"fa5b4506-b26d-4387-8e04-ac7a5a90861a"}],"id":{"$":0,"Item":"75c3d033-99b5-409f-8ecb-cd9bd8b101ab"},"expanded":true,"level":0,"properties":{}},{"name":"MainForm","content":"let snippetList = \n    codeSnippets.View\n       |> View.SnapshotOn codeSnippets.Value refresh.View\n       |> bindHElem listEntries\n       \nlet inline fixedHorSplitter1 px ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", renderSplitterNode ch1)\n                       .Content(\"two\", renderSplitterNode ch2).Padding(0.0)\n    grid.RowFixedPx(px).RowAuto(50.0).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\nlet inline fixedHorSplitter2 px ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", renderSplitterNode ch1)\n                       .Content(\"two\", renderSplitterNode ch2).Padding(0.0)\n    grid.RowAuto(50.0).RowFixedPx(px).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\nlet title         = SHtmlNode <| Template.Input.New(Val.bindIRef curSnippetNameOf currentCodeSnippetId).Prefix(htmlText \"name:\").Render\nlet messages      = STabStrip <| TabStrip.New(Messages).Top\nlet code          = SHtmlNode <| codeMirrorRender\nlet snippets      = SHtmlNode <| snippetList\nlet buttons       = SHtmlNode <| buttonsH\nlet menu          = SHtmlNode <| menuBar\n\nlet title_code    = SplitterStructure.New(       title        , code         , fixedHorSplitter1 34.0)\nlet code_buttons  = SplitterStructure.New(       title_code   , buttons      , fixedHorSplitter2 80.0)\nlet snippets_code = SplitterStructure.New(true , snippets     , code_buttons ,                   15.0)\nlet main_messages = SplitterStructure.New(false, snippets_code, messages     ,                   82.0)\nlet main_window   = SplitterStructure.New(       menu         , main_messages, fixedHorSplitter1 50.0)\n\n//let code_messages = SplitterStructure.New(false, title_Code           , STabStrip messages,                   75.0)\n//let main_Buttons  = SplitterStructure.New(       snippets_code        , SHtmlNode buttons                 , fixedHorSplitter2 80.0)\n\nlet rootSplitter = SplitterNode.New(main_window)\n\nVal.sink (fun _ -> rootSplitter.SelectTab \"Output\"    |> ignore ) outputMsgs \nVal.sink (fun _ -> rootSplitter.SelectTab \"Parser\"    |> ignore ) parserMsgs \nVal.sink (fun _ -> rootSplitter.SelectTab \"WS Result\" |> ignore ) triggerWSResult \n\ndiv [\n    style \"height: 100vh; width: 100% \"\n    rootSplitter.Render.Style(\"height: 100%; width: 100% \")\n    script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                                     ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ]\n    link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    link   [ href \"/EPFileX/css/main.css\"                                               ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    css styleEditor                                                                                                               \n    style  \"\"\" \n          color      : #333;\n          font-size  : small;\n          font-family: monospace;\n          line-height: 1.2;\n              \"\"\"\n] |> renderDoc\n\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"75c3d033-99b5-409f-8ecb-cd9bd8b101ab"},{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},{"$":0,"Item":"95ca1e9f-4029-4fc1-8b1c-ab12db71c90b"},{"$":0,"Item":"a48d72fc-5220-4dac-b3b3-98bad48b0561"}],"id":{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"},"expanded":true,"level":0,"properties":{}},{"name":"CodeEditor (old not used)","content":"let splitterMain1 =\n    Template.SplitterBar.New( 0.0).Vertical(directionVertical).Min( 0.0).Max(35.0)\n\nlet splitterMain2 =\n    Template.SplitterBar.New(24.0).Vertical(directionVertical).Min( 0.5).Max(Val.map (fun pos -> if pos = NewBrowser then 0.1 else 50.0) position).Before\n\nstoreVarCodeEditor \"splitterMain1\" splitterMain1.Var\nstoreVarCodeEditor \"splitterMain2\" splitterMain2.Var\n\n//RunCode.RunNode(\"CodeEditor\").AddBootstrap.RunHtml <| CodeEditor()\n//addNodeById \"pageStyle\"                            <| styleH [ htmlText pageStyle ]\n//addNodeById \"splitterMain1\"                        <| splitterMain1.Render\n//addNodeById \"splitterMain2\"                        <| splitterMain2.Render\n\nlet grid = \n    Template.Grid.New\n       .Padding(0.0)\n       .Content(\"editor\", CodeEditor())\n       .Content(style    \"height: 100vh; margin: 0px; \")\n       .Content(css \"\"\"\n           #CodeEditor              { grid-area: editor  ; overflow: hidden; }\n           #TestNode                { grid-area: testNode; overflow: auto  ; }\n           body > div:first-of-type { grid-area: header  ; overflow: hidden; }\n       \"\"\")\n\ndirectionVertical\n|> Val.map (fun dir ->\n    (if dir\n     then grid.ColVariable(splitterMain1).ColAuto(16.0).ColVariable(splitterMain2).Content(style \"\"\" grid-template-areas: 'header   editor   testNode'; \"\"\")\n     else grid.RowVariable(splitterMain1).RowAuto(16.0).RowVariable(splitterMain2).Content(style \"\"\" grid-template-areas: 'header' 'editor' 'testNode'; \"\"\")\n    ).GridTemplate())\n|> bindHElem body\n|> renderDoc\n|> Doc.RunReplace JS.Document.Body\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"75c3d033-99b5-409f-8ecb-cd9bd8b101ab"},{"$":0,"Item":"95ca1e9f-4029-4fc1-8b1c-ab12db71c90b"},{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},{"$":0,"Item":"456562f7-0757-4431-9aeb-d58b050cecf7"}],"id":{"$":0,"Item":"07f11803-2084-4a0a-9066-a43fd11be1c7"},"expanded":true,"level":0,"properties":{}},{"name":"Editor2","content":"// Version using ZafirTranspiler.dll & Remote.dll\n[< JavaScript >]\nlet Main = FSharpStationClient() |> Doc.Run JS.Document.Body\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"8fbd59ac-9417-4309-8d01-3ccd5d62452c"},{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"}],"id":{"$":0,"Item":"8d84a97a-8fbf-4ee6-81c3-cf70db4adfa4"},"expanded":true,"level":0,"properties":{}},{"name":"Site","content":"// Version using internal Rpc's\n#define FSS_SERVER\n//#define NOMESSAGING\n\nopen WebSharper.Sitelets\nopen WebSharper.UI.Next.Server\nopen WebSharper.UI.Next\n\ntype EndPoint = | [< EndPoint \"/\" >] EP\n\nlet content (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n    Content.Page(\n        Title = \"F# Station\"\n      , Head  = [ Html.scriptAttr [ attr.``type`` \"text/javascript\"; attr.src \"https://code.jquery.com/jquery-3.1.1.min.js\"] [] \n                  Html.scriptAttr [ attr.``type`` \"text/javascript\"; attr.src \"/EPFileX/CIPHERSpaceLoadFiles.js\"           ] [] \n                ]\n      , Body  = [ Html.client <@  FSharpStationClient () @> ])\n\nlet site = Application.MultiPage content\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"},{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"}],"id":{"$":0,"Item":"b9ca9697-6cb4-4085-b509-9f702a62086f"},"expanded":true,"level":0,"properties":{}},{"name":"FSharpStation","content":"#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net45\\Microsoft.Owin.Hosting.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net45\\Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net45\\Microsoft.Owin.StaticFiles.dll\"\n#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net45\\Microsoft.Owin.FileSystems.dll\"\n#r @\"..\\packages\\Zafir.Owin\\lib\\net45\\WebSharper.Owin.dll\"\n#r @\"..\\packages\\Zafir.Owin\\lib\\net45\\HttpMultipartParser.dll\"\n//#r @\"WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n\nopen global.Owin\nopen Microsoft.Owin.Hosting\nopen Microsoft.Owin.StaticFiles\nopen Microsoft.Owin.FileSystems\nopen WebSharper.Owin\n\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://localhost\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://*\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"file://\"\nWebSharper.Web.Remoting.DisableCsrfProtection()\n\n[< EntryPoint >]\nlet Main args =\n    let rootDirectory, url =\n        match args with\n        | [| rootDirectory; url |] -> rootDirectory, url\n        | [| url                |] -> \"website\"    , url\n        | [|                    |] -> \"website\"    , \"http://localhost:9010/\"\n        | _ -> eprintfn \"Usage: WebServer3 ROOT_DIRECTORY URL\"; exit 1\n    use server = \n        WebApp.Start(url, fun appB ->\n            appB.UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(rootDirectory)))\n                .UseWebSharper(WebSharperOptions(ServerRootDirectory = rootDirectory\n                                               , Sitelet             = Some site\n                                               , BinDirectory        = \".\"\n                                               , Debug               = true))\n            |> ignore\n            let listener = appB.Properties.[\"Microsoft.Owin.Host.HttpListener.OwinHttpListener\"] |> unbox<Microsoft.Owin.Host.HttpListener.OwinHttpListener>\n            listener.SetRequestProcessingLimits(1000, 1000)\n            let maxA : int ref = ref 0\n            let maxB : int ref = ref 0\n            listener.GetRequestProcessingLimits(maxA, maxB)\n            printfn \"Accepts: %d Requests:%d\" !maxA !maxB\n        )\n    stdout.WriteLine(\"Serving {0}\", url)\n    stdin.ReadLine() |> ignore\n    0\n    ","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"95a237c8-a9ff-40d1-bd72-bd298b20af8c"},{"$":0,"Item":"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"},{"$":0,"Item":"b9ca9697-6cb4-4085-b509-9f702a62086f"},{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"}],"id":{"$":0,"Item":"0dbfcc9d-8ea2-42a3-8f81-ce2bf7d0fad4"},"expanded":true,"level":0,"properties":{}},{"name":"compile & run FSharpStation","content":"#define FSS_SERVER\n\nopen System.IO\nopen FsStationShared\nopen Useful\nopen UsefulDotNet\nopen CompOptionsModule\n\nWrap.wrapper {\n    let  options   = compileOptionsExeDebug \"FSSGlobal/WebSharper Code/FSharpStation Code/FSharpStation\"\n                     + opDirectory    /= @\"Compiled\\FSharpStation2\"\n                     + siteOptions\n                     + (opGenInternal /= \"showoptions\")\n    let  exeFile   = options?Output\n    let  site      = Path.GetFullPath(options?Website)\n    let! res       = FsStationClient(\"Compile WebSharper\").CompileSnippetW options\n    do   printfn     \"%s\"              res\n    do   printfn     \"Starting %s\"     exeFile\n    let  url       = @\"http://localhost:9020/\"\n    let  parms     = sprintf \"%A %A\" site url \n    do   runProcess  exeFile parms |> ignore\n    do   runProcess  url     \"\"    |> ignore\n} |> Wrap.runSynchronouslyS true |> printfn \"%s\"\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"56e5bc09-e528-49cc-9d42-6359b32a0cc9"}],"id":{"$":0,"Item":"5e8209e0-9203-4fe0-8289-fb4579b24038"},"expanded":true,"level":0,"properties":{}},{"name":"WebSharper Snippets1","content":"[< JavaScript >]\nmodule Snippets =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"456562f7-0757-4431-9aeb-d58b050cecf7"},{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"}],"id":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"expanded":false,"level":0,"properties":{}},{"name":"Demo Button","content":"\nTemplate.Button\n   .New(    \"Press me!\"                         )\n   .OnClick(fun _ _ -> JS.Alert \"Button pressed\")\n   .Style(  \"font-size: 48px\"                   )\n   .Render\n|> RunCode.RunNode(\"HEllo\").RunHtml//PlusFree\n   \n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}],"id":{"$":0,"Item":"0a1fa320-b731-473a-93e2-dae49cc296f7"},"expanded":true,"level":0,"properties":{}},{"name":"Demo Input","content":"let inp = Template.Input.New(\"Type something...\")\n\nlet inline show3Sizes txt styleP =\n    div [\n      style styleP\n      htmlText txt\n      h2 [ htmlText txt ]\n      h1 [ htmlText <| Val.map (fun (s: string) -> s.ToUpper()) txt ]\n    ]\n    \ndiv [\n  inp.Render\n  show3Sizes inp.Var \"\"\n]    \n|> RunCode.RunNode().RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"f3a7ead2-49e1-4ff4-b96e-6fe699a1c8a9"},"expanded":true,"level":0,"properties":{}},{"name":"Demo TextArea","content":"let inp = Template.TextArea.New(\"Type Something...\").Placeholder(\"Output:\"    ).Title(\"Output\"                   )\n\nlet inline h1 ch = htmlElement \"h1\" ch\n\nlet text = htmlText inp.Var\n\nh3 [\n  inp.RenderWith [ on.dblClick (fun e m -> \n      let v : string = e?value |> unbox\n      let s : int    = e?selectionStart |> unbox\n      let lines = v.Split '\\n'\n      lines \n      |> Seq.mapFold (fun total line -> (line, total, total + line.Length + 1), total + line.Length + 1) 0 \n      |> fst\n      |> Seq.pick (fun (line, from, to_) -> if s >= from && s < to_ then Some line else None)\n      |> JS.Alert\n      ) ]\n  text\n  htmlElement \"h2\" [ text ]\n  h1 [ text ]\n  htmlElement \"menu\" // does not work anymore. support for this was dropped by Chrome\n      [ ``type`` \"context\"\n        Id       \"right-menu\"\n        htmlElement \"menuitem\" [ htmlAttribute \"label\" \"Goto Definition\" ; SomeAttr <| on.click (fun _ _ -> JS.Alert \"Goto Definition\")  ] \n      ]\n  htmlAttribute \"contextmenu\" \"right-menu\"\n]\n|> RunCode.RunNode().RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}],"id":{"$":0,"Item":"87770aad-e1d9-4fcb-be12-ff3c4ce58b7b"},"expanded":true,"level":0,"properties":{}},{"name":"Demo CodeMirror","content":"open FSAutoComplete\nopen Template\nopen Useful\n\nlet  file               = @\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\bin\\Test.fsx\"\nlet  autoCompleteClient = FSAutoCompleteClient(\"Demo Code\")\n\ntype KeyMapAutoComplete = { \n    F2             : CodeMirrorEditor -> unit \n    ``Ctrl-Space`` : CodeMirrorEditor -> unit\n}\n\n[< Inline \"$editor.setOption('extraKeys', { 'F2': function(cm) { var pos = cm.getCursor(); $f(pos) } })\" >]\nlet addMiddleClick (f: CodeMirrorPos -> unit) (editor:CodeMirrorEditor) = ()\n\nlet showToolTip (ed:CodeMirrorEditor) =\n    printfn \"showToolTip\"\n    async {\n        let  pos = ed.GetCursor()\n        let! tip = autoCompleteClient.ToolTip(file, pos.line + 1, pos.ch + 1)\n        do   JS.Alert tip\n    } |> Async.Start\n\nlet getHints (ed:Template.CodeMirrorEditor, cb, _) =\n    async {\n        let  pos    = ed.GetCursor()\n        let  l      = ed.GetLine pos.line\n        let  word   = match l.Substring(0, pos.ch) with\n                      | REGEX @\"([a-zA-Z_]\\w*)$\" \"g\" [| txt |] -> txt\n                      | _                                      -> \"\"          \n        let! res    = autoCompleteClient.Parse   (file, ed.GetValue()           )\n        let! com    = autoCompleteClient.Complete(file, pos.line + 1, pos.ch + 1)\n        cb { list   = com |> Array.map (fun (dis, rep, cls, chr) -> \n                            { text        = rep\n                              displayText = chr + \"| \" + dis\n                              className   = cls                              \n                            })\n             from   = { pos with ch = pos.ch - word.Length }\n             ``to`` = pos \n           }\n    } |> Async.Start\n\nlet rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\"\"\"\nlet rex2 = \"\"\"(Err|Warning)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) ?)?F?#? ?(.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\nlet rex = rex1 + \"|\" + rex2\n\nlet getAnnotations (txt, cb, _, ed:Template.CodeMirrorEditor) =\n    async {\n        let! res    = autoCompleteClient.Parse   (file, ed.GetValue()           )\n        match res with\n        | REGEX rex \"g\" m -> m\n        | _               -> [||]\n        |> Array.choose (fun v ->\n            match v with\n            | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, int fl, int fc - int indent    , int tl, int tc - int indent, sev, from , msg)\n            | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, int fl, int fc - int indent - 1, int fl, int fc - int indent, sev, \"fsi\", msg)\n            | _ -> None\n        )\n        |> Array.map (fun (file, fl, fc, tl, tc, sev, from, msg) ->\n            { message  = msg\n              severity = (if sev.ToUpper().StartsWith(\"ERR\") then \"error\" else \"warning\")\n              from     = cmPos(fl - 1, fc - 1) \n              ``to``   = cmPos(tl - 1, tc - 1)\n            }\n          )\n        |> cb\n    } |> Async.Start\n\nlet code = \n    Template.CodeMirror.New(\"let a = \\\"123\\\" |> Str\")\n       .OnRender(fun ed -> \n          ed.SetOption(\"gutter\", [| \"CodeMirror-lint-markers\" |])\n          ed.AddKeyMap({ F2             = showToolTip \n                         ``Ctrl-Space`` = showHints   ed getHints false\n                       })\n          setLint ed getAnnotations\n       )\n\ndiv [ \n      code.Render.AddChildren [ SomeAttr <| on.dblClick (fun _ _ -> JS.Alert \"HIHI\")  ]\n      Template.Button.New(\"Mark\").OnClick(fun _ _ -> \n          printfn \"Mark\"\n          code.editorO \n          |> Option.iter (fun ed -> \n              printfn \"inside\"\n              ed.MarkText (0,5) (0,12) \"Error\"   \"this is wrong!\"\n              ed.MarkText (0,0) (0, 3) \"Warning\" \"this is not so bad.Fix it now.\"\n            )\n      ).Render\n      Template.Button.New(\"Unmark\").OnClick(fun _ _ -> \n          printfn \"Unmark\"\n          code.editorO \n          |> Option.iter (fun ed -> \n              printfn \"inside\"\n              ed.RemoveMarks()\n            )\n      ).Render\n      Template.Button.New(\"Parse\").OnClick(fun _ _ -> \n          code.editorO \n          |> Option.iter (fun ed -> autoCompleteClient.Parse(file, ed.GetValue()) |> Async.map ignore |> Async.Start)\n      ).Render\n      css  \".Error   { text-decoration: underline; text-decoration-color: orange; text-decoration-style: wavy } \n            .Warning { text-decoration: underline; text-decoration-color: yellow                              } \"\n      h1 [ htmlText code.Var ]      \n      htmlElement \"menu\" \n          [ ``type`` \"context\"\n            Id       \"right-menu\"\n            htmlElement \"menuitem\" [ htmlAttribute \"label\" \"Goto Definition\" ; SomeAttr <| on.click (fun _ _ -> JS.Alert \"Goto Definition\")  ] \n          ]\n      htmlAttribute \"contextmenu\" \"right-menu\"\n]\n|> RunCode.RunNode().RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"08e9600a-804b-4aba-a262-85f22e0cc8de"},{"$":0,"Item":"18d8153d-422c-42f6-8266-9a9d854bd6a1"},{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},{"$":0,"Item":"a05dd36e-a15e-4394-8013-128e21e69574"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"id":{"$":0,"Item":"f2cc3e92-5e61-47b2-982b-40f5c5784e6a"},"expanded":true,"level":0,"properties":{}},{"name":"Demo SplitterBar","content":"let styleT   p =\n  sprintf \"\"\"\n.SplitterArea {\n    display: grid;\n    grid-template-columns: %f%% %f%%;\n    grid-template-areas:   \"left right\";\n    background-color: #41414d;\n    color: #444;\n    height: 50px;\n    width: 1000px;\n    grid-gap: 9px;\n    padding : 9px;\n}\n\n.SplitterArea > :nth-child(1){  grid-area: left  ; overflow: hidden; background-color: lightgreen; }\n.SplitterArea > :nth-child(2){  grid-area: right ; overflow: hidden; background-color: lightblue ; }\n\n.Splitter { \n    grid-column     :    2      ;\n    grid-row        :  1/2      ;\n    width           :    5px    ; \n    margin-left     :   -7px    ; \n    border          :    0px    ; \n    padding         :    0px    ;\n    cursor          : col-resize;\n  \tbackground-color: #eef      ; \n}   \"\"\"  (p * 0.99) (0.99 * (100.0 - p))\n\nlet min        = Template.Input.New(\"25.0\").Prefix(htmlText \"Min:  \")\nlet max        = Template.Input.New(\"75.0\").Prefix(htmlText \"Max:  \")\nlet value      = Template.Input.New(\"40.0\").Prefix(htmlText \"Value:\")\nlet splitter   = Template.SplitterBar.New(value.Var.Lens (fun s -> float s) (fun prev f -> sprintf \"%f\" <| (f * 10. |> Math.Round |> float ) / 10. ) )\n                     .Min(Val.map float min.Var)\n                     .Max(Val.map float max.Var)\n                     \n\nlet bar =\n    div [\n      ``class`` \"SplitterArea\"\n      div    [ htmlText <| Val.map (             sprintf \"LEFT  %f\")  splitter.GetValue ]\n      div    [ htmlText <| Val.map (((-)100.) >>(sprintf \"RIGHT %f\")) splitter.GetValue ]\n      styleH [ htmlText <| Val.map styleT                             splitter.GetValue ]\n      splitter.Render\n    ]\n    \ndiv [\n  bar\n  min  .Render\n  max  .Render\n  value.Render\n]\n|> RunCode.RunNode().AddBootstrap.RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"id":{"$":0,"Item":"0aa90429-4e7c-42eb-b108-3dd70e710bf1"},"expanded":true,"level":0,"properties":{}},{"name":"Demo Grid","content":"open Template\n        \nlet sc1 = SplitterBar.New(30.0)\nlet sr1 = SplitterBar.New(30.0).Horizontal()\n\nlet inline content1 v     (g: Grid) = g.Content(v   )\nlet inline content2 (a,b) (g: Grid) = g.Content(a, b)\nlet inline render         (g: Grid)         = g.Render\n\nlet inline fixedHorSplitter1 px ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", ch1)\n                       .Content(\"two\", ch2).Padding(0.0)\n    grid.RowFixedPx(px).RowAuto(50.0).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\nlet inline fixedHorSplitter2 px ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", ch1)\n                       .Content(\"two\", ch2).Padding(0.0)\n    grid.RowAuto(50.0).RowFixedPx(px).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\nlet div22 =\n        fixedHorSplitter2 80.0    \n            <| (fixedHorSplitter1 34.0 \n                <| div [ htmlText \"Fixed34px\" ; style \"background-color: lightblue\"  ]\n                <| div [ htmlText \"Variable \" ; style \"background-color: lightgreen\" ])\n            <| div [ htmlText \"Fixed80px\" ; style \"background-color: magenta\"    ]\n\nlet grid =\n  Grid.New\n    .ColFixed(8.0).ColVariable(sc1).ColAuto(16.0).ColVariable(50.0).Before.Max(Val.map ((-) 84.0) sc1.GetValue)\n    .RowFixed(8.0).RowVariable(sr1).RowAuto(16.0).RowVariable(50.0).Before.Max(Val.map ((-) 84.0) sr1.GetValue)\n    .Content(         div [ htmlText \"Div11\" ; style \"background-color: lightblue\"  ])\n    .Content(\"1 / 2\", div [ htmlText \"Div12\" ; style \"background-color: lightgreen\" ])\n    .Content(\"1 / 3\", div [ htmlText \"Div13\" ; style \"background-color: pink\"       ])\n    .Content(\"1 / 4\", div [ htmlText \"Div14\" ; style \"background-color: magenta\"    ])\n    .Content(\"2 / 1\", div [ htmlText \"Div21\" ; style \"background-color: lightblue\"  ])\n    .Content(\"2 / 2\", div22                                                          )\n    .Content(\"3 / 3\", div [ htmlText \"Div33\" ; style \"background-color: pink\"       ])\n    .Content(\"4 / 4\", div [ htmlText \"Div44\" ; style \"background-color: magenta\"    ])\n\ngrid.Render\n|> fun el -> el.AddChildren [ style \"height: 600px\" ]\n|> RunCode.RunNode().ShowHtmlResult\n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"},{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"id":{"$":0,"Item":"9682eb8f-e1de-4d7c-adca-a5e2322558c2"},"expanded":true,"level":0,"properties":{}},{"name":"F# Station Layout","content":"printfn \"F# Station Layout\"\nopen Template\n\nlet actLoadFile       = Template.Action.New(\"Load...\"                    ).OnClick(Do id ()        )  \nlet actSaveFile       = Template.Action.New(\"Save as...\"                 ).OnClick(Do id ()        )//.Highlight(dirty)\nlet actAddSnippet     = Template.Action.New(\"Add Snippet\"                ).OnClick(Do id ()        )\nlet actDeleteSnippet  = Template.Action.New(\"Delete Snippet\"             ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actIndentSnippet  = Template.Action.New(\"Indent In  >>\"              ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actOutdentSnippet = Template.Action.New(\"Indent Out <<\"              ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actGetFsCode      = Template.Action.New(\"Get F# Code\"                ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actEvalCode       = Template.Action.New(\"Evaluate F#\"                ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actRunWSNewTab    = Template.Action.New(\"Run WebSharper in new tab\"  ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actRunWSHere      = Template.Action.New(\"Run WebSharper in WS Result\").OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actRunWSIn        = Template.Action.New(\"Run WebSharper in ...\"      ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actParseCode      = Template.Action.New(\"Parse F#\"                   ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actCompileWS      = Template.Action.New(\"Compile WebSharper\"         ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actFindDefinition = Template.Action.New(\"Find Definition\"            ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\n\nlet buttonsH =\n    div [ \n          actAddSnippet    .Button.Render\n          actOutdentSnippet.Button.Render\n          actIndentSnippet .Button.Render\n          span []       \n          span []       \n          actParseCode     .Button.Render\n          actEvalCode      .Button.Render\n          actGetFsCode     .Button.Render\n       \n          actDeleteSnippet .Button.Render\n          actFindDefinition.Button.Render\n          span []       \n          actSaveFile      .Button.Render\n          span []\n          actCompileWS     .Button.Render\n          actRunWSIn       .Button.Render\n          span []       \n          style \"\"\"\n              overflow: hidden;\n              display: grid;\n              grid-template-columns: repeat(8, 12.1%);\n              bxackground-color: #eee;\n              padding : 5px;\n              grid-gap: 5px;\n          \"\"\"\n        ]\n        \nlet output = Var.Create \"HEre\"        \n\nlet mutable x: obj =  0 :> obj\n\nlet codeMirror = \n    Template.CodeMirror.New(\"let a = \\\"123\\\" |> Str\").Style(\"height: 100%\").Render\n        .AddChildren [\n            SomeAttr <| on.afterRender(fun el   -> \n                JS.SetTimeout\n                    (fun () ->\n                        addResizeObserver(fun () ->\n                            let r = el.GetBoundingClientRect()\n                            output.Value <- sprintf \"%A\" (r.Width, r.Height) ) el\n                        printfn \"F# Station Layout\"\n                    )\n                    2000 |> ignore\n            )\n        ]\n\n\nlet Messages =\n    [\n     \"Output\"    , Template.TextArea.New( output     ).Placeholder(\"Output:\"    ).Title(\"Output\"                   ).RenderWith [ on.dblClick (fun _ _ -> JS.Alert \"DblClick\") ]\n     \"Errors\"    , Template.TextArea.New(\"parserMsgs\").Placeholder(\"Errors:\"    ).Title(\"Messages\"                 ).RenderWith [ on.dblClick (fun _ _ -> JS.Alert \"DblClick\") ]\n     \"JavaScript\", Template.TextArea.New(\"codeJS    \").Placeholder(\"Javascript:\").Title(\"JavaScript code generated\").Render\n     \"F# code\"   , Template.TextArea.New(\"codeFS    \").Placeholder(\"F# code:\"   ).Title(\"F# code assembled\"        ).Render\n     \"WS Result\" , div [ div [ Id \"TestNode\" ; style \"background: white; height: 100%; width: 100%; \"] ]\n    ]\n\nlet inline fixedHorSplitter first px ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", renderSplitterNode ch1)\n                       .Content(\"two\", renderSplitterNode ch2)\n                       .Padding(0.0)\n    (if   first \n     then grid.RowFixedPx(px).RowAuto( 50.0)\n     else grid.RowAuto( 50.0).RowFixedPx(px)\n    ).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\nlet title         = SHtmlNode <| div [ htmlText \"Title\"    ; style \"background-color: lightblue\"  ]\nlet snippets      = SHtmlNode <| div [ htmlText \"Snippets\" ; style \"background-color: lightgreen\" ]\nlet buttons       = SHtmlNode <| buttonsH\nlet menu          = SHtmlNode <| div [ htmlText \"Menu\"     ; style \"background-color: pink\"       ]\nlet code          = SHtmlNode <| codeMirror\nlet messages      = STabStrip <| TabStrip.New(Messages).Top\n\nlet title_code    = SplitterStructure.New(       title        , code         , fixedHorSplitter true  34.0)\nlet code_buttons  = SplitterStructure.New(       title_code   , buttons      , fixedHorSplitter false 80.0)\nlet snippets_code = SplitterStructure.New(true , snippets     , code_buttons ,                        15.0)\nlet main_messages = SplitterStructure.New(false, snippets_code, messages     ,                        82.0)\nlet main_window   = SplitterStructure.New(       menu         , main_messages, fixedHorSplitter true  50.0)\n\n//let code_messages = SplitterStructure.New(false, title_Code           , STabStrip messages,                   75.0)\n//let main_Buttons  = SplitterStructure.New(       snippets_code        , SHtmlNode buttons                 , fixedHorSplitter2 80.0)\n\nlet rootSplitter = SplitterNode.New(main_window)\n\nlet styleEditor    =\n     \"\"\"\ndiv textarea {\nfont-family: monospace;\n}\n.code-editor-list-tile {\nwhite-space: nowrap; \nborder-style: solid none none;\nborder-color: white;\nborder-width: 1px;\nbackground-color: #D8D8D8;\ndisplay: flex;\n}\n.code-editor-list-text{\npadding: 1px 10px 1px 5px;\noverflow:hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;\nflex: 1;\n}\n\n.code-editor-list-tile.direct-predecessor {\nfont-weight: bold;\n}\n.code-editor-list-tile.indirect-predecessor {\ncolor: blue;\n}\n.code-editor-list-tile.selected {\nbackground-color: #77F;\ncolor: white;\n}\n.code-editor-list-tile.hovering {\nbackground: lightgray;\n}\n.code-editor-list-tile.hovering.selected {\nbackground:  blue;\n}\n.code-editor-list-tile>.predecessor {\nfont-weight: bold;\nborder-style: inset;\nborder-width: 1px;\ntext-align: center;\ncolor: transparent;\n}\n.code-editor-list-tile.direct-predecessor>.predecessor {\ncolor: blue;\n}\n\n.CodeMirror { height: 100%; }\n\n.node {\n    background-color:white; \n    width: 2ch; \n    color: #A03; \n    font-weight:bold; \n    text-align: center;\n    font-family: arial;\n}\n.Warning { text-decoration: underline lightblue } \n.Error   { text-decoration: underline red       } \n.body    { margin         : 0px                 }\n    \"\"\"\n\ndiv [\n    style \"height: 100vh; width: 100% \"\n    rootSplitter.Render.Style(\"height: 100%; width: 100% \")\n    script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                                     ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ]\n    link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    link   [ href \"/EPFileX/css/main.css\"                                               ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    css styleEditor                                                                                                               \n    style  \"\"\" \n          color      : #333;\n          font-size  : small;\n          font-family: monospace;\n          line-height: 1.2;\n              \"\"\"\n] \n|> renderDoc\n|> RunCode.RunNode().RunDoc\n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},{"$":0,"Item":"a48d72fc-5220-4dac-b3b3-98bad48b0561"}],"id":{"$":0,"Item":"a6148457-ad15-4de6-a038-af77ff4af675"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"let snippetName0 (content: string) =\n    content.Split([| '\\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n    |> Seq.map    (fun l -> l.Trim())\n    |> Seq.filter (fun l -> not (l.StartsWith(\"#\") || l.StartsWith(\"[<\")))\n    |> Seq.tryHead\n    |> Option.defaultValue \"<empty>\"\n\n[\n  \"\"\"#if INTERACTIVE\n  #I @\"../WebServer/bin\"\n  #else\n  namespace TestFS\n  #endif\n  #nowarn \"1182\"\n  \"\"\"    \n  |> snippetName0    \n  \"[< hjhj >]\n    let name = \n  \" \n  |> snippetName0\n]\n|> Seq.map (htmlText >> List.singleton >> li)\n|> ul\n|> RunCode.RunNode().ShowHtmlResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[],"id":{"$":0,"Item":"a54701f2-1d68-4997-a1ea-62deaeb73e1b"},"expanded":true,"level":0,"properties":{}},{"name":"Test mouse","content":"//Template.Button.New(\"Run JS\").Style(\"vertical-align:top\").OnClick(fun _ _ -> JS.Eval(\"alert('hello')\") |> ignore).Render\n//|> getStyle\n//|> sprintf \"%A\"\n//|> RunCode.RunNode().ShowResult\nlet panel1 res =\n    Template.Panel.New\n      .Title(Val.map (fun pressed -> if pressed then \"PRESSED\" else \"---\") Input.Mouse.MousePressed)\n      .Header([])\n      .Content([ h3 [ htmlText <| sprintf \"%A\" res ; style \"font-family:monospace;\"] ])\n      .Render\n\n\ndiv [ ``class`` \"container\"\n      panel1 <| 7 * 7\n      div [ ``class`` \"container\"\n            div [ ``class`` \"container\"\n                  panel1 <| 7 * 8\n\n                ]\n          ]\n    ]\n|> RunCode.RunNode().AddBootstrap.RunHtml\n     ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}],"id":{"$":0,"Item":"4dc58ba1-75d1-4c96-9641-235ee7d8c2c2"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"[1..10] |> Seq.take 5 |> Seq.toArray\n|> RunCode.RunNode().ShowResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[],"id":{"$":0,"Item":"74b8570e-dcd4-4dff-87a5-cd7ec96b8527"},"expanded":true,"level":0,"properties":{}},{"name":"InputSelect","content":"module InputSelect = \n    type Position =\n        | Below\n        | Right\n        | Tab\n        | NewBrowser\n        \n    let positionTxt v =\n        match v with\n        | Below      -> \"Below\"\n        | Right      -> \"Right\"\n        | Tab        -> \"In Tab\"\n        | NewBrowser -> \"New Browser\" \n    \n    let position = Var.Create Below \n    \n    let inp = Template.Input.New(position.Lens positionTxt (fun prev s -> \n        match s with\n        | \"Below\"        -> Below     \n        | \"Right\"        -> Right     \n        | \"In Tab\"       -> Tab       \n        | \"New Browser\"  -> NewBrowser\n        | _              -> prev\n        ) )\n    \n    div [\n      inp.Render\n      Doc.Select [] positionTxt [ Below ; Right ; Tab ; NewBrowser ] position |> someElt\n    ]\n    |> RunCode.RunNode().RunHtml\n        ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"38b21610-7350-4676-993b-88fea844314f"},"expanded":true,"level":0,"properties":{}},{"name":"Regex Pattern matching","content":"module regex1 =\n    // from: https://github.com/intellifactory/websharper/blob/master/docs/ECMA-262.md\n    let str    = new String(\"Bob likes pineapples.\")\n    let regex  = new RegExp(@\"^\\w+\") // matches the first word\n    let newstr = str.Replace(regex,\"Alice\")\n    \n    let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n        if value = null then None else\n        try \n            match String(value).Match(RegExp(expr, opt)) with\n            | null         -> None\n            | [| |]        -> None\n            | m            -> Some m\n        with e -> None\n        \n    let duple a b = a, b\n    4 * 8\n    let txt = \"\"\"Compiling to JavaScript...\n    2 errors, 0 warnings\n    ErrFSharp\n      \"F# Regex Pattern matching (47,39) - (47,40) parse 10: Unexpected symbol '<' in expression\"\n    ErrFSharp\n      \"F# Regex Pattern matching (47,49) - (47,50) parse 514: End of file in string begun at or before here\" \n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"  \n    Evaluating F# code...\n    (6) F# 7k.fsx(1,7): error FS1156: This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).  \n    Compiling to JavaScript...\n    6 errors, 1 warnings\n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (120, 19) - (120, 46) Type not found in JavaScript compilation: System.Text.RegularExpressions.Regex\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 14) - (121, 23) Type not found in JavaScript compilation: System.Text.RegularExpressions.Group\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 67) - (121, 74) Type not found in JavaScript compilation: System.Text.RegularExpressions.Capture\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.Match\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Method name not found in JavaScript compilation: (EnumerateFromFunctions<_,_> : (unit -> 'T0) * ('T0 -> System.Boolean) * ('T0 -> 'T1) -> System.Collections.Generic.IEnumerable`1<'T1>), Members: safeDispose, EnumerateThenFinally, EnumerateUsing, EnumerateWhile, CreateEvent\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.GroupCollection\"\n    \"\"\"\n    let rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\\.\"\"\"\n    let rex2 = \"\"\"(Err|Warning|Info)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) ?)?F?#? ?(.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\n    //\"\n    let rex = rex1 + \"|\" + rex2\n    \n    //[ \"JavaScript RegExp:\"\n    //  sprintf \"String(%A).Match  %A: %A\" txt rex <| String(txt).Match rex\n    //  sprintf \"Active pattern: %A\" <|\n    //      match txt with\n    //      | REGEX rex m -> m\n    //      | _           -> \"<no match>\"\n    //]\n    //|> List.map  (fun t -> div [ htmlText t ] )\n    //|> fun lst -> List.Cons (style \"text-align: left\", lst)  // two different styles\n    //|> List.map  (htmlText >> List.singleton >> div )\n    //|> (duple (style \"text-align: left\") >> List.Cons) \n    //|> RunCode.RunNode().ShowHtmlResult\n    \n    let inp = Template.TextArea.New(txt)                            .Placeholder(\"Text\")\n    let rx  = Template.Input   .New(rex).Prefix(htmlText \"RegEx  :\").Placeholder(\"Regex: . \\d \\w \\s \\n \\r \\t \\f (|)[a-z]+*?{3,5}\")  \n    let opt = Template.Input   .New(\"g\").Prefix(htmlText \"Options:\").Placeholder(\"Options: g i m u y\") \n    \n    h5 [\n      inp.Render\n      rx .Render\n      opt.Render\n      Val.map3 (fun inp rx opt ->\n              ul [\n                  match inp with\n                  | REGEX rx opt m -> yield! m |> Array.map (htmlText >> List.singleton >> li)\n                  | _              -> yield  htmlText \"<no match>\" \n              ]\n          ) inp.Var rx.Var opt.Var\n          |> bindHElem id\n    ]\n    |> RunCode.RunNode().ShowHtmlResult\n    \n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n    //open System.Text.RegularExpressions\n    //\n    //let (|Regex|_|) pattern input =\n    //    let m = Regex.Match(input, pattern)\n    //    if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])\n    //    else None\n    //\n    ////Example:\n    //let phone = \"(555) 555-5555\"\n    //match phone with\n    //| Regex @\"\\(([0-9]{3})\\)[-. ]?([0-9]{3})[-. ]?([0-9]{4})\" [ area; prefix; suffix ] ->\n    //    printfn \"Area: %s, Prefix: %s, Suffix: %s\" area prefix suffix\n    //| _ -> printfn \"Not a phone number\"","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"7754c074-862e-4550-9d61-ea837adf6d85"},"expanded":true,"level":0,"properties":{}},{"name":"Regex Pattern matching2","content":"module regex2 =\n    let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n        if value = null then None else\n        try \n            match String(value).Match(RegExp(expr, opt)) with\n            | null         -> None\n            | [| |]        -> None\n            | m            -> Some m\n        with e -> None \n       \n    let txt = \"\"\"Compiling to JavaScript...\n    Compiling to JavaScript...\n    Compiled!\n    0 errors, 1 warnings\n    WarningFSharp\n      \"(6)47f7c0ba-35b0-466e-a759-4e4d9963e524 codeMirror (1,11) - (1,19) typecheck 1178: The struct, record or union type 'KeyMapF2' is not structurally comparable because the type 'obj' does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type 'KeyMapF2' to clarify that the type is not comparable\"\n      2 errors, 0 warnings\n    ErrFSharp\n      \"F# Regex Pattern matching (47,39) - (47,40) parse 10: Unexpected symbol '<' in expression\"\n    ErrFSharp\n      \"F# Regex Pattern matching (47,49) - (47,50) parse 514: End of file in string begun at or before here\" \n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"  \n    Evaluating F# code...\n    (6) F# 7k.fsx(1,7): error FS1156: This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).  \n    Compiling to JavaScript...\n    6 errors, 1 warnings\n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (120, 19) - (120, 46) Type not found in JavaScript compilation: System.Text.RegularExpressions.Regex\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 14) - (121, 23) Type not found in JavaScript compilation: System.Text.RegularExpressions.Group\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 67) - (121, 74) Type not found in JavaScript compilation: System.Text.RegularExpressions.Capture\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.Match\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Method name not found in JavaScript compilation: (EnumerateFromFunctions<_,_> : (unit -> 'T0) * ('T0 -> System.Boolean) * ('T0 -> 'T1) -> System.Collections.Generic.IEnumerable`1<'T1>), Members: safeDispose, EnumerateThenFinally, EnumerateUsing, EnumerateWhile, CreateEvent\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.GroupCollection\"\n    \"\"\"\n    let rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\\.\"\"\"\n    let rex2 = \"\"\"(Err|Warning)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) )?F# (.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\n    let rex = rex1 + \"|\" + rex2\n    \n    match txt with\n    | REGEX rex \"g\" m -> m\n    | _               -> [||]\n    |> Array.choose (fun v ->\n        match v with\n        | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, int fl, int fc - int indent, int tl, int tc - int indent, sev, from , msg)\n        | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, int fl, int fc - int indent, int fl, int fc - int indent, sev, \"fsi\", msg)\n        | _ -> None\n    )\n    |> Array.map (fun (file, fl, fc, tl, tc, sev, from, msg) -> sprintf \"%s (%d,%d)-(%d,%d) %s %s : %s\" file fl fc tl tc sev from msg)\n    |> Array.map (htmlText >> List.singleton >> List.append [ style \"text-align: left\" ] >> li)\n    |> h5\n    |> RunCode.RunNode().ShowHtmlResult\n    ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"ff6bfed0-83ae-4497-b197-fea6432aa958"},"expanded":true,"level":0,"properties":{}},{"name":"Load File","content":"let fileName = Var.Create \"\"\nlet justFileName (f:string) = f.Split [| '/' ; '\\\\' |] |> Seq.last\n\nTemplate.Input \n    .New(fileName.Lens justFileName (fun prev n -> prev) )\n    .Prefix(\n        label [ \n            ``class`` \"btn btn-primary\" \n            htmlText \"Browse...\" \n            Template.Input.New(fileName).Type(\"file\").Style(\"display: none\")\n              .Content([ on.change (fun el _ -> JS.Alert \"loading \" ) ]) \n              .Render \n        ])\n    .Render\n|> RunCode.RunNode().ShowHtmlResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"ee8fe0d0-14ad-4ae8-bd77-e0918817d67e"},"expanded":true,"level":0,"properties":{}},{"name":"Storage","content":"module Storage =\n    let min        = Template.Input.New(\"25.0\").Prefix(htmlText \"Min:  \")\n    let max        = Template.Input.New(\"75.0\").Prefix(htmlText \"Max:  \")\n    let value      = Template.Input.New(\"40.0\").Prefix(htmlText \"Value:\")\n    \n    let settingsStorage = JS.Window.LocalStorage\n    \n    settingsStorage.GetItem \"CodeEditor.min\"   |> fun v -> if v <> null then min  .Var.Value <- v\n    settingsStorage.GetItem \"CodeEditor.max\"   |> fun v -> if v <> null then max  .Var.Value <- v\n    settingsStorage.GetItem \"CodeEditor.value\" |> fun v -> if v <> null then value.Var.Value <- v\n    \n    Val.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.min\"  , v)) min  .Var\n    Val.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.max\"  , v)) max  .Var\n    Val.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.value\", v)) value.Var\n    \n    let styleT   p =\n      p |> sprintf \"\"\"\n    .SplitterArea {\n        display: grid;\n        grid-template-columns: %f%% auto;\n        grid-template-areas:   \"left right\";\n        background-color: #41414d;\n        color: #444;\n        height: 50px;\n        grid-gap: 9px;\n        padding : 9px;\n    }\n    \n    .SplitterArea > :nth-child(1){  grid-area: left  ; overflow: hidden; background-color: lightgreen; }\n    .SplitterArea > :nth-child(2){  grid-area: right ; overflow: hidden; background-color: lightblue ; }\n    \n    .Splitter { \n        grid-column     :    2      ;\n        grid-row        :  1/2      ;\n        width           :    5px    ; \n        margin-left     : -7.5px    ; \n        border          :    0px    ; \n        padding         :    0px    ;\n        cursor          : col-resize;\n      \tbackground-color: #eef      ; \n    }   \"\"\"\n    \n    let splitter   = Template.SplitterBar\n                         .New(value.Var.Lens (fun s -> float s) (fun prev f -> sprintf \"%f\" <| (f * 10. |> Math.Round |> float ) / 10. ) )\n                         .Min(Val.map float min.Var)\n                         .Max(Val.map float max.Var)\n                         \n    \n    let bar =\n        div [\n          ``class`` \"SplitterArea\"\n          div    [ htmlText <| Val.map (             sprintf \"LEFT  %f\")  splitter.GetValue ]\n          div    [ htmlText <| Val.map (((-)100.) >>(sprintf \"RIGHT %f\")) splitter.GetValue ]\n          styleH [ htmlText <| Val.map styleT                             splitter.GetValue ]\n          splitter.Render\n        ]\n        \n    div [\n      bar\n      min  .Render\n      max  .Render\n      value.Render\n    ]\n    |> RunCode.RunNode().AddBootstrap.RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"3d8bf6d2-a66b-4f18-aa83-8e74836e38e4"},"expanded":true,"level":0,"properties":{}},{"name":"Messaging Test","content":"//#r @\"remote.dll\"\n\n//open CIPHERPrototype.Messaging\nopen FsStationShared\nopen System\nopen Useful\n\nlet messageTypes = \n    [\n        GetSnippetContentById CodeSnippetId.New\n        GetSnippetCodeById    CodeSnippetId.New\n        GetSnippetPredsById   CodeSnippetId.New\n        GetSnippetById        CodeSnippetId.New\n        GetSnippetContent     [||]\n        GetSnippetPreds       [||]\n        GetSnippetCode        [||]\n        GetSnippetJSCode      [||]\n        GetSnippet            [||]\n        GenericMessage        \"\"\n        GetIdentification     \n        GetWholeFile\n    ]\n    \nlet messageTxt v =\n    match v with\n    | GetSnippetContentById _ -> \"GetSnippetContentById\"\n    | GetSnippetCodeById    _ -> \"GetSnippetCodeById   \"\n    | GetSnippetPredsById   _ -> \"GetSnippetCodeById   \"\n    | GetSnippetById        _ -> \"GetSnippetById       \"\n    | GetSnippetContent     _ -> \"GetSnippetContent    \"\n    | GetSnippetPreds       _ -> \"GetSnippetPreds      \"\n    | GetSnippetCode        _ -> \"GetSnippetCode       \"\n    | GetSnippetJSCode      _ -> \"GetSnippetJSCode     \" \n    | GetSnippet            _ -> \"GetSnippet           \"\n    | GenericMessage        _ -> \"GenericMessage       \"\n    | RunSnippetUrlJS       _ -> \"RunSnippetUrlJS      \"\n    | RunSnippetUrlJSById   _ -> \"RunSnippetUrlJSById  \"\n    | GetIdentification       -> \"GetIdentification    \"\n    | GetWholeFile            -> \"GetWholeFile         \"\n\nlet fsClient = FsStationClient(\"MessagingTest\")\n\nlet snpId       = Var.Create \"\" \nlet message     = Var.Create \"\"\nlet messageType = Var.Create GetIdentification\n\nlet listener  : Var<string option> = Var.Create None\nlet listeners : Var<string[]     > = Var.Create [||]\n\nlet getListeners _ _ =\n    async {\n        let! ls          = fsClient.MessagingClient.POListeners()\n        do   if listeners.Value <> ls then listeners.Value <- ls\n    } |> Async.Start\n\nlet requestMessage msgT (content:string) : Async<string> =\n    let msg =\n        match msgT with\n        | GetSnippetContentById _ -> GetSnippetContentById  <| CodeSnippetId (Guid content)\n        | GetSnippetCodeById    _ -> GetSnippetCodeById     <| CodeSnippetId (Guid content)\n        | GetSnippetPredsById   _ -> GetSnippetPredsById    <| CodeSnippetId (Guid content)\n        | GetSnippetById        _ -> GetSnippetById         <| CodeSnippetId (Guid content)\n        | RunSnippetUrlJSById   _ -> RunSnippetUrlJSById    <|(CodeSnippetId (Guid content), \"http://localhost:9000\")\n        | RunSnippetUrlJS       _ -> RunSnippetUrlJS        <|(content.Split '/'           , \"http://localhost:9000\")\n        | GetSnippetContent     _ -> GetSnippetContent      <| content.Split '/'\n        | GetSnippetPreds       _ -> GetSnippetPreds        <| content.Split '/'\n        | GetSnippetCode        _ -> GetSnippetCode         <| content.Split '/'\n        | GetSnippetJSCode      _ -> GetSnippetJSCode       <| content.Split '/'\n        | GetSnippet            _ -> GetSnippet             <| content.Split '/'\n        | GenericMessage        _ -> GenericMessage         <| content\n        | GetIdentification       -> GetIdentification    \n        | GetWholeFile            -> GetWholeFile         \n    async {\n        let! response = fsClient.SendMessage(AddressId(listener.Value |> Option.defaultValue \"WebServer:PostOffice\"), msg) |> Wrap.getAsync\n        let resp =\n            match response with\n            | SnippetResponse(Some snp )    -> snp  |> Json.Serialize\n            | SnippetsResponse     snps     -> snps |> Json.Serialize\n            | StringResponse (Some code)    -> code\n            | IdResponse      id            -> id\n            | _                             -> sprintf \"<Incomplete response: %A>\" response\n        return resp\n    }\n\ndiv [\n    Doc.SelectDynOptional [ on.click getListeners ] \"--\" id    (View.Map Seq.toList listeners.View) listener    |> someElt\n    Doc.Select            [ ] messageTxt messageTypes                         messageType |> someElt\n    Template.Input   .New(snpId  ).Render\n    Template.TextArea.New(message).Render\n    Template.Button.New(\"Send Message to Server\").OnClick(fun _ _ ->\n        async {\n          message.Value <- \"Sending request...\"\n          let! code = requestMessage messageType.Value snpId.Value\n          message.Value <- code\n          return ()\n        }  |> Async.Start\n      ).Render\n]    \n|> RunCode.RunNode().ShowHtmlResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}],"id":{"$":0,"Item":"e9c3ceaf-8fe5-4752-aa4c-2db6e1ac4577"},"expanded":true,"level":0,"properties":{}},{"name":"Json.Parse","content":"module JsonParse =\n    open Useful\n    open FsStationShared\n    //let provider = WebSharper.Json.Provider\n    let inp = Template.TextArea.New(\"[ { \\\"name\\\": \\\"Hello\\\" }, { \\\"name\\\": \\\"How are you?\\\" } ]\").Placeholder(\"Text\")\n    \n    let inline ifUndef def v = if isUndefined v then def else v\n    let obj2CodeSnippetId o = \n        if isUndefined o then\n            System.Guid(\"00000000-0000-0000-0000-000000000000\")\n        else\n            o?Item\n        |> CodeSnippetId \n    \n    let obj2CodeSnippetIdO o = // the json representation of an option is different from the internal representation\n        if isUndefined o then\n            None\n        else\n            Some <| obj2CodeSnippetId o\n    \n    let obj2Map o =\n        if isUndefined o then\n            Map.empty\n        else\n            JS.GetFields o |> Array.map (fun (f, v) -> f, v :?> string ) |> Map.ofSeq\n    \n    let deserializeCodeSnipets v = \n        try\n            let objs= WebSharper.Json.Parse v |> unbox<obj[]>\n            printfn \"%A\" <| Array.length objs\n            let snps =\n                objs\n                |> Array.choose (fun o ->\n                     if isUndefined o then None else\n                     {\n                        name         = o?name         |> ifUndef \"\"\n                        content      = o?content      |> ifUndef \"\"\n                        parent       = o?parent       |> obj2CodeSnippetIdO\n                        predecessors = o?predecessors |> ifUndef [||] |> Array.map  obj2CodeSnippetId |> Seq.toList\n                        id           = o?id           |> obj2CodeSnippetId\n                        expanded     = o?expanded     |> ifUndef false\n                        level        = o?level        |> ifUndef 0\n                        properties   = o?properties   |> obj2Map\n                      } |> Some)\n            snps\n        with _ -> [||]\n    \n    \n    \n    h5 [\n      inp.Render\n      bindHElem (deserializeCodeSnipets >> Array.map (sprintf \"%A\" >> htmlText >> Seq.singleton >> li) >> ul) inp.Var\n    ]\n    |> RunCode.RunNode().ShowHtmlResult\n    ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}],"id":{"$":0,"Item":"b47dbe9c-8623-4b35-98ee-5073edfc21b3"},"expanded":true,"level":0,"properties":{}},{"name":"WebSharper Snippets2","content":"[< JavaScript >]\nmodule Snippets2 = ","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"},{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"}],"id":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"expanded":false,"level":0,"properties":{}},{"name":"Tab Panel","content":"printfn \"strip\"\nopen Template\n#nowarn \"1178\"\n\ntype SplitterNode = | SplitterNode of Var<SplitterStructure>\nand  SplitterStructure =\n    | HtmlNode of HtmlNode\n    | TabStrip of TabStrip\n    | Split    of bool * Var<float> * SplitterNode * SplitterNode\nwith    \n    static member New(vertical : bool, child1, child2) = Split(vertical, Var.Create 50.0, SplitterNode (Var.Create             child1), SplitterNode (Var.Create             child2))\n    static member New(vertical : bool, child1, child2) = Split(vertical, Var.Create 50.0, SplitterNode (Var.Create <| HtmlNode child1), SplitterNode (Var.Create <| HtmlNode child2))\n    static member New(vertical : bool, child1, child2) = Split(vertical, Var.Create 50.0, SplitterNode (Var.Create <| TabStrip child1), SplitterNode (Var.Create <| TabStrip child2))\n    static member New(strip                          ) = TabStrip strip\n    static member New(node                           ) = HtmlNode node\n\nlet rec renderSplitterNode      sn = match sn with SplitterNode chV -> bindHElem (fun ch -> renderSplitterStructure ch) chV \nand     renderSplitterStructure ss =\n        match ss with\n        | HtmlNode node                -> node\n        | TabStrip strip               -> strip.Render  \n        | Split   (ver, var, ch1, ch2) ->\n        let grid = Grid.New.Content(\"one\", renderSplitterNode ch1)\n                           .Content(\"two\", renderSplitterNode ch2).Padding(0.0)\n        if ver then grid.ColVariable(50.0).ColAuto(50.0).Content( style \"grid-template-areas: 'one   two' \" ).Render\n               else grid.RowVariable(50.0).RowAuto(50.0).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\ntype SplitterNode with\n    static member New        ss           = SplitterNode <| Var.Create ss\n    static member New       (ss:HtmlNode) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    static member New       (ss:TabStrip) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    member this.Render                    = renderSplitterNode this\n    member this.Var                       = match this with SplitterNode chV -> chV\n    member this.Value                     = this.Var.Value\n    member this.SplitMe(first, ver, node) =\n        this.Var.Value <- if first then SplitterStructure.New(ver, node      , this.Value) \n                                   else SplitterStructure.New(ver, this.Value, node      )\n    member this.SplitMe(first, ver, node:TabStrip) = this.SplitMe(first, ver, TabStrip  node      )\n    member this.SplitMe(first, ver, node:HtmlNode) = this.SplitMe(first, ver, HtmlNode  node      )\n    member this.SplitMe(first, ver               ) = this.SplitMe(first, ver, TabStrip.New([||])  )\n    member this.IsEmpty                            =\n        match this.Value with\n        | HtmlNode HtmlEmpty           -> true\n        | HtmlNode _                   -> false\n        | TabStrip strip               -> strip.tabs.Value.Length = 0\n        | Split   (ver, var, ch1, ch2) -> ch1.IsEmpty && ch2.IsEmpty\n    member this.UnSplitEmpties()                   =\n        if                                    this.IsEmpty then this.Var.Value <- SplitterStructure.New(TabStrip.New([||])) else\n        match this.Value with\n        | Split   (ver, var, ch1, ch2) -> if   ch1.IsEmpty then ch2.UnSplitEmpties() ; this.Var.Value <- ch2.Value \n                                          elif ch2.IsEmpty then ch1.UnSplitEmpties() ; this.Var.Value <- ch1.Value \n                                                           else ch1.UnSplitEmpties()\n                                                                ch2.UnSplitEmpties()\n        | _                            -> ()  \n\nlet tabs1 = \n      [|\n        \"Hello\"   \n        \"How\"   \n        \"Are\"   \n        \"You\"   \n        \"Today?\"\n      |]\n\nlet tabs2 = \n      [|\n        \"Very\"   \n        \"Well\"  \n        \"Thank\" \n        \"You\"   \n      |]\n\nlet direction    = Var.Create true\nlet createdNodes = System.Collections.Generic.Dictionary<System.Guid, Dom.Element>()\n\nlet getU tabs =\n    [| for tab in tabs do \n           yield tab\n               , Template.TextArea.New(tab:string).Render\n    |]\n    \nlet getU2 tabs = tabs |> getU |> Array.map (fun def -> System.Guid.NewGuid(), def)    \n\nlet tabs1V = TabStrip.New(getU tabs1).Top   \nlet tabs2V = TabStrip.New(getU tabs2).Bottom\n\nlet rootSplitter = SplitterNode.New(SplitterStructure.New(true, tabs1V, tabs2V))\n\ndo  TabMoved <- Some (fun _ -> rootSplitter.UnSplitEmpties())\n\ndiv [ style \"height: 500px\"\n      rootSplitter.Render.Style(\"height: 100%; width: 100% \")\n      //direction\n      //|> Val.map3 (fun t1 t2 dir-> t1,t2,dir) tabs1V.tabs tabs2V.tabs\n      //|> bindHElem (fun (t1,t2,dir) ->\n      //    match t1.Length, t2.Length with\n      //    | _, 0 -> tabs1V.Render\n      //    | 0, _ -> tabs2V.Render\n      //    | _, _ -> Grid.New\n      //                   .Content(\"one\", tabs1V.Render.Style(\"height: 100%; width: 100% \")\n      //                   .Content(\"two\", tabs2V.Render.Style(\"height: 100%; width: 100% \") )\n      //              |> (fun grid -> if dir then grid.ColVariable(50.0).ColAuto(50.0).Content( style \"grid-template-areas: 'one   two' \" ).Render\n      //                                     else grid.RowVariable(50.0).RowAuto(50.0).Content( style \"grid-template-areas: 'one' 'two' \" ).Render)\n      //    |> (fun html -> html.Style(\"height: 100%; width: 100% \")\n      //)\n      Button.New(\"print\"  ).OnClick(fun _ _ -> printfn \"strip\"                                                                ).Render\n      Button.New(\"Split\"  ).OnClick(fun _ _ -> direction.Value <- not direction.Value\n                                               rootSplitter.SplitMe(false, direction.Value)                                   ).Render\n      Button.New(\"New\"    ).OnClick(fun _ _ -> tabs1V.tabs.Value <- Array.append tabs1V.tabs.Value <| getU2 [| \"New1\" |] \n                                               tabs2V.tabs.Value <- Array.append tabs2V.tabs.Value <| getU2 [| \"New2\" |]      ).Render\n      //Button.New(\"UnSplit\").OnClick(fun _ _ -> rootSplitter.UnSplitEmpties()                                                  ).Render\n]\n|> RunCode.RunNode().AddBootstrap.RunHtml\n\n//    css \"\n//:host {\n//  all: initial;\n//  display: block;\n//  contain: content; /* Boom. CSS containment FTW. */\n//}\"\n","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"cddabd38-7ecb-4692-99bd-13ca70e4232f"},{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"}],"id":{"$":0,"Item":"58e71035-74ac-4b97-8798-3a15d4944467"},"expanded":true,"level":0,"properties":{}},{"name":"Grid Bug","content":"\ntype Grid = {  before : bool }\nwith\n    static member New  = {           before = false }\n    member this.Before = { this with before = true  }\n\n\nGrid.New\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n|> printfn \"%A\"    ","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[],"id":{"$":0,"Item":"b3d2418a-1cb8-48bd-9f12-e90b61dcc572"},"expanded":true,"level":0,"properties":{}},{"name":"Demo Action","content":"printfn \"Menu00\"\nopen Template\n\nlet actionClick act () = Val.iter (fun txt -> JS.Alert <| txt + \" Clicked!\") act.text\n\nlet actLoadFile       = Action.New(\"Load...\"                    ).OnClick2(Do2 actionClick () ) \nlet actSaveFile       = Action.New(\"Save as...\"                 ).OnClick2(Do2 actionClick () ).Highlight(true)\nlet actAddSnippet     = Action.New(\"Add Snippet\"                ).OnClick2(Do2 actionClick () )\nlet actDeleteSnippet  = Action.New(\"Delete Snippet\"             ).OnClick2(Do2 actionClick () )\nlet actIndentSnippet  = Action.New(\"Indent Snippet\"             ).OnClick2(Do2 actionClick () )\nlet actOutdentSnippet = Action.New(\"Outdent Snippet\"            ).OnClick2(Do2 actionClick () )\nlet actGetFsCode      = Action.New(\"Get F# Code\"                ).OnClick2(Do2 actionClick () )\nlet actEvalCode       = Action.New(\"Evaluate F#\"                ).OnClick2(Do2 actionClick () )\nlet actRunWSNewTab    = Action.New(\"Run WebSharper in new tab\"  ).OnClick2(Do2 actionClick () )\nlet actRunWSHere      = Action.New(\"Run WebSharper in WS Result\").OnClick2(Do2 actionClick () )\nlet actParseCode      = Action.New(\"Parse F#\"                   ).OnClick2(Do2 actionClick () )\nlet actCompileWS      = Action.New(\"Compile WebSharper\"         ).OnClick2(Do2 actionClick () )\n\nlet menu1 =\n    Menu.New2\n      [\n        MenuEntry.New(\"File\")\n            .SubMenu(\n                    [\n                        actLoadFile      .MenuEntry\n                        actSaveFile      .MenuEntry\n                    ]\n            ) \n        MenuEntry.New(\"Code\")\n            .SubMenu(\n                    [\n                        actAddSnippet    .MenuEntry.MenuNode\n                        actDeleteSnippet .MenuEntry.MenuNode\n                        MenuHtml <| li [ ``class`` \"divider\" ] \n                        actIndentSnippet .MenuEntry.MenuNode\n                        actOutdentSnippet.MenuEntry.MenuNode\n                        MenuHtml <| li [ ``class`` \"divider\" ] \n                        actGetFsCode     .MenuEntry.MenuNode \n                    ]\n            ) \n        MenuEntry.New(\"Run\")\n            .SubMenu(\n                    [\n                        actEvalCode      .MenuEntry\n                        MenuEntry.New(\"\").Divider\n                        actRunWSNewTab   .MenuEntry\n                        actRunWSHere     .MenuEntry\n                        MenuEntry.New(\"\").Divider\n                        actParseCode     .MenuEntry\n                        actCompileWS     .MenuEntry\n                    ]\n            ) \n      ]\n\nlet buttons =\n        div [ \n              actAddSnippet    .Button.Render\n              actOutdentSnippet.Button.Render\n              actIndentSnippet .Button.Render\n              actLoadFile      .Button.Render\n              actParseCode     .Button.Render\n              actEvalCode      .Button.Render\n              actGetFsCode     .Button.Render\n       \n              actDeleteSnippet .Button.Render\n              span []       \n              span []       \n              actSaveFile      .Button.Render\n              span []\n              actRunWSNewTab   .Button.Render\n              actCompileWS     .Button.Render\n//              Doc.Select [ attr.id \"Position\" ] positionTxt [ Below ; Right ; NewBrowser ] position |> someElt\n              style \"\"\"\n                  overflow: hidden;\n                  display: grid;\n                  grid-template-columns: repeat(8, 12.1%);\n                  bxackground-color: #eee;\n                  padding : 5px;\n                  grid-gap: 5px;\n              \"\"\"\n            ]\n\n\nprintfn \"Menu1\"\n\ndiv [\n    navbar <| h1 [ htmlText \"F# Station\" ; style \"font-size: 48px; margin-top: -19px\" ]\n           <| menu1.Render \n           <| menu1.Render\n    buttons\n]       \n|> RunCode.RunNode().AddBootstrap.RunHtml","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"}],"id":{"$":0,"Item":"332b130a-111b-48ca-bd75-26f96dcbb779"},"expanded":true,"level":0,"properties":{}},{"name":"kimsereyblog single-page-app-with-websharper-uinext","content":"// https://kimsereyblog.blogspot.com/2015/08/single-page-app-with-websharper-uinext.html\n\n#r \"WebSharper.JQuery.dll\"\n\nopen System\nopen WebSharper\n\n[<JavaScript>]\nmodule Domain =\n    type Claim = {\n        id: string\n        name: string\n    }\n\n    type Claims = Claim list\n\n    type User = {\n        id: string\n        fullName: string\n        emailAddress: Option<string>\n        phoneNumber: Option<string>\n        enabled: bool\n        claims: Claims\n    }\n\n[<JavaScript>]\nmodule Async =\n    let map f xAsync = async { let! x = xAsync\n                               return f x      }\n    let retn x       = async { return   x      }\n\n[<JavaScript>]\nmodule AsyncApi =\n    type ApiResult<'a> =\n        | Success of 'a\n        | Failure of ApiResponseException list\n\n    and ApiResponseException =\n        | Unauthorized of string\n        | NotFound of string\n        | UnsupportedMediaType of string\n        | BadRequest of string\n        | JsonDeserializeError of string\n        override this.ToString() =\n            match this with\n            | ApiResponseException.Unauthorized         err -> err\n            | ApiResponseException.NotFound             err -> err\n            | ApiResponseException.UnsupportedMediaType err -> err\n            | ApiResponseException.BadRequest           err -> err\n            | ApiResponseException.JsonDeserializeError err -> err\n\n    let map f xAsyncApiResult =\n        async {\n            let! xApiResult = xAsyncApiResult\n            match xApiResult with\n            | Success x   -> return Success(f x)\n            | Failure err -> return Failure err\n        }\n\n    let retn x = async { return ApiResult.Success x }\n\n    let apply fAsyncApiResult xAsyncApiResult =\n        async {\n            let! fApiResult = fAsyncApiResult\n            let! xApiResult = xAsyncApiResult\n            match fApiResult, xApiResult with\n            | Success f   , Success x    -> return Success(f x)\n            | Success f   , Failure err  -> return Failure err\n            | Failure err , Success f    -> return Failure err\n            | Failure err1, Failure err2 -> return Failure(List.concat [ err1; err2 ])\n        }\n\n    let bind f xAsyncApiResult =\n        async {\n            let! xApiResult = xAsyncApiResult\n            match xApiResult with\n            | Success x -> return! f x\n            | Failure err -> return (Failure err)\n        }\n\n    let start xAsyncApiRes =\n        xAsyncApiRes\n        |> Async.map (fun x -> ())\n        |> Async.Start\n\n    type ApiCallBuilder() =\n\n        member this.Bind(x, f) =\n            async {\n                let! xApiResult = x\n                match xApiResult with\n                | Success x -> return! f x\n                | Failure err -> return (Failure err)\n            }\n        member this.Return x = async { return ApiResult.Success x }\n        member this.ReturnFrom x = x\n\n    let apiCall = new ApiCallBuilder()\n\n[<JavaScript>]\nmodule ApiClient =\n    open WebSharper.JavaScript\n    open WebSharper.JQuery\n    open AsyncApi\n    open Domain\n    open WebSharper.UI.Next\n\n    type AuthToken =\n        { Token : string\n          Expiry : DateTime }\n        member this.IsExpired() = DateTime.UtcNow - this.Expiry < TimeSpan.FromMinutes(10.0)\n\n        static member Make token =\n            { Token = token\n              Expiry = DateTime.UtcNow }\n\n        static member Default =\n            { Token = \"\"\n              Expiry = DateTime.UtcNow }\n\n    type ValidToken =\n        | ValidToken of string\n\n    type Credentials =\n        { Username : string\n          Password : string }\n        static member Default =\n            { Username = \"admin\"\n              Password = \"admin\" }\n\n    type RequestSettings =\n        { RequestType :  JQuery.RequestType\n          Url         :  string\n          ContentType :  string option\n          Headers     : (string * string) list option\n          Data        :  string option }\n        member this.toAjaxSettings ok ko =\n            let success  (result:obj)  (_ : string) (_ : JqXHR ) : unit = ok (result :?> string)\n            let errorf   (jqXHR:JqXHR) (_ : string) (_ : string) : unit = ko (System.Exception(string jqXHR.Status))\n            let settings =\n                JQuery.AjaxSettings\n                    (Url      = \"http://localhost/api/\" + this.Url\n                   , Type     = this.RequestType\n                   , DataType = JQuery.DataType.Text\n                   , Success  = Action<obj,string,JqXHR> success\n                   , Error    = Action<JqXHR,string,string> errorf)\n\n            this.Headers     |> Option.iter (fun h -> settings.Headers     <- Object<string>(h |> Array.ofList))\n            this.ContentType |> Option.iter (fun c -> settings.ContentType <- Union2Of2 c                      )\n            this.Data        |> Option.iter (fun d -> settings.Data        <- d                                )\n            settings\n\n    type Api =\n        { Login     : Credentials -> Async<ApiResult<unit>>\n          Logout    : unit        -> unit\n          GetUsers  : unit        -> Async<ApiResult<User list>>\n          GetClaims : unit        -> Async<ApiResult<Claims>> }\n\n    [<Literal>]\n    let tokenStorageKey = \"authtoken\"\n\n    let private ajaxCall (requestSettings : RequestSettings) =\n        Async.FromContinuations <| fun (ok, ko, _) ->\n            requestSettings.toAjaxSettings ok ko\n            |> JQuery.Ajax\n            |> ignore\n\n    let private matchErrorStatusCode url code =\n        match code with\n        | \"401\" ->\n            Failure\n                [ ApiResponseException.Unauthorized\n                  <| sprintf \"\"\"\"%s\" - 401 The Authorization header did not pass security\"\"\" url ]\n        | \"404\" -> Failure [ ApiResponseException.NotFound <| sprintf \"\"\"\"%s\" - 404 Endpoint not found\"\"\" url ]\n        | \"415\" ->\n            Failure\n                [ ApiResponseException.UnsupportedMediaType\n                  <| sprintf \"\"\"\"%s\" - 415 The request Content-Type is not supported/invalid\"\"\" url ]\n        | code -> Failure [ ApiResponseException.BadRequest <| sprintf \"\"\"\"%s\" - %s Bad request\"\"\" url code ]\n\n    let private tryDeserialize deserialization input =\n        try\n            deserialization input |> ApiResult.Success\n        with _ ->\n            Failure [ ApiResponseException.JsonDeserializeError <| sprintf \"\"\"\"{%s}\" cannot be deserialized\"\"\" input ]\n        |> Async.retn\n\n    let private getToken() =\n        try\n            JS.Window.LocalStorage.GetItem tokenStorageKey\n            |> Json.Deserialize<AuthToken>\n            |> ApiResult.Success\n        with ex -> ApiResult.Failure [ Unauthorized \"Unauthorized\" ]\n        |> Async.retn\n\n    let private refreshToken (authToken : AuthToken) =\n        async {\n            let url = \"auth/login/token/renew\"\n            if not (authToken.IsExpired()) then return ApiResult.Success authToken.Token\n            else\n                try\n                    let! token = ajaxCall {\n                                    RequestType = JQuery.RequestType.POST\n                                    Url = url\n                                    ContentType = None\n                                    Headers = Some [ \"Authorization\", \"Bearer \" + authToken.Token ]\n                                    Data = None }\n                    return ApiResult.Success token\n                with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (tryDeserialize Json.Deserialize<string>)\n        |> AsyncApi.map (ValidToken)\n\n    let private login credentials =\n        async {\n            let url = \"auth/login/token\"\n            try\n                let! token = ajaxCall {\n                                RequestType = JQuery.RequestType.POST\n                                Url = url\n                                ContentType = Some \"application/json\"\n                                Headers = None\n                                Data = Some(Json.Serialize<Credentials>(credentials)) }\n                return ApiResult.Success token\n            with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (Json.Deserialize<string>\n                          >> AuthToken.Make\n                          |> tryDeserialize)\n        |> AsyncApi.map (fun token -> JS.Window.LocalStorage.SetItem(tokenStorageKey, Json.Serialize<AuthToken>(token)))\n\n    let private logout() = JS.Window.LocalStorage.RemoveItem(tokenStorageKey)\n\n    let private getClaims (ValidToken token) =\n        async {\n            let url = \"auth/claims\"\n            try\n                let! claims = ajaxCall {\n                                RequestType = JQuery.RequestType.GET\n                                Url = url\n                                ContentType = None\n                                Headers = Some [ \"Authorization\", \"Bearer \" + token ]\n                                Data = None\n                            }\n                return ApiResult.Success(claims)\n            with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (tryDeserialize Json.Deserialize<Claims>)\n\n    let private getUsers (ValidToken token) =\n        async {\n            let url = \"users\"\n            try\n                let! users = ajaxCall {\n                                RequestType = JQuery.RequestType.GET\n                                Url = url\n                                ContentType = None\n                                Headers = Some [ \"Authorization\", \"Bearer \" + token ]\n                                Data = None\n                            }\n                return ApiResult.Success users\n            with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (tryDeserialize Json.Deserialize<User list>)\n\n    let api =\n        { Login    = login\n          Logout   = logout\n          GetUsers = fun () -> apiCall {\n                                    let! token      = getToken()\n                                    let! validToken = refreshToken token\n                                    return! getUsers  validToken\n                                }\n          GetClaims = fun () -> apiCall {\n                                    let! token      = getToken()\n                                    let! validToken = refreshToken token\n                                    return! getClaims validToken\n                                } }\n\n[<JavaScript>]\nmodule BootstrapUI =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n\n    module Button =\n        type private ButtonColor =\n            | Default\n            | Primary\n\n        type private ButtonStyle =\n            | FullWidth\n            | Inline\n\n        let private makeButton txt btnColor btnStyle action =\n            let classes =\n                [ yield \"btn\"\n                  yield match btnColor with\n                        | Default -> \"btn-default\"\n                        | Primary -> \"btn-primary\"\n                  yield match btnStyle with\n                        | FullWidth -> \"full\"\n                        | Inline -> \"inline\" ]\n                |> String.concat (\" \")\n            Doc.Button <| txt <| [ attr.``class`` classes\n                                   attr.``type`` \"submit\" ]\n            <| action\n\n        let bsBtnDefaultInline txt action =\n            makeButton txt ButtonColor.Default ButtonStyle.Inline action\n\n        let bsBtnDefaultFull txt action =\n            makeButton txt ButtonColor.Default ButtonStyle.FullWidth action\n\n        let bsBtnPrimaryInline txt action =\n            makeButton txt ButtonColor.Primary ButtonStyle.Inline action\n\n        let bsBtnPrimaryFull txt action =\n            makeButton txt ButtonColor.Primary ButtonStyle.FullWidth action\n\n    let bsNav brand leftLinks rightLinks =\n        let navHeader =\n            divAttr [ attr.``class`` \"navbar-header\" ]\n                    [ buttonAttr [ attr.``class`` \"navbar-toggle collapsed\"\n                                   Attr.Create \"data-toggle\" \"collapse\"\n                                   Attr.Create \"data-target\" \"#menu\"\n                                   Attr.Create \"aria-expanded\" \"false\" ]\n                                 [ spanAttr [ attr.``class`` \"sr-only\" ] []\n                                   spanAttr [ attr.``class`` \"icon-bar\" ] []\n                                   spanAttr [ attr.``class`` \"icon-bar\" ] []\n                                   spanAttr [ attr.``class`` \"icon-bar\" ] [] ]\n                      aAttr [ attr.``class`` \"navbar-brand title\"\n                              attr.href \"#\" ] [ text brand ] ]\n\n        let navMenu =\n            divAttr [ attr.``class`` \"collapse navbar-collapse\"\n                      attr.id \"menu\" ]\n                    [ ulAttr [ attr.``class`` \"nav navbar-nav\" ] [ leftLinks ]\n                      ulAttr [ attr.``class`` \"nav navbar-nav navbar-right\" ]\n                             [ rightLinks ] ]\n\n        navAttr [ attr.``class`` \"navbar navbar-default\" ]\n            [ divAttr [ attr.``class`` \"container-fluid\" ]\n                      [ navHeader; navMenu ] ] :> Doc\n\n    let bsInput placeHolder rvTxt =\n        Doc.Input [ attr.``class`` \"form-control\"\n                    attr.placeholder placeHolder ] rvTxt\n\n    let bsPasswordInput placeHolder rvPwd =\n        Doc.PasswordBox [ attr.``class`` \"form-control\"\n                          attr.placeholder placeHolder ] rvPwd\n\n    let bsPanelDefault body =\n        divAttr [ attr.``class`` \"panel panel-default\" ] [ divAttr [ attr.``class`` \"panel-body\" ] body ]\n\n    let bsPanelDefaultWithTitle title body =\n        divAttr [ attr.``class`` \"panel panel-default\" ]\n                [ divAttr [ attr.``class`` \"panel-heading\" ]\n                          [ h3Attr  [ attr.``class`` \"panel-title\" ]\n                                    [ text title ] ]\n                  divAttr [ attr.``class`` \"panel-body\" ] body ]\n\n    let bsAlertDanger message =\n        divAttr [ attr.``class`` \"alert alert-danger\"\n                  Attr.Create \"role\" \"alert\" ] [ text message ] :> Doc\n\n    let bsRow bsCol = divAttr [ attr.``class`` \"row\" ] bsCol\n\n    let bsCol3 body = divAttr [ attr.``class`` \"col-md-3\" ] body\n\n    let bsCol4 body = divAttr [ attr.``class`` \"col-md-4\" ] body\n\n    let bsContainer body = divAttr [ attr.``class`` \"container\" ] body\n\n    let bsJumbotron title body =\n        divAttr [ attr.``class`` \"jumbotron\" ]\n                [ divAttr [ attr.``class`` \"container\" ]\n                          [ h1 [ text title ] \n                            body ] ]\n\n[<JavaScript>]\nmodule ClientRoutes =\n    open WebSharper.UI.Next\n\n    type Page =\n        | Home\n        | Claims\n        | Users\n        | Login\n        override this.ToString() =\n            match this with\n            | Home -> \"Home\"\n            | Claims -> \"Claims\"\n            | Users -> \"Users\"\n            | Login -> \"Login\"\n\n    let private map =\n        function\n        | Home -> []\n        | Claims -> [ \"claims\" ]\n        | Users -> [ \"users\" ]\n        | Login -> [ \"login\" ]\n\n    let private reverMap =\n        function\n        | [] -> Home\n        | [ \"home\" ] -> Home\n        | [ \"claims\" ] -> Claims\n        | [ \"users\" ] -> Users\n        | [ \"login\" ] -> Login\n        | _ -> failwith \"404\"\n\n    let install () =\n        RouteMap.Create map reverMap\n        |> RouteMap.Install\n\n[<JavaScript>]\nmodule NavBarPage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n    open ApiClient\n\n    let private makeNavlinks routerView go =\n        routerView\n        |> View.Map(fun currentPage ->\n               [ ClientRoutes.Home; ClientRoutes.Claims; ClientRoutes.Users ]\n               |> List.map\n                      (fun page ->\n                      liAttr [ if page = currentPage then yield attr.``class`` \"active\" ]\n                             [ Doc.Link (string page) [] (fun _ -> go page) ] :> Doc)\n               |> Doc.Concat)\n        |> Doc.EmbedView\n\n    let private logout go =\n        li [ Doc.Link \"Log out\" [] (fun () ->\n                                     api.Logout()\n                                     go ClientRoutes.Login) ] :> Doc\n\n    let doc routerView go = bsNav \"admin portal\" (makeNavlinks routerView go) (logout go)\n\n\n[<JavaScript>]\nmodule LoginPage =\n    open BootstrapUI\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open ApiClient\n\n    let private login rvUsername rvPassword rvLoginError go () =\n        async {\n            let! login = api.Login { Username = Var.Get rvUsername\n                                     Password = Var.Get rvPassword }\n            match login with\n            | AsyncApi.Failure err ->\n                Var.Set rvLoginError\n                        \"You may have keyed in an invalid Username or Password. Please try again.\"\n                api.Logout()\n            | _ -> ()\n            return login\n        }\n        |> AsyncApi.map (fun _ -> go ClientRoutes.Home)\n        |> AsyncApi.start\n\n    let doc go =\n        let rvUsername = Var.Create \"\"\n        let rvPassword = Var.Create \"\"\n        let rvErr = Var.Create \"\"\n\n        let nameInput = bsInput \"Username\" rvUsername\n        let pwdInput = bsPasswordInput \"Password\" rvPassword\n        let errDiv = rvErr.View\n                     |> View.Map(fun err ->     if err = \"\" then Doc.Empty\n                                                else bsAlertDanger err)\n                     |> Doc.EmbedView\n\n        let buttons =\n            bsPanelDefault\n                [ form [ errDiv\n                         nameInput\n                         pwdInput\n                         Button.bsBtnDefaultFull \"Log in\"\n                                                 (login rvUsername rvPassword rvErr go) ] ]\n        bsRow [ bsCol4 [ Doc.Empty ]\n                bsCol4 [ h1Attr [attr.``class`` \"title\"]\n                                [text \"admin portal\"]\n                         buttons ]\n                bsCol4 [ Doc.Empty ] ]\n\n\n[<JavaScript>]\nmodule HomePage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let doc go =\n        bsJumbotron \"Hello,\"\n                    ([p [text \"Welcome to the admin portal v1.0.\"] :> Doc\n                      Button.bsBtnPrimaryInline \"View claims\"\n                                                (fun () -> go ClientRoutes.Claims) :> Doc\n                      Button.bsBtnPrimaryInline \"View users\"\n                                                (fun () -> go ClientRoutes.Users) :> Doc]\n                     |> Doc.Concat)\n\n[<JavaScript>]\nmodule ClaimsPage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let doc go =\n        bsJumbotron \"Claims\" Doc.Empty\n\n[<JavaScript>]\nmodule UsersPage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let doc go =\n        bsJumbotron \"Users\" Doc.Empty\n\n[<JavaScript>]\nmodule Client =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let Main =\n        let router = ClientRoutes.install()\n\n        let doc =\n            router.View\n            |> View.Map(fun page ->\n                   let go = Var.Set router\n\n                   let addNavBar body =\n                       [ NavBarPage.doc router.View go\n                         body ]\n                       |> Doc.Concat\n\n                   let embedInContainer body = bsContainer [ body ]\n\n                   match page with\n                   | ClientRoutes.Login ->\n                       LoginPage.doc go\n                       |> embedInContainer :> Doc\n                   | ClientRoutes.Home ->\n                       HomePage.doc go\n                       |> embedInContainer\n                       |> addNavBar\n                   | ClientRoutes.Claims ->\n                       ClaimsPage.doc go\n                       |> embedInContainer\n                       |> addNavBar\n                   | ClientRoutes.Users ->\n                       UsersPage.doc go\n                       |> embedInContainer\n                       |> addNavBar)\n            |> Doc.EmbedView\n\n        RunCode.RunNode().AddBootstrap.RunDoc doc","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[],"id":{"$":0,"Item":"9ff8bc4a-76c7-4db5-b59a-9252f82fa61d"},"expanded":true,"level":0,"properties":{}},{"name":"Check All WebSharper Code","content":"// add everyone as a predecessor to check if they parse/compile","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"},{"$":0,"Item":"b9ca9697-6cb4-4085-b509-9f702a62086f"},{"$":0,"Item":"9ff8bc4a-76c7-4db5-b59a-9252f82fa61d"},{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"},{"$":0,"Item":"332b130a-111b-48ca-bd75-26f96dcbb779"},{"$":0,"Item":"58e71035-74ac-4b97-8798-3a15d4944467"},{"$":0,"Item":"0a1fa320-b731-473a-93e2-dae49cc296f7"},{"$":0,"Item":"f3a7ead2-49e1-4ff4-b96e-6fe699a1c8a9"},{"$":0,"Item":"f2cc3e92-5e61-47b2-982b-40f5c5784e6a"},{"$":0,"Item":"0aa90429-4e7c-42eb-b108-3dd70e710bf1"},{"$":0,"Item":"9682eb8f-e1de-4d7c-adca-a5e2322558c2"},{"$":0,"Item":"a54701f2-1d68-4997-a1ea-62deaeb73e1b"},{"$":0,"Item":"4dc58ba1-75d1-4c96-9641-235ee7d8c2c2"},{"$":0,"Item":"74b8570e-dcd4-4dff-87a5-cd7ec96b8527"},{"$":0,"Item":"38b21610-7350-4676-993b-88fea844314f"},{"$":0,"Item":"7754c074-862e-4550-9d61-ea837adf6d85"},{"$":0,"Item":"ff6bfed0-83ae-4497-b197-fea6432aa958"},{"$":0,"Item":"ee8fe0d0-14ad-4ae8-bd77-e0918817d67e"},{"$":0,"Item":"3d8bf6d2-a66b-4f18-aa83-8e74836e38e4"},{"$":0,"Item":"e9c3ceaf-8fe5-4752-aa4c-2db6e1ac4577"},{"$":0,"Item":"b47dbe9c-8623-4b35-98ee-5073edfc21b3"},{"$":0,"Item":"b3d2418a-1cb8-48bd-9f12-e90b61dcc572"}],"id":{"$":0,"Item":"a3bec308-c3bd-4fad-b400-b9a33d1b15c8"},"expanded":true,"level":0,"properties":{}},{"name":"Client-Server Demo","content":"module WSServer = ","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[],"id":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"expanded":false,"level":0,"properties":{}},{"name":"Client (and Rpc)","content":"\nlet invert (txt: string) : string = txt |> Seq.rev |> Seq.map string |> String.concat \"\"\n\n[< Rpc >]\nlet invertA txt = async { return invert txt }\n\n[< JavaScript >]\nlet ClientForm () =\n    let inp = Template.Input.New(\"Type something...\")\n    div [ \n      ``class`` \"container\"    \n      Template.Bootstrap().Render\n      Template.Panel.New\n        .Title(\"Client Server Demo\")\n        .Header([])\n        .Content(\n          [ h3 [\n              inp.Render\n              htmlText inp.Var\n              htmlElement \"h2\" [ htmlText inp.Var ]\n              h1 [ htmlText <| Val.mapAsync invertA inp.Var ]\n            ]\n          ]).Render\n    ] |> renderDoc\n","parent":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"predecessors":[{"$":0,"Item":"0a11766b-f227-4b38-88a3-919d964387bf"},{"$":0,"Item":"40614ad6-3f81-468b-a4ff-034124b82ae1"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"0dabc34f-673d-4f79-ae00-3960ca196392"},"expanded":true,"level":0,"properties":{}},{"name":"Site","content":"open WebSharper.Sitelets\nopen WebSharper.UI.Next.Server\nopen WebSharper.UI.Next\n\ntype EndPoint = | [< EndPoint \"/\" >] EP\n\nlet content (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n    Content.Page(\n        Title = \"Main Page\"\n      , Head  = [ Html.scriptAttr [ attr.``type`` \"text/javascript\"; attr.src \"https://code.jquery.com/jquery-3.1.1.min.js\"] [] ]\n      , Body  = [ Html.client <@  ClientForm () @> ])\n\nlet site = Application.MultiPage content\n","parent":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"predecessors":[{"$":0,"Item":"0dabc34f-673d-4f79-ae00-3960ca196392"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"92837099-e4e4-4c7f-ac52-6c922824304f"},"expanded":true,"level":0,"properties":{}},{"name":"ClientServerDemo","content":"#r @\"Owin.dll\"\n#r @\"Microsoft.Owin.dll\"\n#r @\"Microsoft.Owin.Hosting.dll\"\n#r @\"Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"Microsoft.Owin.StaticFiles.dll\"\n#r @\"Microsoft.Owin.FileSystems.dll\"\n#r @\"WebSharper.Owin.dll\"\n#r @\"HttpMultipartParser.dll\"\n#r @\"WebSharper.Core.JavaScript.dll\"\n\nopen global.Owin\nopen Microsoft.Owin.Hosting\nopen Microsoft.Owin.StaticFiles\nopen Microsoft.Owin.FileSystems\nopen WebSharper.Owin\n\n[< EntryPoint >]\nlet Main args =\n    let rootDirectory, url =\n        match args with\n        | [| rootDirectory; url |] -> rootDirectory, url\n        | [| url                |] -> \"website\"    , url\n        | [|                    |] -> \"website\"    , \"http://localhost:9000/\"\n        | _ -> eprintfn \"Usage: WebServer3 ROOT_DIRECTORY URL\"; exit 1\n    use server = \n        WebApp.Start(url, fun appB ->\n            appB.UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(rootDirectory)))\n                .UseWebSharper(WebSharperOptions(ServerRootDirectory = rootDirectory\n                                               , Sitelet             = Some site\n                                               , BinDirectory        = \".\"\n                                               , Debug               = true))\n            |> ignore\n            let listener = appB.Properties.[\"Microsoft.Owin.Host.HttpListener.OwinHttpListener\"] |> unbox<Microsoft.Owin.Host.HttpListener.OwinHttpListener>\n            listener.SetRequestProcessingLimits(1000, 1000)\n            let maxA = ref 0\n            let maxB = ref 0\n            listener.GetRequestProcessingLimits(maxA, maxB)\n            printfn \"Accepts: %d Requests:%d\" !maxA !maxB\n        )\n    stdout.WriteLine(\"Serving {0}\", url)\n    stdin.ReadLine() |> ignore\n    0\n    ","parent":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"predecessors":[{"$":0,"Item":"92837099-e4e4-4c7f-ac52-6c922824304f"}],"id":{"$":0,"Item":"7e36bd56-d4fa-4509-bece-b4444df38c5c"},"expanded":true,"level":0,"properties":{}},{"name":"compile & run ClientServerDemo","content":"open System.IO\nopen FsStationShared\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.CompOptionsModule\n\nWrap.wrapper {\n    let  options   = compileOptionsExeDebug \"FSSGlobal/WebSharper Code/Client-Server Demo/ClientServerDemo\"\n                     + siteOptions\n    let  exeFile   = options?Output\n    let  site      = Path.GetFullPath(options?Website)\n    let! res       = FsStationClient(\"Compile WebSharper\").CompileSnippetW options\n    do   printfn     \"Starting %s\"     exeFile\n    let  url       = @\"http://localhost:9001/\"\n    let  parms     = sprintf \"%A %A\" site url \n    do   runProcess  exeFile parms |> ignore\n    do   runProcess  url     \"\"    |> ignore\n    return res\n} |> Wrap.runSynchronouslyS true |> printfn \"%s\"\n","parent":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"predecessors":[{"$":0,"Item":"56e5bc09-e528-49cc-9d42-6359b32a0cc9"}],"id":{"$":0,"Item":"c8c93861-321c-4d73-beb0-2fef0052bc7b"},"expanded":true,"level":0,"properties":{}},{"name":"ACTIONS","content":"module Actions =","predecessors":[],"id":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"expanded":false,"level":0,"properties":{}},{"name":"SAVE FSharpStation.js","content":"FSSGlobal.FsStationShared.FsStationClient(\"SAVE CodeEditor\")\n    .SaveSnippetJS @\"website\\EPFileX\" \"FSSGlobal/WebSharper Code/FSharpStation Code/FSharpStation\"\n","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"}],"id":{"$":0,"Item":"07a3e5d2-a793-49cf-bb87-88a98c5d9c7d"},"expanded":true,"level":0,"properties":{}},{"name":"SAVE FSharpStation.fsx","content":"FSSGlobal.FsStationShared.FsStationClient(\"SAVE CodeEditor\")\n    .SaveSnippetFsx @\"..\\bin\\website\\EPFileX\" \"FSSGlobal/WebSharper Code/FSharpStation Code/FSharpStation\"","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"}],"id":{"$":0,"Item":"56b4fb1e-909e-4b83-b312-8993751d0685"},"expanded":true,"level":0,"properties":{}},{"name":"SAVE FsJson File","content":"FSSGlobal.FsStationShared.FsStationClient(\"SAVE CodeEditor\")\n    .SaveWholeFile @\"..\\..\" \"CodeEditor\"","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"}],"id":{"$":0,"Item":"df25d045-936b-4f0e-9a22-429cd4f8848a"},"expanded":true,"level":0,"properties":{}},{"name":"DO Saves","content":"// Click Evaluate F#","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"07a3e5d2-a793-49cf-bb87-88a98c5d9c7d"},{"$":0,"Item":"56b4fb1e-909e-4b83-b312-8993751d0685"},{"$":0,"Item":"df25d045-936b-4f0e-9a22-429cd4f8848a"}],"id":{"$":0,"Item":"e307def4-b29d-4abf-9ec6-8744c0b8d75a"},"expanded":true,"level":0,"properties":{}},{"name":"Compile Modules","content":"#define FSS_SERVER\n#define COMPILING\nopen FSSGlobal.FsStationShared // open's need to be here\nopen FSSGlobal.Useful\nopen FSSGlobal.UsefulDotNet.CompOptionsModule\n\nlet fsStation = FsStationClient(\"Compile Modules\")\n[\n\n","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"56e5bc09-e528-49cc-9d42-6359b32a0cc9"}],"id":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"\"FSSGlobal/F# Code/FsTranslator/FsTranslator\"        |> compileOptionsExeDebug\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"b89801cc-5412-4025-bd88-c6ec0624a970"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"\"FSSGlobal/F# Code/FsStationShared/SelfHostedServer\" |> compileOptionsExeDebug\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"2db6dbb4-6c03-4c3d-990f-abfb997e9855"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"(\"FSSGlobal/F# Code/UsefulDotNet/RemotingDll\"        |> compileOptionsDllDebug)\n  + opGenWSharper /= \"ws:library\" \n  + opDirectory   /= \"Compiled/RemotingDll2\"\n  + wsProjectOptions\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"8deb7606-0602-4a16-83b4-4528985f267e"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"\"FSSGlobal/F# Code/FSAutoComplete/FSAutoCompleteDll\" |> compileOptionsDllDebug\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"53c32bfe-219e-4ff1-8913-adbc067b40d4"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"\"FSSGlobal/F# Code/Snippets/Calculate primes\"        |> compileOptionsWinExeDebug","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"7196e914-b38c-489b-a119-c980432ac41b"},"expanded":true,"level":0,"properties":{}},{"name":"Compile selected modules","content":"// select the module(s) to compile\n\n] |> Seq.iter (id \n        >> swap (+) [ opGenInternal /= \"showoptions\" ] \n        //>> swap (+) [ opGenFSharp2  /= \"standalone\"  ] \n        >> fsStation.CompileSnippetW \n        >> Wrap.runSynchronouslyS true\n        >> printfn \"%s\"\n     )\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[{"$":0,"Item":"7196e914-b38c-489b-a119-c980432ac41b"}],"id":{"$":0,"Item":"d39e3783-fb76-4963-b9fe-2da76c4b2a86"},"expanded":true,"level":0,"properties":{}},{"name":"DO/check all ACTIONS","content":"// Just Select as predecessors all the actions you want to execute \n// and then click on Evaluate F#\n","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"5e8209e0-9203-4fe0-8289-fb4579b24038"},{"$":0,"Item":"d39e3783-fb76-4963-b9fe-2da76c4b2a86"},{"$":0,"Item":"c8c93861-321c-4d73-beb0-2fef0052bc7b"},{"$":0,"Item":"e307def4-b29d-4abf-9ec6-8744c0b8d75a"},{"$":0,"Item":"c578e375-e299-4450-957e-1596e7af2007"},{"$":0,"Item":"24394c61-747d-41ff-816e-c70e46573bb7"},{"$":0,"Item":"d5d1c9fc-856e-44fd-aa74-9a8e88c3818f"}],"id":{"$":0,"Item":"64f180f8-8781-4630-9239-b5610a6329b6"},"expanded":true,"level":0,"properties":{}},{"name":"FSI AREA","content":"//model//.GetType()\n//|> printfn \"::::%A\"\n\n//FP_vs_MD_Perc.calFormulas.[1].forExpression.RuleText (model, model.modCubes.[0].cubId) |> printfn \"%s\"\n//ReportCube.cubRules.[0].AleaRule (model, model.modCubes.[0].cubId)\n//|> printfn \"%A\"\n\n//Price\n//|> printfn \"%A\"\n\n\n//open FSSGlobal.FSAutoCompleteIntermediary\n//\n//let responder = Responder2()\n//let file = \"ParseFSharp.fsx\"\n//ACMParse(file, \"let abc = 123 \\nlet xyz = abc + 3\", [|  |] ) |> responder.Respond\n//|> printfn \"%A\"\n//\n//ACMSignature(file, 2, 11) |> responder.Respond\n//|> printfn \"%A\"\n//\n//ACMFindDeclaration(file, 2, 11) |> responder.Respond\n//|> printfn \"%A\"\n//\n\n\n\n[<AutoOpen>]\nmodule GlobalValues = \n  open System\n  open System.IO\n  open System.Reflection\n  open System.Security\n  open System.Security.Permissions\n  open System.Security.Policy\n\n  type 'a IOEffect = private | IOSafe of 'a | Unsafe of exn\n    with\n      override x.ToString() = x |> function\n        | IOSafe s -> sprintf \"IOSafe %s\" (s.ToString())\n        | Unsafe e -> sprintf \"Unsafe %A\" e\n\n  let (|IOSafe|Unsafe|) = function | IOSafe s -> IOSafe s | Unsafe e -> Unsafe e\n\n  module IOEffect = \n    let bind f = function | IOSafe s -> f s | Unsafe u -> Unsafe u\n    let defaultValue x = function | IOSafe s -> s | Unsafe _ -> x\n\n  let inline (>>=) m f = IOEffect.bind f m\n  let inline (|==) m x = IOEffect.defaultValue x m\n\n  [<Sealed>]\n  type private RemoveConsoleIO() = \n    inherit MarshalByRefObject()\n//    do \n//      Console.SetIn(new StreamReader(Stream.Null))\n//      Console.SetOut(new StreamWriter(Stream.Null))\n//      Console.SetError(new StreamWriter(Stream.Null))\n  \n  [<Sealed>]\n  type SandboxBuilder() = \n    inherit MarshalByRefObject()\n    member x.Return v = IOSafe v\n    [<SecurityPermissionAttribute(SecurityAction.PermitOnly, Execution = true)>]\n    member x.Delay f = try f() with ex -> Unsafe ex\n  \n  let private sandboxDomain,sandboxType =\n    match AppDomain.CurrentDomain.GetData(\"domain\"),\n          AppDomain.CurrentDomain.GetData(\"typeof\") with\n    | null,_ | _,null ->\n      let sandboxType' = typeof<SandboxBuilder>\n      let consoleType' = typeof<RemoveConsoleIO>\n\n      let permissionSet = PermissionSet(PermissionState.None)\n      let securityPermission =\n        SecurityPermission(\n            SecurityPermissionFlag.UnmanagedCode ||| \n            SecurityPermissionFlag.Execution)\n      do permissionSet.AddPermission(securityPermission) |> ignore\n\n      let sandboxDomain' = \n        AppDomain.CreateDomain(\n          \"Sandbox_\" + Guid.NewGuid().ToString(),\n          AppDomain.CurrentDomain.Evidence,\n          AppDomain.CurrentDomain.SetupInformation,\n          permissionSet)\n      // Most likely not theadsafe but it's always the same value so ...\n      do sandboxDomain'.SetData(\"domain\", sandboxDomain' :> obj)\n      do sandboxDomain'.SetData(\"typeof\", sandboxType'   :> obj)\n\n      sandboxDomain'.CreateInstanceAndUnwrap(\n        consoleType'.Assembly.FullName, consoleType'.FullName)\n          :?> RemoveConsoleIO |> ignore\n\n      sandboxDomain',sandboxType'\n    | domain,``typeof`` -> domain :?> AppDomain, ``typeof`` :?> Type\n\n  let sandbox =\n    sandboxDomain.CreateInstanceAndUnwrap(\n      sandboxType.Assembly.FullName, sandboxType.FullName) :?> SandboxBuilder\n      \nopen System\nopen System.IO\nlet fooBar = sandbox{ return Console.ReadLine() + \"FooBar\" }      \n","predecessors":[],"id":{"$":0,"Item":"c2fd97dd-907f-4c2e-ae68-d80f2b8caf3c"},"expanded":true,"level":0,"properties":{}}]